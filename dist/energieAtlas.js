/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@glartek/leaflet.markercluster/dist/leaflet.markercluster-src.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@glartek/leaflet.markercluster/dist/leaflet.markercluster-src.js ***!
  \***************************************************************************************/
/***/ (function(__unused_webpack_module, exports) {

/*
 * Leaflet.markercluster 1.4.4+master.c818927,
 * Provides Beautiful Animated Marker Clustering functionality for Leaflet, a JS library for interactive maps.
 * https://github.com/Leaflet/Leaflet.markercluster
 * (c) 2012-2017, Dave Leaver, smartrak
 */
(function (global, factory) {
	 true ? factory(exports) :
	0;
}(this, (function (exports) { 'use strict';

	/*
	 * L.MarkerClusterGroup extends L.FeatureGroup by clustering the markers contained within
	 */

	var MarkerClusterGroup = L.MarkerClusterGroup = L.FeatureGroup.extend({

		options: {
			maxClusterRadius: 80, //A cluster will cover at most this many pixels from its center
			iconCreateFunction: null,
			clusterPane: L.Marker.prototype.options.pane,

			spiderfyOnMaxZoom: true,
			showCoverageOnHover: true,
			zoomToBoundsOnClick: true,
			singleMarkerMode: false,

			disableClusteringAtZoom: null,

			// Setting this to false prevents the removal of any clusters outside of the viewpoint, which
			// is the default behaviour for performance reasons.
			removeOutsideVisibleBounds: true,

			// Set to false to disable all animations (zoom and spiderfy).
			// If false, option animateAddingMarkers below has no effect.
			// If L.DomUtil.TRANSITION is falsy, this option has no effect.
			animate: true,

			//Whether to animate adding markers after adding the MarkerClusterGroup to the map
			// If you are adding individual markers set to true, if adding bulk markers leave false for massive performance gains.
			animateAddingMarkers: false,

			// Make it possible to provide custom function to calculate spiderfy shape positions
			spiderfyShapePositions: null,

			//Increase to increase the distance away that spiderfied markers appear from the center
			spiderfyDistanceMultiplier: 1,

			// Make it possible to specify a polyline options on a spider leg
			spiderLegPolylineOptions: { weight: 1.5, color: '#222', opacity: 0.5 },

			// When bulk adding layers, adds markers in chunks. Means addLayers may not add all the layers in the call, others will be loaded during setTimeouts
			chunkedLoading: false,
			chunkInterval: 200, // process markers for a maximum of ~ n milliseconds (then trigger the chunkProgress callback)
			chunkDelay: 50, // at the end of each interval, give n milliseconds back to system/browser
			chunkProgress: null, // progress callback: function(processed, total, elapsed) (e.g. for a progress indicator)

			//Options to pass to the L.Polygon constructor
			polygonOptions: {}
		},

		initialize: function (options) {
			L.Util.setOptions(this, options);
			if (!this.options.iconCreateFunction) {
				this.options.iconCreateFunction = this._defaultIconCreateFunction;
			}

			this._featureGroup = L.featureGroup();
			this._featureGroup.addEventParent(this);

			this._nonPointGroup = L.featureGroup();
			this._nonPointGroup.addEventParent(this);

			this._inZoomAnimation = 0;
			this._needsClustering = [];
			this._needsRemoving = []; //Markers removed while we aren't on the map need to be kept track of
			//The bounds of the currently shown area (from _getExpandedVisibleBounds) Updated on zoom/move
			this._currentShownBounds = null;

			this._queue = [];

			this._childMarkerEventHandlers = {
				'dragstart': this._childMarkerDragStart,
				'move': this._childMarkerMoved,
				'dragend': this._childMarkerDragEnd,
			};

			// Hook the appropriate animation methods.
			var animate = L.DomUtil.TRANSITION && this.options.animate;
			L.extend(this, animate ? this._withAnimation : this._noAnimation);
			// Remember which MarkerCluster class to instantiate (animated or not).
			this._markerCluster = animate ? L.MarkerCluster : L.MarkerClusterNonAnimated;
		},

		addLayer: function (layer) {

			if (layer instanceof L.LayerGroup) {
				return this.addLayers([layer]);
			}

			//Don't cluster non point data
			if (!layer.getLatLng) {
				this._nonPointGroup.addLayer(layer);
				this.fire('layeradd', { layer: layer });
				return this;
			}

			if (!this._map) {
				this._needsClustering.push(layer);
				this.fire('layeradd', { layer: layer });
				return this;
			}

			if (this.hasLayer(layer)) {
				return this;
			}


			//If we have already clustered we'll need to add this one to a cluster

			if (this._unspiderfy) {
				this._unspiderfy();
			}

			this._addLayer(layer, this._maxZoom);
			this.fire('layeradd', { layer: layer });

			// Refresh bounds and weighted positions.
			this._topClusterLevel._recalculateBounds();

			this._refreshClustersIcons();

			//Work out what is visible
			var visibleLayer = layer,
			    currentZoom = this._zoom;
			if (layer.__parent) {
				while (visibleLayer.__parent._zoom >= currentZoom) {
					visibleLayer = visibleLayer.__parent;
				}
			}

			if (this._currentShownBounds.contains(visibleLayer.getLatLng())) {
				if (this.options.animateAddingMarkers) {
					this._animationAddLayer(layer, visibleLayer);
				} else {
					this._animationAddLayerNonAnimated(layer, visibleLayer);
				}
			}
			return this;
		},

		removeLayer: function (layer) {

			if (layer instanceof L.LayerGroup) {
				return this.removeLayers([layer]);
			}

			//Non point layers
			if (!layer.getLatLng) {
				this._nonPointGroup.removeLayer(layer);
				this.fire('layerremove', { layer: layer });
				return this;
			}

			if (!this._map) {
				if (!this._arraySplice(this._needsClustering, layer) && this.hasLayer(layer)) {
					this._needsRemoving.push({ layer: layer, latlng: layer._latlng });
				}
				this.fire('layerremove', { layer: layer });
				return this;
			}

			if (!layer.__parent) {
				return this;
			}

			if (this._unspiderfy) {
				this._unspiderfy();
				this._unspiderfyLayer(layer);
			}

			//Remove the marker from clusters
			this._removeLayer(layer, true);
			this.fire('layerremove', { layer: layer });

			// Refresh bounds and weighted positions.
			this._topClusterLevel._recalculateBounds();

			this._refreshClustersIcons();

			layer.off(this._childMarkerEventHandlers, this);

			if (this._featureGroup.hasLayer(layer)) {
				this._featureGroup.removeLayer(layer);
				if (layer.clusterShow) {
					layer.clusterShow();
				}
			}

			return this;
		},

		//Takes an array of markers and adds them in bulk
		addLayers: function (layersArray, skipLayerAddEvent) {
			if (!L.Util.isArray(layersArray)) {
				return this.addLayer(layersArray);
			}

			var fg = this._featureGroup,
			    npg = this._nonPointGroup,
			    chunked = this.options.chunkedLoading,
			    chunkInterval = this.options.chunkInterval,
			    chunkProgress = this.options.chunkProgress,
			    l = layersArray.length,
			    offset = 0,
			    originalArray = true,
			    m;

			if (this._map) {
				var started = (new Date()).getTime();
				var process = L.bind(function () {
					var start = (new Date()).getTime();

					// Make sure to unspiderfy before starting to add some layers
					if (this._map && this._unspiderfy) {
						this._unspiderfy();
					}

					for (; offset < l; offset++) {
						if (chunked && offset % 200 === 0) {
							// every couple hundred markers, instrument the time elapsed since processing started:
							var elapsed = (new Date()).getTime() - start;
							if (elapsed > chunkInterval) {
								break; // been working too hard, time to take a break :-)
							}
						}

						m = layersArray[offset];

						// Group of layers, append children to layersArray and skip.
						// Side effects:
						// - Total increases, so chunkProgress ratio jumps backward.
						// - Groups are not included in this group, only their non-group child layers (hasLayer).
						// Changing array length while looping does not affect performance in current browsers:
						// http://jsperf.com/for-loop-changing-length/6
						if (m instanceof L.LayerGroup) {
							if (originalArray) {
								layersArray = layersArray.slice();
								originalArray = false;
							}
							this._extractNonGroupLayers(m, layersArray);
							l = layersArray.length;
							continue;
						}

						//Not point data, can't be clustered
						if (!m.getLatLng) {
							npg.addLayer(m);
							if (!skipLayerAddEvent) {
								this.fire('layeradd', { layer: m });
							}
							continue;
						}

						if (this.hasLayer(m)) {
							continue;
						}

						this._addLayer(m, this._maxZoom);
						if (!skipLayerAddEvent) {
							this.fire('layeradd', { layer: m });
						}

						//If we just made a cluster of size 2 then we need to remove the other marker from the map (if it is) or we never will
						if (m.__parent) {
							if (m.__parent.getChildCount() === 2) {
								var markers = m.__parent.getAllChildMarkers(),
								    otherMarker = markers[0] === m ? markers[1] : markers[0];
								fg.removeLayer(otherMarker);
							}
						}
					}

					if (chunkProgress) {
						// report progress and time elapsed:
						chunkProgress(offset, l, (new Date()).getTime() - started);
					}

					// Completed processing all markers.
					if (offset === l) {

						// Refresh bounds and weighted positions.
						this._topClusterLevel._recalculateBounds();

						this._refreshClustersIcons();

						this._topClusterLevel._recursivelyAddChildrenToMap(null, this._zoom, this._currentShownBounds);
					} else {
						setTimeout(process, this.options.chunkDelay);
					}
				}, this);

				process();
			} else {
				var needsClustering = new Array(l - offset);	// improve performance by preallocating the maximum size of our array
				var tail = 0;

				for (; offset < l; offset++) {
					m = layersArray[offset];

					// Group of layers, append children to layersArray and skip.
					if (m instanceof L.LayerGroup) {
						if (originalArray) {
							layersArray = layersArray.slice();
							originalArray = false;
						}
						this._extractNonGroupLayers(m, layersArray);
						l = layersArray.length;
						continue;
					}

					//Not point data, can't be clustered
					if (!m.getLatLng) {
						npg.addLayer(m);
						continue;
					}

					if (this.hasLayer(m)) {
						continue;
					}

					needsClustering[tail++] = m;
				}

				needsClustering = needsClustering.slice(0, tail);	// truncate empty elements
				this._needsClustering.push.apply(this._needsClustering, needsClustering);
			}
			return this;
		},

		//Takes an array of markers and removes them in bulk
		removeLayers: function (layersArray) {
			var i, m,
			    l = layersArray.length,
			    fg = this._featureGroup,
			    npg = this._nonPointGroup,
			    originalArray = true;

			if (!this._map) {
				for (i = 0; i < l; i++) {
					m = layersArray[i];

					// Group of layers, append children to layersArray and skip.
					if (m instanceof L.LayerGroup) {
						if (originalArray) {
							layersArray = layersArray.slice();
							originalArray = false;
						}
						this._extractNonGroupLayers(m, layersArray);
						l = layersArray.length;
						continue;
					}

					this._arraySplice(this._needsClustering, m);
					npg.removeLayer(m);
					if (this.hasLayer(m)) {
						this._needsRemoving.push({ layer: m, latlng: m._latlng });
					}
					this.fire('layerremove', { layer: m });
				}
				return this;
			}

			if (this._unspiderfy) {
				this._unspiderfy();

				// Work on a copy of the array, so that next loop is not affected.
				var layersArray2 = layersArray.slice(),
				    l2 = l;
				for (i = 0; i < l2; i++) {
					m = layersArray2[i];

					// Group of layers, append children to layersArray and skip.
					if (m instanceof L.LayerGroup) {
						this._extractNonGroupLayers(m, layersArray2);
						l2 = layersArray2.length;
						continue;
					}

					this._unspiderfyLayer(m);
				}
			}

			for (i = 0; i < l; i++) {
				m = layersArray[i];

				// Group of layers, append children to layersArray and skip.
				if (m instanceof L.LayerGroup) {
					if (originalArray) {
						layersArray = layersArray.slice();
						originalArray = false;
					}
					this._extractNonGroupLayers(m, layersArray);
					l = layersArray.length;
					continue;
				}

				if (!m.__parent) {
					npg.removeLayer(m);
					this.fire('layerremove', { layer: m });
					continue;
				}

				this._removeLayer(m, true, true);
				this.fire('layerremove', { layer: m });

				if (fg.hasLayer(m)) {
					fg.removeLayer(m);
					if (m.clusterShow) {
						m.clusterShow();
					}
				}
			}

			// Refresh bounds and weighted positions.
			this._topClusterLevel._recalculateBounds();

			this._refreshClustersIcons();

			//Fix up the clusters and markers on the map
			this._topClusterLevel._recursivelyAddChildrenToMap(null, this._zoom, this._currentShownBounds);

			return this;
		},

		//Removes all layers from the MarkerClusterGroup
		clearLayers: function () {
			//Need our own special implementation as the LayerGroup one doesn't work for us

			//If we aren't on the map (yet), blow away the markers we know of
			if (!this._map) {
				this._needsClustering = [];
				this._needsRemoving = [];
				delete this._gridClusters;
				delete this._gridUnclustered;
			}

			if (this._noanimationUnspiderfy) {
				this._noanimationUnspiderfy();
			}

			//Remove all the visible layers
			this._featureGroup.clearLayers();
			this._nonPointGroup.clearLayers();

			this.eachLayer(function (marker) {
				marker.off(this._childMarkerEventHandlers, this);
				delete marker.__parent;
			}, this);

			if (this._map) {
				//Reset _topClusterLevel and the DistanceGrids
				this._generateInitialClusters();
			}

			return this;
		},

		//Override FeatureGroup.getBounds as it doesn't work
		getBounds: function () {
			var bounds = new L.LatLngBounds();

			if (this._topClusterLevel) {
				bounds.extend(this._topClusterLevel._bounds);
			}

			for (var i = this._needsClustering.length - 1; i >= 0; i--) {
				bounds.extend(this._needsClustering[i].getLatLng());
			}

			bounds.extend(this._nonPointGroup.getBounds());

			return bounds;
		},

		//Overrides LayerGroup.eachLayer
		eachLayer: function (method, context) {
			var markers = this._needsClustering.slice(),
				needsRemoving = this._needsRemoving,
				thisNeedsRemoving, i, j;

			if (this._topClusterLevel) {
				this._topClusterLevel.getAllChildMarkers(markers);
			}

			for (i = markers.length - 1; i >= 0; i--) {
				thisNeedsRemoving = true;

				for (j = needsRemoving.length - 1; j >= 0; j--) {
					if (needsRemoving[j].layer === markers[i]) {
						thisNeedsRemoving = false;
						break;
					}
				}

				if (thisNeedsRemoving) {
					method.call(context, markers[i]);
				}
			}

			this._nonPointGroup.eachLayer(method, context);
		},

		//Overrides LayerGroup.getLayers
		getLayers: function () {
			var layers = [];
			this.eachLayer(function (l) {
				layers.push(l);
			});
			return layers;
		},

		//Overrides LayerGroup.getLayer, WARNING: Really bad performance
		getLayer: function (id) {
			var result = null;

			id = parseInt(id, 10);

			this.eachLayer(function (l) {
				if (L.stamp(l) === id) {
					result = l;
				}
			});

			return result;
		},

		//Returns true if the given layer is in this MarkerClusterGroup
		hasLayer: function (layer) {
			if (!layer) {
				return false;
			}

			var i, anArray = this._needsClustering;

			for (i = anArray.length - 1; i >= 0; i--) {
				if (anArray[i] === layer) {
					return true;
				}
			}

			anArray = this._needsRemoving;
			for (i = anArray.length - 1; i >= 0; i--) {
				if (anArray[i].layer === layer) {
					return false;
				}
			}

			return !!(layer.__parent && layer.__parent._group === this) || this._nonPointGroup.hasLayer(layer);
		},

		//Zoom down to show the given layer (spiderfying if necessary) then calls the callback
		zoomToShowLayer: function (layer, callback) {

			var map = this._map;

			if (typeof callback !== 'function') {
				callback = function () {};
			}

			var showMarker = function () {
				// Assumes that map.hasLayer checks for direct appearance on map, not recursively calling
				// hasLayer on Layer Groups that are on map (typically not calling this MarkerClusterGroup.hasLayer, which would always return true)
				if ((map.hasLayer(layer) || map.hasLayer(layer.__parent)) && !this._inZoomAnimation) {
					this._map.off('moveend', showMarker, this);
					this.off('animationend', showMarker, this);

					if (map.hasLayer(layer)) {
						callback();
					} else if (layer.__parent._icon) {
						this.once('spiderfied', callback, this);
						layer.__parent.spiderfy();
					}
				}
			};

			if (layer._icon && this._map.getBounds().contains(layer.getLatLng())) {
				//Layer is visible ond on screen, immediate return
				callback();
			} else if (layer.__parent._zoom < Math.round(this._map._zoom)) {
				//Layer should be visible at this zoom level. It must not be on screen so just pan over to it
				this._map.on('moveend', showMarker, this);
				this._map.panTo(layer.getLatLng());
			} else {
				this._map.on('moveend', showMarker, this);
				this.on('animationend', showMarker, this);
				layer.__parent.zoomToBounds();
			}
		},

		//Overrides FeatureGroup.onAdd
		onAdd: function (map) {
			this._map = map;
			var i, l, layer;

			if (!isFinite(this._map.getMaxZoom())) {
				throw "Map has no maxZoom specified";
			}

			this._featureGroup.addTo(map);
			this._nonPointGroup.addTo(map);

			if (!this._gridClusters) {
				this._generateInitialClusters();
			}

			this._maxLat = map.options.crs.projection.MAX_LATITUDE;

			//Restore all the positions as they are in the MCG before removing them
			for (i = 0, l = this._needsRemoving.length; i < l; i++) {
				layer = this._needsRemoving[i];
				layer.newlatlng = layer.layer._latlng;
				layer.layer._latlng = layer.latlng;
			}
			//Remove them, then restore their new positions
			for (i = 0, l = this._needsRemoving.length; i < l; i++) {
				layer = this._needsRemoving[i];
				this._removeLayer(layer.layer, true);
				layer.layer._latlng = layer.newlatlng;
			}
			this._needsRemoving = [];

			//Remember the current zoom level and bounds
			this._zoom = Math.round(this._map._zoom);
			this._currentShownBounds = this._getExpandedVisibleBounds();

			this._map.on('zoomend', this._zoomEnd, this);
			this._map.on('moveend', this._moveEnd, this);

			if (this._spiderfierOnAdd) { //TODO FIXME: Not sure how to have spiderfier add something on here nicely
				this._spiderfierOnAdd();
			}

			this._bindEvents();

			//Actually add our markers to the map:
			l = this._needsClustering;
			this._needsClustering = [];
			this.addLayers(l, true);
		},

		//Overrides FeatureGroup.onRemove
		onRemove: function (map) {
			map.off('zoomend', this._zoomEnd, this);
			map.off('moveend', this._moveEnd, this);

			this._unbindEvents();

			//In case we are in a cluster animation
			this._map._mapPane.className = this._map._mapPane.className.replace(' leaflet-cluster-anim', '');

			if (this._spiderfierOnRemove) { //TODO FIXME: Not sure how to have spiderfier add something on here nicely
				this._spiderfierOnRemove();
			}

			delete this._maxLat;

			//Clean up all the layers we added to the map
			this._hideCoverage();
			this._featureGroup.remove();
			this._nonPointGroup.remove();

			this._featureGroup.clearLayers();

			this._map = null;
		},

		getVisibleParent: function (marker) {
			var vMarker = marker;
			while (vMarker && !vMarker._icon) {
				vMarker = vMarker.__parent;
			}
			return vMarker || null;
		},

		//Remove the given object from the given array
		_arraySplice: function (anArray, obj) {
			for (var i = anArray.length - 1; i >= 0; i--) {
				if (anArray[i] === obj) {
					anArray.splice(i, 1);
					return true;
				}
			}
		},

		/**
		 * Removes a marker from all _gridUnclustered zoom levels, starting at the supplied zoom.
		 * @param marker to be removed from _gridUnclustered.
		 * @param z integer bottom start zoom level (included)
		 * @private
		 */
		_removeFromGridUnclustered: function (marker, z) {
			var map = this._map,
			    gridUnclustered = this._gridUnclustered,
				minZoom = Math.floor(this._map.getMinZoom());

			for (; z >= minZoom; z--) {
				if (!gridUnclustered[z].removeObject(marker, map.project(marker.getLatLng(), z))) {
					break;
				}
			}
		},

		_childMarkerDragStart: function (e) {
			e.target.__dragStart = e.target._latlng;
		},

		_childMarkerMoved: function (e) {
			if (!this._ignoreMove && !e.target.__dragStart) {
				var isPopupOpen = e.target._popup && e.target._popup.isOpen();

				this._moveChild(e.target, e.oldLatLng, e.latlng);

				if (isPopupOpen) {
					e.target.openPopup();
				}
			}
		},

		_moveChild: function (layer, from, to) {
			layer._latlng = from;
			this.removeLayer(layer);

			layer._latlng = to;
			this.addLayer(layer);
		},

		_childMarkerDragEnd: function (e) {
			var dragStart = e.target.__dragStart;
			delete e.target.__dragStart;
			if (dragStart) {
				this._moveChild(e.target, dragStart, e.target._latlng);
			}		
		},


		//Internal function for removing a marker from everything.
		//dontUpdateMap: set to true if you will handle updating the map manually (for bulk functions)
		_removeLayer: function (marker, removeFromDistanceGrid, dontUpdateMap) {
			var gridClusters = this._gridClusters,
				gridUnclustered = this._gridUnclustered,
				fg = this._featureGroup,
				map = this._map,
				minZoom = Math.floor(this._map.getMinZoom());

			//Remove the marker from distance clusters it might be in
			if (removeFromDistanceGrid) {
				this._removeFromGridUnclustered(marker, this._maxZoom);
			}

			//Work our way up the clusters removing them as we go if required
			var cluster = marker.__parent,
				markers = cluster._markers,
				otherMarker;

			//Remove the marker from the immediate parents marker list
			this._arraySplice(markers, marker);

			while (cluster) {
				cluster._childCount--;
				cluster._boundsNeedUpdate = true;

				if (cluster._zoom < minZoom) {
					//Top level, do nothing
					break;
				} else if (removeFromDistanceGrid && cluster._childCount <= 1) { //Cluster no longer required
					//We need to push the other marker up to the parent
					otherMarker = cluster._markers[0] === marker ? cluster._markers[1] : cluster._markers[0];

					//Update distance grid
					gridClusters[cluster._zoom].removeObject(cluster, map.project(cluster._cLatLng, cluster._zoom));
					gridUnclustered[cluster._zoom].addObject(otherMarker, map.project(otherMarker.getLatLng(), cluster._zoom));

					//Move otherMarker up to parent
					this._arraySplice(cluster.__parent._childClusters, cluster);
					cluster.__parent._markers.push(otherMarker);
					otherMarker.__parent = cluster.__parent;

					if (cluster._icon) {
						//Cluster is currently on the map, need to put the marker on the map instead
						fg.removeLayer(cluster);
						if (!dontUpdateMap) {
							fg.addLayer(otherMarker);
						}
					}
				} else {
					cluster._iconNeedsUpdate = true;
				}

				cluster = cluster.__parent;
			}

			delete marker.__parent;
		},

		_isOrIsParent: function (el, oel) {
			while (oel) {
				if (el === oel) {
					return true;
				}
				oel = oel.parentNode;
			}
			return false;
		},

		//Override L.Evented.fire
		fire: function (type, data, propagate) {
			if (data && data.layer instanceof L.MarkerCluster) {
				//Prevent multiple clustermouseover/off events if the icon is made up of stacked divs (Doesn't work in ie <= 8, no relatedTarget)
				if (data.originalEvent && this._isOrIsParent(data.layer._icon, data.originalEvent.relatedTarget)) {
					return;
				}
				type = 'cluster' + type;
			}

			L.FeatureGroup.prototype.fire.call(this, type, data, propagate);
		},

		//Override L.Evented.listens
		listens: function (type, propagate) {
			return L.FeatureGroup.prototype.listens.call(this, type, propagate) || L.FeatureGroup.prototype.listens.call(this, 'cluster' + type, propagate);
		},

		//Default functionality
		_defaultIconCreateFunction: function (cluster) {
			var childCount = cluster.getChildCount();

			var c = ' marker-cluster-';
			if (childCount < 10) {
				c += 'small';
			} else if (childCount < 100) {
				c += 'medium';
			} else {
				c += 'large';
			}

			return new L.DivIcon({ html: '<div><span>' + childCount + '</span></div>', className: 'marker-cluster' + c, iconSize: new L.Point(40, 40) });
		},

		_bindEvents: function () {
			var map = this._map,
			    spiderfyOnMaxZoom = this.options.spiderfyOnMaxZoom,
			    showCoverageOnHover = this.options.showCoverageOnHover,
			    zoomToBoundsOnClick = this.options.zoomToBoundsOnClick;

			//Zoom on cluster click or spiderfy if we are at the lowest level
			if (spiderfyOnMaxZoom || zoomToBoundsOnClick) {
				this.on('clusterclick', this._zoomOrSpiderfy, this);
			}

			//Show convex hull (boundary) polygon on mouse over
			if (showCoverageOnHover) {
				this.on('clustermouseover', this._showCoverage, this);
				this.on('clustermouseout', this._hideCoverage, this);
				map.on('zoomend', this._hideCoverage, this);
			}
		},

		_zoomOrSpiderfy: function (e) {
			var cluster = e.layer,
			    bottomCluster = cluster;

			while (bottomCluster._childClusters.length === 1) {
				bottomCluster = bottomCluster._childClusters[0];
			}

			if (bottomCluster._zoom === this._maxZoom &&
				bottomCluster._childCount === cluster._childCount &&
				this.options.spiderfyOnMaxZoom) {

				// All child markers are contained in a single cluster from this._maxZoom to this cluster.
				cluster.spiderfy();
			} else if (this.options.zoomToBoundsOnClick) {
				cluster.zoomToBounds();
			}

			// Focus the map again for keyboard users.
			if (e.originalEvent && e.originalEvent.keyCode === 13) {
				this._map._container.focus();
			}
		},

		_showCoverage: function (e) {
			var map = this._map;
			if (this._inZoomAnimation) {
				return;
			}
			if (this._shownPolygon) {
				map.removeLayer(this._shownPolygon);
			}
			if (e.layer.getChildCount() > 2 && e.layer !== this._spiderfied) {
				this._shownPolygon = new L.Polygon(e.layer.getConvexHull(), this.options.polygonOptions);
				map.addLayer(this._shownPolygon);
			}
		},

		_hideCoverage: function () {
			if (this._shownPolygon) {
				this._map.removeLayer(this._shownPolygon);
				this._shownPolygon = null;
			}
		},

		_unbindEvents: function () {
			var spiderfyOnMaxZoom = this.options.spiderfyOnMaxZoom,
				showCoverageOnHover = this.options.showCoverageOnHover,
				zoomToBoundsOnClick = this.options.zoomToBoundsOnClick,
				map = this._map;

			if (spiderfyOnMaxZoom || zoomToBoundsOnClick) {
				this.off('clusterclick', this._zoomOrSpiderfy, this);
			}
			if (showCoverageOnHover) {
				this.off('clustermouseover', this._showCoverage, this);
				this.off('clustermouseout', this._hideCoverage, this);
				map.off('zoomend', this._hideCoverage, this);
			}
		},

		_zoomEnd: function () {
			if (!this._map) { //May have been removed from the map by a zoomEnd handler
				return;
			}
			this._mergeSplitClusters();

			this._zoom = Math.round(this._map._zoom);
			this._currentShownBounds = this._getExpandedVisibleBounds();
		},

		_moveEnd: function () {
			if (this._inZoomAnimation) {
				return;
			}

			var newBounds = this._getExpandedVisibleBounds();

			this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, Math.floor(this._map.getMinZoom()), this._zoom, newBounds);
			this._topClusterLevel._recursivelyAddChildrenToMap(null, Math.round(this._map._zoom), newBounds);

			this._currentShownBounds = newBounds;
			return;
		},

		_generateInitialClusters: function () {
			var maxZoom = Math.ceil(this._map.getMaxZoom()),
				minZoom = Math.floor(this._map.getMinZoom()),
				radius = this.options.maxClusterRadius,
				radiusFn = radius;

			//If we just set maxClusterRadius to a single number, we need to create
			//a simple function to return that number. Otherwise, we just have to
			//use the function we've passed in.
			if (typeof radius !== "function") {
				radiusFn = function () { return radius; };
			}

			if (this.options.disableClusteringAtZoom !== null) {
				maxZoom = this.options.disableClusteringAtZoom - 1;
			}
			this._maxZoom = maxZoom;
			this._gridClusters = {};
			this._gridUnclustered = {};

			//Set up DistanceGrids for each zoom
			for (var zoom = maxZoom; zoom >= minZoom; zoom--) {
				this._gridClusters[zoom] = new L.DistanceGrid(radiusFn(zoom));
				this._gridUnclustered[zoom] = new L.DistanceGrid(radiusFn(zoom));
			}

			// Instantiate the appropriate L.MarkerCluster class (animated or not).
			this._topClusterLevel = new this._markerCluster(this, minZoom - 1);
		},

		//Zoom: Zoom to start adding at (Pass this._maxZoom to start at the bottom)
		_addLayer: function (layer, zoom) {
			var gridClusters = this._gridClusters,
			    gridUnclustered = this._gridUnclustered,
				minZoom = Math.floor(this._map.getMinZoom()),
			    markerPoint, z;

			if (this.options.singleMarkerMode) {
				this._overrideMarkerIcon(layer);
			}

			layer.on(this._childMarkerEventHandlers, this);

			//Find the lowest zoom level to slot this one in
			for (; zoom >= minZoom; zoom--) {
				markerPoint = this._map.project(layer.getLatLng(), zoom); // calculate pixel position

				//Try find a cluster close by
				var closest = gridClusters[zoom].getNearObject(markerPoint);
				if (closest) {
					closest._addChild(layer);
					layer.__parent = closest;
					return;
				}

				//Try find a marker close by to form a new cluster with
				closest = gridUnclustered[zoom].getNearObject(markerPoint);
				if (closest) {
					var parent = closest.__parent;
					if (parent) {
						this._removeLayer(closest, false);
					}

					//Create new cluster with these 2 in it

					var newCluster = new this._markerCluster(this, zoom, closest, layer);
					gridClusters[zoom].addObject(newCluster, this._map.project(newCluster._cLatLng, zoom));
					closest.__parent = newCluster;
					layer.__parent = newCluster;

					//First create any new intermediate parent clusters that don't exist
					var lastParent = newCluster;
					for (z = zoom - 1; z > parent._zoom; z--) {
						lastParent = new this._markerCluster(this, z, lastParent);
						gridClusters[z].addObject(lastParent, this._map.project(closest.getLatLng(), z));
					}
					parent._addChild(lastParent);

					//Remove closest from this zoom level and any above that it is in, replace with newCluster
					this._removeFromGridUnclustered(closest, zoom);

					return;
				}

				//Didn't manage to cluster in at this zoom, record us as a marker here and continue upwards
				gridUnclustered[zoom].addObject(layer, markerPoint);
			}

			//Didn't get in anything, add us to the top
			this._topClusterLevel._addChild(layer);
			layer.__parent = this._topClusterLevel;
			return;
		},

		/**
		 * Refreshes the icon of all "dirty" visible clusters.
		 * Non-visible "dirty" clusters will be updated when they are added to the map.
		 * @private
		 */
		_refreshClustersIcons: function () {
			this._featureGroup.eachLayer(function (c) {
				if (c instanceof L.MarkerCluster && c._iconNeedsUpdate) {
					c._updateIcon();
				}
			});
		},

		//Enqueue code to fire after the marker expand/contract has happened
		_enqueue: function (fn) {
			this._queue.push(fn);
			if (!this._queueTimeout) {
				this._queueTimeout = setTimeout(L.bind(this._processQueue, this), 300);
			}
		},
		_processQueue: function () {
			for (var i = 0; i < this._queue.length; i++) {
				this._queue[i].call(this);
			}
			this._queue.length = 0;
			clearTimeout(this._queueTimeout);
			this._queueTimeout = null;
		},

		//Merge and split any existing clusters that are too big or small
		_mergeSplitClusters: function () {
			var mapZoom = Math.round(this._map._zoom);

			//In case we are starting to split before the animation finished
			this._processQueue();

			if (this._zoom < mapZoom && this._currentShownBounds.intersects(this._getExpandedVisibleBounds())) { //Zoom in, split
				this._animationStart();
				//Remove clusters now off screen
				this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, Math.floor(this._map.getMinZoom()), this._zoom, this._getExpandedVisibleBounds());

				this._animationZoomIn(this._zoom, mapZoom);

			} else if (this._zoom > mapZoom) { //Zoom out, merge
				this._animationStart();

				this._animationZoomOut(this._zoom, mapZoom);
			} else {
				this._moveEnd();
			}
		},

		//Gets the maps visible bounds expanded in each direction by the size of the screen (so the user cannot see an area we do not cover in one pan)
		_getExpandedVisibleBounds: function () {
			if (!this.options.removeOutsideVisibleBounds) {
				return this._mapBoundsInfinite;
			} else if (L.Browser.mobile) {
				return this._checkBoundsMaxLat(this._map.getBounds());
			}

			return this._checkBoundsMaxLat(this._map.getBounds().pad(1)); // Padding expands the bounds by its own dimensions but scaled with the given factor.
		},

		/**
		 * Expands the latitude to Infinity (or -Infinity) if the input bounds reach the map projection maximum defined latitude
		 * (in the case of Web/Spherical Mercator, it is 85.0511287798 / see https://en.wikipedia.org/wiki/Web_Mercator#Formulas).
		 * Otherwise, the removeOutsideVisibleBounds option will remove markers beyond that limit, whereas the same markers without
		 * this option (or outside MCG) will have their position floored (ceiled) by the projection and rendered at that limit,
		 * making the user think that MCG "eats" them and never displays them again.
		 * @param bounds L.LatLngBounds
		 * @returns {L.LatLngBounds}
		 * @private
		 */
		_checkBoundsMaxLat: function (bounds) {
			var maxLat = this._maxLat;

			if (maxLat !== undefined) {
				if (bounds.getNorth() >= maxLat) {
					bounds._northEast.lat = Infinity;
				}
				if (bounds.getSouth() <= -maxLat) {
					bounds._southWest.lat = -Infinity;
				}
			}

			return bounds;
		},

		//Shared animation code
		_animationAddLayerNonAnimated: function (layer, newCluster) {
			if (newCluster === layer) {
				this._featureGroup.addLayer(layer);
			} else if (newCluster._childCount === 2) {
				newCluster._addToMap();

				var markers = newCluster.getAllChildMarkers();
				this._featureGroup.removeLayer(markers[0]);
				this._featureGroup.removeLayer(markers[1]);
			} else {
				newCluster._updateIcon();
			}
		},

		/**
		 * Extracts individual (i.e. non-group) layers from a Layer Group.
		 * @param group to extract layers from.
		 * @param output {Array} in which to store the extracted layers.
		 * @returns {*|Array}
		 * @private
		 */
		_extractNonGroupLayers: function (group, output) {
			var layers = group.getLayers(),
			    i = 0,
			    layer;

			output = output || [];

			for (; i < layers.length; i++) {
				layer = layers[i];

				if (layer instanceof L.LayerGroup) {
					this._extractNonGroupLayers(layer, output);
					continue;
				}

				output.push(layer);
			}

			return output;
		},

		/**
		 * Implements the singleMarkerMode option.
		 * @param layer Marker to re-style using the Clusters iconCreateFunction.
		 * @returns {L.Icon} The newly created icon.
		 * @private
		 */
		_overrideMarkerIcon: function (layer) {
			var icon = layer.options.icon = this.options.iconCreateFunction({
				getChildCount: function () {
					return 1;
				},
				getAllChildMarkers: function () {
					return [layer];
				}
			});

			return icon;
		}
	});

	// Constant bounds used in case option "removeOutsideVisibleBounds" is set to false.
	L.MarkerClusterGroup.include({
		_mapBoundsInfinite: new L.LatLngBounds(new L.LatLng(-Infinity, -Infinity), new L.LatLng(Infinity, Infinity))
	});

	L.MarkerClusterGroup.include({
		_noAnimation: {
			//Non Animated versions of everything
			_animationStart: function () {
				//Do nothing...
			},
			_animationZoomIn: function (previousZoomLevel, newZoomLevel) {
				this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, Math.floor(this._map.getMinZoom()), previousZoomLevel);
				this._topClusterLevel._recursivelyAddChildrenToMap(null, newZoomLevel, this._getExpandedVisibleBounds());

				//We didn't actually animate, but we use this event to mean "clustering animations have finished"
				this.fire('animationend');
			},
			_animationZoomOut: function (previousZoomLevel, newZoomLevel) {
				this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, Math.floor(this._map.getMinZoom()), previousZoomLevel);
				this._topClusterLevel._recursivelyAddChildrenToMap(null, newZoomLevel, this._getExpandedVisibleBounds());

				//We didn't actually animate, but we use this event to mean "clustering animations have finished"
				this.fire('animationend');
			},
			_animationAddLayer: function (layer, newCluster) {
				this._animationAddLayerNonAnimated(layer, newCluster);
			}
		},

		_withAnimation: {
			//Animated versions here
			_animationStart: function () {
				this._map._mapPane.className += ' leaflet-cluster-anim';
				this._inZoomAnimation++;
			},

			_animationZoomIn: function (previousZoomLevel, newZoomLevel) {
				var bounds = this._getExpandedVisibleBounds(),
				    fg = this._featureGroup,
					minZoom = Math.floor(this._map.getMinZoom()),
				    i;

				this._ignoreMove = true;

				//Add all children of current clusters to map and remove those clusters from map
				this._topClusterLevel._recursively(bounds, previousZoomLevel, minZoom, function (c) {
					var startPos = c._latlng,
					    markers  = c._markers,
					    m;

					if (!bounds.contains(startPos)) {
						startPos = null;
					}

					if (c._isSingleParent() && previousZoomLevel + 1 === newZoomLevel) { //Immediately add the new child and remove us
						fg.removeLayer(c);
						c._recursivelyAddChildrenToMap(null, newZoomLevel, bounds);
					} else {
						//Fade out old cluster
						c.clusterHide();
						c._recursivelyAddChildrenToMap(startPos, newZoomLevel, bounds);
					}

					//Remove all markers that aren't visible any more
					//TODO: Do we actually need to do this on the higher levels too?
					for (i = markers.length - 1; i >= 0; i--) {
						m = markers[i];
						if (!bounds.contains(m._latlng)) {
							fg.removeLayer(m);
						}
					}

				});

				this._forceLayout();

				//Update opacities
				this._topClusterLevel._recursivelyBecomeVisible(bounds, newZoomLevel);
				//TODO Maybe? Update markers in _recursivelyBecomeVisible
				fg.eachLayer(function (n) {
					if (!(n instanceof L.MarkerCluster) && n._icon) {
						n.clusterShow();
					}
				});

				//update the positions of the just added clusters/markers
				this._topClusterLevel._recursively(bounds, previousZoomLevel, newZoomLevel, function (c) {
					c._recursivelyRestoreChildPositions(newZoomLevel);
				});

				this._ignoreMove = false;

				//Remove the old clusters and close the zoom animation
				this._enqueue(function () {
					//update the positions of the just added clusters/markers
					this._topClusterLevel._recursively(bounds, previousZoomLevel, minZoom, function (c) {
						fg.removeLayer(c);
						c.clusterShow();
					});

					this._animationEnd();
				});
			},

			_animationZoomOut: function (previousZoomLevel, newZoomLevel) {
				this._animationZoomOutSingle(this._topClusterLevel, previousZoomLevel - 1, newZoomLevel);

				//Need to add markers for those that weren't on the map before but are now
				this._topClusterLevel._recursivelyAddChildrenToMap(null, newZoomLevel, this._getExpandedVisibleBounds());
				//Remove markers that were on the map before but won't be now
				this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, Math.floor(this._map.getMinZoom()), previousZoomLevel, this._getExpandedVisibleBounds());
			},

			_animationAddLayer: function (layer, newCluster) {
				var me = this,
				    fg = this._featureGroup;

				fg.addLayer(layer);
				if (newCluster !== layer) {
					if (newCluster._childCount > 2) { //Was already a cluster

						newCluster._updateIcon();
						this._forceLayout();
						this._animationStart();

						layer._setPos(this._map.latLngToLayerPoint(newCluster.getLatLng()));
						layer.clusterHide();

						this._enqueue(function () {
							fg.removeLayer(layer);
							layer.clusterShow();

							me._animationEnd();
						});

					} else { //Just became a cluster
						this._forceLayout();

						me._animationStart();
						me._animationZoomOutSingle(newCluster, this._map.getMaxZoom(), this._zoom);
					}
				}
			}
		},

		// Private methods for animated versions.
		_animationZoomOutSingle: function (cluster, previousZoomLevel, newZoomLevel) {
			var bounds = this._getExpandedVisibleBounds(),
				minZoom = Math.floor(this._map.getMinZoom());

			//Animate all of the markers in the clusters to move to their cluster center point
			cluster._recursivelyAnimateChildrenInAndAddSelfToMap(bounds, minZoom, previousZoomLevel + 1, newZoomLevel);

			var me = this;

			//Update the opacity (If we immediately set it they won't animate)
			this._forceLayout();
			cluster._recursivelyBecomeVisible(bounds, newZoomLevel);

			//TODO: Maybe use the transition timing stuff to make this more reliable
			//When the animations are done, tidy up
			this._enqueue(function () {

				//This cluster stopped being a cluster before the timeout fired
				if (cluster._childCount === 1) {
					var m = cluster._markers[0];
					//If we were in a cluster animation at the time then the opacity and position of our child could be wrong now, so fix it
					this._ignoreMove = true;
					m.setLatLng(m.getLatLng());
					this._ignoreMove = false;
					if (m.clusterShow) {
						m.clusterShow();
					}
				} else {
					cluster._recursively(bounds, newZoomLevel, minZoom, function (c) {
						c._recursivelyRemoveChildrenFromMap(bounds, minZoom, previousZoomLevel + 1);
					});
				}
				me._animationEnd();
			});
		},

		_animationEnd: function () {
			if (this._map) {
				this._map._mapPane.className = this._map._mapPane.className.replace(' leaflet-cluster-anim', '');
			}
			this._inZoomAnimation--;
			this.fire('animationend');
		},

		//Force a browser layout of stuff in the map
		// Should apply the current opacity and location to all elements so we can update them again for an animation
		_forceLayout: function () {
			//In my testing this works, infact offsetWidth of any element seems to work.
			//Could loop all this._layers and do this for each _icon if it stops working

			L.Util.falseFn(document.body.offsetWidth);
		}
	});

	L.markerClusterGroup = function (options) {
		return new L.MarkerClusterGroup(options);
	};

	var MarkerCluster = L.MarkerCluster = L.Marker.extend({
		options: L.Icon.prototype.options,

		initialize: function (group, zoom, a, b) {

			L.Marker.prototype.initialize.call(this, a ? (a._cLatLng || a.getLatLng()) : new L.LatLng(0, 0),
	            { icon: this, pane: group.options.clusterPane });

			this._group = group;
			this._zoom = zoom;

			this._markers = [];
			this._childClusters = [];
			this._childCount = 0;
			this._iconNeedsUpdate = true;
			this._boundsNeedUpdate = true;

			this._bounds = new L.LatLngBounds();

			if (a) {
				this._addChild(a);
			}
			if (b) {
				this._addChild(b);
			}
		},

		//Recursively retrieve all child markers of this cluster
		getAllChildMarkers: function (storageArray, ignoreDraggedMarker) {
			storageArray = storageArray || [];

			for (var i = this._childClusters.length - 1; i >= 0; i--) {
				this._childClusters[i].getAllChildMarkers(storageArray);
			}

			for (var j = this._markers.length - 1; j >= 0; j--) {
				if (ignoreDraggedMarker && this._markers[j].__dragStart) {
					continue;
				}
				storageArray.push(this._markers[j]);
			}

			return storageArray;
		},

		//Returns the count of how many child markers we have
		getChildCount: function () {
			return this._childCount;
		},

		//Zoom to the minimum of showing all of the child markers, or the extents of this cluster
		zoomToBounds: function (fitBoundsOptions) {
			var childClusters = this._childClusters.slice(),
				map = this._group._map,
				boundsZoom = map.getBoundsZoom(this._bounds),
				zoom = this._zoom + 1,
				mapZoom = map.getZoom(),
				i;

			//calculate how far we need to zoom down to see all of the markers
			while (childClusters.length > 0 && boundsZoom > zoom) {
				zoom++;
				var newClusters = [];
				for (i = 0; i < childClusters.length; i++) {
					newClusters = newClusters.concat(childClusters[i]._childClusters);
				}
				childClusters = newClusters;
			}

			if (boundsZoom > zoom) {
				this._group._map.setView(this._latlng, zoom);
			} else if (boundsZoom <= mapZoom) { //If fitBounds wouldn't zoom us down, zoom us down instead
				this._group._map.setView(this._latlng, mapZoom + 1);
			} else {
				this._group._map.fitBounds(this._bounds, fitBoundsOptions);
			}
		},

		getBounds: function () {
			var bounds = new L.LatLngBounds();
			bounds.extend(this._bounds);
			return bounds;
		},

		_updateIcon: function () {
			this._iconNeedsUpdate = true;
			if (this._icon) {
				this.setIcon(this);
			}
		},

		//Cludge for Icon, we pretend to be an icon for performance
		createIcon: function () {
			if (this._iconNeedsUpdate) {
				this._iconObj = this._group.options.iconCreateFunction(this);
				this._iconNeedsUpdate = false;
			}
			return this._iconObj.createIcon();
		},
		createShadow: function () {
			return this._iconObj.createShadow();
		},


		_addChild: function (new1, isNotificationFromChild) {

			this._iconNeedsUpdate = true;

			this._boundsNeedUpdate = true;
			this._setClusterCenter(new1);

			if (new1 instanceof L.MarkerCluster) {
				if (!isNotificationFromChild) {
					this._childClusters.push(new1);
					new1.__parent = this;
				}
				this._childCount += new1._childCount;
			} else {
				if (!isNotificationFromChild) {
					this._markers.push(new1);
				}
				this._childCount++;
			}

			if (this.__parent) {
				this.__parent._addChild(new1, true);
			}
		},

		/**
		 * Makes sure the cluster center is set. If not, uses the child center if it is a cluster, or the marker position.
		 * @param child L.MarkerCluster|L.Marker that will be used as cluster center if not defined yet.
		 * @private
		 */
		_setClusterCenter: function (child) {
			if (!this._cLatLng) {
				// when clustering, take position of the first point as the cluster center
				this._cLatLng = child._cLatLng || child._latlng;
			}
		},

		/**
		 * Assigns impossible bounding values so that the next extend entirely determines the new bounds.
		 * This method avoids having to trash the previous L.LatLngBounds object and to create a new one, which is much slower for this class.
		 * As long as the bounds are not extended, most other methods would probably fail, as they would with bounds initialized but not extended.
		 * @private
		 */
		_resetBounds: function () {
			var bounds = this._bounds;

			if (bounds._southWest) {
				bounds._southWest.lat = Infinity;
				bounds._southWest.lng = Infinity;
			}
			if (bounds._northEast) {
				bounds._northEast.lat = -Infinity;
				bounds._northEast.lng = -Infinity;
			}
		},

		_recalculateBounds: function () {
			var markers = this._markers,
			    childClusters = this._childClusters,
			    latSum = 0,
			    lngSum = 0,
			    totalCount = this._childCount,
			    i, child, childLatLng, childCount;

			// Case where all markers are removed from the map and we are left with just an empty _topClusterLevel.
			if (totalCount === 0) {
				return;
			}

			// Reset rather than creating a new object, for performance.
			this._resetBounds();

			// Child markers.
			for (i = 0; i < markers.length; i++) {
				childLatLng = markers[i]._latlng;

				this._bounds.extend(childLatLng);

				latSum += childLatLng.lat;
				lngSum += childLatLng.lng;
			}

			// Child clusters.
			for (i = 0; i < childClusters.length; i++) {
				child = childClusters[i];

				// Re-compute child bounds and weighted position first if necessary.
				if (child._boundsNeedUpdate) {
					child._recalculateBounds();
				}

				this._bounds.extend(child._bounds);

				childLatLng = child._wLatLng;
				childCount = child._childCount;

				latSum += childLatLng.lat * childCount;
				lngSum += childLatLng.lng * childCount;
			}

			this._latlng = this._wLatLng = new L.LatLng(latSum / totalCount, lngSum / totalCount);

			// Reset dirty flag.
			this._boundsNeedUpdate = false;
		},

		//Set our markers position as given and add it to the map
		_addToMap: function (startPos) {
			if (startPos) {
				this._backupLatlng = this._latlng;
				this.setLatLng(startPos);
			}
			this._group._featureGroup.addLayer(this);
		},

		_recursivelyAnimateChildrenIn: function (bounds, center, maxZoom) {
			this._recursively(bounds, this._group._map.getMinZoom(), maxZoom - 1,
				function (c) {
					var markers = c._markers,
						i, m;
					for (i = markers.length - 1; i >= 0; i--) {
						m = markers[i];

						//Only do it if the icon is still on the map
						if (m._icon) {
							m._setPos(center);
							m.clusterHide();
						}
					}
				},
				function (c) {
					var childClusters = c._childClusters,
						j, cm;
					for (j = childClusters.length - 1; j >= 0; j--) {
						cm = childClusters[j];
						if (cm._icon) {
							cm._setPos(center);
							cm.clusterHide();
						}
					}
				}
			);
		},

		_recursivelyAnimateChildrenInAndAddSelfToMap: function (bounds, mapMinZoom, previousZoomLevel, newZoomLevel) {
			this._recursively(bounds, newZoomLevel, mapMinZoom,
				function (c) {
					c._recursivelyAnimateChildrenIn(bounds, c._group._map.latLngToLayerPoint(c.getLatLng()).round(), previousZoomLevel);

					//TODO: depthToAnimateIn affects _isSingleParent, if there is a multizoom we may/may not be.
					//As a hack we only do a animation free zoom on a single level zoom, if someone does multiple levels then we always animate
					if (c._isSingleParent() && previousZoomLevel - 1 === newZoomLevel) {
						c.clusterShow();
						c._recursivelyRemoveChildrenFromMap(bounds, mapMinZoom, previousZoomLevel); //Immediately remove our children as we are replacing them. TODO previousBounds not bounds
					} else {
						c.clusterHide();
					}

					c._addToMap();
				}
			);
		},

		_recursivelyBecomeVisible: function (bounds, zoomLevel) {
			this._recursively(bounds, this._group._map.getMinZoom(), zoomLevel, null, function (c) {
				c.clusterShow();
			});
		},

		_recursivelyAddChildrenToMap: function (startPos, zoomLevel, bounds) {
			this._recursively(bounds, this._group._map.getMinZoom() - 1, zoomLevel,
				function (c) {
					if (zoomLevel === c._zoom) {
						return;
					}

					//Add our child markers at startPos (so they can be animated out)
					for (var i = c._markers.length - 1; i >= 0; i--) {
						var nm = c._markers[i];

						if (!bounds.contains(nm._latlng)) {
							continue;
						}

						if (startPos) {
							nm._backupLatlng = nm.getLatLng();

							nm.setLatLng(startPos);
							if (nm.clusterHide) {
								nm.clusterHide();
							}
						}

						c._group._featureGroup.addLayer(nm);
					}
				},
				function (c) {
					c._addToMap(startPos);
				}
			);
		},

		_recursivelyRestoreChildPositions: function (zoomLevel) {
			//Fix positions of child markers
			for (var i = this._markers.length - 1; i >= 0; i--) {
				var nm = this._markers[i];
				if (nm._backupLatlng) {
					nm.setLatLng(nm._backupLatlng);
					delete nm._backupLatlng;
				}
			}

			if (zoomLevel - 1 === this._zoom) {
				//Reposition child clusters
				for (var j = this._childClusters.length - 1; j >= 0; j--) {
					this._childClusters[j]._restorePosition();
				}
			} else {
				for (var k = this._childClusters.length - 1; k >= 0; k--) {
					this._childClusters[k]._recursivelyRestoreChildPositions(zoomLevel);
				}
			}
		},

		_restorePosition: function () {
			if (this._backupLatlng) {
				this.setLatLng(this._backupLatlng);
				delete this._backupLatlng;
			}
		},

		//exceptBounds: If set, don't remove any markers/clusters in it
		_recursivelyRemoveChildrenFromMap: function (previousBounds, mapMinZoom, zoomLevel, exceptBounds) {
			var m, i;
			this._recursively(previousBounds, mapMinZoom - 1, zoomLevel - 1,
				function (c) {
					//Remove markers at every level
					for (i = c._markers.length - 1; i >= 0; i--) {
						m = c._markers[i];
						if (!exceptBounds || !exceptBounds.contains(m._latlng)) {
							c._group._featureGroup.removeLayer(m);
							if (m.clusterShow) {
								m.clusterShow();
							}
						}
					}
				},
				function (c) {
					//Remove child clusters at just the bottom level
					for (i = c._childClusters.length - 1; i >= 0; i--) {
						m = c._childClusters[i];
						if (!exceptBounds || !exceptBounds.contains(m._latlng)) {
							c._group._featureGroup.removeLayer(m);
							if (m.clusterShow) {
								m.clusterShow();
							}
						}
					}
				}
			);
		},

		//Run the given functions recursively to this and child clusters
		// boundsToApplyTo: a L.LatLngBounds representing the bounds of what clusters to recurse in to
		// zoomLevelToStart: zoom level to start running functions (inclusive)
		// zoomLevelToStop: zoom level to stop running functions (inclusive)
		// runAtEveryLevel: function that takes an L.MarkerCluster as an argument that should be applied on every level
		// runAtBottomLevel: function that takes an L.MarkerCluster as an argument that should be applied at only the bottom level
		_recursively: function (boundsToApplyTo, zoomLevelToStart, zoomLevelToStop, runAtEveryLevel, runAtBottomLevel) {
			var childClusters = this._childClusters,
			    zoom = this._zoom,
			    i, c;

			if (zoomLevelToStart <= zoom) {
				if (runAtEveryLevel) {
					runAtEveryLevel(this);
				}
				if (runAtBottomLevel && zoom === zoomLevelToStop) {
					runAtBottomLevel(this);
				}
			}

			if (zoom < zoomLevelToStart || zoom < zoomLevelToStop) {
				for (i = childClusters.length - 1; i >= 0; i--) {
					c = childClusters[i];
					if (c._boundsNeedUpdate) {
						c._recalculateBounds();
					}
					if (boundsToApplyTo.intersects(c._bounds)) {
						c._recursively(boundsToApplyTo, zoomLevelToStart, zoomLevelToStop, runAtEveryLevel, runAtBottomLevel);
					}
				}
			}
		},

		//Returns true if we are the parent of only one cluster and that cluster is the same as us
		_isSingleParent: function () {
			//Don't need to check this._markers as the rest won't work if there are any
			return this._childClusters.length > 0 && this._childClusters[0]._childCount === this._childCount;
		}
	});

	/*
	* Extends L.Marker to include two extra methods: clusterHide and clusterShow.
	* 
	* They work as setOpacity(0) and setOpacity(1) respectively, but
	* don't overwrite the options.opacity
	* 
	*/

	L.Marker.include({
		clusterHide: function () {
			var backup = this.options.opacity;
			this.setOpacity(0);
			this.options.opacity = backup;
			return this;
		},
		
		clusterShow: function () {
			return this.setOpacity(this.options.opacity);
		}
	});

	L.DistanceGrid = function (cellSize) {
		this._cellSize = cellSize;
		this._sqCellSize = cellSize * cellSize;
		this._grid = {};
		this._objectPoint = { };
	};

	L.DistanceGrid.prototype = {

		addObject: function (obj, point) {
			var x = this._getCoord(point.x),
			    y = this._getCoord(point.y),
			    grid = this._grid,
			    row = grid[y] = grid[y] || {},
			    cell = row[x] = row[x] || [],
			    stamp = L.Util.stamp(obj);

			this._objectPoint[stamp] = point;

			cell.push(obj);
		},

		updateObject: function (obj, point) {
			this.removeObject(obj);
			this.addObject(obj, point);
		},

		//Returns true if the object was found
		removeObject: function (obj, point) {
			var x = this._getCoord(point.x),
			    y = this._getCoord(point.y),
			    grid = this._grid,
			    row = grid[y] = grid[y] || {},
			    cell = row[x] = row[x] || [],
			    i, len;

			delete this._objectPoint[L.Util.stamp(obj)];

			for (i = 0, len = cell.length; i < len; i++) {
				if (cell[i] === obj) {

					cell.splice(i, 1);

					if (len === 1) {
						delete row[x];
					}

					return true;
				}
			}

		},

		eachObject: function (fn, context) {
			var i, j, k, len, row, cell, removed,
			    grid = this._grid;

			for (i in grid) {
				row = grid[i];

				for (j in row) {
					cell = row[j];

					for (k = 0, len = cell.length; k < len; k++) {
						removed = fn.call(context, cell[k]);
						if (removed) {
							k--;
							len--;
						}
					}
				}
			}
		},

		getNearObject: function (point) {
			var x = this._getCoord(point.x),
			    y = this._getCoord(point.y),
			    i, j, k, row, cell, len, obj, dist,
			    objectPoint = this._objectPoint,
			    closestDistSq = this._sqCellSize,
			    closest = null;

			for (i = y - 1; i <= y + 1; i++) {
				row = this._grid[i];
				if (row) {

					for (j = x - 1; j <= x + 1; j++) {
						cell = row[j];
						if (cell) {

							for (k = 0, len = cell.length; k < len; k++) {
								obj = cell[k];
								dist = this._sqDist(objectPoint[L.Util.stamp(obj)], point);
								if (dist < closestDistSq ||
									dist <= closestDistSq && closest === null) {
									closestDistSq = dist;
									closest = obj;
								}
							}
						}
					}
				}
			}
			return closest;
		},

		_getCoord: function (x) {
			var coord = Math.floor(x / this._cellSize);
			return isFinite(coord) ? coord : x;
		},

		_sqDist: function (p, p2) {
			var dx = p2.x - p.x,
			    dy = p2.y - p.y;
			return dx * dx + dy * dy;
		}
	};

	/* Copyright (c) 2012 the authors listed at the following URL, and/or
	the authors of referenced articles or incorporated external code:
	http://en.literateprograms.org/Quickhull_(Javascript)?action=history&offset=20120410175256

	Permission is hereby granted, free of charge, to any person obtaining
	a copy of this software and associated documentation files (the
	"Software"), to deal in the Software without restriction, including
	without limitation the rights to use, copy, modify, merge, publish,
	distribute, sublicense, and/or sell copies of the Software, and to
	permit persons to whom the Software is furnished to do so, subject to
	the following conditions:

	The above copyright notice and this permission notice shall be
	included in all copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
	IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
	CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
	TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
	SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

	Retrieved from: http://en.literateprograms.org/Quickhull_(Javascript)?oldid=18434
	*/

	(function () {
		L.QuickHull = {

			/*
			 * @param {Object} cpt a point to be measured from the baseline
			 * @param {Array} bl the baseline, as represented by a two-element
			 *   array of latlng objects.
			 * @returns {Number} an approximate distance measure
			 */
			getDistant: function (cpt, bl) {
				var vY = bl[1].lat - bl[0].lat,
					vX = bl[0].lng - bl[1].lng;
				return (vX * (cpt.lat - bl[0].lat) + vY * (cpt.lng - bl[0].lng));
			},

			/*
			 * @param {Array} baseLine a two-element array of latlng objects
			 *   representing the baseline to project from
			 * @param {Array} latLngs an array of latlng objects
			 * @returns {Object} the maximum point and all new points to stay
			 *   in consideration for the hull.
			 */
			findMostDistantPointFromBaseLine: function (baseLine, latLngs) {
				var maxD = 0,
					maxPt = null,
					newPoints = [],
					i, pt, d;

				for (i = latLngs.length - 1; i >= 0; i--) {
					pt = latLngs[i];
					d = this.getDistant(pt, baseLine);

					if (d > 0) {
						newPoints.push(pt);
					} else {
						continue;
					}

					if (d > maxD) {
						maxD = d;
						maxPt = pt;
					}
				}

				return { maxPoint: maxPt, newPoints: newPoints };
			},


			/*
			 * Given a baseline, compute the convex hull of latLngs as an array
			 * of latLngs.
			 *
			 * @param {Array} latLngs
			 * @returns {Array}
			 */
			buildConvexHull: function (baseLine, latLngs) {
				var convexHullBaseLines = [],
					t = this.findMostDistantPointFromBaseLine(baseLine, latLngs);

				if (t.maxPoint) { // if there is still a point "outside" the base line
					convexHullBaseLines =
						convexHullBaseLines.concat(
							this.buildConvexHull([baseLine[0], t.maxPoint], t.newPoints)
						);
					convexHullBaseLines =
						convexHullBaseLines.concat(
							this.buildConvexHull([t.maxPoint, baseLine[1]], t.newPoints)
						);
					return convexHullBaseLines;
				} else {  // if there is no more point "outside" the base line, the current base line is part of the convex hull
					return [baseLine[0]];
				}
			},

			/*
			 * Given an array of latlngs, compute a convex hull as an array
			 * of latlngs
			 *
			 * @param {Array} latLngs
			 * @returns {Array}
			 */
			getConvexHull: function (latLngs) {
				// find first baseline
				var maxLat = false, minLat = false,
					maxLng = false, minLng = false,
					maxLatPt = null, minLatPt = null,
					maxLngPt = null, minLngPt = null,
					maxPt = null, minPt = null,
					i;

				for (i = latLngs.length - 1; i >= 0; i--) {
					var pt = latLngs[i];
					if (maxLat === false || pt.lat > maxLat) {
						maxLatPt = pt;
						maxLat = pt.lat;
					}
					if (minLat === false || pt.lat < minLat) {
						minLatPt = pt;
						minLat = pt.lat;
					}
					if (maxLng === false || pt.lng > maxLng) {
						maxLngPt = pt;
						maxLng = pt.lng;
					}
					if (minLng === false || pt.lng < minLng) {
						minLngPt = pt;
						minLng = pt.lng;
					}
				}
				
				if (minLat !== maxLat) {
					minPt = minLatPt;
					maxPt = maxLatPt;
				} else {
					minPt = minLngPt;
					maxPt = maxLngPt;
				}

				var ch = [].concat(this.buildConvexHull([minPt, maxPt], latLngs),
									this.buildConvexHull([maxPt, minPt], latLngs));
				return ch;
			}
		};
	}());

	L.MarkerCluster.include({
		getConvexHull: function () {
			var childMarkers = this.getAllChildMarkers(),
				points = [],
				p, i;

			for (i = childMarkers.length - 1; i >= 0; i--) {
				p = childMarkers[i].getLatLng();
				points.push(p);
			}

			return L.QuickHull.getConvexHull(points);
		}
	});

	//This code is 100% based on https://github.com/jawj/OverlappingMarkerSpiderfier-Leaflet
	//Huge thanks to jawj for implementing it first to make my job easy :-)

	L.MarkerCluster.include({

		_2PI: Math.PI * 2,
		_circleFootSeparation: 25, //related to circumference of circle
		_circleStartAngle: 0,

		_spiralFootSeparation:  28, //related to size of spiral (experiment!)
		_spiralLengthStart: 11,
		_spiralLengthFactor: 5,

		_circleSpiralSwitchover: 9, //show spiral instead of circle from this marker count upwards.
									// 0 -> always spiral; Infinity -> always circle

		spiderfy: function () {
			if (this._group._spiderfied === this || this._group._inZoomAnimation) {
				return;
			}

			var childMarkers = this.getAllChildMarkers(null, true),
				group = this._group,
				map = group._map,
				center = map.latLngToLayerPoint(this._latlng),
				positions;

			this._group._unspiderfy();
			this._group._spiderfied = this;

			//TODO Maybe: childMarkers order by distance to center

			if (this._group.options.spiderfyShapePositions) {
				positions = this._group.options.spiderfyShapePositions(childMarkers.length, center);
			} else if (childMarkers.length >= this._circleSpiralSwitchover) {
				positions = this._generatePointsSpiral(childMarkers.length, center);
			} else {
				center.y += 10; // Otherwise circles look wrong => hack for standard blue icon, renders differently for other icons.
				positions = this._generatePointsCircle(childMarkers.length, center);
			}

			this._animationSpiderfy(childMarkers, positions);
		},

		unspiderfy: function (zoomDetails) {
			/// <param Name="zoomDetails">Argument from zoomanim if being called in a zoom animation or null otherwise</param>
			if (this._group._inZoomAnimation) {
				return;
			}
			this._animationUnspiderfy(zoomDetails);

			this._group._spiderfied = null;
		},

		_generatePointsCircle: function (count, centerPt) {
			var circumference = this._group.options.spiderfyDistanceMultiplier * this._circleFootSeparation * (2 + count),
				legLength = circumference / this._2PI,  //radius from circumference
				angleStep = this._2PI / count,
				res = [],
				i, angle;

			legLength = Math.max(legLength, 35); // Minimum distance to get outside the cluster icon.

			res.length = count;

			for (i = 0; i < count; i++) { // Clockwise, like spiral.
				angle = this._circleStartAngle + i * angleStep;
				res[i] = new L.Point(centerPt.x + legLength * Math.cos(angle), centerPt.y + legLength * Math.sin(angle))._round();
			}

			return res;
		},

		_generatePointsSpiral: function (count, centerPt) {
			var spiderfyDistanceMultiplier = this._group.options.spiderfyDistanceMultiplier,
				legLength = spiderfyDistanceMultiplier * this._spiralLengthStart,
				separation = spiderfyDistanceMultiplier * this._spiralFootSeparation,
				lengthFactor = spiderfyDistanceMultiplier * this._spiralLengthFactor * this._2PI,
				angle = 0,
				res = [],
				i;

			res.length = count;

			// Higher index, closer position to cluster center.
			for (i = count; i >= 0; i--) {
				// Skip the first position, so that we are already farther from center and we avoid
				// being under the default cluster icon (especially important for Circle Markers).
				if (i < count) {
					res[i] = new L.Point(centerPt.x + legLength * Math.cos(angle), centerPt.y + legLength * Math.sin(angle))._round();
				}
				angle += separation / legLength + i * 0.0005;
				legLength += lengthFactor / angle;
			}
			return res;
		},

		_noanimationUnspiderfy: function () {
			var group = this._group,
				map = group._map,
				fg = group._featureGroup,
				childMarkers = this.getAllChildMarkers(null, true),
				m, i;

			group._ignoreMove = true;

			this.setOpacity(1);
			for (i = childMarkers.length - 1; i >= 0; i--) {
				m = childMarkers[i];

				fg.removeLayer(m);

				if (m._preSpiderfyLatlng) {
					m.setLatLng(m._preSpiderfyLatlng);
					delete m._preSpiderfyLatlng;
				}
				if (m.setZIndexOffset) {
					m.setZIndexOffset(0);
				}

				if (m._spiderLeg) {
					map.removeLayer(m._spiderLeg);
					delete m._spiderLeg;
				}
			}

			group.fire('unspiderfied', {
				cluster: this,
				markers: childMarkers
			});
			group._ignoreMove = false;
			group._spiderfied = null;
		}
	});

	//Non Animated versions of everything
	L.MarkerClusterNonAnimated = L.MarkerCluster.extend({
		_animationSpiderfy: function (childMarkers, positions) {
			var group = this._group,
				map = group._map,
				fg = group._featureGroup,
				legOptions = this._group.options.spiderLegPolylineOptions,
				i, m, leg, newPos;

			group._ignoreMove = true;

			// Traverse in ascending order to make sure that inner circleMarkers are on top of further legs. Normal markers are re-ordered by newPosition.
			// The reverse order trick no longer improves performance on modern browsers.
			for (i = 0; i < childMarkers.length; i++) {
				newPos = map.layerPointToLatLng(positions[i]);
				m = childMarkers[i];

				// Add the leg before the marker, so that in case the latter is a circleMarker, the leg is behind it.
				leg = new L.Polyline([this._latlng, newPos], legOptions);
				map.addLayer(leg);
				m._spiderLeg = leg;

				// Now add the marker.
				m._preSpiderfyLatlng = m._latlng;
				m.setLatLng(newPos);
				if (m.setZIndexOffset) {
					m.setZIndexOffset(1000000); //Make these appear on top of EVERYTHING
				}

				fg.addLayer(m);
			}
			this.setOpacity(0.3);

			group._ignoreMove = false;
			group.fire('spiderfied', {
				cluster: this,
				markers: childMarkers
			});
		},

		_animationUnspiderfy: function () {
			this._noanimationUnspiderfy();
		}
	});

	//Animated versions here
	L.MarkerCluster.include({

		_animationSpiderfy: function (childMarkers, positions) {
			var me = this,
				group = this._group,
				map = group._map,
				fg = group._featureGroup,
				thisLayerLatLng = this._latlng,
				thisLayerPos = map.latLngToLayerPoint(thisLayerLatLng),
				svg = L.Path.SVG,
				legOptions = L.extend({}, this._group.options.spiderLegPolylineOptions), // Copy the options so that we can modify them for animation.
				finalLegOpacity = legOptions.opacity,
				i, m, leg, legPath, legLength, newPos;

			if (finalLegOpacity === undefined) {
				finalLegOpacity = L.MarkerClusterGroup.prototype.options.spiderLegPolylineOptions.opacity;
			}

			if (svg) {
				// If the initial opacity of the spider leg is not 0 then it appears before the animation starts.
				legOptions.opacity = 0;

				// Add the class for CSS transitions.
				legOptions.className = (legOptions.className || '') + ' leaflet-cluster-spider-leg';
			} else {
				// Make sure we have a defined opacity.
				legOptions.opacity = finalLegOpacity;
			}

			group._ignoreMove = true;

			// Add markers and spider legs to map, hidden at our center point.
			// Traverse in ascending order to make sure that inner circleMarkers are on top of further legs. Normal markers are re-ordered by newPosition.
			// The reverse order trick no longer improves performance on modern browsers.
			for (i = 0; i < childMarkers.length; i++) {
				m = childMarkers[i];

				newPos = map.layerPointToLatLng(positions[i]);

				// Add the leg before the marker, so that in case the latter is a circleMarker, the leg is behind it.
				leg = new L.Polyline([thisLayerLatLng, newPos], legOptions);
				map.addLayer(leg);
				m._spiderLeg = leg;

				// Explanations: https://jakearchibald.com/2013/animated-line-drawing-svg/
				// In our case the transition property is declared in the CSS file.
				if (svg) {
					legPath = leg._path;
					legLength = legPath.getTotalLength() + 0.1; // Need a small extra length to avoid remaining dot in Firefox.
					legPath.style.strokeDasharray = legLength; // Just 1 length is enough, it will be duplicated.
					legPath.style.strokeDashoffset = legLength;
				}

				// If it is a marker, add it now and we'll animate it out
				if (m.setZIndexOffset) {
					m.setZIndexOffset(1000000); // Make normal markers appear on top of EVERYTHING
				}
				if (m.clusterHide) {
					m.clusterHide();
				}
				
				// Vectors just get immediately added
				fg.addLayer(m);

				if (m._setPos) {
					m._setPos(thisLayerPos);
				}
			}

			group._forceLayout();
			group._animationStart();

			// Reveal markers and spider legs.
			for (i = childMarkers.length - 1; i >= 0; i--) {
				newPos = map.layerPointToLatLng(positions[i]);
				m = childMarkers[i];

				//Move marker to new position
				m._preSpiderfyLatlng = m._latlng;
				m.setLatLng(newPos);
				
				if (m.clusterShow) {
					m.clusterShow();
				}

				// Animate leg (animation is actually delegated to CSS transition).
				if (svg) {
					leg = m._spiderLeg;
					legPath = leg._path;
					legPath.style.strokeDashoffset = 0;
					//legPath.style.strokeOpacity = finalLegOpacity;
					leg.setStyle({opacity: finalLegOpacity});
				}
			}
			this.setOpacity(0.3);

			group._ignoreMove = false;

			setTimeout(function () {
				group._animationEnd();
				group.fire('spiderfied', {
					cluster: me,
					markers: childMarkers
				});
			}, 200);
		},

		_animationUnspiderfy: function (zoomDetails) {
			var me = this,
				group = this._group,
				map = group._map,
				fg = group._featureGroup,
				thisLayerPos = zoomDetails ? map._latLngToNewLayerPoint(this._latlng, zoomDetails.zoom, zoomDetails.center) : map.latLngToLayerPoint(this._latlng),
				childMarkers = this.getAllChildMarkers(null, true),
				svg = L.Path.SVG,
				m, i, leg, legPath, legLength, nonAnimatable;

			group._ignoreMove = true;
			group._animationStart();

			//Make us visible and bring the child markers back in
			this.setOpacity(1);
			for (i = childMarkers.length - 1; i >= 0; i--) {
				m = childMarkers[i];

				//Marker was added to us after we were spiderfied
				if (!m._preSpiderfyLatlng) {
					continue;
				}

				//Close any popup on the marker first, otherwise setting the location of the marker will make the map scroll
				m.closePopup();

				//Fix up the location to the real one
				m.setLatLng(m._preSpiderfyLatlng);
				delete m._preSpiderfyLatlng;

				//Hack override the location to be our center
				nonAnimatable = true;
				if (m._setPos) {
					m._setPos(thisLayerPos);
					nonAnimatable = false;
				}
				if (m.clusterHide) {
					m.clusterHide();
					nonAnimatable = false;
				}
				if (nonAnimatable) {
					fg.removeLayer(m);
				}

				// Animate the spider leg back in (animation is actually delegated to CSS transition).
				if (svg) {
					leg = m._spiderLeg;
					legPath = leg._path;
					legLength = legPath.getTotalLength() + 0.1;
					legPath.style.strokeDashoffset = legLength;
					leg.setStyle({opacity: 0});
				}
			}

			group._ignoreMove = false;

			setTimeout(function () {
				//If we have only <= one child left then that marker will be shown on the map so don't remove it!
				var stillThereChildCount = 0;
				for (i = childMarkers.length - 1; i >= 0; i--) {
					m = childMarkers[i];
					if (m._spiderLeg) {
						stillThereChildCount++;
					}
				}


				for (i = childMarkers.length - 1; i >= 0; i--) {
					m = childMarkers[i];

					if (!m._spiderLeg) { //Has already been unspiderfied
						continue;
					}

					if (m.clusterShow) {
						m.clusterShow();
					}
					if (m.setZIndexOffset) {
						m.setZIndexOffset(0);
					}

					if (stillThereChildCount > 1) {
						fg.removeLayer(m);
					}

					map.removeLayer(m._spiderLeg);
					delete m._spiderLeg;
				}
				group._animationEnd();
				group.fire('unspiderfied', {
					cluster: me,
					markers: childMarkers
				});
			}, 200);
		}
	});


	L.MarkerClusterGroup.include({
		//The MarkerCluster currently spiderfied (if any)
		_spiderfied: null,

		unspiderfy: function () {
			this._unspiderfy.apply(this, arguments);
		},

		_spiderfierOnAdd: function () {
			this._map.on('click', this._unspiderfyWrapper, this);

			if (this._map.options.zoomAnimation) {
				this._map.on('zoomstart', this._unspiderfyZoomStart, this);
			}
			//Browsers without zoomAnimation or a big zoom don't fire zoomstart
			this._map.on('zoomend', this._noanimationUnspiderfy, this);

			if (!L.Browser.touch) {
				this._map.getRenderer(this);
				//Needs to happen in the pageload, not after, or animations don't work in webkit
				//  http://stackoverflow.com/questions/8455200/svg-animate-with-dynamically-added-elements
				//Disable on touch browsers as the animation messes up on a touch zoom and isn't very noticable
			}
		},

		_spiderfierOnRemove: function () {
			this._map.off('click', this._unspiderfyWrapper, this);
			this._map.off('zoomstart', this._unspiderfyZoomStart, this);
			this._map.off('zoomanim', this._unspiderfyZoomAnim, this);
			this._map.off('zoomend', this._noanimationUnspiderfy, this);

			//Ensure that markers are back where they should be
			// Use no animation to avoid a sticky leaflet-cluster-anim class on mapPane
			this._noanimationUnspiderfy();
		},

		//On zoom start we add a zoomanim handler so that we are guaranteed to be last (after markers are animated)
		//This means we can define the animation they do rather than Markers doing an animation to their actual location
		_unspiderfyZoomStart: function () {
			if (!this._map) { //May have been removed from the map by a zoomEnd handler
				return;
			}

			this._map.on('zoomanim', this._unspiderfyZoomAnim, this);
		},

		_unspiderfyZoomAnim: function (zoomDetails) {
			//Wait until the first zoomanim after the user has finished touch-zooming before running the animation
			if (L.DomUtil.hasClass(this._map._mapPane, 'leaflet-touching')) {
				return;
			}

			this._map.off('zoomanim', this._unspiderfyZoomAnim, this);
			this._unspiderfy(zoomDetails);
		},

		_unspiderfyWrapper: function () {
			/// <summary>_unspiderfy but passes no arguments</summary>
			this._unspiderfy();
		},

		_unspiderfy: function (zoomDetails) {
			if (this._spiderfied) {
				this._spiderfied.unspiderfy(zoomDetails);
			}
		},

		_noanimationUnspiderfy: function () {
			if (this._spiderfied) {
				this._spiderfied._noanimationUnspiderfy();
			}
		},

		//If the given layer is currently being spiderfied then we unspiderfy it so it isn't on the map anymore etc
		_unspiderfyLayer: function (layer) {
			if (layer._spiderLeg) {
				this._featureGroup.removeLayer(layer);

				if (layer.clusterShow) {
					layer.clusterShow();
				}
					//Position will be fixed up immediately in _animationUnspiderfy
				if (layer.setZIndexOffset) {
					layer.setZIndexOffset(0);
				}

				this._map.removeLayer(layer._spiderLeg);
				delete layer._spiderLeg;
			}
		}
	});

	/**
	 * Adds 1 public method to MCG and 1 to L.Marker to facilitate changing
	 * markers' icon options and refreshing their icon and their parent clusters
	 * accordingly (case where their iconCreateFunction uses data of childMarkers
	 * to make up the cluster icon).
	 */


	L.MarkerClusterGroup.include({
		/**
		 * Updates the icon of all clusters which are parents of the given marker(s).
		 * In singleMarkerMode, also updates the given marker(s) icon.
		 * @param layers L.MarkerClusterGroup|L.LayerGroup|Array(L.Marker)|Map(L.Marker)|
		 * L.MarkerCluster|L.Marker (optional) list of markers (or single marker) whose parent
		 * clusters need to be updated. If not provided, retrieves all child markers of this.
		 * @returns {L.MarkerClusterGroup}
		 */
		refreshClusters: function (layers) {
			if (!layers) {
				layers = this._topClusterLevel.getAllChildMarkers();
			} else if (layers instanceof L.MarkerClusterGroup) {
				layers = layers._topClusterLevel.getAllChildMarkers();
			} else if (layers instanceof L.LayerGroup) {
				layers = layers._layers;
			} else if (layers instanceof L.MarkerCluster) {
				layers = layers.getAllChildMarkers();
			} else if (layers instanceof L.Marker) {
				layers = [layers];
			} // else: must be an Array(L.Marker)|Map(L.Marker)
			this._flagParentsIconsNeedUpdate(layers);
			this._refreshClustersIcons();

			// In case of singleMarkerMode, also re-draw the markers.
			if (this.options.singleMarkerMode) {
				this._refreshSingleMarkerModeMarkers(layers);
			}

			return this;
		},

		/**
		 * Simply flags all parent clusters of the given markers as having a "dirty" icon.
		 * @param layers Array(L.Marker)|Map(L.Marker) list of markers.
		 * @private
		 */
		_flagParentsIconsNeedUpdate: function (layers) {
			var id, parent;

			// Assumes layers is an Array or an Object whose prototype is non-enumerable.
			for (id in layers) {
				// Flag parent clusters' icon as "dirty", all the way up.
				// Dumb process that flags multiple times upper parents, but still
				// much more efficient than trying to be smart and make short lists,
				// at least in the case of a hierarchy following a power law:
				// http://jsperf.com/flag-nodes-in-power-hierarchy/2
				parent = layers[id].__parent;
				while (parent) {
					parent._iconNeedsUpdate = true;
					parent = parent.__parent;
				}
			}
		},

		/**
		 * Re-draws the icon of the supplied markers.
		 * To be used in singleMarkerMode only.
		 * @param layers Array(L.Marker)|Map(L.Marker) list of markers.
		 * @private
		 */
		_refreshSingleMarkerModeMarkers: function (layers) {
			var id, layer;

			for (id in layers) {
				layer = layers[id];

				// Make sure we do not override markers that do not belong to THIS group.
				if (this.hasLayer(layer)) {
					// Need to re-create the icon first, then re-draw the marker.
					layer.setIcon(this._overrideMarkerIcon(layer));
				}
			}
		}
	});

	L.Marker.include({
		/**
		 * Updates the given options in the marker's icon and refreshes the marker.
		 * @param options map object of icon options.
		 * @param directlyRefreshClusters boolean (optional) true to trigger
		 * MCG.refreshClustersOf() right away with this single marker.
		 * @returns {L.Marker}
		 */
		refreshIconOptions: function (options, directlyRefreshClusters) {
			var icon = this.options.icon;

			L.setOptions(icon, options);

			this.setIcon(icon);

			// Shortcut to refresh the associated MCG clusters right away.
			// To be used when refreshing a single marker.
			// Otherwise, better use MCG.refreshClusters() once at the end with
			// the list of modified markers.
			if (directlyRefreshClusters && this.__parent) {
				this.__parent._group.refreshClusters(this);
			}

			return this;
		}
	});

	exports.MarkerCluster = MarkerCluster;
	exports.MarkerClusterGroup = MarkerClusterGroup;

	Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=leaflet.markercluster-src.js.map


/***/ }),

/***/ "./node_modules/fuse.js/dist/fuse.esm.js":
/*!***********************************************!*\
  !*** ./node_modules/fuse.js/dist/fuse.esm.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Fuse.js v6.4.6 - Lightweight fuzzy-search (http://fusejs.io)
 *
 * Copyright (c) 2021 Kiro Risk (http://kiro.me)
 * All Rights Reserved. Apache Software License 2.0
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 */

function isArray(value) {
  return !Array.isArray
    ? getTag(value) === '[object Array]'
    : Array.isArray(value)
}

// Adapted from: https://github.com/lodash/lodash/blob/master/.internal/baseToString.js
const INFINITY = 1 / 0;
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value
  }
  let result = value + '';
  return result == '0' && 1 / value == -INFINITY ? '-0' : result
}

function toString(value) {
  return value == null ? '' : baseToString(value)
}

function isString(value) {
  return typeof value === 'string'
}

function isNumber(value) {
  return typeof value === 'number'
}

// Adapted from: https://github.com/lodash/lodash/blob/master/isBoolean.js
function isBoolean(value) {
  return (
    value === true ||
    value === false ||
    (isObjectLike(value) && getTag(value) == '[object Boolean]')
  )
}

function isObject(value) {
  return typeof value === 'object'
}

// Checks if `value` is object-like.
function isObjectLike(value) {
  return isObject(value) && value !== null
}

function isDefined(value) {
  return value !== undefined && value !== null
}

function isBlank(value) {
  return !value.trim().length
}

// Gets the `toStringTag` of `value`.
// Adapted from: https://github.com/lodash/lodash/blob/master/.internal/getTag.js
function getTag(value) {
  return value == null
    ? value === undefined
      ? '[object Undefined]'
      : '[object Null]'
    : Object.prototype.toString.call(value)
}

const EXTENDED_SEARCH_UNAVAILABLE = 'Extended search is not available';

const INCORRECT_INDEX_TYPE = "Incorrect 'index' type";

const LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY = (key) =>
  `Invalid value for key ${key}`;

const PATTERN_LENGTH_TOO_LARGE = (max) =>
  `Pattern length exceeds max of ${max}.`;

const MISSING_KEY_PROPERTY = (name) => `Missing ${name} property in key`;

const INVALID_KEY_WEIGHT_VALUE = (key) =>
  `Property 'weight' in key '${key}' must be a positive integer`;

const hasOwn = Object.prototype.hasOwnProperty;

class KeyStore {
  constructor(keys) {
    this._keys = [];
    this._keyMap = {};

    let totalWeight = 0;

    keys.forEach((key) => {
      let obj = createKey(key);

      totalWeight += obj.weight;

      this._keys.push(obj);
      this._keyMap[obj.id] = obj;

      totalWeight += obj.weight;
    });

    // Normalize weights so that their sum is equal to 1
    this._keys.forEach((key) => {
      key.weight /= totalWeight;
    });
  }
  get(keyId) {
    return this._keyMap[keyId]
  }
  keys() {
    return this._keys
  }
  toJSON() {
    return JSON.stringify(this._keys)
  }
}

function createKey(key) {
  let path = null;
  let id = null;
  let src = null;
  let weight = 1;

  if (isString(key) || isArray(key)) {
    src = key;
    path = createKeyPath(key);
    id = createKeyId(key);
  } else {
    if (!hasOwn.call(key, 'name')) {
      throw new Error(MISSING_KEY_PROPERTY('name'))
    }

    const name = key.name;
    src = name;

    if (hasOwn.call(key, 'weight')) {
      weight = key.weight;

      if (weight <= 0) {
        throw new Error(INVALID_KEY_WEIGHT_VALUE(name))
      }
    }

    path = createKeyPath(name);
    id = createKeyId(name);
  }

  return { path, id, weight, src }
}

function createKeyPath(key) {
  return isArray(key) ? key : key.split('.')
}

function createKeyId(key) {
  return isArray(key) ? key.join('.') : key
}

function get(obj, path) {
  let list = [];
  let arr = false;

  const deepGet = (obj, path, index) => {
    if (!isDefined(obj)) {
      return
    }
    if (!path[index]) {
      // If there's no path left, we've arrived at the object we care about.
      list.push(obj);
    } else {
      let key = path[index];

      const value = obj[key];

      if (!isDefined(value)) {
        return
      }

      // If we're at the last value in the path, and if it's a string/number/bool,
      // add it to the list
      if (
        index === path.length - 1 &&
        (isString(value) || isNumber(value) || isBoolean(value))
      ) {
        list.push(toString(value));
      } else if (isArray(value)) {
        arr = true;
        // Search each item in the array.
        for (let i = 0, len = value.length; i < len; i += 1) {
          deepGet(value[i], path, index + 1);
        }
      } else if (path.length) {
        // An object. Recurse further.
        deepGet(value, path, index + 1);
      }
    }
  };

  // Backwards compatibility (since path used to be a string)
  deepGet(obj, isString(path) ? path.split('.') : path, 0);

  return arr ? list : list[0]
}

const MatchOptions = {
  // Whether the matches should be included in the result set. When `true`, each record in the result
  // set will include the indices of the matched characters.
  // These can consequently be used for highlighting purposes.
  includeMatches: false,
  // When `true`, the matching function will continue to the end of a search pattern even if
  // a perfect match has already been located in the string.
  findAllMatches: false,
  // Minimum number of characters that must be matched before a result is considered a match
  minMatchCharLength: 1
};

const BasicOptions = {
  // When `true`, the algorithm continues searching to the end of the input even if a perfect
  // match is found before the end of the same input.
  isCaseSensitive: false,
  // When true, the matching function will continue to the end of a search pattern even if
  includeScore: false,
  // List of properties that will be searched. This also supports nested properties.
  keys: [],
  // Whether to sort the result list, by score
  shouldSort: true,
  // Default sort function: sort by ascending score, ascending index
  sortFn: (a, b) =>
    a.score === b.score ? (a.idx < b.idx ? -1 : 1) : a.score < b.score ? -1 : 1
};

const FuzzyOptions = {
  // Approximately where in the text is the pattern expected to be found?
  location: 0,
  // At what point does the match algorithm give up. A threshold of '0.0' requires a perfect match
  // (of both letters and location), a threshold of '1.0' would match anything.
  threshold: 0.6,
  // Determines how close the match must be to the fuzzy location (specified above).
  // An exact letter match which is 'distance' characters away from the fuzzy location
  // would score as a complete mismatch. A distance of '0' requires the match be at
  // the exact location specified, a threshold of '1000' would require a perfect match
  // to be within 800 characters of the fuzzy location to be found using a 0.8 threshold.
  distance: 100
};

const AdvancedOptions = {
  // When `true`, it enables the use of unix-like search commands
  useExtendedSearch: false,
  // The get function to use when fetching an object's properties.
  // The default will search nested paths *ie foo.bar.baz*
  getFn: get,
  // When `true`, search will ignore `location` and `distance`, so it won't matter
  // where in the string the pattern appears.
  // More info: https://fusejs.io/concepts/scoring-theory.html#fuzziness-score
  ignoreLocation: false,
  // When `true`, the calculation for the relevance score (used for sorting) will
  // ignore the field-length norm.
  // More info: https://fusejs.io/concepts/scoring-theory.html#field-length-norm
  ignoreFieldNorm: false
};

var Config = {
  ...BasicOptions,
  ...MatchOptions,
  ...FuzzyOptions,
  ...AdvancedOptions
};

const SPACE = /[^ ]+/g;

// Field-length norm: the shorter the field, the higher the weight.
// Set to 3 decimals to reduce index size.
function norm(mantissa = 3) {
  const cache = new Map();
  const m = Math.pow(10, mantissa);

  return {
    get(value) {
      const numTokens = value.match(SPACE).length;

      if (cache.has(numTokens)) {
        return cache.get(numTokens)
      }

      const norm = 1 / Math.sqrt(numTokens);

      // In place of `toFixed(mantissa)`, for faster computation
      const n = parseFloat(Math.round(norm * m) / m);

      cache.set(numTokens, n);

      return n
    },
    clear() {
      cache.clear();
    }
  }
}

class FuseIndex {
  constructor({ getFn = Config.getFn } = {}) {
    this.norm = norm(3);
    this.getFn = getFn;
    this.isCreated = false;

    this.setIndexRecords();
  }
  setSources(docs = []) {
    this.docs = docs;
  }
  setIndexRecords(records = []) {
    this.records = records;
  }
  setKeys(keys = []) {
    this.keys = keys;
    this._keysMap = {};
    keys.forEach((key, idx) => {
      this._keysMap[key.id] = idx;
    });
  }
  create() {
    if (this.isCreated || !this.docs.length) {
      return
    }

    this.isCreated = true;

    // List is Array<String>
    if (isString(this.docs[0])) {
      this.docs.forEach((doc, docIndex) => {
        this._addString(doc, docIndex);
      });
    } else {
      // List is Array<Object>
      this.docs.forEach((doc, docIndex) => {
        this._addObject(doc, docIndex);
      });
    }

    this.norm.clear();
  }
  // Adds a doc to the end of the index
  add(doc) {
    const idx = this.size();

    if (isString(doc)) {
      this._addString(doc, idx);
    } else {
      this._addObject(doc, idx);
    }
  }
  // Removes the doc at the specified index of the index
  removeAt(idx) {
    this.records.splice(idx, 1);

    // Change ref index of every subsquent doc
    for (let i = idx, len = this.size(); i < len; i += 1) {
      this.records[i].i -= 1;
    }
  }
  getValueForItemAtKeyId(item, keyId) {
    return item[this._keysMap[keyId]]
  }
  size() {
    return this.records.length
  }
  _addString(doc, docIndex) {
    if (!isDefined(doc) || isBlank(doc)) {
      return
    }

    let record = {
      v: doc,
      i: docIndex,
      n: this.norm.get(doc)
    };

    this.records.push(record);
  }
  _addObject(doc, docIndex) {
    let record = { i: docIndex, $: {} };

    // Iterate over every key (i.e, path), and fetch the value at that key
    this.keys.forEach((key, keyIndex) => {
      // console.log(key)
      let value = this.getFn(doc, key.path);

      if (!isDefined(value)) {
        return
      }

      if (isArray(value)) {
        let subRecords = [];
        const stack = [{ nestedArrIndex: -1, value }];

        while (stack.length) {
          const { nestedArrIndex, value } = stack.pop();

          if (!isDefined(value)) {
            continue
          }

          if (isString(value) && !isBlank(value)) {
            let subRecord = {
              v: value,
              i: nestedArrIndex,
              n: this.norm.get(value)
            };

            subRecords.push(subRecord);
          } else if (isArray(value)) {
            value.forEach((item, k) => {
              stack.push({
                nestedArrIndex: k,
                value: item
              });
            });
          }
        }
        record.$[keyIndex] = subRecords;
      } else if (!isBlank(value)) {
        let subRecord = {
          v: value,
          n: this.norm.get(value)
        };

        record.$[keyIndex] = subRecord;
      }
    });

    this.records.push(record);
  }
  toJSON() {
    return {
      keys: this.keys,
      records: this.records
    }
  }
}

function createIndex(keys, docs, { getFn = Config.getFn } = {}) {
  const myIndex = new FuseIndex({ getFn });
  myIndex.setKeys(keys.map(createKey));
  myIndex.setSources(docs);
  myIndex.create();
  return myIndex
}

function parseIndex(data, { getFn = Config.getFn } = {}) {
  const { keys, records } = data;
  const myIndex = new FuseIndex({ getFn });
  myIndex.setKeys(keys);
  myIndex.setIndexRecords(records);
  return myIndex
}

function computeScore(
  pattern,
  {
    errors = 0,
    currentLocation = 0,
    expectedLocation = 0,
    distance = Config.distance,
    ignoreLocation = Config.ignoreLocation
  } = {}
) {
  const accuracy = errors / pattern.length;

  if (ignoreLocation) {
    return accuracy
  }

  const proximity = Math.abs(expectedLocation - currentLocation);

  if (!distance) {
    // Dodge divide by zero error.
    return proximity ? 1.0 : accuracy
  }

  return accuracy + proximity / distance
}

function convertMaskToIndices(
  matchmask = [],
  minMatchCharLength = Config.minMatchCharLength
) {
  let indices = [];
  let start = -1;
  let end = -1;
  let i = 0;

  for (let len = matchmask.length; i < len; i += 1) {
    let match = matchmask[i];
    if (match && start === -1) {
      start = i;
    } else if (!match && start !== -1) {
      end = i - 1;
      if (end - start + 1 >= minMatchCharLength) {
        indices.push([start, end]);
      }
      start = -1;
    }
  }

  // (i-1 - start) + 1 => i - start
  if (matchmask[i - 1] && i - start >= minMatchCharLength) {
    indices.push([start, i - 1]);
  }

  return indices
}

// Machine word size
const MAX_BITS = 32;

function search(
  text,
  pattern,
  patternAlphabet,
  {
    location = Config.location,
    distance = Config.distance,
    threshold = Config.threshold,
    findAllMatches = Config.findAllMatches,
    minMatchCharLength = Config.minMatchCharLength,
    includeMatches = Config.includeMatches,
    ignoreLocation = Config.ignoreLocation
  } = {}
) {
  if (pattern.length > MAX_BITS) {
    throw new Error(PATTERN_LENGTH_TOO_LARGE(MAX_BITS))
  }

  const patternLen = pattern.length;
  // Set starting location at beginning text and initialize the alphabet.
  const textLen = text.length;
  // Handle the case when location > text.length
  const expectedLocation = Math.max(0, Math.min(location, textLen));
  // Highest score beyond which we give up.
  let currentThreshold = threshold;
  // Is there a nearby exact match? (speedup)
  let bestLocation = expectedLocation;

  // Performance: only computer matches when the minMatchCharLength > 1
  // OR if `includeMatches` is true.
  const computeMatches = minMatchCharLength > 1 || includeMatches;
  // A mask of the matches, used for building the indices
  const matchMask = computeMatches ? Array(textLen) : [];

  let index;

  // Get all exact matches, here for speed up
  while ((index = text.indexOf(pattern, bestLocation)) > -1) {
    let score = computeScore(pattern, {
      currentLocation: index,
      expectedLocation,
      distance,
      ignoreLocation
    });

    currentThreshold = Math.min(score, currentThreshold);
    bestLocation = index + patternLen;

    if (computeMatches) {
      let i = 0;
      while (i < patternLen) {
        matchMask[index + i] = 1;
        i += 1;
      }
    }
  }

  // Reset the best location
  bestLocation = -1;

  let lastBitArr = [];
  let finalScore = 1;
  let binMax = patternLen + textLen;

  const mask = 1 << (patternLen - 1);

  for (let i = 0; i < patternLen; i += 1) {
    // Scan for the best match; each iteration allows for one more error.
    // Run a binary search to determine how far from the match location we can stray
    // at this error level.
    let binMin = 0;
    let binMid = binMax;

    while (binMin < binMid) {
      const score = computeScore(pattern, {
        errors: i,
        currentLocation: expectedLocation + binMid,
        expectedLocation,
        distance,
        ignoreLocation
      });

      if (score <= currentThreshold) {
        binMin = binMid;
      } else {
        binMax = binMid;
      }

      binMid = Math.floor((binMax - binMin) / 2 + binMin);
    }

    // Use the result from this iteration as the maximum for the next.
    binMax = binMid;

    let start = Math.max(1, expectedLocation - binMid + 1);
    let finish = findAllMatches
      ? textLen
      : Math.min(expectedLocation + binMid, textLen) + patternLen;

    // Initialize the bit array
    let bitArr = Array(finish + 2);

    bitArr[finish + 1] = (1 << i) - 1;

    for (let j = finish; j >= start; j -= 1) {
      let currentLocation = j - 1;
      let charMatch = patternAlphabet[text.charAt(currentLocation)];

      if (computeMatches) {
        // Speed up: quick bool to int conversion (i.e, `charMatch ? 1 : 0`)
        matchMask[currentLocation] = +!!charMatch;
      }

      // First pass: exact match
      bitArr[j] = ((bitArr[j + 1] << 1) | 1) & charMatch;

      // Subsequent passes: fuzzy match
      if (i) {
        bitArr[j] |=
          ((lastBitArr[j + 1] | lastBitArr[j]) << 1) | 1 | lastBitArr[j + 1];
      }

      if (bitArr[j] & mask) {
        finalScore = computeScore(pattern, {
          errors: i,
          currentLocation,
          expectedLocation,
          distance,
          ignoreLocation
        });

        // This match will almost certainly be better than any existing match.
        // But check anyway.
        if (finalScore <= currentThreshold) {
          // Indeed it is
          currentThreshold = finalScore;
          bestLocation = currentLocation;

          // Already passed `loc`, downhill from here on in.
          if (bestLocation <= expectedLocation) {
            break
          }

          // When passing `bestLocation`, don't exceed our current distance from `expectedLocation`.
          start = Math.max(1, 2 * expectedLocation - bestLocation);
        }
      }
    }

    // No hope for a (better) match at greater error levels.
    const score = computeScore(pattern, {
      errors: i + 1,
      currentLocation: expectedLocation,
      expectedLocation,
      distance,
      ignoreLocation
    });

    if (score > currentThreshold) {
      break
    }

    lastBitArr = bitArr;
  }

  const result = {
    isMatch: bestLocation >= 0,
    // Count exact matches (those with a score of 0) to be "almost" exact
    score: Math.max(0.001, finalScore)
  };

  if (computeMatches) {
    const indices = convertMaskToIndices(matchMask, minMatchCharLength);
    if (!indices.length) {
      result.isMatch = false;
    } else if (includeMatches) {
      result.indices = indices;
    }
  }

  return result
}

function createPatternAlphabet(pattern) {
  let mask = {};

  for (let i = 0, len = pattern.length; i < len; i += 1) {
    const char = pattern.charAt(i);
    mask[char] = (mask[char] || 0) | (1 << (len - i - 1));
  }

  return mask
}

class BitapSearch {
  constructor(
    pattern,
    {
      location = Config.location,
      threshold = Config.threshold,
      distance = Config.distance,
      includeMatches = Config.includeMatches,
      findAllMatches = Config.findAllMatches,
      minMatchCharLength = Config.minMatchCharLength,
      isCaseSensitive = Config.isCaseSensitive,
      ignoreLocation = Config.ignoreLocation
    } = {}
  ) {
    this.options = {
      location,
      threshold,
      distance,
      includeMatches,
      findAllMatches,
      minMatchCharLength,
      isCaseSensitive,
      ignoreLocation
    };

    this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();

    this.chunks = [];

    if (!this.pattern.length) {
      return
    }

    const addChunk = (pattern, startIndex) => {
      this.chunks.push({
        pattern,
        alphabet: createPatternAlphabet(pattern),
        startIndex
      });
    };

    const len = this.pattern.length;

    if (len > MAX_BITS) {
      let i = 0;
      const remainder = len % MAX_BITS;
      const end = len - remainder;

      while (i < end) {
        addChunk(this.pattern.substr(i, MAX_BITS), i);
        i += MAX_BITS;
      }

      if (remainder) {
        const startIndex = len - MAX_BITS;
        addChunk(this.pattern.substr(startIndex), startIndex);
      }
    } else {
      addChunk(this.pattern, 0);
    }
  }

  searchIn(text) {
    const { isCaseSensitive, includeMatches } = this.options;

    if (!isCaseSensitive) {
      text = text.toLowerCase();
    }

    // Exact match
    if (this.pattern === text) {
      let result = {
        isMatch: true,
        score: 0
      };

      if (includeMatches) {
        result.indices = [[0, text.length - 1]];
      }

      return result
    }

    // Otherwise, use Bitap algorithm
    const {
      location,
      distance,
      threshold,
      findAllMatches,
      minMatchCharLength,
      ignoreLocation
    } = this.options;

    let allIndices = [];
    let totalScore = 0;
    let hasMatches = false;

    this.chunks.forEach(({ pattern, alphabet, startIndex }) => {
      const { isMatch, score, indices } = search(text, pattern, alphabet, {
        location: location + startIndex,
        distance,
        threshold,
        findAllMatches,
        minMatchCharLength,
        includeMatches,
        ignoreLocation
      });

      if (isMatch) {
        hasMatches = true;
      }

      totalScore += score;

      if (isMatch && indices) {
        allIndices = [...allIndices, ...indices];
      }
    });

    let result = {
      isMatch: hasMatches,
      score: hasMatches ? totalScore / this.chunks.length : 1
    };

    if (hasMatches && includeMatches) {
      result.indices = allIndices;
    }

    return result
  }
}

class BaseMatch {
  constructor(pattern) {
    this.pattern = pattern;
  }
  static isMultiMatch(pattern) {
    return getMatch(pattern, this.multiRegex)
  }
  static isSingleMatch(pattern) {
    return getMatch(pattern, this.singleRegex)
  }
  search(/*text*/) {}
}

function getMatch(pattern, exp) {
  const matches = pattern.match(exp);
  return matches ? matches[1] : null
}

// Token: 'file

class ExactMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return 'exact'
  }
  static get multiRegex() {
    return /^="(.*)"$/
  }
  static get singleRegex() {
    return /^=(.*)$/
  }
  search(text) {
    const isMatch = text === this.pattern;

    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, this.pattern.length - 1]
    }
  }
}

// Token: !fire

class InverseExactMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return 'inverse-exact'
  }
  static get multiRegex() {
    return /^!"(.*)"$/
  }
  static get singleRegex() {
    return /^!(.*)$/
  }
  search(text) {
    const index = text.indexOf(this.pattern);
    const isMatch = index === -1;

    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text.length - 1]
    }
  }
}

// Token: ^file

class PrefixExactMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return 'prefix-exact'
  }
  static get multiRegex() {
    return /^\^"(.*)"$/
  }
  static get singleRegex() {
    return /^\^(.*)$/
  }
  search(text) {
    const isMatch = text.startsWith(this.pattern);

    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, this.pattern.length - 1]
    }
  }
}

// Token: !^fire

class InversePrefixExactMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return 'inverse-prefix-exact'
  }
  static get multiRegex() {
    return /^!\^"(.*)"$/
  }
  static get singleRegex() {
    return /^!\^(.*)$/
  }
  search(text) {
    const isMatch = !text.startsWith(this.pattern);

    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text.length - 1]
    }
  }
}

// Token: .file$

class SuffixExactMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return 'suffix-exact'
  }
  static get multiRegex() {
    return /^"(.*)"\$$/
  }
  static get singleRegex() {
    return /^(.*)\$$/
  }
  search(text) {
    const isMatch = text.endsWith(this.pattern);

    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [text.length - this.pattern.length, text.length - 1]
    }
  }
}

// Token: !.file$

class InverseSuffixExactMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return 'inverse-suffix-exact'
  }
  static get multiRegex() {
    return /^!"(.*)"\$$/
  }
  static get singleRegex() {
    return /^!(.*)\$$/
  }
  search(text) {
    const isMatch = !text.endsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text.length - 1]
    }
  }
}

class FuzzyMatch extends BaseMatch {
  constructor(
    pattern,
    {
      location = Config.location,
      threshold = Config.threshold,
      distance = Config.distance,
      includeMatches = Config.includeMatches,
      findAllMatches = Config.findAllMatches,
      minMatchCharLength = Config.minMatchCharLength,
      isCaseSensitive = Config.isCaseSensitive,
      ignoreLocation = Config.ignoreLocation
    } = {}
  ) {
    super(pattern);
    this._bitapSearch = new BitapSearch(pattern, {
      location,
      threshold,
      distance,
      includeMatches,
      findAllMatches,
      minMatchCharLength,
      isCaseSensitive,
      ignoreLocation
    });
  }
  static get type() {
    return 'fuzzy'
  }
  static get multiRegex() {
    return /^"(.*)"$/
  }
  static get singleRegex() {
    return /^(.*)$/
  }
  search(text) {
    return this._bitapSearch.searchIn(text)
  }
}

// Token: 'file

class IncludeMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return 'include'
  }
  static get multiRegex() {
    return /^'"(.*)"$/
  }
  static get singleRegex() {
    return /^'(.*)$/
  }
  search(text) {
    let location = 0;
    let index;

    const indices = [];
    const patternLen = this.pattern.length;

    // Get all exact matches
    while ((index = text.indexOf(this.pattern, location)) > -1) {
      location = index + patternLen;
      indices.push([index, location - 1]);
    }

    const isMatch = !!indices.length;

    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices
    }
  }
}

// Order is important. DO NOT CHANGE.
const searchers = [
  ExactMatch,
  IncludeMatch,
  PrefixExactMatch,
  InversePrefixExactMatch,
  InverseSuffixExactMatch,
  SuffixExactMatch,
  InverseExactMatch,
  FuzzyMatch
];

const searchersLen = searchers.length;

// Regex to split by spaces, but keep anything in quotes together
const SPACE_RE = / +(?=([^\"]*\"[^\"]*\")*[^\"]*$)/;
const OR_TOKEN = '|';

// Return a 2D array representation of the query, for simpler parsing.
// Example:
// "^core go$ | rb$ | py$ xy$" => [["^core", "go$"], ["rb$"], ["py$", "xy$"]]
function parseQuery(pattern, options = {}) {
  return pattern.split(OR_TOKEN).map((item) => {
    let query = item
      .trim()
      .split(SPACE_RE)
      .filter((item) => item && !!item.trim());

    let results = [];
    for (let i = 0, len = query.length; i < len; i += 1) {
      const queryItem = query[i];

      // 1. Handle multiple query match (i.e, once that are quoted, like `"hello world"`)
      let found = false;
      let idx = -1;
      while (!found && ++idx < searchersLen) {
        const searcher = searchers[idx];
        let token = searcher.isMultiMatch(queryItem);
        if (token) {
          results.push(new searcher(token, options));
          found = true;
        }
      }

      if (found) {
        continue
      }

      // 2. Handle single query matches (i.e, once that are *not* quoted)
      idx = -1;
      while (++idx < searchersLen) {
        const searcher = searchers[idx];
        let token = searcher.isSingleMatch(queryItem);
        if (token) {
          results.push(new searcher(token, options));
          break
        }
      }
    }

    return results
  })
}

// These extended matchers can return an array of matches, as opposed
// to a singl match
const MultiMatchSet = new Set([FuzzyMatch.type, IncludeMatch.type]);

/**
 * Command-like searching
 * ======================
 *
 * Given multiple search terms delimited by spaces.e.g. `^jscript .python$ ruby !java`,
 * search in a given text.
 *
 * Search syntax:
 *
 * | Token       | Match type                 | Description                            |
 * | ----------- | -------------------------- | -------------------------------------- |
 * | `jscript`   | fuzzy-match                | Items that fuzzy match `jscript`       |
 * | `=scheme`   | exact-match                | Items that are `scheme`                |
 * | `'python`   | include-match              | Items that include `python`            |
 * | `!ruby`     | inverse-exact-match        | Items that do not include `ruby`       |
 * | `^java`     | prefix-exact-match         | Items that start with `java`           |
 * | `!^earlang` | inverse-prefix-exact-match | Items that do not start with `earlang` |
 * | `.js$`      | suffix-exact-match         | Items that end with `.js`              |
 * | `!.go$`     | inverse-suffix-exact-match | Items that do not end with `.go`       |
 *
 * A single pipe character acts as an OR operator. For example, the following
 * query matches entries that start with `core` and end with either`go`, `rb`,
 * or`py`.
 *
 * ```
 * ^core go$ | rb$ | py$
 * ```
 */
class ExtendedSearch {
  constructor(
    pattern,
    {
      isCaseSensitive = Config.isCaseSensitive,
      includeMatches = Config.includeMatches,
      minMatchCharLength = Config.minMatchCharLength,
      ignoreLocation = Config.ignoreLocation,
      findAllMatches = Config.findAllMatches,
      location = Config.location,
      threshold = Config.threshold,
      distance = Config.distance
    } = {}
  ) {
    this.query = null;
    this.options = {
      isCaseSensitive,
      includeMatches,
      minMatchCharLength,
      findAllMatches,
      ignoreLocation,
      location,
      threshold,
      distance
    };

    this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
    this.query = parseQuery(this.pattern, this.options);
  }

  static condition(_, options) {
    return options.useExtendedSearch
  }

  searchIn(text) {
    const query = this.query;

    if (!query) {
      return {
        isMatch: false,
        score: 1
      }
    }

    const { includeMatches, isCaseSensitive } = this.options;

    text = isCaseSensitive ? text : text.toLowerCase();

    let numMatches = 0;
    let allIndices = [];
    let totalScore = 0;

    // ORs
    for (let i = 0, qLen = query.length; i < qLen; i += 1) {
      const searchers = query[i];

      // Reset indices
      allIndices.length = 0;
      numMatches = 0;

      // ANDs
      for (let j = 0, pLen = searchers.length; j < pLen; j += 1) {
        const searcher = searchers[j];
        const { isMatch, indices, score } = searcher.search(text);

        if (isMatch) {
          numMatches += 1;
          totalScore += score;
          if (includeMatches) {
            const type = searcher.constructor.type;
            if (MultiMatchSet.has(type)) {
              allIndices = [...allIndices, ...indices];
            } else {
              allIndices.push(indices);
            }
          }
        } else {
          totalScore = 0;
          numMatches = 0;
          allIndices.length = 0;
          break
        }
      }

      // OR condition, so if TRUE, return
      if (numMatches) {
        let result = {
          isMatch: true,
          score: totalScore / numMatches
        };

        if (includeMatches) {
          result.indices = allIndices;
        }

        return result
      }
    }

    // Nothing was matched
    return {
      isMatch: false,
      score: 1
    }
  }
}

const registeredSearchers = [];

function register(...args) {
  registeredSearchers.push(...args);
}

function createSearcher(pattern, options) {
  for (let i = 0, len = registeredSearchers.length; i < len; i += 1) {
    let searcherClass = registeredSearchers[i];
    if (searcherClass.condition(pattern, options)) {
      return new searcherClass(pattern, options)
    }
  }

  return new BitapSearch(pattern, options)
}

const LogicalOperator = {
  AND: '$and',
  OR: '$or'
};

const KeyType = {
  PATH: '$path',
  PATTERN: '$val'
};

const isExpression = (query) =>
  !!(query[LogicalOperator.AND] || query[LogicalOperator.OR]);

const isPath = (query) => !!query[KeyType.PATH];

const isLeaf = (query) =>
  !isArray(query) && isObject(query) && !isExpression(query);

const convertToExplicit = (query) => ({
  [LogicalOperator.AND]: Object.keys(query).map((key) => ({
    [key]: query[key]
  }))
});

// When `auto` is `true`, the parse function will infer and initialize and add
// the appropriate `Searcher` instance
function parse(query, options, { auto = true } = {}) {
  const next = (query) => {
    let keys = Object.keys(query);

    const isQueryPath = isPath(query);

    if (!isQueryPath && keys.length > 1 && !isExpression(query)) {
      return next(convertToExplicit(query))
    }

    if (isLeaf(query)) {
      const key = isQueryPath ? query[KeyType.PATH] : keys[0];

      const pattern = isQueryPath ? query[KeyType.PATTERN] : query[key];

      if (!isString(pattern)) {
        throw new Error(LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY(key))
      }

      const obj = {
        keyId: createKeyId(key),
        pattern
      };

      if (auto) {
        obj.searcher = createSearcher(pattern, options);
      }

      return obj
    }

    let node = {
      children: [],
      operator: keys[0]
    };

    keys.forEach((key) => {
      const value = query[key];

      if (isArray(value)) {
        value.forEach((item) => {
          node.children.push(next(item));
        });
      }
    });

    return node
  };

  if (!isExpression(query)) {
    query = convertToExplicit(query);
  }

  return next(query)
}

// Practical scoring function
function computeScore$1(
  results,
  { ignoreFieldNorm = Config.ignoreFieldNorm }
) {
  results.forEach((result) => {
    let totalScore = 1;

    result.matches.forEach(({ key, norm, score }) => {
      const weight = key ? key.weight : null;

      totalScore *= Math.pow(
        score === 0 && weight ? Number.EPSILON : score,
        (weight || 1) * (ignoreFieldNorm ? 1 : norm)
      );
    });

    result.score = totalScore;
  });
}

function transformMatches(result, data) {
  const matches = result.matches;
  data.matches = [];

  if (!isDefined(matches)) {
    return
  }

  matches.forEach((match) => {
    if (!isDefined(match.indices) || !match.indices.length) {
      return
    }

    const { indices, value } = match;

    let obj = {
      indices,
      value
    };

    if (match.key) {
      obj.key = match.key.src;
    }

    if (match.idx > -1) {
      obj.refIndex = match.idx;
    }

    data.matches.push(obj);
  });
}

function transformScore(result, data) {
  data.score = result.score;
}

function format(
  results,
  docs,
  {
    includeMatches = Config.includeMatches,
    includeScore = Config.includeScore
  } = {}
) {
  const transformers = [];

  if (includeMatches) transformers.push(transformMatches);
  if (includeScore) transformers.push(transformScore);

  return results.map((result) => {
    const { idx } = result;

    const data = {
      item: docs[idx],
      refIndex: idx
    };

    if (transformers.length) {
      transformers.forEach((transformer) => {
        transformer(result, data);
      });
    }

    return data
  })
}

class Fuse {
  constructor(docs, options = {}, index) {
    this.options = { ...Config, ...options };

    if (
      this.options.useExtendedSearch &&
      !true
    ) {}

    this._keyStore = new KeyStore(this.options.keys);

    this.setCollection(docs, index);
  }

  setCollection(docs, index) {
    this._docs = docs;

    if (index && !(index instanceof FuseIndex)) {
      throw new Error(INCORRECT_INDEX_TYPE)
    }

    this._myIndex =
      index ||
      createIndex(this.options.keys, this._docs, {
        getFn: this.options.getFn
      });
  }

  add(doc) {
    if (!isDefined(doc)) {
      return
    }

    this._docs.push(doc);
    this._myIndex.add(doc);
  }

  remove(predicate = (/* doc, idx */) => false) {
    const results = [];

    for (let i = 0, len = this._docs.length; i < len; i += 1) {
      const doc = this._docs[i];
      if (predicate(doc, i)) {
        this.removeAt(i);
        i -= 1;
        len -= 1;

        results.push(doc);
      }
    }

    return results
  }

  removeAt(idx) {
    this._docs.splice(idx, 1);
    this._myIndex.removeAt(idx);
  }

  getIndex() {
    return this._myIndex
  }

  search(query, { limit = -1 } = {}) {
    const {
      includeMatches,
      includeScore,
      shouldSort,
      sortFn,
      ignoreFieldNorm
    } = this.options;

    let results = isString(query)
      ? isString(this._docs[0])
        ? this._searchStringList(query)
        : this._searchObjectList(query)
      : this._searchLogical(query);

    computeScore$1(results, { ignoreFieldNorm });

    if (shouldSort) {
      results.sort(sortFn);
    }

    if (isNumber(limit) && limit > -1) {
      results = results.slice(0, limit);
    }

    return format(results, this._docs, {
      includeMatches,
      includeScore
    })
  }

  _searchStringList(query) {
    const searcher = createSearcher(query, this.options);
    const { records } = this._myIndex;
    const results = [];

    // Iterate over every string in the index
    records.forEach(({ v: text, i: idx, n: norm }) => {
      if (!isDefined(text)) {
        return
      }

      const { isMatch, score, indices } = searcher.searchIn(text);

      if (isMatch) {
        results.push({
          item: text,
          idx,
          matches: [{ score, value: text, norm, indices }]
        });
      }
    });

    return results
  }

  _searchLogical(query) {

    const expression = parse(query, this.options);

    const evaluate = (node, item, idx) => {
      if (!node.children) {
        const { keyId, searcher } = node;

        const matches = this._findMatches({
          key: this._keyStore.get(keyId),
          value: this._myIndex.getValueForItemAtKeyId(item, keyId),
          searcher
        });

        if (matches && matches.length) {
          return [
            {
              idx,
              item,
              matches
            }
          ]
        }

        return []
      }

      /*eslint indent: [2, 2, {"SwitchCase": 1}]*/
      switch (node.operator) {
        case LogicalOperator.AND: {
          const res = [];
          for (let i = 0, len = node.children.length; i < len; i += 1) {
            const child = node.children[i];
            const result = evaluate(child, item, idx);
            if (result.length) {
              res.push(...result);
            } else {
              return []
            }
          }
          return res
        }
        case LogicalOperator.OR: {
          const res = [];
          for (let i = 0, len = node.children.length; i < len; i += 1) {
            const child = node.children[i];
            const result = evaluate(child, item, idx);
            if (result.length) {
              res.push(...result);
              break
            }
          }
          return res
        }
      }
    };

    const records = this._myIndex.records;
    const resultMap = {};
    const results = [];

    records.forEach(({ $: item, i: idx }) => {
      if (isDefined(item)) {
        let expResults = evaluate(expression, item, idx);

        if (expResults.length) {
          // Dedupe when adding
          if (!resultMap[idx]) {
            resultMap[idx] = { idx, item, matches: [] };
            results.push(resultMap[idx]);
          }
          expResults.forEach(({ matches }) => {
            resultMap[idx].matches.push(...matches);
          });
        }
      }
    });

    return results
  }

  _searchObjectList(query) {
    const searcher = createSearcher(query, this.options);
    const { keys, records } = this._myIndex;
    const results = [];

    // List is Array<Object>
    records.forEach(({ $: item, i: idx }) => {
      if (!isDefined(item)) {
        return
      }

      let matches = [];

      // Iterate over every key (i.e, path), and fetch the value at that key
      keys.forEach((key, keyIndex) => {
        matches.push(
          ...this._findMatches({
            key,
            value: item[keyIndex],
            searcher
          })
        );
      });

      if (matches.length) {
        results.push({
          idx,
          item,
          matches
        });
      }
    });

    return results
  }
  _findMatches({ key, value, searcher }) {
    if (!isDefined(value)) {
      return []
    }

    let matches = [];

    if (isArray(value)) {
      value.forEach(({ v: text, i: idx, n: norm }) => {
        if (!isDefined(text)) {
          return
        }

        const { isMatch, score, indices } = searcher.searchIn(text);

        if (isMatch) {
          matches.push({
            score,
            key,
            value: text,
            idx,
            norm,
            indices
          });
        }
      });
    } else {
      const { v: text, n: norm } = value;

      const { isMatch, score, indices } = searcher.searchIn(text);

      if (isMatch) {
        matches.push({ score, key, value: text, norm, indices });
      }
    }

    return matches
  }
}

Fuse.version = '6.4.6';
Fuse.createIndex = createIndex;
Fuse.parseIndex = parseIndex;
Fuse.config = Config;

{
  Fuse.parseQuery = parse;
}

{
  register(ExtendedSearch);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Fuse);


/***/ }),

/***/ "./node_modules/leaflet/dist/leaflet-src.js":
/*!**************************************************!*\
  !*** ./node_modules/leaflet/dist/leaflet-src.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports) {

/* @preserve
 * Leaflet 1.7.1, a JS library for interactive maps. http://leafletjs.com
 * (c) 2010-2019 Vladimir Agafonkin, (c) 2010-2011 CloudMade
 */

(function (global, factory) {
   true ? factory(exports) :
  0;
}(this, (function (exports) { 'use strict';

  var version = "1.7.1";

  /*
   * @namespace Util
   *
   * Various utility functions, used by Leaflet internally.
   */

  // @function extend(dest: Object, src?: Object): Object
  // Merges the properties of the `src` object (or multiple objects) into `dest` object and returns the latter. Has an `L.extend` shortcut.
  function extend(dest) {
  	var i, j, len, src;

  	for (j = 1, len = arguments.length; j < len; j++) {
  		src = arguments[j];
  		for (i in src) {
  			dest[i] = src[i];
  		}
  	}
  	return dest;
  }

  // @function create(proto: Object, properties?: Object): Object
  // Compatibility polyfill for [Object.create](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/create)
  var create = Object.create || (function () {
  	function F() {}
  	return function (proto) {
  		F.prototype = proto;
  		return new F();
  	};
  })();

  // @function bind(fn: Function, ): Function
  // Returns a new function bound to the arguments passed, like [Function.prototype.bind](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).
  // Has a `L.bind()` shortcut.
  function bind(fn, obj) {
  	var slice = Array.prototype.slice;

  	if (fn.bind) {
  		return fn.bind.apply(fn, slice.call(arguments, 1));
  	}

  	var args = slice.call(arguments, 2);

  	return function () {
  		return fn.apply(obj, args.length ? args.concat(slice.call(arguments)) : arguments);
  	};
  }

  // @property lastId: Number
  // Last unique ID used by [`stamp()`](#util-stamp)
  var lastId = 0;

  // @function stamp(obj: Object): Number
  // Returns the unique ID of an object, assigning it one if it doesn't have it.
  function stamp(obj) {
  	/*eslint-disable */
  	obj._leaflet_id = obj._leaflet_id || ++lastId;
  	return obj._leaflet_id;
  	/* eslint-enable */
  }

  // @function throttle(fn: Function, time: Number, context: Object): Function
  // Returns a function which executes function `fn` with the given scope `context`
  // (so that the `this` keyword refers to `context` inside `fn`'s code). The function
  // `fn` will be called no more than one time per given amount of `time`. The arguments
  // received by the bound function will be any arguments passed when binding the
  // function, followed by any arguments passed when invoking the bound function.
  // Has an `L.throttle` shortcut.
  function throttle(fn, time, context) {
  	var lock, args, wrapperFn, later;

  	later = function () {
  		// reset lock and call if queued
  		lock = false;
  		if (args) {
  			wrapperFn.apply(context, args);
  			args = false;
  		}
  	};

  	wrapperFn = function () {
  		if (lock) {
  			// called too soon, queue to call later
  			args = arguments;

  		} else {
  			// call and lock until later
  			fn.apply(context, arguments);
  			setTimeout(later, time);
  			lock = true;
  		}
  	};

  	return wrapperFn;
  }

  // @function wrapNum(num: Number, range: Number[], includeMax?: Boolean): Number
  // Returns the number `num` modulo `range` in such a way so it lies within
  // `range[0]` and `range[1]`. The returned value will be always smaller than
  // `range[1]` unless `includeMax` is set to `true`.
  function wrapNum(x, range, includeMax) {
  	var max = range[1],
  	    min = range[0],
  	    d = max - min;
  	return x === max && includeMax ? x : ((x - min) % d + d) % d + min;
  }

  // @function falseFn(): Function
  // Returns a function which always returns `false`.
  function falseFn() { return false; }

  // @function formatNum(num: Number, digits?: Number): Number
  // Returns the number `num` rounded to `digits` decimals, or to 6 decimals by default.
  function formatNum(num, digits) {
  	var pow = Math.pow(10, (digits === undefined ? 6 : digits));
  	return Math.round(num * pow) / pow;
  }

  // @function trim(str: String): String
  // Compatibility polyfill for [String.prototype.trim](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String/Trim)
  function trim(str) {
  	return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
  }

  // @function splitWords(str: String): String[]
  // Trims and splits the string on whitespace and returns the array of parts.
  function splitWords(str) {
  	return trim(str).split(/\s+/);
  }

  // @function setOptions(obj: Object, options: Object): Object
  // Merges the given properties to the `options` of the `obj` object, returning the resulting options. See `Class options`. Has an `L.setOptions` shortcut.
  function setOptions(obj, options) {
  	if (!Object.prototype.hasOwnProperty.call(obj, 'options')) {
  		obj.options = obj.options ? create(obj.options) : {};
  	}
  	for (var i in options) {
  		obj.options[i] = options[i];
  	}
  	return obj.options;
  }

  // @function getParamString(obj: Object, existingUrl?: String, uppercase?: Boolean): String
  // Converts an object into a parameter URL string, e.g. `{a: "foo", b: "bar"}`
  // translates to `'?a=foo&b=bar'`. If `existingUrl` is set, the parameters will
  // be appended at the end. If `uppercase` is `true`, the parameter names will
  // be uppercased (e.g. `'?A=foo&B=bar'`)
  function getParamString(obj, existingUrl, uppercase) {
  	var params = [];
  	for (var i in obj) {
  		params.push(encodeURIComponent(uppercase ? i.toUpperCase() : i) + '=' + encodeURIComponent(obj[i]));
  	}
  	return ((!existingUrl || existingUrl.indexOf('?') === -1) ? '?' : '&') + params.join('&');
  }

  var templateRe = /\{ *([\w_-]+) *\}/g;

  // @function template(str: String, data: Object): String
  // Simple templating facility, accepts a template string of the form `'Hello {a}, {b}'`
  // and a data object like `{a: 'foo', b: 'bar'}`, returns evaluated string
  // `('Hello foo, bar')`. You can also specify functions instead of strings for
  // data values  they will be evaluated passing `data` as an argument.
  function template(str, data) {
  	return str.replace(templateRe, function (str, key) {
  		var value = data[key];

  		if (value === undefined) {
  			throw new Error('No value provided for variable ' + str);

  		} else if (typeof value === 'function') {
  			value = value(data);
  		}
  		return value;
  	});
  }

  // @function isArray(obj): Boolean
  // Compatibility polyfill for [Array.isArray](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray)
  var isArray = Array.isArray || function (obj) {
  	return (Object.prototype.toString.call(obj) === '[object Array]');
  };

  // @function indexOf(array: Array, el: Object): Number
  // Compatibility polyfill for [Array.prototype.indexOf](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf)
  function indexOf(array, el) {
  	for (var i = 0; i < array.length; i++) {
  		if (array[i] === el) { return i; }
  	}
  	return -1;
  }

  // @property emptyImageUrl: String
  // Data URI string containing a base64-encoded empty GIF image.
  // Used as a hack to free memory from unused images on WebKit-powered
  // mobile devices (by setting image `src` to this string).
  var emptyImageUrl = 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=';

  // inspired by http://paulirish.com/2011/requestanimationframe-for-smart-animating/

  function getPrefixed(name) {
  	return window['webkit' + name] || window['moz' + name] || window['ms' + name];
  }

  var lastTime = 0;

  // fallback for IE 7-8
  function timeoutDefer(fn) {
  	var time = +new Date(),
  	    timeToCall = Math.max(0, 16 - (time - lastTime));

  	lastTime = time + timeToCall;
  	return window.setTimeout(fn, timeToCall);
  }

  var requestFn = window.requestAnimationFrame || getPrefixed('RequestAnimationFrame') || timeoutDefer;
  var cancelFn = window.cancelAnimationFrame || getPrefixed('CancelAnimationFrame') ||
  		getPrefixed('CancelRequestAnimationFrame') || function (id) { window.clearTimeout(id); };

  // @function requestAnimFrame(fn: Function, context?: Object, immediate?: Boolean): Number
  // Schedules `fn` to be executed when the browser repaints. `fn` is bound to
  // `context` if given. When `immediate` is set, `fn` is called immediately if
  // the browser doesn't have native support for
  // [`window.requestAnimationFrame`](https://developer.mozilla.org/docs/Web/API/window/requestAnimationFrame),
  // otherwise it's delayed. Returns a request ID that can be used to cancel the request.
  function requestAnimFrame(fn, context, immediate) {
  	if (immediate && requestFn === timeoutDefer) {
  		fn.call(context);
  	} else {
  		return requestFn.call(window, bind(fn, context));
  	}
  }

  // @function cancelAnimFrame(id: Number): undefined
  // Cancels a previous `requestAnimFrame`. See also [window.cancelAnimationFrame](https://developer.mozilla.org/docs/Web/API/window/cancelAnimationFrame).
  function cancelAnimFrame(id) {
  	if (id) {
  		cancelFn.call(window, id);
  	}
  }

  var Util = ({
    extend: extend,
    create: create,
    bind: bind,
    lastId: lastId,
    stamp: stamp,
    throttle: throttle,
    wrapNum: wrapNum,
    falseFn: falseFn,
    formatNum: formatNum,
    trim: trim,
    splitWords: splitWords,
    setOptions: setOptions,
    getParamString: getParamString,
    template: template,
    isArray: isArray,
    indexOf: indexOf,
    emptyImageUrl: emptyImageUrl,
    requestFn: requestFn,
    cancelFn: cancelFn,
    requestAnimFrame: requestAnimFrame,
    cancelAnimFrame: cancelAnimFrame
  });

  // @class Class
  // @aka L.Class

  // @section
  // @uninheritable

  // Thanks to John Resig and Dean Edwards for inspiration!

  function Class() {}

  Class.extend = function (props) {

  	// @function extend(props: Object): Function
  	// [Extends the current class](#class-inheritance) given the properties to be included.
  	// Returns a Javascript function that is a class constructor (to be called with `new`).
  	var NewClass = function () {

  		// call the constructor
  		if (this.initialize) {
  			this.initialize.apply(this, arguments);
  		}

  		// call all constructor hooks
  		this.callInitHooks();
  	};

  	var parentProto = NewClass.__super__ = this.prototype;

  	var proto = create(parentProto);
  	proto.constructor = NewClass;

  	NewClass.prototype = proto;

  	// inherit parent's statics
  	for (var i in this) {
  		if (Object.prototype.hasOwnProperty.call(this, i) && i !== 'prototype' && i !== '__super__') {
  			NewClass[i] = this[i];
  		}
  	}

  	// mix static properties into the class
  	if (props.statics) {
  		extend(NewClass, props.statics);
  		delete props.statics;
  	}

  	// mix includes into the prototype
  	if (props.includes) {
  		checkDeprecatedMixinEvents(props.includes);
  		extend.apply(null, [proto].concat(props.includes));
  		delete props.includes;
  	}

  	// merge options
  	if (proto.options) {
  		props.options = extend(create(proto.options), props.options);
  	}

  	// mix given properties into the prototype
  	extend(proto, props);

  	proto._initHooks = [];

  	// add method for calling all hooks
  	proto.callInitHooks = function () {

  		if (this._initHooksCalled) { return; }

  		if (parentProto.callInitHooks) {
  			parentProto.callInitHooks.call(this);
  		}

  		this._initHooksCalled = true;

  		for (var i = 0, len = proto._initHooks.length; i < len; i++) {
  			proto._initHooks[i].call(this);
  		}
  	};

  	return NewClass;
  };


  // @function include(properties: Object): this
  // [Includes a mixin](#class-includes) into the current class.
  Class.include = function (props) {
  	extend(this.prototype, props);
  	return this;
  };

  // @function mergeOptions(options: Object): this
  // [Merges `options`](#class-options) into the defaults of the class.
  Class.mergeOptions = function (options) {
  	extend(this.prototype.options, options);
  	return this;
  };

  // @function addInitHook(fn: Function): this
  // Adds a [constructor hook](#class-constructor-hooks) to the class.
  Class.addInitHook = function (fn) { // (Function) || (String, args...)
  	var args = Array.prototype.slice.call(arguments, 1);

  	var init = typeof fn === 'function' ? fn : function () {
  		this[fn].apply(this, args);
  	};

  	this.prototype._initHooks = this.prototype._initHooks || [];
  	this.prototype._initHooks.push(init);
  	return this;
  };

  function checkDeprecatedMixinEvents(includes) {
  	if (typeof L === 'undefined' || !L || !L.Mixin) { return; }

  	includes = isArray(includes) ? includes : [includes];

  	for (var i = 0; i < includes.length; i++) {
  		if (includes[i] === L.Mixin.Events) {
  			console.warn('Deprecated include of L.Mixin.Events: ' +
  				'this property will be removed in future releases, ' +
  				'please inherit from L.Evented instead.', new Error().stack);
  		}
  	}
  }

  /*
   * @class Evented
   * @aka L.Evented
   * @inherits Class
   *
   * A set of methods shared between event-powered classes (like `Map` and `Marker`). Generally, events allow you to execute some function when something happens with an object (e.g. the user clicks on the map, causing the map to fire `'click'` event).
   *
   * @example
   *
   * ```js
   * map.on('click', function(e) {
   * 	alert(e.latlng);
   * } );
   * ```
   *
   * Leaflet deals with event listeners by reference, so if you want to add a listener and then remove it, define it as a function:
   *
   * ```js
   * function onClick(e) { ... }
   *
   * map.on('click', onClick);
   * map.off('click', onClick);
   * ```
   */

  var Events = {
  	/* @method on(type: String, fn: Function, context?: Object): this
  	 * Adds a listener function (`fn`) to a particular event type of the object. You can optionally specify the context of the listener (object the this keyword will point to). You can also pass several space-separated types (e.g. `'click dblclick'`).
  	 *
  	 * @alternative
  	 * @method on(eventMap: Object): this
  	 * Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
  	 */
  	on: function (types, fn, context) {

  		// types can be a map of types/handlers
  		if (typeof types === 'object') {
  			for (var type in types) {
  				// we don't process space-separated events here for performance;
  				// it's a hot path since Layer uses the on(obj) syntax
  				this._on(type, types[type], fn);
  			}

  		} else {
  			// types can be a string of space-separated words
  			types = splitWords(types);

  			for (var i = 0, len = types.length; i < len; i++) {
  				this._on(types[i], fn, context);
  			}
  		}

  		return this;
  	},

  	/* @method off(type: String, fn?: Function, context?: Object): this
  	 * Removes a previously added listener function. If no function is specified, it will remove all the listeners of that particular event from the object. Note that if you passed a custom context to `on`, you must pass the same context to `off` in order to remove the listener.
  	 *
  	 * @alternative
  	 * @method off(eventMap: Object): this
  	 * Removes a set of type/listener pairs.
  	 *
  	 * @alternative
  	 * @method off: this
  	 * Removes all listeners to all events on the object. This includes implicitly attached events.
  	 */
  	off: function (types, fn, context) {

  		if (!types) {
  			// clear all listeners if called without arguments
  			delete this._events;

  		} else if (typeof types === 'object') {
  			for (var type in types) {
  				this._off(type, types[type], fn);
  			}

  		} else {
  			types = splitWords(types);

  			for (var i = 0, len = types.length; i < len; i++) {
  				this._off(types[i], fn, context);
  			}
  		}

  		return this;
  	},

  	// attach listener (without syntactic sugar now)
  	_on: function (type, fn, context) {
  		this._events = this._events || {};

  		/* get/init listeners for type */
  		var typeListeners = this._events[type];
  		if (!typeListeners) {
  			typeListeners = [];
  			this._events[type] = typeListeners;
  		}

  		if (context === this) {
  			// Less memory footprint.
  			context = undefined;
  		}
  		var newListener = {fn: fn, ctx: context},
  		    listeners = typeListeners;

  		// check if fn already there
  		for (var i = 0, len = listeners.length; i < len; i++) {
  			if (listeners[i].fn === fn && listeners[i].ctx === context) {
  				return;
  			}
  		}

  		listeners.push(newListener);
  	},

  	_off: function (type, fn, context) {
  		var listeners,
  		    i,
  		    len;

  		if (!this._events) { return; }

  		listeners = this._events[type];

  		if (!listeners) {
  			return;
  		}

  		if (!fn) {
  			// Set all removed listeners to noop so they are not called if remove happens in fire
  			for (i = 0, len = listeners.length; i < len; i++) {
  				listeners[i].fn = falseFn;
  			}
  			// clear all listeners for a type if function isn't specified
  			delete this._events[type];
  			return;
  		}

  		if (context === this) {
  			context = undefined;
  		}

  		if (listeners) {

  			// find fn and remove it
  			for (i = 0, len = listeners.length; i < len; i++) {
  				var l = listeners[i];
  				if (l.ctx !== context) { continue; }
  				if (l.fn === fn) {

  					// set the removed listener to noop so that's not called if remove happens in fire
  					l.fn = falseFn;

  					if (this._firingCount) {
  						/* copy array in case events are being fired */
  						this._events[type] = listeners = listeners.slice();
  					}
  					listeners.splice(i, 1);

  					return;
  				}
  			}
  		}
  	},

  	// @method fire(type: String, data?: Object, propagate?: Boolean): this
  	// Fires an event of the specified type. You can optionally provide an data
  	// object  the first argument of the listener function will contain its
  	// properties. The event can optionally be propagated to event parents.
  	fire: function (type, data, propagate) {
  		if (!this.listens(type, propagate)) { return this; }

  		var event = extend({}, data, {
  			type: type,
  			target: this,
  			sourceTarget: data && data.sourceTarget || this
  		});

  		if (this._events) {
  			var listeners = this._events[type];

  			if (listeners) {
  				this._firingCount = (this._firingCount + 1) || 1;
  				for (var i = 0, len = listeners.length; i < len; i++) {
  					var l = listeners[i];
  					l.fn.call(l.ctx || this, event);
  				}

  				this._firingCount--;
  			}
  		}

  		if (propagate) {
  			// propagate the event to parents (set with addEventParent)
  			this._propagateEvent(event);
  		}

  		return this;
  	},

  	// @method listens(type: String): Boolean
  	// Returns `true` if a particular event type has any listeners attached to it.
  	listens: function (type, propagate) {
  		var listeners = this._events && this._events[type];
  		if (listeners && listeners.length) { return true; }

  		if (propagate) {
  			// also check parents for listeners if event propagates
  			for (var id in this._eventParents) {
  				if (this._eventParents[id].listens(type, propagate)) { return true; }
  			}
  		}
  		return false;
  	},

  	// @method once(): this
  	// Behaves as [`on()`](#evented-on), except the listener will only get fired once and then removed.
  	once: function (types, fn, context) {

  		if (typeof types === 'object') {
  			for (var type in types) {
  				this.once(type, types[type], fn);
  			}
  			return this;
  		}

  		var handler = bind(function () {
  			this
  			    .off(types, fn, context)
  			    .off(types, handler, context);
  		}, this);

  		// add a listener that's executed once and removed after that
  		return this
  		    .on(types, fn, context)
  		    .on(types, handler, context);
  	},

  	// @method addEventParent(obj: Evented): this
  	// Adds an event parent - an `Evented` that will receive propagated events
  	addEventParent: function (obj) {
  		this._eventParents = this._eventParents || {};
  		this._eventParents[stamp(obj)] = obj;
  		return this;
  	},

  	// @method removeEventParent(obj: Evented): this
  	// Removes an event parent, so it will stop receiving propagated events
  	removeEventParent: function (obj) {
  		if (this._eventParents) {
  			delete this._eventParents[stamp(obj)];
  		}
  		return this;
  	},

  	_propagateEvent: function (e) {
  		for (var id in this._eventParents) {
  			this._eventParents[id].fire(e.type, extend({
  				layer: e.target,
  				propagatedFrom: e.target
  			}, e), true);
  		}
  	}
  };

  // aliases; we should ditch those eventually

  // @method addEventListener(): this
  // Alias to [`on()`](#evented-on)
  Events.addEventListener = Events.on;

  // @method removeEventListener(): this
  // Alias to [`off()`](#evented-off)

  // @method clearAllEventListeners(): this
  // Alias to [`off()`](#evented-off)
  Events.removeEventListener = Events.clearAllEventListeners = Events.off;

  // @method addOneTimeEventListener(): this
  // Alias to [`once()`](#evented-once)
  Events.addOneTimeEventListener = Events.once;

  // @method fireEvent(): this
  // Alias to [`fire()`](#evented-fire)
  Events.fireEvent = Events.fire;

  // @method hasEventListeners(): Boolean
  // Alias to [`listens()`](#evented-listens)
  Events.hasEventListeners = Events.listens;

  var Evented = Class.extend(Events);

  /*
   * @class Point
   * @aka L.Point
   *
   * Represents a point with `x` and `y` coordinates in pixels.
   *
   * @example
   *
   * ```js
   * var point = L.point(200, 300);
   * ```
   *
   * All Leaflet methods and options that accept `Point` objects also accept them in a simple Array form (unless noted otherwise), so these lines are equivalent:
   *
   * ```js
   * map.panBy([200, 300]);
   * map.panBy(L.point(200, 300));
   * ```
   *
   * Note that `Point` does not inherit from Leaflet's `Class` object,
   * which means new classes can't inherit from it, and new methods
   * can't be added to it with the `include` function.
   */

  function Point(x, y, round) {
  	// @property x: Number; The `x` coordinate of the point
  	this.x = (round ? Math.round(x) : x);
  	// @property y: Number; The `y` coordinate of the point
  	this.y = (round ? Math.round(y) : y);
  }

  var trunc = Math.trunc || function (v) {
  	return v > 0 ? Math.floor(v) : Math.ceil(v);
  };

  Point.prototype = {

  	// @method clone(): Point
  	// Returns a copy of the current point.
  	clone: function () {
  		return new Point(this.x, this.y);
  	},

  	// @method add(otherPoint: Point): Point
  	// Returns the result of addition of the current and the given points.
  	add: function (point) {
  		// non-destructive, returns a new point
  		return this.clone()._add(toPoint(point));
  	},

  	_add: function (point) {
  		// destructive, used directly for performance in situations where it's safe to modify existing point
  		this.x += point.x;
  		this.y += point.y;
  		return this;
  	},

  	// @method subtract(otherPoint: Point): Point
  	// Returns the result of subtraction of the given point from the current.
  	subtract: function (point) {
  		return this.clone()._subtract(toPoint(point));
  	},

  	_subtract: function (point) {
  		this.x -= point.x;
  		this.y -= point.y;
  		return this;
  	},

  	// @method divideBy(num: Number): Point
  	// Returns the result of division of the current point by the given number.
  	divideBy: function (num) {
  		return this.clone()._divideBy(num);
  	},

  	_divideBy: function (num) {
  		this.x /= num;
  		this.y /= num;
  		return this;
  	},

  	// @method multiplyBy(num: Number): Point
  	// Returns the result of multiplication of the current point by the given number.
  	multiplyBy: function (num) {
  		return this.clone()._multiplyBy(num);
  	},

  	_multiplyBy: function (num) {
  		this.x *= num;
  		this.y *= num;
  		return this;
  	},

  	// @method scaleBy(scale: Point): Point
  	// Multiply each coordinate of the current point by each coordinate of
  	// `scale`. In linear algebra terms, multiply the point by the
  	// [scaling matrix](https://en.wikipedia.org/wiki/Scaling_%28geometry%29#Matrix_representation)
  	// defined by `scale`.
  	scaleBy: function (point) {
  		return new Point(this.x * point.x, this.y * point.y);
  	},

  	// @method unscaleBy(scale: Point): Point
  	// Inverse of `scaleBy`. Divide each coordinate of the current point by
  	// each coordinate of `scale`.
  	unscaleBy: function (point) {
  		return new Point(this.x / point.x, this.y / point.y);
  	},

  	// @method round(): Point
  	// Returns a copy of the current point with rounded coordinates.
  	round: function () {
  		return this.clone()._round();
  	},

  	_round: function () {
  		this.x = Math.round(this.x);
  		this.y = Math.round(this.y);
  		return this;
  	},

  	// @method floor(): Point
  	// Returns a copy of the current point with floored coordinates (rounded down).
  	floor: function () {
  		return this.clone()._floor();
  	},

  	_floor: function () {
  		this.x = Math.floor(this.x);
  		this.y = Math.floor(this.y);
  		return this;
  	},

  	// @method ceil(): Point
  	// Returns a copy of the current point with ceiled coordinates (rounded up).
  	ceil: function () {
  		return this.clone()._ceil();
  	},

  	_ceil: function () {
  		this.x = Math.ceil(this.x);
  		this.y = Math.ceil(this.y);
  		return this;
  	},

  	// @method trunc(): Point
  	// Returns a copy of the current point with truncated coordinates (rounded towards zero).
  	trunc: function () {
  		return this.clone()._trunc();
  	},

  	_trunc: function () {
  		this.x = trunc(this.x);
  		this.y = trunc(this.y);
  		return this;
  	},

  	// @method distanceTo(otherPoint: Point): Number
  	// Returns the cartesian distance between the current and the given points.
  	distanceTo: function (point) {
  		point = toPoint(point);

  		var x = point.x - this.x,
  		    y = point.y - this.y;

  		return Math.sqrt(x * x + y * y);
  	},

  	// @method equals(otherPoint: Point): Boolean
  	// Returns `true` if the given point has the same coordinates.
  	equals: function (point) {
  		point = toPoint(point);

  		return point.x === this.x &&
  		       point.y === this.y;
  	},

  	// @method contains(otherPoint: Point): Boolean
  	// Returns `true` if both coordinates of the given point are less than the corresponding current point coordinates (in absolute values).
  	contains: function (point) {
  		point = toPoint(point);

  		return Math.abs(point.x) <= Math.abs(this.x) &&
  		       Math.abs(point.y) <= Math.abs(this.y);
  	},

  	// @method toString(): String
  	// Returns a string representation of the point for debugging purposes.
  	toString: function () {
  		return 'Point(' +
  		        formatNum(this.x) + ', ' +
  		        formatNum(this.y) + ')';
  	}
  };

  // @factory L.point(x: Number, y: Number, round?: Boolean)
  // Creates a Point object with the given `x` and `y` coordinates. If optional `round` is set to true, rounds the `x` and `y` values.

  // @alternative
  // @factory L.point(coords: Number[])
  // Expects an array of the form `[x, y]` instead.

  // @alternative
  // @factory L.point(coords: Object)
  // Expects a plain object of the form `{x: Number, y: Number}` instead.
  function toPoint(x, y, round) {
  	if (x instanceof Point) {
  		return x;
  	}
  	if (isArray(x)) {
  		return new Point(x[0], x[1]);
  	}
  	if (x === undefined || x === null) {
  		return x;
  	}
  	if (typeof x === 'object' && 'x' in x && 'y' in x) {
  		return new Point(x.x, x.y);
  	}
  	return new Point(x, y, round);
  }

  /*
   * @class Bounds
   * @aka L.Bounds
   *
   * Represents a rectangular area in pixel coordinates.
   *
   * @example
   *
   * ```js
   * var p1 = L.point(10, 10),
   * p2 = L.point(40, 60),
   * bounds = L.bounds(p1, p2);
   * ```
   *
   * All Leaflet methods that accept `Bounds` objects also accept them in a simple Array form (unless noted otherwise), so the bounds example above can be passed like this:
   *
   * ```js
   * otherBounds.intersects([[10, 10], [40, 60]]);
   * ```
   *
   * Note that `Bounds` does not inherit from Leaflet's `Class` object,
   * which means new classes can't inherit from it, and new methods
   * can't be added to it with the `include` function.
   */

  function Bounds(a, b) {
  	if (!a) { return; }

  	var points = b ? [a, b] : a;

  	for (var i = 0, len = points.length; i < len; i++) {
  		this.extend(points[i]);
  	}
  }

  Bounds.prototype = {
  	// @method extend(point: Point): this
  	// Extends the bounds to contain the given point.
  	extend: function (point) { // (Point)
  		point = toPoint(point);

  		// @property min: Point
  		// The top left corner of the rectangle.
  		// @property max: Point
  		// The bottom right corner of the rectangle.
  		if (!this.min && !this.max) {
  			this.min = point.clone();
  			this.max = point.clone();
  		} else {
  			this.min.x = Math.min(point.x, this.min.x);
  			this.max.x = Math.max(point.x, this.max.x);
  			this.min.y = Math.min(point.y, this.min.y);
  			this.max.y = Math.max(point.y, this.max.y);
  		}
  		return this;
  	},

  	// @method getCenter(round?: Boolean): Point
  	// Returns the center point of the bounds.
  	getCenter: function (round) {
  		return new Point(
  		        (this.min.x + this.max.x) / 2,
  		        (this.min.y + this.max.y) / 2, round);
  	},

  	// @method getBottomLeft(): Point
  	// Returns the bottom-left point of the bounds.
  	getBottomLeft: function () {
  		return new Point(this.min.x, this.max.y);
  	},

  	// @method getTopRight(): Point
  	// Returns the top-right point of the bounds.
  	getTopRight: function () { // -> Point
  		return new Point(this.max.x, this.min.y);
  	},

  	// @method getTopLeft(): Point
  	// Returns the top-left point of the bounds (i.e. [`this.min`](#bounds-min)).
  	getTopLeft: function () {
  		return this.min; // left, top
  	},

  	// @method getBottomRight(): Point
  	// Returns the bottom-right point of the bounds (i.e. [`this.max`](#bounds-max)).
  	getBottomRight: function () {
  		return this.max; // right, bottom
  	},

  	// @method getSize(): Point
  	// Returns the size of the given bounds
  	getSize: function () {
  		return this.max.subtract(this.min);
  	},

  	// @method contains(otherBounds: Bounds): Boolean
  	// Returns `true` if the rectangle contains the given one.
  	// @alternative
  	// @method contains(point: Point): Boolean
  	// Returns `true` if the rectangle contains the given point.
  	contains: function (obj) {
  		var min, max;

  		if (typeof obj[0] === 'number' || obj instanceof Point) {
  			obj = toPoint(obj);
  		} else {
  			obj = toBounds(obj);
  		}

  		if (obj instanceof Bounds) {
  			min = obj.min;
  			max = obj.max;
  		} else {
  			min = max = obj;
  		}

  		return (min.x >= this.min.x) &&
  		       (max.x <= this.max.x) &&
  		       (min.y >= this.min.y) &&
  		       (max.y <= this.max.y);
  	},

  	// @method intersects(otherBounds: Bounds): Boolean
  	// Returns `true` if the rectangle intersects the given bounds. Two bounds
  	// intersect if they have at least one point in common.
  	intersects: function (bounds) { // (Bounds) -> Boolean
  		bounds = toBounds(bounds);

  		var min = this.min,
  		    max = this.max,
  		    min2 = bounds.min,
  		    max2 = bounds.max,
  		    xIntersects = (max2.x >= min.x) && (min2.x <= max.x),
  		    yIntersects = (max2.y >= min.y) && (min2.y <= max.y);

  		return xIntersects && yIntersects;
  	},

  	// @method overlaps(otherBounds: Bounds): Boolean
  	// Returns `true` if the rectangle overlaps the given bounds. Two bounds
  	// overlap if their intersection is an area.
  	overlaps: function (bounds) { // (Bounds) -> Boolean
  		bounds = toBounds(bounds);

  		var min = this.min,
  		    max = this.max,
  		    min2 = bounds.min,
  		    max2 = bounds.max,
  		    xOverlaps = (max2.x > min.x) && (min2.x < max.x),
  		    yOverlaps = (max2.y > min.y) && (min2.y < max.y);

  		return xOverlaps && yOverlaps;
  	},

  	isValid: function () {
  		return !!(this.min && this.max);
  	}
  };


  // @factory L.bounds(corner1: Point, corner2: Point)
  // Creates a Bounds object from two corners coordinate pairs.
  // @alternative
  // @factory L.bounds(points: Point[])
  // Creates a Bounds object from the given array of points.
  function toBounds(a, b) {
  	if (!a || a instanceof Bounds) {
  		return a;
  	}
  	return new Bounds(a, b);
  }

  /*
   * @class LatLngBounds
   * @aka L.LatLngBounds
   *
   * Represents a rectangular geographical area on a map.
   *
   * @example
   *
   * ```js
   * var corner1 = L.latLng(40.712, -74.227),
   * corner2 = L.latLng(40.774, -74.125),
   * bounds = L.latLngBounds(corner1, corner2);
   * ```
   *
   * All Leaflet methods that accept LatLngBounds objects also accept them in a simple Array form (unless noted otherwise), so the bounds example above can be passed like this:
   *
   * ```js
   * map.fitBounds([
   * 	[40.712, -74.227],
   * 	[40.774, -74.125]
   * ]);
   * ```
   *
   * Caution: if the area crosses the antimeridian (often confused with the International Date Line), you must specify corners _outside_ the [-180, 180] degrees longitude range.
   *
   * Note that `LatLngBounds` does not inherit from Leaflet's `Class` object,
   * which means new classes can't inherit from it, and new methods
   * can't be added to it with the `include` function.
   */

  function LatLngBounds(corner1, corner2) { // (LatLng, LatLng) or (LatLng[])
  	if (!corner1) { return; }

  	var latlngs = corner2 ? [corner1, corner2] : corner1;

  	for (var i = 0, len = latlngs.length; i < len; i++) {
  		this.extend(latlngs[i]);
  	}
  }

  LatLngBounds.prototype = {

  	// @method extend(latlng: LatLng): this
  	// Extend the bounds to contain the given point

  	// @alternative
  	// @method extend(otherBounds: LatLngBounds): this
  	// Extend the bounds to contain the given bounds
  	extend: function (obj) {
  		var sw = this._southWest,
  		    ne = this._northEast,
  		    sw2, ne2;

  		if (obj instanceof LatLng) {
  			sw2 = obj;
  			ne2 = obj;

  		} else if (obj instanceof LatLngBounds) {
  			sw2 = obj._southWest;
  			ne2 = obj._northEast;

  			if (!sw2 || !ne2) { return this; }

  		} else {
  			return obj ? this.extend(toLatLng(obj) || toLatLngBounds(obj)) : this;
  		}

  		if (!sw && !ne) {
  			this._southWest = new LatLng(sw2.lat, sw2.lng);
  			this._northEast = new LatLng(ne2.lat, ne2.lng);
  		} else {
  			sw.lat = Math.min(sw2.lat, sw.lat);
  			sw.lng = Math.min(sw2.lng, sw.lng);
  			ne.lat = Math.max(ne2.lat, ne.lat);
  			ne.lng = Math.max(ne2.lng, ne.lng);
  		}

  		return this;
  	},

  	// @method pad(bufferRatio: Number): LatLngBounds
  	// Returns bounds created by extending or retracting the current bounds by a given ratio in each direction.
  	// For example, a ratio of 0.5 extends the bounds by 50% in each direction.
  	// Negative values will retract the bounds.
  	pad: function (bufferRatio) {
  		var sw = this._southWest,
  		    ne = this._northEast,
  		    heightBuffer = Math.abs(sw.lat - ne.lat) * bufferRatio,
  		    widthBuffer = Math.abs(sw.lng - ne.lng) * bufferRatio;

  		return new LatLngBounds(
  		        new LatLng(sw.lat - heightBuffer, sw.lng - widthBuffer),
  		        new LatLng(ne.lat + heightBuffer, ne.lng + widthBuffer));
  	},

  	// @method getCenter(): LatLng
  	// Returns the center point of the bounds.
  	getCenter: function () {
  		return new LatLng(
  		        (this._southWest.lat + this._northEast.lat) / 2,
  		        (this._southWest.lng + this._northEast.lng) / 2);
  	},

  	// @method getSouthWest(): LatLng
  	// Returns the south-west point of the bounds.
  	getSouthWest: function () {
  		return this._southWest;
  	},

  	// @method getNorthEast(): LatLng
  	// Returns the north-east point of the bounds.
  	getNorthEast: function () {
  		return this._northEast;
  	},

  	// @method getNorthWest(): LatLng
  	// Returns the north-west point of the bounds.
  	getNorthWest: function () {
  		return new LatLng(this.getNorth(), this.getWest());
  	},

  	// @method getSouthEast(): LatLng
  	// Returns the south-east point of the bounds.
  	getSouthEast: function () {
  		return new LatLng(this.getSouth(), this.getEast());
  	},

  	// @method getWest(): Number
  	// Returns the west longitude of the bounds
  	getWest: function () {
  		return this._southWest.lng;
  	},

  	// @method getSouth(): Number
  	// Returns the south latitude of the bounds
  	getSouth: function () {
  		return this._southWest.lat;
  	},

  	// @method getEast(): Number
  	// Returns the east longitude of the bounds
  	getEast: function () {
  		return this._northEast.lng;
  	},

  	// @method getNorth(): Number
  	// Returns the north latitude of the bounds
  	getNorth: function () {
  		return this._northEast.lat;
  	},

  	// @method contains(otherBounds: LatLngBounds): Boolean
  	// Returns `true` if the rectangle contains the given one.

  	// @alternative
  	// @method contains (latlng: LatLng): Boolean
  	// Returns `true` if the rectangle contains the given point.
  	contains: function (obj) { // (LatLngBounds) or (LatLng) -> Boolean
  		if (typeof obj[0] === 'number' || obj instanceof LatLng || 'lat' in obj) {
  			obj = toLatLng(obj);
  		} else {
  			obj = toLatLngBounds(obj);
  		}

  		var sw = this._southWest,
  		    ne = this._northEast,
  		    sw2, ne2;

  		if (obj instanceof LatLngBounds) {
  			sw2 = obj.getSouthWest();
  			ne2 = obj.getNorthEast();
  		} else {
  			sw2 = ne2 = obj;
  		}

  		return (sw2.lat >= sw.lat) && (ne2.lat <= ne.lat) &&
  		       (sw2.lng >= sw.lng) && (ne2.lng <= ne.lng);
  	},

  	// @method intersects(otherBounds: LatLngBounds): Boolean
  	// Returns `true` if the rectangle intersects the given bounds. Two bounds intersect if they have at least one point in common.
  	intersects: function (bounds) {
  		bounds = toLatLngBounds(bounds);

  		var sw = this._southWest,
  		    ne = this._northEast,
  		    sw2 = bounds.getSouthWest(),
  		    ne2 = bounds.getNorthEast(),

  		    latIntersects = (ne2.lat >= sw.lat) && (sw2.lat <= ne.lat),
  		    lngIntersects = (ne2.lng >= sw.lng) && (sw2.lng <= ne.lng);

  		return latIntersects && lngIntersects;
  	},

  	// @method overlaps(otherBounds: LatLngBounds): Boolean
  	// Returns `true` if the rectangle overlaps the given bounds. Two bounds overlap if their intersection is an area.
  	overlaps: function (bounds) {
  		bounds = toLatLngBounds(bounds);

  		var sw = this._southWest,
  		    ne = this._northEast,
  		    sw2 = bounds.getSouthWest(),
  		    ne2 = bounds.getNorthEast(),

  		    latOverlaps = (ne2.lat > sw.lat) && (sw2.lat < ne.lat),
  		    lngOverlaps = (ne2.lng > sw.lng) && (sw2.lng < ne.lng);

  		return latOverlaps && lngOverlaps;
  	},

  	// @method toBBoxString(): String
  	// Returns a string with bounding box coordinates in a 'southwest_lng,southwest_lat,northeast_lng,northeast_lat' format. Useful for sending requests to web services that return geo data.
  	toBBoxString: function () {
  		return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(',');
  	},

  	// @method equals(otherBounds: LatLngBounds, maxMargin?: Number): Boolean
  	// Returns `true` if the rectangle is equivalent (within a small margin of error) to the given bounds. The margin of error can be overridden by setting `maxMargin` to a small number.
  	equals: function (bounds, maxMargin) {
  		if (!bounds) { return false; }

  		bounds = toLatLngBounds(bounds);

  		return this._southWest.equals(bounds.getSouthWest(), maxMargin) &&
  		       this._northEast.equals(bounds.getNorthEast(), maxMargin);
  	},

  	// @method isValid(): Boolean
  	// Returns `true` if the bounds are properly initialized.
  	isValid: function () {
  		return !!(this._southWest && this._northEast);
  	}
  };

  // TODO International date line?

  // @factory L.latLngBounds(corner1: LatLng, corner2: LatLng)
  // Creates a `LatLngBounds` object by defining two diagonally opposite corners of the rectangle.

  // @alternative
  // @factory L.latLngBounds(latlngs: LatLng[])
  // Creates a `LatLngBounds` object defined by the geographical points it contains. Very useful for zooming the map to fit a particular set of locations with [`fitBounds`](#map-fitbounds).
  function toLatLngBounds(a, b) {
  	if (a instanceof LatLngBounds) {
  		return a;
  	}
  	return new LatLngBounds(a, b);
  }

  /* @class LatLng
   * @aka L.LatLng
   *
   * Represents a geographical point with a certain latitude and longitude.
   *
   * @example
   *
   * ```
   * var latlng = L.latLng(50.5, 30.5);
   * ```
   *
   * All Leaflet methods that accept LatLng objects also accept them in a simple Array form and simple object form (unless noted otherwise), so these lines are equivalent:
   *
   * ```
   * map.panTo([50, 30]);
   * map.panTo({lon: 30, lat: 50});
   * map.panTo({lat: 50, lng: 30});
   * map.panTo(L.latLng(50, 30));
   * ```
   *
   * Note that `LatLng` does not inherit from Leaflet's `Class` object,
   * which means new classes can't inherit from it, and new methods
   * can't be added to it with the `include` function.
   */

  function LatLng(lat, lng, alt) {
  	if (isNaN(lat) || isNaN(lng)) {
  		throw new Error('Invalid LatLng object: (' + lat + ', ' + lng + ')');
  	}

  	// @property lat: Number
  	// Latitude in degrees
  	this.lat = +lat;

  	// @property lng: Number
  	// Longitude in degrees
  	this.lng = +lng;

  	// @property alt: Number
  	// Altitude in meters (optional)
  	if (alt !== undefined) {
  		this.alt = +alt;
  	}
  }

  LatLng.prototype = {
  	// @method equals(otherLatLng: LatLng, maxMargin?: Number): Boolean
  	// Returns `true` if the given `LatLng` point is at the same position (within a small margin of error). The margin of error can be overridden by setting `maxMargin` to a small number.
  	equals: function (obj, maxMargin) {
  		if (!obj) { return false; }

  		obj = toLatLng(obj);

  		var margin = Math.max(
  		        Math.abs(this.lat - obj.lat),
  		        Math.abs(this.lng - obj.lng));

  		return margin <= (maxMargin === undefined ? 1.0E-9 : maxMargin);
  	},

  	// @method toString(): String
  	// Returns a string representation of the point (for debugging purposes).
  	toString: function (precision) {
  		return 'LatLng(' +
  		        formatNum(this.lat, precision) + ', ' +
  		        formatNum(this.lng, precision) + ')';
  	},

  	// @method distanceTo(otherLatLng: LatLng): Number
  	// Returns the distance (in meters) to the given `LatLng` calculated using the [Spherical Law of Cosines](https://en.wikipedia.org/wiki/Spherical_law_of_cosines).
  	distanceTo: function (other) {
  		return Earth.distance(this, toLatLng(other));
  	},

  	// @method wrap(): LatLng
  	// Returns a new `LatLng` object with the longitude wrapped so it's always between -180 and +180 degrees.
  	wrap: function () {
  		return Earth.wrapLatLng(this);
  	},

  	// @method toBounds(sizeInMeters: Number): LatLngBounds
  	// Returns a new `LatLngBounds` object in which each boundary is `sizeInMeters/2` meters apart from the `LatLng`.
  	toBounds: function (sizeInMeters) {
  		var latAccuracy = 180 * sizeInMeters / 40075017,
  		    lngAccuracy = latAccuracy / Math.cos((Math.PI / 180) * this.lat);

  		return toLatLngBounds(
  		        [this.lat - latAccuracy, this.lng - lngAccuracy],
  		        [this.lat + latAccuracy, this.lng + lngAccuracy]);
  	},

  	clone: function () {
  		return new LatLng(this.lat, this.lng, this.alt);
  	}
  };



  // @factory L.latLng(latitude: Number, longitude: Number, altitude?: Number): LatLng
  // Creates an object representing a geographical point with the given latitude and longitude (and optionally altitude).

  // @alternative
  // @factory L.latLng(coords: Array): LatLng
  // Expects an array of the form `[Number, Number]` or `[Number, Number, Number]` instead.

  // @alternative
  // @factory L.latLng(coords: Object): LatLng
  // Expects an plain object of the form `{lat: Number, lng: Number}` or `{lat: Number, lng: Number, alt: Number}` instead.

  function toLatLng(a, b, c) {
  	if (a instanceof LatLng) {
  		return a;
  	}
  	if (isArray(a) && typeof a[0] !== 'object') {
  		if (a.length === 3) {
  			return new LatLng(a[0], a[1], a[2]);
  		}
  		if (a.length === 2) {
  			return new LatLng(a[0], a[1]);
  		}
  		return null;
  	}
  	if (a === undefined || a === null) {
  		return a;
  	}
  	if (typeof a === 'object' && 'lat' in a) {
  		return new LatLng(a.lat, 'lng' in a ? a.lng : a.lon, a.alt);
  	}
  	if (b === undefined) {
  		return null;
  	}
  	return new LatLng(a, b, c);
  }

  /*
   * @namespace CRS
   * @crs L.CRS.Base
   * Object that defines coordinate reference systems for projecting
   * geographical points into pixel (screen) coordinates and back (and to
   * coordinates in other units for [WMS](https://en.wikipedia.org/wiki/Web_Map_Service) services). See
   * [spatial reference system](http://en.wikipedia.org/wiki/Coordinate_reference_system).
   *
   * Leaflet defines the most usual CRSs by default. If you want to use a
   * CRS not defined by default, take a look at the
   * [Proj4Leaflet](https://github.com/kartena/Proj4Leaflet) plugin.
   *
   * Note that the CRS instances do not inherit from Leaflet's `Class` object,
   * and can't be instantiated. Also, new classes can't inherit from them,
   * and methods can't be added to them with the `include` function.
   */

  var CRS = {
  	// @method latLngToPoint(latlng: LatLng, zoom: Number): Point
  	// Projects geographical coordinates into pixel coordinates for a given zoom.
  	latLngToPoint: function (latlng, zoom) {
  		var projectedPoint = this.projection.project(latlng),
  		    scale = this.scale(zoom);

  		return this.transformation._transform(projectedPoint, scale);
  	},

  	// @method pointToLatLng(point: Point, zoom: Number): LatLng
  	// The inverse of `latLngToPoint`. Projects pixel coordinates on a given
  	// zoom into geographical coordinates.
  	pointToLatLng: function (point, zoom) {
  		var scale = this.scale(zoom),
  		    untransformedPoint = this.transformation.untransform(point, scale);

  		return this.projection.unproject(untransformedPoint);
  	},

  	// @method project(latlng: LatLng): Point
  	// Projects geographical coordinates into coordinates in units accepted for
  	// this CRS (e.g. meters for EPSG:3857, for passing it to WMS services).
  	project: function (latlng) {
  		return this.projection.project(latlng);
  	},

  	// @method unproject(point: Point): LatLng
  	// Given a projected coordinate returns the corresponding LatLng.
  	// The inverse of `project`.
  	unproject: function (point) {
  		return this.projection.unproject(point);
  	},

  	// @method scale(zoom: Number): Number
  	// Returns the scale used when transforming projected coordinates into
  	// pixel coordinates for a particular zoom. For example, it returns
  	// `256 * 2^zoom` for Mercator-based CRS.
  	scale: function (zoom) {
  		return 256 * Math.pow(2, zoom);
  	},

  	// @method zoom(scale: Number): Number
  	// Inverse of `scale()`, returns the zoom level corresponding to a scale
  	// factor of `scale`.
  	zoom: function (scale) {
  		return Math.log(scale / 256) / Math.LN2;
  	},

  	// @method getProjectedBounds(zoom: Number): Bounds
  	// Returns the projection's bounds scaled and transformed for the provided `zoom`.
  	getProjectedBounds: function (zoom) {
  		if (this.infinite) { return null; }

  		var b = this.projection.bounds,
  		    s = this.scale(zoom),
  		    min = this.transformation.transform(b.min, s),
  		    max = this.transformation.transform(b.max, s);

  		return new Bounds(min, max);
  	},

  	// @method distance(latlng1: LatLng, latlng2: LatLng): Number
  	// Returns the distance between two geographical coordinates.

  	// @property code: String
  	// Standard code name of the CRS passed into WMS services (e.g. `'EPSG:3857'`)
  	//
  	// @property wrapLng: Number[]
  	// An array of two numbers defining whether the longitude (horizontal) coordinate
  	// axis wraps around a given range and how. Defaults to `[-180, 180]` in most
  	// geographical CRSs. If `undefined`, the longitude axis does not wrap around.
  	//
  	// @property wrapLat: Number[]
  	// Like `wrapLng`, but for the latitude (vertical) axis.

  	// wrapLng: [min, max],
  	// wrapLat: [min, max],

  	// @property infinite: Boolean
  	// If true, the coordinate space will be unbounded (infinite in both axes)
  	infinite: false,

  	// @method wrapLatLng(latlng: LatLng): LatLng
  	// Returns a `LatLng` where lat and lng has been wrapped according to the
  	// CRS's `wrapLat` and `wrapLng` properties, if they are outside the CRS's bounds.
  	wrapLatLng: function (latlng) {
  		var lng = this.wrapLng ? wrapNum(latlng.lng, this.wrapLng, true) : latlng.lng,
  		    lat = this.wrapLat ? wrapNum(latlng.lat, this.wrapLat, true) : latlng.lat,
  		    alt = latlng.alt;

  		return new LatLng(lat, lng, alt);
  	},

  	// @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds
  	// Returns a `LatLngBounds` with the same size as the given one, ensuring
  	// that its center is within the CRS's bounds.
  	// Only accepts actual `L.LatLngBounds` instances, not arrays.
  	wrapLatLngBounds: function (bounds) {
  		var center = bounds.getCenter(),
  		    newCenter = this.wrapLatLng(center),
  		    latShift = center.lat - newCenter.lat,
  		    lngShift = center.lng - newCenter.lng;

  		if (latShift === 0 && lngShift === 0) {
  			return bounds;
  		}

  		var sw = bounds.getSouthWest(),
  		    ne = bounds.getNorthEast(),
  		    newSw = new LatLng(sw.lat - latShift, sw.lng - lngShift),
  		    newNe = new LatLng(ne.lat - latShift, ne.lng - lngShift);

  		return new LatLngBounds(newSw, newNe);
  	}
  };

  /*
   * @namespace CRS
   * @crs L.CRS.Earth
   *
   * Serves as the base for CRS that are global such that they cover the earth.
   * Can only be used as the base for other CRS and cannot be used directly,
   * since it does not have a `code`, `projection` or `transformation`. `distance()` returns
   * meters.
   */

  var Earth = extend({}, CRS, {
  	wrapLng: [-180, 180],

  	// Mean Earth Radius, as recommended for use by
  	// the International Union of Geodesy and Geophysics,
  	// see http://rosettacode.org/wiki/Haversine_formula
  	R: 6371000,

  	// distance between two geographical points using spherical law of cosines approximation
  	distance: function (latlng1, latlng2) {
  		var rad = Math.PI / 180,
  		    lat1 = latlng1.lat * rad,
  		    lat2 = latlng2.lat * rad,
  		    sinDLat = Math.sin((latlng2.lat - latlng1.lat) * rad / 2),
  		    sinDLon = Math.sin((latlng2.lng - latlng1.lng) * rad / 2),
  		    a = sinDLat * sinDLat + Math.cos(lat1) * Math.cos(lat2) * sinDLon * sinDLon,
  		    c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  		return this.R * c;
  	}
  });

  /*
   * @namespace Projection
   * @projection L.Projection.SphericalMercator
   *
   * Spherical Mercator projection  the most common projection for online maps,
   * used by almost all free and commercial tile providers. Assumes that Earth is
   * a sphere. Used by the `EPSG:3857` CRS.
   */

  var earthRadius = 6378137;

  var SphericalMercator = {

  	R: earthRadius,
  	MAX_LATITUDE: 85.0511287798,

  	project: function (latlng) {
  		var d = Math.PI / 180,
  		    max = this.MAX_LATITUDE,
  		    lat = Math.max(Math.min(max, latlng.lat), -max),
  		    sin = Math.sin(lat * d);

  		return new Point(
  			this.R * latlng.lng * d,
  			this.R * Math.log((1 + sin) / (1 - sin)) / 2);
  	},

  	unproject: function (point) {
  		var d = 180 / Math.PI;

  		return new LatLng(
  			(2 * Math.atan(Math.exp(point.y / this.R)) - (Math.PI / 2)) * d,
  			point.x * d / this.R);
  	},

  	bounds: (function () {
  		var d = earthRadius * Math.PI;
  		return new Bounds([-d, -d], [d, d]);
  	})()
  };

  /*
   * @class Transformation
   * @aka L.Transformation
   *
   * Represents an affine transformation: a set of coefficients `a`, `b`, `c`, `d`
   * for transforming a point of a form `(x, y)` into `(a*x + b, c*y + d)` and doing
   * the reverse. Used by Leaflet in its projections code.
   *
   * @example
   *
   * ```js
   * var transformation = L.transformation(2, 5, -1, 10),
   * 	p = L.point(1, 2),
   * 	p2 = transformation.transform(p), //  L.point(7, 8)
   * 	p3 = transformation.untransform(p2); //  L.point(1, 2)
   * ```
   */


  // factory new L.Transformation(a: Number, b: Number, c: Number, d: Number)
  // Creates a `Transformation` object with the given coefficients.
  function Transformation(a, b, c, d) {
  	if (isArray(a)) {
  		// use array properties
  		this._a = a[0];
  		this._b = a[1];
  		this._c = a[2];
  		this._d = a[3];
  		return;
  	}
  	this._a = a;
  	this._b = b;
  	this._c = c;
  	this._d = d;
  }

  Transformation.prototype = {
  	// @method transform(point: Point, scale?: Number): Point
  	// Returns a transformed point, optionally multiplied by the given scale.
  	// Only accepts actual `L.Point` instances, not arrays.
  	transform: function (point, scale) { // (Point, Number) -> Point
  		return this._transform(point.clone(), scale);
  	},

  	// destructive transform (faster)
  	_transform: function (point, scale) {
  		scale = scale || 1;
  		point.x = scale * (this._a * point.x + this._b);
  		point.y = scale * (this._c * point.y + this._d);
  		return point;
  	},

  	// @method untransform(point: Point, scale?: Number): Point
  	// Returns the reverse transformation of the given point, optionally divided
  	// by the given scale. Only accepts actual `L.Point` instances, not arrays.
  	untransform: function (point, scale) {
  		scale = scale || 1;
  		return new Point(
  		        (point.x / scale - this._b) / this._a,
  		        (point.y / scale - this._d) / this._c);
  	}
  };

  // factory L.transformation(a: Number, b: Number, c: Number, d: Number)

  // @factory L.transformation(a: Number, b: Number, c: Number, d: Number)
  // Instantiates a Transformation object with the given coefficients.

  // @alternative
  // @factory L.transformation(coefficients: Array): Transformation
  // Expects an coefficients array of the form
  // `[a: Number, b: Number, c: Number, d: Number]`.

  function toTransformation(a, b, c, d) {
  	return new Transformation(a, b, c, d);
  }

  /*
   * @namespace CRS
   * @crs L.CRS.EPSG3857
   *
   * The most common CRS for online maps, used by almost all free and commercial
   * tile providers. Uses Spherical Mercator projection. Set in by default in
   * Map's `crs` option.
   */

  var EPSG3857 = extend({}, Earth, {
  	code: 'EPSG:3857',
  	projection: SphericalMercator,

  	transformation: (function () {
  		var scale = 0.5 / (Math.PI * SphericalMercator.R);
  		return toTransformation(scale, 0.5, -scale, 0.5);
  	}())
  });

  var EPSG900913 = extend({}, EPSG3857, {
  	code: 'EPSG:900913'
  });

  // @namespace SVG; @section
  // There are several static functions which can be called without instantiating L.SVG:

  // @function create(name: String): SVGElement
  // Returns a instance of [SVGElement](https://developer.mozilla.org/docs/Web/API/SVGElement),
  // corresponding to the class name passed. For example, using 'line' will return
  // an instance of [SVGLineElement](https://developer.mozilla.org/docs/Web/API/SVGLineElement).
  function svgCreate(name) {
  	return document.createElementNS('http://www.w3.org/2000/svg', name);
  }

  // @function pointsToPath(rings: Point[], closed: Boolean): String
  // Generates a SVG path string for multiple rings, with each ring turning
  // into "M..L..L.." instructions
  function pointsToPath(rings, closed) {
  	var str = '',
  	i, j, len, len2, points, p;

  	for (i = 0, len = rings.length; i < len; i++) {
  		points = rings[i];

  		for (j = 0, len2 = points.length; j < len2; j++) {
  			p = points[j];
  			str += (j ? 'L' : 'M') + p.x + ' ' + p.y;
  		}

  		// closes the ring for polygons; "x" is VML syntax
  		str += closed ? (svg ? 'z' : 'x') : '';
  	}

  	// SVG complains about empty path strings
  	return str || 'M0 0';
  }

  /*
   * @namespace Browser
   * @aka L.Browser
   *
   * A namespace with static properties for browser/feature detection used by Leaflet internally.
   *
   * @example
   *
   * ```js
   * if (L.Browser.ielt9) {
   *   alert('Upgrade your browser, dude!');
   * }
   * ```
   */

  var style$1 = document.documentElement.style;

  // @property ie: Boolean; `true` for all Internet Explorer versions (not Edge).
  var ie = 'ActiveXObject' in window;

  // @property ielt9: Boolean; `true` for Internet Explorer versions less than 9.
  var ielt9 = ie && !document.addEventListener;

  // @property edge: Boolean; `true` for the Edge web browser.
  var edge = 'msLaunchUri' in navigator && !('documentMode' in document);

  // @property webkit: Boolean;
  // `true` for webkit-based browsers like Chrome and Safari (including mobile versions).
  var webkit = userAgentContains('webkit');

  // @property android: Boolean
  // `true` for any browser running on an Android platform.
  var android = userAgentContains('android');

  // @property android23: Boolean; `true` for browsers running on Android 2 or Android 3.
  var android23 = userAgentContains('android 2') || userAgentContains('android 3');

  /* See https://stackoverflow.com/a/17961266 for details on detecting stock Android */
  var webkitVer = parseInt(/WebKit\/([0-9]+)|$/.exec(navigator.userAgent)[1], 10); // also matches AppleWebKit
  // @property androidStock: Boolean; `true` for the Android stock browser (i.e. not Chrome)
  var androidStock = android && userAgentContains('Google') && webkitVer < 537 && !('AudioNode' in window);

  // @property opera: Boolean; `true` for the Opera browser
  var opera = !!window.opera;

  // @property chrome: Boolean; `true` for the Chrome browser.
  var chrome = !edge && userAgentContains('chrome');

  // @property gecko: Boolean; `true` for gecko-based browsers like Firefox.
  var gecko = userAgentContains('gecko') && !webkit && !opera && !ie;

  // @property safari: Boolean; `true` for the Safari browser.
  var safari = !chrome && userAgentContains('safari');

  var phantom = userAgentContains('phantom');

  // @property opera12: Boolean
  // `true` for the Opera browser supporting CSS transforms (version 12 or later).
  var opera12 = 'OTransition' in style$1;

  // @property win: Boolean; `true` when the browser is running in a Windows platform
  var win = navigator.platform.indexOf('Win') === 0;

  // @property ie3d: Boolean; `true` for all Internet Explorer versions supporting CSS transforms.
  var ie3d = ie && ('transition' in style$1);

  // @property webkit3d: Boolean; `true` for webkit-based browsers supporting CSS transforms.
  var webkit3d = ('WebKitCSSMatrix' in window) && ('m11' in new window.WebKitCSSMatrix()) && !android23;

  // @property gecko3d: Boolean; `true` for gecko-based browsers supporting CSS transforms.
  var gecko3d = 'MozPerspective' in style$1;

  // @property any3d: Boolean
  // `true` for all browsers supporting CSS transforms.
  var any3d = !window.L_DISABLE_3D && (ie3d || webkit3d || gecko3d) && !opera12 && !phantom;

  // @property mobile: Boolean; `true` for all browsers running in a mobile device.
  var mobile = typeof orientation !== 'undefined' || userAgentContains('mobile');

  // @property mobileWebkit: Boolean; `true` for all webkit-based browsers in a mobile device.
  var mobileWebkit = mobile && webkit;

  // @property mobileWebkit3d: Boolean
  // `true` for all webkit-based browsers in a mobile device supporting CSS transforms.
  var mobileWebkit3d = mobile && webkit3d;

  // @property msPointer: Boolean
  // `true` for browsers implementing the Microsoft touch events model (notably IE10).
  var msPointer = !window.PointerEvent && window.MSPointerEvent;

  // @property pointer: Boolean
  // `true` for all browsers supporting [pointer events](https://msdn.microsoft.com/en-us/library/dn433244%28v=vs.85%29.aspx).
  var pointer = !!(window.PointerEvent || msPointer);

  // @property touch: Boolean
  // `true` for all browsers supporting [touch events](https://developer.mozilla.org/docs/Web/API/Touch_events).
  // This does not necessarily mean that the browser is running in a computer with
  // a touchscreen, it only means that the browser is capable of understanding
  // touch events.
  var touch = !window.L_NO_TOUCH && (pointer || 'ontouchstart' in window ||
  		(window.DocumentTouch && document instanceof window.DocumentTouch));

  // @property mobileOpera: Boolean; `true` for the Opera browser in a mobile device.
  var mobileOpera = mobile && opera;

  // @property mobileGecko: Boolean
  // `true` for gecko-based browsers running in a mobile device.
  var mobileGecko = mobile && gecko;

  // @property retina: Boolean
  // `true` for browsers on a high-resolution "retina" screen or on any screen when browser's display zoom is more than 100%.
  var retina = (window.devicePixelRatio || (window.screen.deviceXDPI / window.screen.logicalXDPI)) > 1;

  // @property passiveEvents: Boolean
  // `true` for browsers that support passive events.
  var passiveEvents = (function () {
  	var supportsPassiveOption = false;
  	try {
  		var opts = Object.defineProperty({}, 'passive', {
  			get: function () { // eslint-disable-line getter-return
  				supportsPassiveOption = true;
  			}
  		});
  		window.addEventListener('testPassiveEventSupport', falseFn, opts);
  		window.removeEventListener('testPassiveEventSupport', falseFn, opts);
  	} catch (e) {
  		// Errors can safely be ignored since this is only a browser support test.
  	}
  	return supportsPassiveOption;
  }());

  // @property canvas: Boolean
  // `true` when the browser supports [`<canvas>`](https://developer.mozilla.org/docs/Web/API/Canvas_API).
  var canvas = (function () {
  	return !!document.createElement('canvas').getContext;
  }());

  // @property svg: Boolean
  // `true` when the browser supports [SVG](https://developer.mozilla.org/docs/Web/SVG).
  var svg = !!(document.createElementNS && svgCreate('svg').createSVGRect);

  // @property vml: Boolean
  // `true` if the browser supports [VML](https://en.wikipedia.org/wiki/Vector_Markup_Language).
  var vml = !svg && (function () {
  	try {
  		var div = document.createElement('div');
  		div.innerHTML = '<v:shape adj="1"/>';

  		var shape = div.firstChild;
  		shape.style.behavior = 'url(#default#VML)';

  		return shape && (typeof shape.adj === 'object');

  	} catch (e) {
  		return false;
  	}
  }());


  function userAgentContains(str) {
  	return navigator.userAgent.toLowerCase().indexOf(str) >= 0;
  }

  var Browser = ({
    ie: ie,
    ielt9: ielt9,
    edge: edge,
    webkit: webkit,
    android: android,
    android23: android23,
    androidStock: androidStock,
    opera: opera,
    chrome: chrome,
    gecko: gecko,
    safari: safari,
    phantom: phantom,
    opera12: opera12,
    win: win,
    ie3d: ie3d,
    webkit3d: webkit3d,
    gecko3d: gecko3d,
    any3d: any3d,
    mobile: mobile,
    mobileWebkit: mobileWebkit,
    mobileWebkit3d: mobileWebkit3d,
    msPointer: msPointer,
    pointer: pointer,
    touch: touch,
    mobileOpera: mobileOpera,
    mobileGecko: mobileGecko,
    retina: retina,
    passiveEvents: passiveEvents,
    canvas: canvas,
    svg: svg,
    vml: vml
  });

  /*
   * Extends L.DomEvent to provide touch support for Internet Explorer and Windows-based devices.
   */


  var POINTER_DOWN =   msPointer ? 'MSPointerDown'   : 'pointerdown';
  var POINTER_MOVE =   msPointer ? 'MSPointerMove'   : 'pointermove';
  var POINTER_UP =     msPointer ? 'MSPointerUp'     : 'pointerup';
  var POINTER_CANCEL = msPointer ? 'MSPointerCancel' : 'pointercancel';

  var _pointers = {};
  var _pointerDocListener = false;

  // Provides a touch events wrapper for (ms)pointer events.
  // ref http://www.w3.org/TR/pointerevents/ https://www.w3.org/Bugs/Public/show_bug.cgi?id=22890

  function addPointerListener(obj, type, handler, id) {
  	if (type === 'touchstart') {
  		_addPointerStart(obj, handler, id);

  	} else if (type === 'touchmove') {
  		_addPointerMove(obj, handler, id);

  	} else if (type === 'touchend') {
  		_addPointerEnd(obj, handler, id);
  	}

  	return this;
  }

  function removePointerListener(obj, type, id) {
  	var handler = obj['_leaflet_' + type + id];

  	if (type === 'touchstart') {
  		obj.removeEventListener(POINTER_DOWN, handler, false);

  	} else if (type === 'touchmove') {
  		obj.removeEventListener(POINTER_MOVE, handler, false);

  	} else if (type === 'touchend') {
  		obj.removeEventListener(POINTER_UP, handler, false);
  		obj.removeEventListener(POINTER_CANCEL, handler, false);
  	}

  	return this;
  }

  function _addPointerStart(obj, handler, id) {
  	var onDown = bind(function (e) {
  		// IE10 specific: MsTouch needs preventDefault. See #2000
  		if (e.MSPOINTER_TYPE_TOUCH && e.pointerType === e.MSPOINTER_TYPE_TOUCH) {
  			preventDefault(e);
  		}

  		_handlePointer(e, handler);
  	});

  	obj['_leaflet_touchstart' + id] = onDown;
  	obj.addEventListener(POINTER_DOWN, onDown, false);

  	// need to keep track of what pointers and how many are active to provide e.touches emulation
  	if (!_pointerDocListener) {
  		// we listen document as any drags that end by moving the touch off the screen get fired there
  		document.addEventListener(POINTER_DOWN, _globalPointerDown, true);
  		document.addEventListener(POINTER_MOVE, _globalPointerMove, true);
  		document.addEventListener(POINTER_UP, _globalPointerUp, true);
  		document.addEventListener(POINTER_CANCEL, _globalPointerUp, true);

  		_pointerDocListener = true;
  	}
  }

  function _globalPointerDown(e) {
  	_pointers[e.pointerId] = e;
  }

  function _globalPointerMove(e) {
  	if (_pointers[e.pointerId]) {
  		_pointers[e.pointerId] = e;
  	}
  }

  function _globalPointerUp(e) {
  	delete _pointers[e.pointerId];
  }

  function _handlePointer(e, handler) {
  	e.touches = [];
  	for (var i in _pointers) {
  		e.touches.push(_pointers[i]);
  	}
  	e.changedTouches = [e];

  	handler(e);
  }

  function _addPointerMove(obj, handler, id) {
  	var onMove = function (e) {
  		// don't fire touch moves when mouse isn't down
  		if ((e.pointerType === (e.MSPOINTER_TYPE_MOUSE || 'mouse')) && e.buttons === 0) {
  			return;
  		}

  		_handlePointer(e, handler);
  	};

  	obj['_leaflet_touchmove' + id] = onMove;
  	obj.addEventListener(POINTER_MOVE, onMove, false);
  }

  function _addPointerEnd(obj, handler, id) {
  	var onUp = function (e) {
  		_handlePointer(e, handler);
  	};

  	obj['_leaflet_touchend' + id] = onUp;
  	obj.addEventListener(POINTER_UP, onUp, false);
  	obj.addEventListener(POINTER_CANCEL, onUp, false);
  }

  /*
   * Extends the event handling code with double tap support for mobile browsers.
   */

  var _touchstart = msPointer ? 'MSPointerDown' : pointer ? 'pointerdown' : 'touchstart';
  var _touchend = msPointer ? 'MSPointerUp' : pointer ? 'pointerup' : 'touchend';
  var _pre = '_leaflet_';

  // inspired by Zepto touch code by Thomas Fuchs
  function addDoubleTapListener(obj, handler, id) {
  	var last, touch$$1,
  	    doubleTap = false,
  	    delay = 250;

  	function onTouchStart(e) {

  		if (pointer) {
  			if (!e.isPrimary) { return; }
  			if (e.pointerType === 'mouse') { return; } // mouse fires native dblclick
  		} else if (e.touches.length > 1) {
  			return;
  		}

  		var now = Date.now(),
  		    delta = now - (last || now);

  		touch$$1 = e.touches ? e.touches[0] : e;
  		doubleTap = (delta > 0 && delta <= delay);
  		last = now;
  	}

  	function onTouchEnd(e) {
  		if (doubleTap && !touch$$1.cancelBubble) {
  			if (pointer) {
  				if (e.pointerType === 'mouse') { return; }
  				// work around .type being readonly with MSPointer* events
  				var newTouch = {},
  				    prop, i;

  				for (i in touch$$1) {
  					prop = touch$$1[i];
  					newTouch[i] = prop && prop.bind ? prop.bind(touch$$1) : prop;
  				}
  				touch$$1 = newTouch;
  			}
  			touch$$1.type = 'dblclick';
  			touch$$1.button = 0;
  			handler(touch$$1);
  			last = null;
  		}
  	}

  	obj[_pre + _touchstart + id] = onTouchStart;
  	obj[_pre + _touchend + id] = onTouchEnd;
  	obj[_pre + 'dblclick' + id] = handler;

  	obj.addEventListener(_touchstart, onTouchStart, passiveEvents ? {passive: false} : false);
  	obj.addEventListener(_touchend, onTouchEnd, passiveEvents ? {passive: false} : false);

  	// On some platforms (notably, chrome<55 on win10 + touchscreen + mouse),
  	// the browser doesn't fire touchend/pointerup events but does fire
  	// native dblclicks. See #4127.
  	// Edge 14 also fires native dblclicks, but only for pointerType mouse, see #5180.
  	obj.addEventListener('dblclick', handler, false);

  	return this;
  }

  function removeDoubleTapListener(obj, id) {
  	var touchstart = obj[_pre + _touchstart + id],
  	    touchend = obj[_pre + _touchend + id],
  	    dblclick = obj[_pre + 'dblclick' + id];

  	obj.removeEventListener(_touchstart, touchstart, passiveEvents ? {passive: false} : false);
  	obj.removeEventListener(_touchend, touchend, passiveEvents ? {passive: false} : false);
  	obj.removeEventListener('dblclick', dblclick, false);

  	return this;
  }

  /*
   * @namespace DomUtil
   *
   * Utility functions to work with the [DOM](https://developer.mozilla.org/docs/Web/API/Document_Object_Model)
   * tree, used by Leaflet internally.
   *
   * Most functions expecting or returning a `HTMLElement` also work for
   * SVG elements. The only difference is that classes refer to CSS classes
   * in HTML and SVG classes in SVG.
   */


  // @property TRANSFORM: String
  // Vendor-prefixed transform style name (e.g. `'webkitTransform'` for WebKit).
  var TRANSFORM = testProp(
  	['transform', 'webkitTransform', 'OTransform', 'MozTransform', 'msTransform']);

  // webkitTransition comes first because some browser versions that drop vendor prefix don't do
  // the same for the transitionend event, in particular the Android 4.1 stock browser

  // @property TRANSITION: String
  // Vendor-prefixed transition style name.
  var TRANSITION = testProp(
  	['webkitTransition', 'transition', 'OTransition', 'MozTransition', 'msTransition']);

  // @property TRANSITION_END: String
  // Vendor-prefixed transitionend event name.
  var TRANSITION_END =
  	TRANSITION === 'webkitTransition' || TRANSITION === 'OTransition' ? TRANSITION + 'End' : 'transitionend';


  // @function get(id: String|HTMLElement): HTMLElement
  // Returns an element given its DOM id, or returns the element itself
  // if it was passed directly.
  function get(id) {
  	return typeof id === 'string' ? document.getElementById(id) : id;
  }

  // @function getStyle(el: HTMLElement, styleAttrib: String): String
  // Returns the value for a certain style attribute on an element,
  // including computed values or values set through CSS.
  function getStyle(el, style) {
  	var value = el.style[style] || (el.currentStyle && el.currentStyle[style]);

  	if ((!value || value === 'auto') && document.defaultView) {
  		var css = document.defaultView.getComputedStyle(el, null);
  		value = css ? css[style] : null;
  	}
  	return value === 'auto' ? null : value;
  }

  // @function create(tagName: String, className?: String, container?: HTMLElement): HTMLElement
  // Creates an HTML element with `tagName`, sets its class to `className`, and optionally appends it to `container` element.
  function create$1(tagName, className, container) {
  	var el = document.createElement(tagName);
  	el.className = className || '';

  	if (container) {
  		container.appendChild(el);
  	}
  	return el;
  }

  // @function remove(el: HTMLElement)
  // Removes `el` from its parent element
  function remove(el) {
  	var parent = el.parentNode;
  	if (parent) {
  		parent.removeChild(el);
  	}
  }

  // @function empty(el: HTMLElement)
  // Removes all of `el`'s children elements from `el`
  function empty(el) {
  	while (el.firstChild) {
  		el.removeChild(el.firstChild);
  	}
  }

  // @function toFront(el: HTMLElement)
  // Makes `el` the last child of its parent, so it renders in front of the other children.
  function toFront(el) {
  	var parent = el.parentNode;
  	if (parent && parent.lastChild !== el) {
  		parent.appendChild(el);
  	}
  }

  // @function toBack(el: HTMLElement)
  // Makes `el` the first child of its parent, so it renders behind the other children.
  function toBack(el) {
  	var parent = el.parentNode;
  	if (parent && parent.firstChild !== el) {
  		parent.insertBefore(el, parent.firstChild);
  	}
  }

  // @function hasClass(el: HTMLElement, name: String): Boolean
  // Returns `true` if the element's class attribute contains `name`.
  function hasClass(el, name) {
  	if (el.classList !== undefined) {
  		return el.classList.contains(name);
  	}
  	var className = getClass(el);
  	return className.length > 0 && new RegExp('(^|\\s)' + name + '(\\s|$)').test(className);
  }

  // @function addClass(el: HTMLElement, name: String)
  // Adds `name` to the element's class attribute.
  function addClass(el, name) {
  	if (el.classList !== undefined) {
  		var classes = splitWords(name);
  		for (var i = 0, len = classes.length; i < len; i++) {
  			el.classList.add(classes[i]);
  		}
  	} else if (!hasClass(el, name)) {
  		var className = getClass(el);
  		setClass(el, (className ? className + ' ' : '') + name);
  	}
  }

  // @function removeClass(el: HTMLElement, name: String)
  // Removes `name` from the element's class attribute.
  function removeClass(el, name) {
  	if (el.classList !== undefined) {
  		el.classList.remove(name);
  	} else {
  		setClass(el, trim((' ' + getClass(el) + ' ').replace(' ' + name + ' ', ' ')));
  	}
  }

  // @function setClass(el: HTMLElement, name: String)
  // Sets the element's class.
  function setClass(el, name) {
  	if (el.className.baseVal === undefined) {
  		el.className = name;
  	} else {
  		// in case of SVG element
  		el.className.baseVal = name;
  	}
  }

  // @function getClass(el: HTMLElement): String
  // Returns the element's class.
  function getClass(el) {
  	// Check if the element is an SVGElementInstance and use the correspondingElement instead
  	// (Required for linked SVG elements in IE11.)
  	if (el.correspondingElement) {
  		el = el.correspondingElement;
  	}
  	return el.className.baseVal === undefined ? el.className : el.className.baseVal;
  }

  // @function setOpacity(el: HTMLElement, opacity: Number)
  // Set the opacity of an element (including old IE support).
  // `opacity` must be a number from `0` to `1`.
  function setOpacity(el, value) {
  	if ('opacity' in el.style) {
  		el.style.opacity = value;
  	} else if ('filter' in el.style) {
  		_setOpacityIE(el, value);
  	}
  }

  function _setOpacityIE(el, value) {
  	var filter = false,
  	    filterName = 'DXImageTransform.Microsoft.Alpha';

  	// filters collection throws an error if we try to retrieve a filter that doesn't exist
  	try {
  		filter = el.filters.item(filterName);
  	} catch (e) {
  		// don't set opacity to 1 if we haven't already set an opacity,
  		// it isn't needed and breaks transparent pngs.
  		if (value === 1) { return; }
  	}

  	value = Math.round(value * 100);

  	if (filter) {
  		filter.Enabled = (value !== 100);
  		filter.Opacity = value;
  	} else {
  		el.style.filter += ' progid:' + filterName + '(opacity=' + value + ')';
  	}
  }

  // @function testProp(props: String[]): String|false
  // Goes through the array of style names and returns the first name
  // that is a valid style name for an element. If no such name is found,
  // it returns false. Useful for vendor-prefixed styles like `transform`.
  function testProp(props) {
  	var style = document.documentElement.style;

  	for (var i = 0; i < props.length; i++) {
  		if (props[i] in style) {
  			return props[i];
  		}
  	}
  	return false;
  }

  // @function setTransform(el: HTMLElement, offset: Point, scale?: Number)
  // Resets the 3D CSS transform of `el` so it is translated by `offset` pixels
  // and optionally scaled by `scale`. Does not have an effect if the
  // browser doesn't support 3D CSS transforms.
  function setTransform(el, offset, scale) {
  	var pos = offset || new Point(0, 0);

  	el.style[TRANSFORM] =
  		(ie3d ?
  			'translate(' + pos.x + 'px,' + pos.y + 'px)' :
  			'translate3d(' + pos.x + 'px,' + pos.y + 'px,0)') +
  		(scale ? ' scale(' + scale + ')' : '');
  }

  // @function setPosition(el: HTMLElement, position: Point)
  // Sets the position of `el` to coordinates specified by `position`,
  // using CSS translate or top/left positioning depending on the browser
  // (used by Leaflet internally to position its layers).
  function setPosition(el, point) {

  	/*eslint-disable */
  	el._leaflet_pos = point;
  	/* eslint-enable */

  	if (any3d) {
  		setTransform(el, point);
  	} else {
  		el.style.left = point.x + 'px';
  		el.style.top = point.y + 'px';
  	}
  }

  // @function getPosition(el: HTMLElement): Point
  // Returns the coordinates of an element previously positioned with setPosition.
  function getPosition(el) {
  	// this method is only used for elements previously positioned using setPosition,
  	// so it's safe to cache the position for performance

  	return el._leaflet_pos || new Point(0, 0);
  }

  // @function disableTextSelection()
  // Prevents the user from generating `selectstart` DOM events, usually generated
  // when the user drags the mouse through a page with text. Used internally
  // by Leaflet to override the behaviour of any click-and-drag interaction on
  // the map. Affects drag interactions on the whole document.

  // @function enableTextSelection()
  // Cancels the effects of a previous [`L.DomUtil.disableTextSelection`](#domutil-disabletextselection).
  var disableTextSelection;
  var enableTextSelection;
  var _userSelect;
  if ('onselectstart' in document) {
  	disableTextSelection = function () {
  		on(window, 'selectstart', preventDefault);
  	};
  	enableTextSelection = function () {
  		off(window, 'selectstart', preventDefault);
  	};
  } else {
  	var userSelectProperty = testProp(
  		['userSelect', 'WebkitUserSelect', 'OUserSelect', 'MozUserSelect', 'msUserSelect']);

  	disableTextSelection = function () {
  		if (userSelectProperty) {
  			var style = document.documentElement.style;
  			_userSelect = style[userSelectProperty];
  			style[userSelectProperty] = 'none';
  		}
  	};
  	enableTextSelection = function () {
  		if (userSelectProperty) {
  			document.documentElement.style[userSelectProperty] = _userSelect;
  			_userSelect = undefined;
  		}
  	};
  }

  // @function disableImageDrag()
  // As [`L.DomUtil.disableTextSelection`](#domutil-disabletextselection), but
  // for `dragstart` DOM events, usually generated when the user drags an image.
  function disableImageDrag() {
  	on(window, 'dragstart', preventDefault);
  }

  // @function enableImageDrag()
  // Cancels the effects of a previous [`L.DomUtil.disableImageDrag`](#domutil-disabletextselection).
  function enableImageDrag() {
  	off(window, 'dragstart', preventDefault);
  }

  var _outlineElement, _outlineStyle;
  // @function preventOutline(el: HTMLElement)
  // Makes the [outline](https://developer.mozilla.org/docs/Web/CSS/outline)
  // of the element `el` invisible. Used internally by Leaflet to prevent
  // focusable elements from displaying an outline when the user performs a
  // drag interaction on them.
  function preventOutline(element) {
  	while (element.tabIndex === -1) {
  		element = element.parentNode;
  	}
  	if (!element.style) { return; }
  	restoreOutline();
  	_outlineElement = element;
  	_outlineStyle = element.style.outline;
  	element.style.outline = 'none';
  	on(window, 'keydown', restoreOutline);
  }

  // @function restoreOutline()
  // Cancels the effects of a previous [`L.DomUtil.preventOutline`]().
  function restoreOutline() {
  	if (!_outlineElement) { return; }
  	_outlineElement.style.outline = _outlineStyle;
  	_outlineElement = undefined;
  	_outlineStyle = undefined;
  	off(window, 'keydown', restoreOutline);
  }

  // @function getSizedParentNode(el: HTMLElement): HTMLElement
  // Finds the closest parent node which size (width and height) is not null.
  function getSizedParentNode(element) {
  	do {
  		element = element.parentNode;
  	} while ((!element.offsetWidth || !element.offsetHeight) && element !== document.body);
  	return element;
  }

  // @function getScale(el: HTMLElement): Object
  // Computes the CSS scale currently applied on the element.
  // Returns an object with `x` and `y` members as horizontal and vertical scales respectively,
  // and `boundingClientRect` as the result of [`getBoundingClientRect()`](https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect).
  function getScale(element) {
  	var rect = element.getBoundingClientRect(); // Read-only in old browsers.

  	return {
  		x: rect.width / element.offsetWidth || 1,
  		y: rect.height / element.offsetHeight || 1,
  		boundingClientRect: rect
  	};
  }

  var DomUtil = ({
    TRANSFORM: TRANSFORM,
    TRANSITION: TRANSITION,
    TRANSITION_END: TRANSITION_END,
    get: get,
    getStyle: getStyle,
    create: create$1,
    remove: remove,
    empty: empty,
    toFront: toFront,
    toBack: toBack,
    hasClass: hasClass,
    addClass: addClass,
    removeClass: removeClass,
    setClass: setClass,
    getClass: getClass,
    setOpacity: setOpacity,
    testProp: testProp,
    setTransform: setTransform,
    setPosition: setPosition,
    getPosition: getPosition,
    disableTextSelection: disableTextSelection,
    enableTextSelection: enableTextSelection,
    disableImageDrag: disableImageDrag,
    enableImageDrag: enableImageDrag,
    preventOutline: preventOutline,
    restoreOutline: restoreOutline,
    getSizedParentNode: getSizedParentNode,
    getScale: getScale
  });

  /*
   * @namespace DomEvent
   * Utility functions to work with the [DOM events](https://developer.mozilla.org/docs/Web/API/Event), used by Leaflet internally.
   */

  // Inspired by John Resig, Dean Edwards and YUI addEvent implementations.

  // @function on(el: HTMLElement, types: String, fn: Function, context?: Object): this
  // Adds a listener function (`fn`) to a particular DOM event type of the
  // element `el`. You can optionally specify the context of the listener
  // (object the `this` keyword will point to). You can also pass several
  // space-separated types (e.g. `'click dblclick'`).

  // @alternative
  // @function on(el: HTMLElement, eventMap: Object, context?: Object): this
  // Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
  function on(obj, types, fn, context) {

  	if (typeof types === 'object') {
  		for (var type in types) {
  			addOne(obj, type, types[type], fn);
  		}
  	} else {
  		types = splitWords(types);

  		for (var i = 0, len = types.length; i < len; i++) {
  			addOne(obj, types[i], fn, context);
  		}
  	}

  	return this;
  }

  var eventsKey = '_leaflet_events';

  // @function off(el: HTMLElement, types: String, fn: Function, context?: Object): this
  // Removes a previously added listener function.
  // Note that if you passed a custom context to on, you must pass the same
  // context to `off` in order to remove the listener.

  // @alternative
  // @function off(el: HTMLElement, eventMap: Object, context?: Object): this
  // Removes a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
  function off(obj, types, fn, context) {

  	if (typeof types === 'object') {
  		for (var type in types) {
  			removeOne(obj, type, types[type], fn);
  		}
  	} else if (types) {
  		types = splitWords(types);

  		for (var i = 0, len = types.length; i < len; i++) {
  			removeOne(obj, types[i], fn, context);
  		}
  	} else {
  		for (var j in obj[eventsKey]) {
  			removeOne(obj, j, obj[eventsKey][j]);
  		}
  		delete obj[eventsKey];
  	}

  	return this;
  }

  function browserFiresNativeDblClick() {
  	// See https://github.com/w3c/pointerevents/issues/171
  	if (pointer) {
  		return !(edge || safari);
  	}
  }

  var mouseSubst = {
  	mouseenter: 'mouseover',
  	mouseleave: 'mouseout',
  	wheel: !('onwheel' in window) && 'mousewheel'
  };

  function addOne(obj, type, fn, context) {
  	var id = type + stamp(fn) + (context ? '_' + stamp(context) : '');

  	if (obj[eventsKey] && obj[eventsKey][id]) { return this; }

  	var handler = function (e) {
  		return fn.call(context || obj, e || window.event);
  	};

  	var originalHandler = handler;

  	if (pointer && type.indexOf('touch') === 0) {
  		// Needs DomEvent.Pointer.js
  		addPointerListener(obj, type, handler, id);

  	} else if (touch && (type === 'dblclick') && !browserFiresNativeDblClick()) {
  		addDoubleTapListener(obj, handler, id);

  	} else if ('addEventListener' in obj) {

  		if (type === 'touchstart' || type === 'touchmove' || type === 'wheel' ||  type === 'mousewheel') {
  			obj.addEventListener(mouseSubst[type] || type, handler, passiveEvents ? {passive: false} : false);

  		} else if (type === 'mouseenter' || type === 'mouseleave') {
  			handler = function (e) {
  				e = e || window.event;
  				if (isExternalTarget(obj, e)) {
  					originalHandler(e);
  				}
  			};
  			obj.addEventListener(mouseSubst[type], handler, false);

  		} else {
  			obj.addEventListener(type, originalHandler, false);
  		}

  	} else if ('attachEvent' in obj) {
  		obj.attachEvent('on' + type, handler);
  	}

  	obj[eventsKey] = obj[eventsKey] || {};
  	obj[eventsKey][id] = handler;
  }

  function removeOne(obj, type, fn, context) {

  	var id = type + stamp(fn) + (context ? '_' + stamp(context) : ''),
  	    handler = obj[eventsKey] && obj[eventsKey][id];

  	if (!handler) { return this; }

  	if (pointer && type.indexOf('touch') === 0) {
  		removePointerListener(obj, type, id);

  	} else if (touch && (type === 'dblclick') && !browserFiresNativeDblClick()) {
  		removeDoubleTapListener(obj, id);

  	} else if ('removeEventListener' in obj) {

  		obj.removeEventListener(mouseSubst[type] || type, handler, false);

  	} else if ('detachEvent' in obj) {
  		obj.detachEvent('on' + type, handler);
  	}

  	obj[eventsKey][id] = null;
  }

  // @function stopPropagation(ev: DOMEvent): this
  // Stop the given event from propagation to parent elements. Used inside the listener functions:
  // ```js
  // L.DomEvent.on(div, 'click', function (ev) {
  // 	L.DomEvent.stopPropagation(ev);
  // });
  // ```
  function stopPropagation(e) {

  	if (e.stopPropagation) {
  		e.stopPropagation();
  	} else if (e.originalEvent) {  // In case of Leaflet event.
  		e.originalEvent._stopped = true;
  	} else {
  		e.cancelBubble = true;
  	}
  	skipped(e);

  	return this;
  }

  // @function disableScrollPropagation(el: HTMLElement): this
  // Adds `stopPropagation` to the element's `'wheel'` events (plus browser variants).
  function disableScrollPropagation(el) {
  	addOne(el, 'wheel', stopPropagation);
  	return this;
  }

  // @function disableClickPropagation(el: HTMLElement): this
  // Adds `stopPropagation` to the element's `'click'`, `'doubleclick'`,
  // `'mousedown'` and `'touchstart'` events (plus browser variants).
  function disableClickPropagation(el) {
  	on(el, 'mousedown touchstart dblclick', stopPropagation);
  	addOne(el, 'click', fakeStop);
  	return this;
  }

  // @function preventDefault(ev: DOMEvent): this
  // Prevents the default action of the DOM Event `ev` from happening (such as
  // following a link in the href of the a element, or doing a POST request
  // with page reload when a `<form>` is submitted).
  // Use it inside listener functions.
  function preventDefault(e) {
  	if (e.preventDefault) {
  		e.preventDefault();
  	} else {
  		e.returnValue = false;
  	}
  	return this;
  }

  // @function stop(ev: DOMEvent): this
  // Does `stopPropagation` and `preventDefault` at the same time.
  function stop(e) {
  	preventDefault(e);
  	stopPropagation(e);
  	return this;
  }

  // @function getMousePosition(ev: DOMEvent, container?: HTMLElement): Point
  // Gets normalized mouse position from a DOM event relative to the
  // `container` (border excluded) or to the whole page if not specified.
  function getMousePosition(e, container) {
  	if (!container) {
  		return new Point(e.clientX, e.clientY);
  	}

  	var scale = getScale(container),
  	    offset = scale.boundingClientRect; // left and top  values are in page scale (like the event clientX/Y)

  	return new Point(
  		// offset.left/top values are in page scale (like clientX/Y),
  		// whereas clientLeft/Top (border width) values are the original values (before CSS scale applies).
  		(e.clientX - offset.left) / scale.x - container.clientLeft,
  		(e.clientY - offset.top) / scale.y - container.clientTop
  	);
  }

  // Chrome on Win scrolls double the pixels as in other platforms (see #4538),
  // and Firefox scrolls device pixels, not CSS pixels
  var wheelPxFactor =
  	(win && chrome) ? 2 * window.devicePixelRatio :
  	gecko ? window.devicePixelRatio : 1;

  // @function getWheelDelta(ev: DOMEvent): Number
  // Gets normalized wheel delta from a wheel DOM event, in vertical
  // pixels scrolled (negative if scrolling down).
  // Events from pointing devices without precise scrolling are mapped to
  // a best guess of 60 pixels.
  function getWheelDelta(e) {
  	return (edge) ? e.wheelDeltaY / 2 : // Don't trust window-geometry-based delta
  	       (e.deltaY && e.deltaMode === 0) ? -e.deltaY / wheelPxFactor : // Pixels
  	       (e.deltaY && e.deltaMode === 1) ? -e.deltaY * 20 : // Lines
  	       (e.deltaY && e.deltaMode === 2) ? -e.deltaY * 60 : // Pages
  	       (e.deltaX || e.deltaZ) ? 0 :	// Skip horizontal/depth wheel events
  	       e.wheelDelta ? (e.wheelDeltaY || e.wheelDelta) / 2 : // Legacy IE pixels
  	       (e.detail && Math.abs(e.detail) < 32765) ? -e.detail * 20 : // Legacy Moz lines
  	       e.detail ? e.detail / -32765 * 60 : // Legacy Moz pages
  	       0;
  }

  var skipEvents = {};

  function fakeStop(e) {
  	// fakes stopPropagation by setting a special event flag, checked/reset with skipped(e)
  	skipEvents[e.type] = true;
  }

  function skipped(e) {
  	var events = skipEvents[e.type];
  	// reset when checking, as it's only used in map container and propagates outside of the map
  	skipEvents[e.type] = false;
  	return events;
  }

  // check if element really left/entered the event target (for mouseenter/mouseleave)
  function isExternalTarget(el, e) {

  	var related = e.relatedTarget;

  	if (!related) { return true; }

  	try {
  		while (related && (related !== el)) {
  			related = related.parentNode;
  		}
  	} catch (err) {
  		return false;
  	}
  	return (related !== el);
  }

  var DomEvent = ({
    on: on,
    off: off,
    stopPropagation: stopPropagation,
    disableScrollPropagation: disableScrollPropagation,
    disableClickPropagation: disableClickPropagation,
    preventDefault: preventDefault,
    stop: stop,
    getMousePosition: getMousePosition,
    getWheelDelta: getWheelDelta,
    fakeStop: fakeStop,
    skipped: skipped,
    isExternalTarget: isExternalTarget,
    addListener: on,
    removeListener: off
  });

  /*
   * @class PosAnimation
   * @aka L.PosAnimation
   * @inherits Evented
   * Used internally for panning animations, utilizing CSS3 Transitions for modern browsers and a timer fallback for IE6-9.
   *
   * @example
   * ```js
   * var fx = new L.PosAnimation();
   * fx.run(el, [300, 500], 0.5);
   * ```
   *
   * @constructor L.PosAnimation()
   * Creates a `PosAnimation` object.
   *
   */

  var PosAnimation = Evented.extend({

  	// @method run(el: HTMLElement, newPos: Point, duration?: Number, easeLinearity?: Number)
  	// Run an animation of a given element to a new position, optionally setting
  	// duration in seconds (`0.25` by default) and easing linearity factor (3rd
  	// argument of the [cubic bezier curve](http://cubic-bezier.com/#0,0,.5,1),
  	// `0.5` by default).
  	run: function (el, newPos, duration, easeLinearity) {
  		this.stop();

  		this._el = el;
  		this._inProgress = true;
  		this._duration = duration || 0.25;
  		this._easeOutPower = 1 / Math.max(easeLinearity || 0.5, 0.2);

  		this._startPos = getPosition(el);
  		this._offset = newPos.subtract(this._startPos);
  		this._startTime = +new Date();

  		// @event start: Event
  		// Fired when the animation starts
  		this.fire('start');

  		this._animate();
  	},

  	// @method stop()
  	// Stops the animation (if currently running).
  	stop: function () {
  		if (!this._inProgress) { return; }

  		this._step(true);
  		this._complete();
  	},

  	_animate: function () {
  		// animation loop
  		this._animId = requestAnimFrame(this._animate, this);
  		this._step();
  	},

  	_step: function (round) {
  		var elapsed = (+new Date()) - this._startTime,
  		    duration = this._duration * 1000;

  		if (elapsed < duration) {
  			this._runFrame(this._easeOut(elapsed / duration), round);
  		} else {
  			this._runFrame(1);
  			this._complete();
  		}
  	},

  	_runFrame: function (progress, round) {
  		var pos = this._startPos.add(this._offset.multiplyBy(progress));
  		if (round) {
  			pos._round();
  		}
  		setPosition(this._el, pos);

  		// @event step: Event
  		// Fired continuously during the animation.
  		this.fire('step');
  	},

  	_complete: function () {
  		cancelAnimFrame(this._animId);

  		this._inProgress = false;
  		// @event end: Event
  		// Fired when the animation ends.
  		this.fire('end');
  	},

  	_easeOut: function (t) {
  		return 1 - Math.pow(1 - t, this._easeOutPower);
  	}
  });

  /*
   * @class Map
   * @aka L.Map
   * @inherits Evented
   *
   * The central class of the API  it is used to create a map on a page and manipulate it.
   *
   * @example
   *
   * ```js
   * // initialize the map on the "map" div with a given center and zoom
   * var map = L.map('map', {
   * 	center: [51.505, -0.09],
   * 	zoom: 13
   * });
   * ```
   *
   */

  var Map = Evented.extend({

  	options: {
  		// @section Map State Options
  		// @option crs: CRS = L.CRS.EPSG3857
  		// The [Coordinate Reference System](#crs) to use. Don't change this if you're not
  		// sure what it means.
  		crs: EPSG3857,

  		// @option center: LatLng = undefined
  		// Initial geographic center of the map
  		center: undefined,

  		// @option zoom: Number = undefined
  		// Initial map zoom level
  		zoom: undefined,

  		// @option minZoom: Number = *
  		// Minimum zoom level of the map.
  		// If not specified and at least one `GridLayer` or `TileLayer` is in the map,
  		// the lowest of their `minZoom` options will be used instead.
  		minZoom: undefined,

  		// @option maxZoom: Number = *
  		// Maximum zoom level of the map.
  		// If not specified and at least one `GridLayer` or `TileLayer` is in the map,
  		// the highest of their `maxZoom` options will be used instead.
  		maxZoom: undefined,

  		// @option layers: Layer[] = []
  		// Array of layers that will be added to the map initially
  		layers: [],

  		// @option maxBounds: LatLngBounds = null
  		// When this option is set, the map restricts the view to the given
  		// geographical bounds, bouncing the user back if the user tries to pan
  		// outside the view. To set the restriction dynamically, use
  		// [`setMaxBounds`](#map-setmaxbounds) method.
  		maxBounds: undefined,

  		// @option renderer: Renderer = *
  		// The default method for drawing vector layers on the map. `L.SVG`
  		// or `L.Canvas` by default depending on browser support.
  		renderer: undefined,


  		// @section Animation Options
  		// @option zoomAnimation: Boolean = true
  		// Whether the map zoom animation is enabled. By default it's enabled
  		// in all browsers that support CSS3 Transitions except Android.
  		zoomAnimation: true,

  		// @option zoomAnimationThreshold: Number = 4
  		// Won't animate zoom if the zoom difference exceeds this value.
  		zoomAnimationThreshold: 4,

  		// @option fadeAnimation: Boolean = true
  		// Whether the tile fade animation is enabled. By default it's enabled
  		// in all browsers that support CSS3 Transitions except Android.
  		fadeAnimation: true,

  		// @option markerZoomAnimation: Boolean = true
  		// Whether markers animate their zoom with the zoom animation, if disabled
  		// they will disappear for the length of the animation. By default it's
  		// enabled in all browsers that support CSS3 Transitions except Android.
  		markerZoomAnimation: true,

  		// @option transform3DLimit: Number = 2^23
  		// Defines the maximum size of a CSS translation transform. The default
  		// value should not be changed unless a web browser positions layers in
  		// the wrong place after doing a large `panBy`.
  		transform3DLimit: 8388608, // Precision limit of a 32-bit float

  		// @section Interaction Options
  		// @option zoomSnap: Number = 1
  		// Forces the map's zoom level to always be a multiple of this, particularly
  		// right after a [`fitBounds()`](#map-fitbounds) or a pinch-zoom.
  		// By default, the zoom level snaps to the nearest integer; lower values
  		// (e.g. `0.5` or `0.1`) allow for greater granularity. A value of `0`
  		// means the zoom level will not be snapped after `fitBounds` or a pinch-zoom.
  		zoomSnap: 1,

  		// @option zoomDelta: Number = 1
  		// Controls how much the map's zoom level will change after a
  		// [`zoomIn()`](#map-zoomin), [`zoomOut()`](#map-zoomout), pressing `+`
  		// or `-` on the keyboard, or using the [zoom controls](#control-zoom).
  		// Values smaller than `1` (e.g. `0.5`) allow for greater granularity.
  		zoomDelta: 1,

  		// @option trackResize: Boolean = true
  		// Whether the map automatically handles browser window resize to update itself.
  		trackResize: true
  	},

  	initialize: function (id, options) { // (HTMLElement or String, Object)
  		options = setOptions(this, options);

  		// Make sure to assign internal flags at the beginning,
  		// to avoid inconsistent state in some edge cases.
  		this._handlers = [];
  		this._layers = {};
  		this._zoomBoundLayers = {};
  		this._sizeChanged = true;

  		this._initContainer(id);
  		this._initLayout();

  		// hack for https://github.com/Leaflet/Leaflet/issues/1980
  		this._onResize = bind(this._onResize, this);

  		this._initEvents();

  		if (options.maxBounds) {
  			this.setMaxBounds(options.maxBounds);
  		}

  		if (options.zoom !== undefined) {
  			this._zoom = this._limitZoom(options.zoom);
  		}

  		if (options.center && options.zoom !== undefined) {
  			this.setView(toLatLng(options.center), options.zoom, {reset: true});
  		}

  		this.callInitHooks();

  		// don't animate on browsers without hardware-accelerated transitions or old Android/Opera
  		this._zoomAnimated = TRANSITION && any3d && !mobileOpera &&
  				this.options.zoomAnimation;

  		// zoom transitions run with the same duration for all layers, so if one of transitionend events
  		// happens after starting zoom animation (propagating to the map pane), we know that it ended globally
  		if (this._zoomAnimated) {
  			this._createAnimProxy();
  			on(this._proxy, TRANSITION_END, this._catchTransitionEnd, this);
  		}

  		this._addLayers(this.options.layers);
  	},


  	// @section Methods for modifying map state

  	// @method setView(center: LatLng, zoom: Number, options?: Zoom/pan options): this
  	// Sets the view of the map (geographical center and zoom) with the given
  	// animation options.
  	setView: function (center, zoom, options) {

  		zoom = zoom === undefined ? this._zoom : this._limitZoom(zoom);
  		center = this._limitCenter(toLatLng(center), zoom, this.options.maxBounds);
  		options = options || {};

  		this._stop();

  		if (this._loaded && !options.reset && options !== true) {

  			if (options.animate !== undefined) {
  				options.zoom = extend({animate: options.animate}, options.zoom);
  				options.pan = extend({animate: options.animate, duration: options.duration}, options.pan);
  			}

  			// try animating pan or zoom
  			var moved = (this._zoom !== zoom) ?
  				this._tryAnimatedZoom && this._tryAnimatedZoom(center, zoom, options.zoom) :
  				this._tryAnimatedPan(center, options.pan);

  			if (moved) {
  				// prevent resize handler call, the view will refresh after animation anyway
  				clearTimeout(this._sizeTimer);
  				return this;
  			}
  		}

  		// animation didn't start, just reset the map view
  		this._resetView(center, zoom);

  		return this;
  	},

  	// @method setZoom(zoom: Number, options?: Zoom/pan options): this
  	// Sets the zoom of the map.
  	setZoom: function (zoom, options) {
  		if (!this._loaded) {
  			this._zoom = zoom;
  			return this;
  		}
  		return this.setView(this.getCenter(), zoom, {zoom: options});
  	},

  	// @method zoomIn(delta?: Number, options?: Zoom options): this
  	// Increases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
  	zoomIn: function (delta, options) {
  		delta = delta || (any3d ? this.options.zoomDelta : 1);
  		return this.setZoom(this._zoom + delta, options);
  	},

  	// @method zoomOut(delta?: Number, options?: Zoom options): this
  	// Decreases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
  	zoomOut: function (delta, options) {
  		delta = delta || (any3d ? this.options.zoomDelta : 1);
  		return this.setZoom(this._zoom - delta, options);
  	},

  	// @method setZoomAround(latlng: LatLng, zoom: Number, options: Zoom options): this
  	// Zooms the map while keeping a specified geographical point on the map
  	// stationary (e.g. used internally for scroll zoom and double-click zoom).
  	// @alternative
  	// @method setZoomAround(offset: Point, zoom: Number, options: Zoom options): this
  	// Zooms the map while keeping a specified pixel on the map (relative to the top-left corner) stationary.
  	setZoomAround: function (latlng, zoom, options) {
  		var scale = this.getZoomScale(zoom),
  		    viewHalf = this.getSize().divideBy(2),
  		    containerPoint = latlng instanceof Point ? latlng : this.latLngToContainerPoint(latlng),

  		    centerOffset = containerPoint.subtract(viewHalf).multiplyBy(1 - 1 / scale),
  		    newCenter = this.containerPointToLatLng(viewHalf.add(centerOffset));

  		return this.setView(newCenter, zoom, {zoom: options});
  	},

  	_getBoundsCenterZoom: function (bounds, options) {

  		options = options || {};
  		bounds = bounds.getBounds ? bounds.getBounds() : toLatLngBounds(bounds);

  		var paddingTL = toPoint(options.paddingTopLeft || options.padding || [0, 0]),
  		    paddingBR = toPoint(options.paddingBottomRight || options.padding || [0, 0]),

  		    zoom = this.getBoundsZoom(bounds, false, paddingTL.add(paddingBR));

  		zoom = (typeof options.maxZoom === 'number') ? Math.min(options.maxZoom, zoom) : zoom;

  		if (zoom === Infinity) {
  			return {
  				center: bounds.getCenter(),
  				zoom: zoom
  			};
  		}

  		var paddingOffset = paddingBR.subtract(paddingTL).divideBy(2),

  		    swPoint = this.project(bounds.getSouthWest(), zoom),
  		    nePoint = this.project(bounds.getNorthEast(), zoom),
  		    center = this.unproject(swPoint.add(nePoint).divideBy(2).add(paddingOffset), zoom);

  		return {
  			center: center,
  			zoom: zoom
  		};
  	},

  	// @method fitBounds(bounds: LatLngBounds, options?: fitBounds options): this
  	// Sets a map view that contains the given geographical bounds with the
  	// maximum zoom level possible.
  	fitBounds: function (bounds, options) {

  		bounds = toLatLngBounds(bounds);

  		if (!bounds.isValid()) {
  			throw new Error('Bounds are not valid.');
  		}

  		var target = this._getBoundsCenterZoom(bounds, options);
  		return this.setView(target.center, target.zoom, options);
  	},

  	// @method fitWorld(options?: fitBounds options): this
  	// Sets a map view that mostly contains the whole world with the maximum
  	// zoom level possible.
  	fitWorld: function (options) {
  		return this.fitBounds([[-90, -180], [90, 180]], options);
  	},

  	// @method panTo(latlng: LatLng, options?: Pan options): this
  	// Pans the map to a given center.
  	panTo: function (center, options) { // (LatLng)
  		return this.setView(center, this._zoom, {pan: options});
  	},

  	// @method panBy(offset: Point, options?: Pan options): this
  	// Pans the map by a given number of pixels (animated).
  	panBy: function (offset, options) {
  		offset = toPoint(offset).round();
  		options = options || {};

  		if (!offset.x && !offset.y) {
  			return this.fire('moveend');
  		}
  		// If we pan too far, Chrome gets issues with tiles
  		// and makes them disappear or appear in the wrong place (slightly offset) #2602
  		if (options.animate !== true && !this.getSize().contains(offset)) {
  			this._resetView(this.unproject(this.project(this.getCenter()).add(offset)), this.getZoom());
  			return this;
  		}

  		if (!this._panAnim) {
  			this._panAnim = new PosAnimation();

  			this._panAnim.on({
  				'step': this._onPanTransitionStep,
  				'end': this._onPanTransitionEnd
  			}, this);
  		}

  		// don't fire movestart if animating inertia
  		if (!options.noMoveStart) {
  			this.fire('movestart');
  		}

  		// animate pan unless animate: false specified
  		if (options.animate !== false) {
  			addClass(this._mapPane, 'leaflet-pan-anim');

  			var newPos = this._getMapPanePos().subtract(offset).round();
  			this._panAnim.run(this._mapPane, newPos, options.duration || 0.25, options.easeLinearity);
  		} else {
  			this._rawPanBy(offset);
  			this.fire('move').fire('moveend');
  		}

  		return this;
  	},

  	// @method flyTo(latlng: LatLng, zoom?: Number, options?: Zoom/pan options): this
  	// Sets the view of the map (geographical center and zoom) performing a smooth
  	// pan-zoom animation.
  	flyTo: function (targetCenter, targetZoom, options) {

  		options = options || {};
  		if (options.animate === false || !any3d) {
  			return this.setView(targetCenter, targetZoom, options);
  		}

  		this._stop();

  		var from = this.project(this.getCenter()),
  		    to = this.project(targetCenter),
  		    size = this.getSize(),
  		    startZoom = this._zoom;

  		targetCenter = toLatLng(targetCenter);
  		targetZoom = targetZoom === undefined ? startZoom : targetZoom;

  		var w0 = Math.max(size.x, size.y),
  		    w1 = w0 * this.getZoomScale(startZoom, targetZoom),
  		    u1 = (to.distanceTo(from)) || 1,
  		    rho = 1.42,
  		    rho2 = rho * rho;

  		function r(i) {
  			var s1 = i ? -1 : 1,
  			    s2 = i ? w1 : w0,
  			    t1 = w1 * w1 - w0 * w0 + s1 * rho2 * rho2 * u1 * u1,
  			    b1 = 2 * s2 * rho2 * u1,
  			    b = t1 / b1,
  			    sq = Math.sqrt(b * b + 1) - b;

  			    // workaround for floating point precision bug when sq = 0, log = -Infinite,
  			    // thus triggering an infinite loop in flyTo
  			    var log = sq < 0.000000001 ? -18 : Math.log(sq);

  			return log;
  		}

  		function sinh(n) { return (Math.exp(n) - Math.exp(-n)) / 2; }
  		function cosh(n) { return (Math.exp(n) + Math.exp(-n)) / 2; }
  		function tanh(n) { return sinh(n) / cosh(n); }

  		var r0 = r(0);

  		function w(s) { return w0 * (cosh(r0) / cosh(r0 + rho * s)); }
  		function u(s) { return w0 * (cosh(r0) * tanh(r0 + rho * s) - sinh(r0)) / rho2; }

  		function easeOut(t) { return 1 - Math.pow(1 - t, 1.5); }

  		var start = Date.now(),
  		    S = (r(1) - r0) / rho,
  		    duration = options.duration ? 1000 * options.duration : 1000 * S * 0.8;

  		function frame() {
  			var t = (Date.now() - start) / duration,
  			    s = easeOut(t) * S;

  			if (t <= 1) {
  				this._flyToFrame = requestAnimFrame(frame, this);

  				this._move(
  					this.unproject(from.add(to.subtract(from).multiplyBy(u(s) / u1)), startZoom),
  					this.getScaleZoom(w0 / w(s), startZoom),
  					{flyTo: true});

  			} else {
  				this
  					._move(targetCenter, targetZoom)
  					._moveEnd(true);
  			}
  		}

  		this._moveStart(true, options.noMoveStart);

  		frame.call(this);
  		return this;
  	},

  	// @method flyToBounds(bounds: LatLngBounds, options?: fitBounds options): this
  	// Sets the view of the map with a smooth animation like [`flyTo`](#map-flyto),
  	// but takes a bounds parameter like [`fitBounds`](#map-fitbounds).
  	flyToBounds: function (bounds, options) {
  		var target = this._getBoundsCenterZoom(bounds, options);
  		return this.flyTo(target.center, target.zoom, options);
  	},

  	// @method setMaxBounds(bounds: LatLngBounds): this
  	// Restricts the map view to the given bounds (see the [maxBounds](#map-maxbounds) option).
  	setMaxBounds: function (bounds) {
  		bounds = toLatLngBounds(bounds);

  		if (!bounds.isValid()) {
  			this.options.maxBounds = null;
  			return this.off('moveend', this._panInsideMaxBounds);
  		} else if (this.options.maxBounds) {
  			this.off('moveend', this._panInsideMaxBounds);
  		}

  		this.options.maxBounds = bounds;

  		if (this._loaded) {
  			this._panInsideMaxBounds();
  		}

  		return this.on('moveend', this._panInsideMaxBounds);
  	},

  	// @method setMinZoom(zoom: Number): this
  	// Sets the lower limit for the available zoom levels (see the [minZoom](#map-minzoom) option).
  	setMinZoom: function (zoom) {
  		var oldZoom = this.options.minZoom;
  		this.options.minZoom = zoom;

  		if (this._loaded && oldZoom !== zoom) {
  			this.fire('zoomlevelschange');

  			if (this.getZoom() < this.options.minZoom) {
  				return this.setZoom(zoom);
  			}
  		}

  		return this;
  	},

  	// @method setMaxZoom(zoom: Number): this
  	// Sets the upper limit for the available zoom levels (see the [maxZoom](#map-maxzoom) option).
  	setMaxZoom: function (zoom) {
  		var oldZoom = this.options.maxZoom;
  		this.options.maxZoom = zoom;

  		if (this._loaded && oldZoom !== zoom) {
  			this.fire('zoomlevelschange');

  			if (this.getZoom() > this.options.maxZoom) {
  				return this.setZoom(zoom);
  			}
  		}

  		return this;
  	},

  	// @method panInsideBounds(bounds: LatLngBounds, options?: Pan options): this
  	// Pans the map to the closest view that would lie inside the given bounds (if it's not already), controlling the animation using the options specific, if any.
  	panInsideBounds: function (bounds, options) {
  		this._enforcingBounds = true;
  		var center = this.getCenter(),
  		    newCenter = this._limitCenter(center, this._zoom, toLatLngBounds(bounds));

  		if (!center.equals(newCenter)) {
  			this.panTo(newCenter, options);
  		}

  		this._enforcingBounds = false;
  		return this;
  	},

  	// @method panInside(latlng: LatLng, options?: options): this
  	// Pans the map the minimum amount to make the `latlng` visible. Use
  	// `padding`, `paddingTopLeft` and `paddingTopRight` options to fit
  	// the display to more restricted bounds, like [`fitBounds`](#map-fitbounds).
  	// If `latlng` is already within the (optionally padded) display bounds,
  	// the map will not be panned.
  	panInside: function (latlng, options) {
  		options = options || {};

  		var paddingTL = toPoint(options.paddingTopLeft || options.padding || [0, 0]),
  		    paddingBR = toPoint(options.paddingBottomRight || options.padding || [0, 0]),
  		    center = this.getCenter(),
  		    pixelCenter = this.project(center),
  		    pixelPoint = this.project(latlng),
  		    pixelBounds = this.getPixelBounds(),
  		    halfPixelBounds = pixelBounds.getSize().divideBy(2),
  		    paddedBounds = toBounds([pixelBounds.min.add(paddingTL), pixelBounds.max.subtract(paddingBR)]);

  		if (!paddedBounds.contains(pixelPoint)) {
  			this._enforcingBounds = true;
  			var diff = pixelCenter.subtract(pixelPoint),
  			    newCenter = toPoint(pixelPoint.x + diff.x, pixelPoint.y + diff.y);

  			if (pixelPoint.x < paddedBounds.min.x || pixelPoint.x > paddedBounds.max.x) {
  				newCenter.x = pixelCenter.x - diff.x;
  				if (diff.x > 0) {
  					newCenter.x += halfPixelBounds.x - paddingTL.x;
  				} else {
  					newCenter.x -= halfPixelBounds.x - paddingBR.x;
  				}
  			}
  			if (pixelPoint.y < paddedBounds.min.y || pixelPoint.y > paddedBounds.max.y) {
  				newCenter.y = pixelCenter.y - diff.y;
  				if (diff.y > 0) {
  					newCenter.y += halfPixelBounds.y - paddingTL.y;
  				} else {
  					newCenter.y -= halfPixelBounds.y - paddingBR.y;
  				}
  			}
  			this.panTo(this.unproject(newCenter), options);
  			this._enforcingBounds = false;
  		}
  		return this;
  	},

  	// @method invalidateSize(options: Zoom/pan options): this
  	// Checks if the map container size changed and updates the map if so 
  	// call it after you've changed the map size dynamically, also animating
  	// pan by default. If `options.pan` is `false`, panning will not occur.
  	// If `options.debounceMoveend` is `true`, it will delay `moveend` event so
  	// that it doesn't happen often even if the method is called many
  	// times in a row.

  	// @alternative
  	// @method invalidateSize(animate: Boolean): this
  	// Checks if the map container size changed and updates the map if so 
  	// call it after you've changed the map size dynamically, also animating
  	// pan by default.
  	invalidateSize: function (options) {
  		if (!this._loaded) { return this; }

  		options = extend({
  			animate: false,
  			pan: true
  		}, options === true ? {animate: true} : options);

  		var oldSize = this.getSize();
  		this._sizeChanged = true;
  		this._lastCenter = null;

  		var newSize = this.getSize(),
  		    oldCenter = oldSize.divideBy(2).round(),
  		    newCenter = newSize.divideBy(2).round(),
  		    offset = oldCenter.subtract(newCenter);

  		if (!offset.x && !offset.y) { return this; }

  		if (options.animate && options.pan) {
  			this.panBy(offset);

  		} else {
  			if (options.pan) {
  				this._rawPanBy(offset);
  			}

  			this.fire('move');

  			if (options.debounceMoveend) {
  				clearTimeout(this._sizeTimer);
  				this._sizeTimer = setTimeout(bind(this.fire, this, 'moveend'), 200);
  			} else {
  				this.fire('moveend');
  			}
  		}

  		// @section Map state change events
  		// @event resize: ResizeEvent
  		// Fired when the map is resized.
  		return this.fire('resize', {
  			oldSize: oldSize,
  			newSize: newSize
  		});
  	},

  	// @section Methods for modifying map state
  	// @method stop(): this
  	// Stops the currently running `panTo` or `flyTo` animation, if any.
  	stop: function () {
  		this.setZoom(this._limitZoom(this._zoom));
  		if (!this.options.zoomSnap) {
  			this.fire('viewreset');
  		}
  		return this._stop();
  	},

  	// @section Geolocation methods
  	// @method locate(options?: Locate options): this
  	// Tries to locate the user using the Geolocation API, firing a [`locationfound`](#map-locationfound)
  	// event with location data on success or a [`locationerror`](#map-locationerror) event on failure,
  	// and optionally sets the map view to the user's location with respect to
  	// detection accuracy (or to the world view if geolocation failed).
  	// Note that, if your page doesn't use HTTPS, this method will fail in
  	// modern browsers ([Chrome 50 and newer](https://sites.google.com/a/chromium.org/dev/Home/chromium-security/deprecating-powerful-features-on-insecure-origins))
  	// See `Locate options` for more details.
  	locate: function (options) {

  		options = this._locateOptions = extend({
  			timeout: 10000,
  			watch: false
  			// setView: false
  			// maxZoom: <Number>
  			// maximumAge: 0
  			// enableHighAccuracy: false
  		}, options);

  		if (!('geolocation' in navigator)) {
  			this._handleGeolocationError({
  				code: 0,
  				message: 'Geolocation not supported.'
  			});
  			return this;
  		}

  		var onResponse = bind(this._handleGeolocationResponse, this),
  		    onError = bind(this._handleGeolocationError, this);

  		if (options.watch) {
  			this._locationWatchId =
  			        navigator.geolocation.watchPosition(onResponse, onError, options);
  		} else {
  			navigator.geolocation.getCurrentPosition(onResponse, onError, options);
  		}
  		return this;
  	},

  	// @method stopLocate(): this
  	// Stops watching location previously initiated by `map.locate({watch: true})`
  	// and aborts resetting the map view if map.locate was called with
  	// `{setView: true}`.
  	stopLocate: function () {
  		if (navigator.geolocation && navigator.geolocation.clearWatch) {
  			navigator.geolocation.clearWatch(this._locationWatchId);
  		}
  		if (this._locateOptions) {
  			this._locateOptions.setView = false;
  		}
  		return this;
  	},

  	_handleGeolocationError: function (error) {
  		var c = error.code,
  		    message = error.message ||
  		            (c === 1 ? 'permission denied' :
  		            (c === 2 ? 'position unavailable' : 'timeout'));

  		if (this._locateOptions.setView && !this._loaded) {
  			this.fitWorld();
  		}

  		// @section Location events
  		// @event locationerror: ErrorEvent
  		// Fired when geolocation (using the [`locate`](#map-locate) method) failed.
  		this.fire('locationerror', {
  			code: c,
  			message: 'Geolocation error: ' + message + '.'
  		});
  	},

  	_handleGeolocationResponse: function (pos) {
  		var lat = pos.coords.latitude,
  		    lng = pos.coords.longitude,
  		    latlng = new LatLng(lat, lng),
  		    bounds = latlng.toBounds(pos.coords.accuracy * 2),
  		    options = this._locateOptions;

  		if (options.setView) {
  			var zoom = this.getBoundsZoom(bounds);
  			this.setView(latlng, options.maxZoom ? Math.min(zoom, options.maxZoom) : zoom);
  		}

  		var data = {
  			latlng: latlng,
  			bounds: bounds,
  			timestamp: pos.timestamp
  		};

  		for (var i in pos.coords) {
  			if (typeof pos.coords[i] === 'number') {
  				data[i] = pos.coords[i];
  			}
  		}

  		// @event locationfound: LocationEvent
  		// Fired when geolocation (using the [`locate`](#map-locate) method)
  		// went successfully.
  		this.fire('locationfound', data);
  	},

  	// TODO Appropriate docs section?
  	// @section Other Methods
  	// @method addHandler(name: String, HandlerClass: Function): this
  	// Adds a new `Handler` to the map, given its name and constructor function.
  	addHandler: function (name, HandlerClass) {
  		if (!HandlerClass) { return this; }

  		var handler = this[name] = new HandlerClass(this);

  		this._handlers.push(handler);

  		if (this.options[name]) {
  			handler.enable();
  		}

  		return this;
  	},

  	// @method remove(): this
  	// Destroys the map and clears all related event listeners.
  	remove: function () {

  		this._initEvents(true);
  		this.off('moveend', this._panInsideMaxBounds);

  		if (this._containerId !== this._container._leaflet_id) {
  			throw new Error('Map container is being reused by another instance');
  		}

  		try {
  			// throws error in IE6-8
  			delete this._container._leaflet_id;
  			delete this._containerId;
  		} catch (e) {
  			/*eslint-disable */
  			this._container._leaflet_id = undefined;
  			/* eslint-enable */
  			this._containerId = undefined;
  		}

  		if (this._locationWatchId !== undefined) {
  			this.stopLocate();
  		}

  		this._stop();

  		remove(this._mapPane);

  		if (this._clearControlPos) {
  			this._clearControlPos();
  		}
  		if (this._resizeRequest) {
  			cancelAnimFrame(this._resizeRequest);
  			this._resizeRequest = null;
  		}

  		this._clearHandlers();

  		if (this._loaded) {
  			// @section Map state change events
  			// @event unload: Event
  			// Fired when the map is destroyed with [remove](#map-remove) method.
  			this.fire('unload');
  		}

  		var i;
  		for (i in this._layers) {
  			this._layers[i].remove();
  		}
  		for (i in this._panes) {
  			remove(this._panes[i]);
  		}

  		this._layers = [];
  		this._panes = [];
  		delete this._mapPane;
  		delete this._renderer;

  		return this;
  	},

  	// @section Other Methods
  	// @method createPane(name: String, container?: HTMLElement): HTMLElement
  	// Creates a new [map pane](#map-pane) with the given name if it doesn't exist already,
  	// then returns it. The pane is created as a child of `container`, or
  	// as a child of the main map pane if not set.
  	createPane: function (name, container) {
  		var className = 'leaflet-pane' + (name ? ' leaflet-' + name.replace('Pane', '') + '-pane' : ''),
  		    pane = create$1('div', className, container || this._mapPane);

  		if (name) {
  			this._panes[name] = pane;
  		}
  		return pane;
  	},

  	// @section Methods for Getting Map State

  	// @method getCenter(): LatLng
  	// Returns the geographical center of the map view
  	getCenter: function () {
  		this._checkIfLoaded();

  		if (this._lastCenter && !this._moved()) {
  			return this._lastCenter;
  		}
  		return this.layerPointToLatLng(this._getCenterLayerPoint());
  	},

  	// @method getZoom(): Number
  	// Returns the current zoom level of the map view
  	getZoom: function () {
  		return this._zoom;
  	},

  	// @method getBounds(): LatLngBounds
  	// Returns the geographical bounds visible in the current map view
  	getBounds: function () {
  		var bounds = this.getPixelBounds(),
  		    sw = this.unproject(bounds.getBottomLeft()),
  		    ne = this.unproject(bounds.getTopRight());

  		return new LatLngBounds(sw, ne);
  	},

  	// @method getMinZoom(): Number
  	// Returns the minimum zoom level of the map (if set in the `minZoom` option of the map or of any layers), or `0` by default.
  	getMinZoom: function () {
  		return this.options.minZoom === undefined ? this._layersMinZoom || 0 : this.options.minZoom;
  	},

  	// @method getMaxZoom(): Number
  	// Returns the maximum zoom level of the map (if set in the `maxZoom` option of the map or of any layers).
  	getMaxZoom: function () {
  		return this.options.maxZoom === undefined ?
  			(this._layersMaxZoom === undefined ? Infinity : this._layersMaxZoom) :
  			this.options.maxZoom;
  	},

  	// @method getBoundsZoom(bounds: LatLngBounds, inside?: Boolean, padding?: Point): Number
  	// Returns the maximum zoom level on which the given bounds fit to the map
  	// view in its entirety. If `inside` (optional) is set to `true`, the method
  	// instead returns the minimum zoom level on which the map view fits into
  	// the given bounds in its entirety.
  	getBoundsZoom: function (bounds, inside, padding) { // (LatLngBounds[, Boolean, Point]) -> Number
  		bounds = toLatLngBounds(bounds);
  		padding = toPoint(padding || [0, 0]);

  		var zoom = this.getZoom() || 0,
  		    min = this.getMinZoom(),
  		    max = this.getMaxZoom(),
  		    nw = bounds.getNorthWest(),
  		    se = bounds.getSouthEast(),
  		    size = this.getSize().subtract(padding),
  		    boundsSize = toBounds(this.project(se, zoom), this.project(nw, zoom)).getSize(),
  		    snap = any3d ? this.options.zoomSnap : 1,
  		    scalex = size.x / boundsSize.x,
  		    scaley = size.y / boundsSize.y,
  		    scale = inside ? Math.max(scalex, scaley) : Math.min(scalex, scaley);

  		zoom = this.getScaleZoom(scale, zoom);

  		if (snap) {
  			zoom = Math.round(zoom / (snap / 100)) * (snap / 100); // don't jump if within 1% of a snap level
  			zoom = inside ? Math.ceil(zoom / snap) * snap : Math.floor(zoom / snap) * snap;
  		}

  		return Math.max(min, Math.min(max, zoom));
  	},

  	// @method getSize(): Point
  	// Returns the current size of the map container (in pixels).
  	getSize: function () {
  		if (!this._size || this._sizeChanged) {
  			this._size = new Point(
  				this._container.clientWidth || 0,
  				this._container.clientHeight || 0);

  			this._sizeChanged = false;
  		}
  		return this._size.clone();
  	},

  	// @method getPixelBounds(): Bounds
  	// Returns the bounds of the current map view in projected pixel
  	// coordinates (sometimes useful in layer and overlay implementations).
  	getPixelBounds: function (center, zoom) {
  		var topLeftPoint = this._getTopLeftPoint(center, zoom);
  		return new Bounds(topLeftPoint, topLeftPoint.add(this.getSize()));
  	},

  	// TODO: Check semantics - isn't the pixel origin the 0,0 coord relative to
  	// the map pane? "left point of the map layer" can be confusing, specially
  	// since there can be negative offsets.
  	// @method getPixelOrigin(): Point
  	// Returns the projected pixel coordinates of the top left point of
  	// the map layer (useful in custom layer and overlay implementations).
  	getPixelOrigin: function () {
  		this._checkIfLoaded();
  		return this._pixelOrigin;
  	},

  	// @method getPixelWorldBounds(zoom?: Number): Bounds
  	// Returns the world's bounds in pixel coordinates for zoom level `zoom`.
  	// If `zoom` is omitted, the map's current zoom level is used.
  	getPixelWorldBounds: function (zoom) {
  		return this.options.crs.getProjectedBounds(zoom === undefined ? this.getZoom() : zoom);
  	},

  	// @section Other Methods

  	// @method getPane(pane: String|HTMLElement): HTMLElement
  	// Returns a [map pane](#map-pane), given its name or its HTML element (its identity).
  	getPane: function (pane) {
  		return typeof pane === 'string' ? this._panes[pane] : pane;
  	},

  	// @method getPanes(): Object
  	// Returns a plain object containing the names of all [panes](#map-pane) as keys and
  	// the panes as values.
  	getPanes: function () {
  		return this._panes;
  	},

  	// @method getContainer: HTMLElement
  	// Returns the HTML element that contains the map.
  	getContainer: function () {
  		return this._container;
  	},


  	// @section Conversion Methods

  	// @method getZoomScale(toZoom: Number, fromZoom: Number): Number
  	// Returns the scale factor to be applied to a map transition from zoom level
  	// `fromZoom` to `toZoom`. Used internally to help with zoom animations.
  	getZoomScale: function (toZoom, fromZoom) {
  		// TODO replace with universal implementation after refactoring projections
  		var crs = this.options.crs;
  		fromZoom = fromZoom === undefined ? this._zoom : fromZoom;
  		return crs.scale(toZoom) / crs.scale(fromZoom);
  	},

  	// @method getScaleZoom(scale: Number, fromZoom: Number): Number
  	// Returns the zoom level that the map would end up at, if it is at `fromZoom`
  	// level and everything is scaled by a factor of `scale`. Inverse of
  	// [`getZoomScale`](#map-getZoomScale).
  	getScaleZoom: function (scale, fromZoom) {
  		var crs = this.options.crs;
  		fromZoom = fromZoom === undefined ? this._zoom : fromZoom;
  		var zoom = crs.zoom(scale * crs.scale(fromZoom));
  		return isNaN(zoom) ? Infinity : zoom;
  	},

  	// @method project(latlng: LatLng, zoom: Number): Point
  	// Projects a geographical coordinate `LatLng` according to the projection
  	// of the map's CRS, then scales it according to `zoom` and the CRS's
  	// `Transformation`. The result is pixel coordinate relative to
  	// the CRS origin.
  	project: function (latlng, zoom) {
  		zoom = zoom === undefined ? this._zoom : zoom;
  		return this.options.crs.latLngToPoint(toLatLng(latlng), zoom);
  	},

  	// @method unproject(point: Point, zoom: Number): LatLng
  	// Inverse of [`project`](#map-project).
  	unproject: function (point, zoom) {
  		zoom = zoom === undefined ? this._zoom : zoom;
  		return this.options.crs.pointToLatLng(toPoint(point), zoom);
  	},

  	// @method layerPointToLatLng(point: Point): LatLng
  	// Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
  	// returns the corresponding geographical coordinate (for the current zoom level).
  	layerPointToLatLng: function (point) {
  		var projectedPoint = toPoint(point).add(this.getPixelOrigin());
  		return this.unproject(projectedPoint);
  	},

  	// @method latLngToLayerPoint(latlng: LatLng): Point
  	// Given a geographical coordinate, returns the corresponding pixel coordinate
  	// relative to the [origin pixel](#map-getpixelorigin).
  	latLngToLayerPoint: function (latlng) {
  		var projectedPoint = this.project(toLatLng(latlng))._round();
  		return projectedPoint._subtract(this.getPixelOrigin());
  	},

  	// @method wrapLatLng(latlng: LatLng): LatLng
  	// Returns a `LatLng` where `lat` and `lng` has been wrapped according to the
  	// map's CRS's `wrapLat` and `wrapLng` properties, if they are outside the
  	// CRS's bounds.
  	// By default this means longitude is wrapped around the dateline so its
  	// value is between -180 and +180 degrees.
  	wrapLatLng: function (latlng) {
  		return this.options.crs.wrapLatLng(toLatLng(latlng));
  	},

  	// @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds
  	// Returns a `LatLngBounds` with the same size as the given one, ensuring that
  	// its center is within the CRS's bounds.
  	// By default this means the center longitude is wrapped around the dateline so its
  	// value is between -180 and +180 degrees, and the majority of the bounds
  	// overlaps the CRS's bounds.
  	wrapLatLngBounds: function (latlng) {
  		return this.options.crs.wrapLatLngBounds(toLatLngBounds(latlng));
  	},

  	// @method distance(latlng1: LatLng, latlng2: LatLng): Number
  	// Returns the distance between two geographical coordinates according to
  	// the map's CRS. By default this measures distance in meters.
  	distance: function (latlng1, latlng2) {
  		return this.options.crs.distance(toLatLng(latlng1), toLatLng(latlng2));
  	},

  	// @method containerPointToLayerPoint(point: Point): Point
  	// Given a pixel coordinate relative to the map container, returns the corresponding
  	// pixel coordinate relative to the [origin pixel](#map-getpixelorigin).
  	containerPointToLayerPoint: function (point) { // (Point)
  		return toPoint(point).subtract(this._getMapPanePos());
  	},

  	// @method layerPointToContainerPoint(point: Point): Point
  	// Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
  	// returns the corresponding pixel coordinate relative to the map container.
  	layerPointToContainerPoint: function (point) { // (Point)
  		return toPoint(point).add(this._getMapPanePos());
  	},

  	// @method containerPointToLatLng(point: Point): LatLng
  	// Given a pixel coordinate relative to the map container, returns
  	// the corresponding geographical coordinate (for the current zoom level).
  	containerPointToLatLng: function (point) {
  		var layerPoint = this.containerPointToLayerPoint(toPoint(point));
  		return this.layerPointToLatLng(layerPoint);
  	},

  	// @method latLngToContainerPoint(latlng: LatLng): Point
  	// Given a geographical coordinate, returns the corresponding pixel coordinate
  	// relative to the map container.
  	latLngToContainerPoint: function (latlng) {
  		return this.layerPointToContainerPoint(this.latLngToLayerPoint(toLatLng(latlng)));
  	},

  	// @method mouseEventToContainerPoint(ev: MouseEvent): Point
  	// Given a MouseEvent object, returns the pixel coordinate relative to the
  	// map container where the event took place.
  	mouseEventToContainerPoint: function (e) {
  		return getMousePosition(e, this._container);
  	},

  	// @method mouseEventToLayerPoint(ev: MouseEvent): Point
  	// Given a MouseEvent object, returns the pixel coordinate relative to
  	// the [origin pixel](#map-getpixelorigin) where the event took place.
  	mouseEventToLayerPoint: function (e) {
  		return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(e));
  	},

  	// @method mouseEventToLatLng(ev: MouseEvent): LatLng
  	// Given a MouseEvent object, returns geographical coordinate where the
  	// event took place.
  	mouseEventToLatLng: function (e) { // (MouseEvent)
  		return this.layerPointToLatLng(this.mouseEventToLayerPoint(e));
  	},


  	// map initialization methods

  	_initContainer: function (id) {
  		var container = this._container = get(id);

  		if (!container) {
  			throw new Error('Map container not found.');
  		} else if (container._leaflet_id) {
  			throw new Error('Map container is already initialized.');
  		}

  		on(container, 'scroll', this._onScroll, this);
  		this._containerId = stamp(container);
  	},

  	_initLayout: function () {
  		var container = this._container;

  		this._fadeAnimated = this.options.fadeAnimation && any3d;

  		addClass(container, 'leaflet-container' +
  			(touch ? ' leaflet-touch' : '') +
  			(retina ? ' leaflet-retina' : '') +
  			(ielt9 ? ' leaflet-oldie' : '') +
  			(safari ? ' leaflet-safari' : '') +
  			(this._fadeAnimated ? ' leaflet-fade-anim' : ''));

  		var position = getStyle(container, 'position');

  		if (position !== 'absolute' && position !== 'relative' && position !== 'fixed') {
  			container.style.position = 'relative';
  		}

  		this._initPanes();

  		if (this._initControlPos) {
  			this._initControlPos();
  		}
  	},

  	_initPanes: function () {
  		var panes = this._panes = {};
  		this._paneRenderers = {};

  		// @section
  		//
  		// Panes are DOM elements used to control the ordering of layers on the map. You
  		// can access panes with [`map.getPane`](#map-getpane) or
  		// [`map.getPanes`](#map-getpanes) methods. New panes can be created with the
  		// [`map.createPane`](#map-createpane) method.
  		//
  		// Every map has the following default panes that differ only in zIndex.
  		//
  		// @pane mapPane: HTMLElement = 'auto'
  		// Pane that contains all other map panes

  		this._mapPane = this.createPane('mapPane', this._container);
  		setPosition(this._mapPane, new Point(0, 0));

  		// @pane tilePane: HTMLElement = 200
  		// Pane for `GridLayer`s and `TileLayer`s
  		this.createPane('tilePane');
  		// @pane overlayPane: HTMLElement = 400
  		// Pane for overlay shadows (e.g. `Marker` shadows)
  		this.createPane('shadowPane');
  		// @pane shadowPane: HTMLElement = 500
  		// Pane for vectors (`Path`s, like `Polyline`s and `Polygon`s), `ImageOverlay`s and `VideoOverlay`s
  		this.createPane('overlayPane');
  		// @pane markerPane: HTMLElement = 600
  		// Pane for `Icon`s of `Marker`s
  		this.createPane('markerPane');
  		// @pane tooltipPane: HTMLElement = 650
  		// Pane for `Tooltip`s.
  		this.createPane('tooltipPane');
  		// @pane popupPane: HTMLElement = 700
  		// Pane for `Popup`s.
  		this.createPane('popupPane');

  		if (!this.options.markerZoomAnimation) {
  			addClass(panes.markerPane, 'leaflet-zoom-hide');
  			addClass(panes.shadowPane, 'leaflet-zoom-hide');
  		}
  	},


  	// private methods that modify map state

  	// @section Map state change events
  	_resetView: function (center, zoom) {
  		setPosition(this._mapPane, new Point(0, 0));

  		var loading = !this._loaded;
  		this._loaded = true;
  		zoom = this._limitZoom(zoom);

  		this.fire('viewprereset');

  		var zoomChanged = this._zoom !== zoom;
  		this
  			._moveStart(zoomChanged, false)
  			._move(center, zoom)
  			._moveEnd(zoomChanged);

  		// @event viewreset: Event
  		// Fired when the map needs to redraw its content (this usually happens
  		// on map zoom or load). Very useful for creating custom overlays.
  		this.fire('viewreset');

  		// @event load: Event
  		// Fired when the map is initialized (when its center and zoom are set
  		// for the first time).
  		if (loading) {
  			this.fire('load');
  		}
  	},

  	_moveStart: function (zoomChanged, noMoveStart) {
  		// @event zoomstart: Event
  		// Fired when the map zoom is about to change (e.g. before zoom animation).
  		// @event movestart: Event
  		// Fired when the view of the map starts changing (e.g. user starts dragging the map).
  		if (zoomChanged) {
  			this.fire('zoomstart');
  		}
  		if (!noMoveStart) {
  			this.fire('movestart');
  		}
  		return this;
  	},

  	_move: function (center, zoom, data) {
  		if (zoom === undefined) {
  			zoom = this._zoom;
  		}
  		var zoomChanged = this._zoom !== zoom;

  		this._zoom = zoom;
  		this._lastCenter = center;
  		this._pixelOrigin = this._getNewPixelOrigin(center);

  		// @event zoom: Event
  		// Fired repeatedly during any change in zoom level, including zoom
  		// and fly animations.
  		if (zoomChanged || (data && data.pinch)) {	// Always fire 'zoom' if pinching because #3530
  			this.fire('zoom', data);
  		}

  		// @event move: Event
  		// Fired repeatedly during any movement of the map, including pan and
  		// fly animations.
  		return this.fire('move', data);
  	},

  	_moveEnd: function (zoomChanged) {
  		// @event zoomend: Event
  		// Fired when the map has changed, after any animations.
  		if (zoomChanged) {
  			this.fire('zoomend');
  		}

  		// @event moveend: Event
  		// Fired when the center of the map stops changing (e.g. user stopped
  		// dragging the map).
  		return this.fire('moveend');
  	},

  	_stop: function () {
  		cancelAnimFrame(this._flyToFrame);
  		if (this._panAnim) {
  			this._panAnim.stop();
  		}
  		return this;
  	},

  	_rawPanBy: function (offset) {
  		setPosition(this._mapPane, this._getMapPanePos().subtract(offset));
  	},

  	_getZoomSpan: function () {
  		return this.getMaxZoom() - this.getMinZoom();
  	},

  	_panInsideMaxBounds: function () {
  		if (!this._enforcingBounds) {
  			this.panInsideBounds(this.options.maxBounds);
  		}
  	},

  	_checkIfLoaded: function () {
  		if (!this._loaded) {
  			throw new Error('Set map center and zoom first.');
  		}
  	},

  	// DOM event handling

  	// @section Interaction events
  	_initEvents: function (remove$$1) {
  		this._targets = {};
  		this._targets[stamp(this._container)] = this;

  		var onOff = remove$$1 ? off : on;

  		// @event click: MouseEvent
  		// Fired when the user clicks (or taps) the map.
  		// @event dblclick: MouseEvent
  		// Fired when the user double-clicks (or double-taps) the map.
  		// @event mousedown: MouseEvent
  		// Fired when the user pushes the mouse button on the map.
  		// @event mouseup: MouseEvent
  		// Fired when the user releases the mouse button on the map.
  		// @event mouseover: MouseEvent
  		// Fired when the mouse enters the map.
  		// @event mouseout: MouseEvent
  		// Fired when the mouse leaves the map.
  		// @event mousemove: MouseEvent
  		// Fired while the mouse moves over the map.
  		// @event contextmenu: MouseEvent
  		// Fired when the user pushes the right mouse button on the map, prevents
  		// default browser context menu from showing if there are listeners on
  		// this event. Also fired on mobile when the user holds a single touch
  		// for a second (also called long press).
  		// @event keypress: KeyboardEvent
  		// Fired when the user presses a key from the keyboard that produces a character value while the map is focused.
  		// @event keydown: KeyboardEvent
  		// Fired when the user presses a key from the keyboard while the map is focused. Unlike the `keypress` event,
  		// the `keydown` event is fired for keys that produce a character value and for keys
  		// that do not produce a character value.
  		// @event keyup: KeyboardEvent
  		// Fired when the user releases a key from the keyboard while the map is focused.
  		onOff(this._container, 'click dblclick mousedown mouseup ' +
  			'mouseover mouseout mousemove contextmenu keypress keydown keyup', this._handleDOMEvent, this);

  		if (this.options.trackResize) {
  			onOff(window, 'resize', this._onResize, this);
  		}

  		if (any3d && this.options.transform3DLimit) {
  			(remove$$1 ? this.off : this.on).call(this, 'moveend', this._onMoveEnd);
  		}
  	},

  	_onResize: function () {
  		cancelAnimFrame(this._resizeRequest);
  		this._resizeRequest = requestAnimFrame(
  		        function () { this.invalidateSize({debounceMoveend: true}); }, this);
  	},

  	_onScroll: function () {
  		this._container.scrollTop  = 0;
  		this._container.scrollLeft = 0;
  	},

  	_onMoveEnd: function () {
  		var pos = this._getMapPanePos();
  		if (Math.max(Math.abs(pos.x), Math.abs(pos.y)) >= this.options.transform3DLimit) {
  			// https://bugzilla.mozilla.org/show_bug.cgi?id=1203873 but Webkit also have
  			// a pixel offset on very high values, see: http://jsfiddle.net/dg6r5hhb/
  			this._resetView(this.getCenter(), this.getZoom());
  		}
  	},

  	_findEventTargets: function (e, type) {
  		var targets = [],
  		    target,
  		    isHover = type === 'mouseout' || type === 'mouseover',
  		    src = e.target || e.srcElement,
  		    dragging = false;

  		while (src) {
  			target = this._targets[stamp(src)];
  			if (target && (type === 'click' || type === 'preclick') && !e._simulated && this._draggableMoved(target)) {
  				// Prevent firing click after you just dragged an object.
  				dragging = true;
  				break;
  			}
  			if (target && target.listens(type, true)) {
  				if (isHover && !isExternalTarget(src, e)) { break; }
  				targets.push(target);
  				if (isHover) { break; }
  			}
  			if (src === this._container) { break; }
  			src = src.parentNode;
  		}
  		if (!targets.length && !dragging && !isHover && isExternalTarget(src, e)) {
  			targets = [this];
  		}
  		return targets;
  	},

  	_handleDOMEvent: function (e) {
  		if (!this._loaded || skipped(e)) { return; }

  		var type = e.type;

  		if (type === 'mousedown' || type === 'keypress' || type === 'keyup' || type === 'keydown') {
  			// prevents outline when clicking on keyboard-focusable element
  			preventOutline(e.target || e.srcElement);
  		}

  		this._fireDOMEvent(e, type);
  	},

  	_mouseEvents: ['click', 'dblclick', 'mouseover', 'mouseout', 'contextmenu'],

  	_fireDOMEvent: function (e, type, targets) {

  		if (e.type === 'click') {
  			// Fire a synthetic 'preclick' event which propagates up (mainly for closing popups).
  			// @event preclick: MouseEvent
  			// Fired before mouse click on the map (sometimes useful when you
  			// want something to happen on click before any existing click
  			// handlers start running).
  			var synth = extend({}, e);
  			synth.type = 'preclick';
  			this._fireDOMEvent(synth, synth.type, targets);
  		}

  		if (e._stopped) { return; }

  		// Find the layer the event is propagating from and its parents.
  		targets = (targets || []).concat(this._findEventTargets(e, type));

  		if (!targets.length) { return; }

  		var target = targets[0];
  		if (type === 'contextmenu' && target.listens(type, true)) {
  			preventDefault(e);
  		}

  		var data = {
  			originalEvent: e
  		};

  		if (e.type !== 'keypress' && e.type !== 'keydown' && e.type !== 'keyup') {
  			var isMarker = target.getLatLng && (!target._radius || target._radius <= 10);
  			data.containerPoint = isMarker ?
  				this.latLngToContainerPoint(target.getLatLng()) : this.mouseEventToContainerPoint(e);
  			data.layerPoint = this.containerPointToLayerPoint(data.containerPoint);
  			data.latlng = isMarker ? target.getLatLng() : this.layerPointToLatLng(data.layerPoint);
  		}

  		for (var i = 0; i < targets.length; i++) {
  			targets[i].fire(type, data, true);
  			if (data.originalEvent._stopped ||
  				(targets[i].options.bubblingMouseEvents === false && indexOf(this._mouseEvents, type) !== -1)) { return; }
  		}
  	},

  	_draggableMoved: function (obj) {
  		obj = obj.dragging && obj.dragging.enabled() ? obj : this;
  		return (obj.dragging && obj.dragging.moved()) || (this.boxZoom && this.boxZoom.moved());
  	},

  	_clearHandlers: function () {
  		for (var i = 0, len = this._handlers.length; i < len; i++) {
  			this._handlers[i].disable();
  		}
  	},

  	// @section Other Methods

  	// @method whenReady(fn: Function, context?: Object): this
  	// Runs the given function `fn` when the map gets initialized with
  	// a view (center and zoom) and at least one layer, or immediately
  	// if it's already initialized, optionally passing a function context.
  	whenReady: function (callback, context) {
  		if (this._loaded) {
  			callback.call(context || this, {target: this});
  		} else {
  			this.on('load', callback, context);
  		}
  		return this;
  	},


  	// private methods for getting map state

  	_getMapPanePos: function () {
  		return getPosition(this._mapPane) || new Point(0, 0);
  	},

  	_moved: function () {
  		var pos = this._getMapPanePos();
  		return pos && !pos.equals([0, 0]);
  	},

  	_getTopLeftPoint: function (center, zoom) {
  		var pixelOrigin = center && zoom !== undefined ?
  			this._getNewPixelOrigin(center, zoom) :
  			this.getPixelOrigin();
  		return pixelOrigin.subtract(this._getMapPanePos());
  	},

  	_getNewPixelOrigin: function (center, zoom) {
  		var viewHalf = this.getSize()._divideBy(2);
  		return this.project(center, zoom)._subtract(viewHalf)._add(this._getMapPanePos())._round();
  	},

  	_latLngToNewLayerPoint: function (latlng, zoom, center) {
  		var topLeft = this._getNewPixelOrigin(center, zoom);
  		return this.project(latlng, zoom)._subtract(topLeft);
  	},

  	_latLngBoundsToNewLayerBounds: function (latLngBounds, zoom, center) {
  		var topLeft = this._getNewPixelOrigin(center, zoom);
  		return toBounds([
  			this.project(latLngBounds.getSouthWest(), zoom)._subtract(topLeft),
  			this.project(latLngBounds.getNorthWest(), zoom)._subtract(topLeft),
  			this.project(latLngBounds.getSouthEast(), zoom)._subtract(topLeft),
  			this.project(latLngBounds.getNorthEast(), zoom)._subtract(topLeft)
  		]);
  	},

  	// layer point of the current center
  	_getCenterLayerPoint: function () {
  		return this.containerPointToLayerPoint(this.getSize()._divideBy(2));
  	},

  	// offset of the specified place to the current center in pixels
  	_getCenterOffset: function (latlng) {
  		return this.latLngToLayerPoint(latlng).subtract(this._getCenterLayerPoint());
  	},

  	// adjust center for view to get inside bounds
  	_limitCenter: function (center, zoom, bounds) {

  		if (!bounds) { return center; }

  		var centerPoint = this.project(center, zoom),
  		    viewHalf = this.getSize().divideBy(2),
  		    viewBounds = new Bounds(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf)),
  		    offset = this._getBoundsOffset(viewBounds, bounds, zoom);

  		// If offset is less than a pixel, ignore.
  		// This prevents unstable projections from getting into
  		// an infinite loop of tiny offsets.
  		if (offset.round().equals([0, 0])) {
  			return center;
  		}

  		return this.unproject(centerPoint.add(offset), zoom);
  	},

  	// adjust offset for view to get inside bounds
  	_limitOffset: function (offset, bounds) {
  		if (!bounds) { return offset; }

  		var viewBounds = this.getPixelBounds(),
  		    newBounds = new Bounds(viewBounds.min.add(offset), viewBounds.max.add(offset));

  		return offset.add(this._getBoundsOffset(newBounds, bounds));
  	},

  	// returns offset needed for pxBounds to get inside maxBounds at a specified zoom
  	_getBoundsOffset: function (pxBounds, maxBounds, zoom) {
  		var projectedMaxBounds = toBounds(
  		        this.project(maxBounds.getNorthEast(), zoom),
  		        this.project(maxBounds.getSouthWest(), zoom)
  		    ),
  		    minOffset = projectedMaxBounds.min.subtract(pxBounds.min),
  		    maxOffset = projectedMaxBounds.max.subtract(pxBounds.max),

  		    dx = this._rebound(minOffset.x, -maxOffset.x),
  		    dy = this._rebound(minOffset.y, -maxOffset.y);

  		return new Point(dx, dy);
  	},

  	_rebound: function (left, right) {
  		return left + right > 0 ?
  			Math.round(left - right) / 2 :
  			Math.max(0, Math.ceil(left)) - Math.max(0, Math.floor(right));
  	},

  	_limitZoom: function (zoom) {
  		var min = this.getMinZoom(),
  		    max = this.getMaxZoom(),
  		    snap = any3d ? this.options.zoomSnap : 1;
  		if (snap) {
  			zoom = Math.round(zoom / snap) * snap;
  		}
  		return Math.max(min, Math.min(max, zoom));
  	},

  	_onPanTransitionStep: function () {
  		this.fire('move');
  	},

  	_onPanTransitionEnd: function () {
  		removeClass(this._mapPane, 'leaflet-pan-anim');
  		this.fire('moveend');
  	},

  	_tryAnimatedPan: function (center, options) {
  		// difference between the new and current centers in pixels
  		var offset = this._getCenterOffset(center)._trunc();

  		// don't animate too far unless animate: true specified in options
  		if ((options && options.animate) !== true && !this.getSize().contains(offset)) { return false; }

  		this.panBy(offset, options);

  		return true;
  	},

  	_createAnimProxy: function () {

  		var proxy = this._proxy = create$1('div', 'leaflet-proxy leaflet-zoom-animated');
  		this._panes.mapPane.appendChild(proxy);

  		this.on('zoomanim', function (e) {
  			var prop = TRANSFORM,
  			    transform = this._proxy.style[prop];

  			setTransform(this._proxy, this.project(e.center, e.zoom), this.getZoomScale(e.zoom, 1));

  			// workaround for case when transform is the same and so transitionend event is not fired
  			if (transform === this._proxy.style[prop] && this._animatingZoom) {
  				this._onZoomTransitionEnd();
  			}
  		}, this);

  		this.on('load moveend', this._animMoveEnd, this);

  		this._on('unload', this._destroyAnimProxy, this);
  	},

  	_destroyAnimProxy: function () {
  		remove(this._proxy);
  		this.off('load moveend', this._animMoveEnd, this);
  		delete this._proxy;
  	},

  	_animMoveEnd: function () {
  		var c = this.getCenter(),
  		    z = this.getZoom();
  		setTransform(this._proxy, this.project(c, z), this.getZoomScale(z, 1));
  	},

  	_catchTransitionEnd: function (e) {
  		if (this._animatingZoom && e.propertyName.indexOf('transform') >= 0) {
  			this._onZoomTransitionEnd();
  		}
  	},

  	_nothingToAnimate: function () {
  		return !this._container.getElementsByClassName('leaflet-zoom-animated').length;
  	},

  	_tryAnimatedZoom: function (center, zoom, options) {

  		if (this._animatingZoom) { return true; }

  		options = options || {};

  		// don't animate if disabled, not supported or zoom difference is too large
  		if (!this._zoomAnimated || options.animate === false || this._nothingToAnimate() ||
  		        Math.abs(zoom - this._zoom) > this.options.zoomAnimationThreshold) { return false; }

  		// offset is the pixel coords of the zoom origin relative to the current center
  		var scale = this.getZoomScale(zoom),
  		    offset = this._getCenterOffset(center)._divideBy(1 - 1 / scale);

  		// don't animate if the zoom origin isn't within one screen from the current center, unless forced
  		if (options.animate !== true && !this.getSize().contains(offset)) { return false; }

  		requestAnimFrame(function () {
  			this
  			    ._moveStart(true, false)
  			    ._animateZoom(center, zoom, true);
  		}, this);

  		return true;
  	},

  	_animateZoom: function (center, zoom, startAnim, noUpdate) {
  		if (!this._mapPane) { return; }

  		if (startAnim) {
  			this._animatingZoom = true;

  			// remember what center/zoom to set after animation
  			this._animateToCenter = center;
  			this._animateToZoom = zoom;

  			addClass(this._mapPane, 'leaflet-zoom-anim');
  		}

  		// @section Other Events
  		// @event zoomanim: ZoomAnimEvent
  		// Fired at least once per zoom animation. For continuous zoom, like pinch zooming, fired once per frame during zoom.
  		this.fire('zoomanim', {
  			center: center,
  			zoom: zoom,
  			noUpdate: noUpdate
  		});

  		// Work around webkit not firing 'transitionend', see https://github.com/Leaflet/Leaflet/issues/3689, 2693
  		setTimeout(bind(this._onZoomTransitionEnd, this), 250);
  	},

  	_onZoomTransitionEnd: function () {
  		if (!this._animatingZoom) { return; }

  		if (this._mapPane) {
  			removeClass(this._mapPane, 'leaflet-zoom-anim');
  		}

  		this._animatingZoom = false;

  		this._move(this._animateToCenter, this._animateToZoom);

  		// This anim frame should prevent an obscure iOS webkit tile loading race condition.
  		requestAnimFrame(function () {
  			this._moveEnd(true);
  		}, this);
  	}
  });

  // @section

  // @factory L.map(id: String, options?: Map options)
  // Instantiates a map object given the DOM ID of a `<div>` element
  // and optionally an object literal with `Map options`.
  //
  // @alternative
  // @factory L.map(el: HTMLElement, options?: Map options)
  // Instantiates a map object given an instance of a `<div>` HTML element
  // and optionally an object literal with `Map options`.
  function createMap(id, options) {
  	return new Map(id, options);
  }

  /*
   * @class Control
   * @aka L.Control
   * @inherits Class
   *
   * L.Control is a base class for implementing map controls. Handles positioning.
   * All other controls extend from this class.
   */

  var Control = Class.extend({
  	// @section
  	// @aka Control options
  	options: {
  		// @option position: String = 'topright'
  		// The position of the control (one of the map corners). Possible values are `'topleft'`,
  		// `'topright'`, `'bottomleft'` or `'bottomright'`
  		position: 'topright'
  	},

  	initialize: function (options) {
  		setOptions(this, options);
  	},

  	/* @section
  	 * Classes extending L.Control will inherit the following methods:
  	 *
  	 * @method getPosition: string
  	 * Returns the position of the control.
  	 */
  	getPosition: function () {
  		return this.options.position;
  	},

  	// @method setPosition(position: string): this
  	// Sets the position of the control.
  	setPosition: function (position) {
  		var map = this._map;

  		if (map) {
  			map.removeControl(this);
  		}

  		this.options.position = position;

  		if (map) {
  			map.addControl(this);
  		}

  		return this;
  	},

  	// @method getContainer: HTMLElement
  	// Returns the HTMLElement that contains the control.
  	getContainer: function () {
  		return this._container;
  	},

  	// @method addTo(map: Map): this
  	// Adds the control to the given map.
  	addTo: function (map) {
  		this.remove();
  		this._map = map;

  		var container = this._container = this.onAdd(map),
  		    pos = this.getPosition(),
  		    corner = map._controlCorners[pos];

  		addClass(container, 'leaflet-control');

  		if (pos.indexOf('bottom') !== -1) {
  			corner.insertBefore(container, corner.firstChild);
  		} else {
  			corner.appendChild(container);
  		}

  		this._map.on('unload', this.remove, this);

  		return this;
  	},

  	// @method remove: this
  	// Removes the control from the map it is currently active on.
  	remove: function () {
  		if (!this._map) {
  			return this;
  		}

  		remove(this._container);

  		if (this.onRemove) {
  			this.onRemove(this._map);
  		}

  		this._map.off('unload', this.remove, this);
  		this._map = null;

  		return this;
  	},

  	_refocusOnMap: function (e) {
  		// if map exists and event is not a keyboard event
  		if (this._map && e && e.screenX > 0 && e.screenY > 0) {
  			this._map.getContainer().focus();
  		}
  	}
  });

  var control = function (options) {
  	return new Control(options);
  };

  /* @section Extension methods
   * @uninheritable
   *
   * Every control should extend from `L.Control` and (re-)implement the following methods.
   *
   * @method onAdd(map: Map): HTMLElement
   * Should return the container DOM element for the control and add listeners on relevant map events. Called on [`control.addTo(map)`](#control-addTo).
   *
   * @method onRemove(map: Map)
   * Optional method. Should contain all clean up code that removes the listeners previously added in [`onAdd`](#control-onadd). Called on [`control.remove()`](#control-remove).
   */

  /* @namespace Map
   * @section Methods for Layers and Controls
   */
  Map.include({
  	// @method addControl(control: Control): this
  	// Adds the given control to the map
  	addControl: function (control) {
  		control.addTo(this);
  		return this;
  	},

  	// @method removeControl(control: Control): this
  	// Removes the given control from the map
  	removeControl: function (control) {
  		control.remove();
  		return this;
  	},

  	_initControlPos: function () {
  		var corners = this._controlCorners = {},
  		    l = 'leaflet-',
  		    container = this._controlContainer =
  		            create$1('div', l + 'control-container', this._container);

  		function createCorner(vSide, hSide) {
  			var className = l + vSide + ' ' + l + hSide;

  			corners[vSide + hSide] = create$1('div', className, container);
  		}

  		createCorner('top', 'left');
  		createCorner('top', 'right');
  		createCorner('bottom', 'left');
  		createCorner('bottom', 'right');
  	},

  	_clearControlPos: function () {
  		for (var i in this._controlCorners) {
  			remove(this._controlCorners[i]);
  		}
  		remove(this._controlContainer);
  		delete this._controlCorners;
  		delete this._controlContainer;
  	}
  });

  /*
   * @class Control.Layers
   * @aka L.Control.Layers
   * @inherits Control
   *
   * The layers control gives users the ability to switch between different base layers and switch overlays on/off (check out the [detailed example](http://leafletjs.com/examples/layers-control/)). Extends `Control`.
   *
   * @example
   *
   * ```js
   * var baseLayers = {
   * 	"Mapbox": mapbox,
   * 	"OpenStreetMap": osm
   * };
   *
   * var overlays = {
   * 	"Marker": marker,
   * 	"Roads": roadsLayer
   * };
   *
   * L.control.layers(baseLayers, overlays).addTo(map);
   * ```
   *
   * The `baseLayers` and `overlays` parameters are object literals with layer names as keys and `Layer` objects as values:
   *
   * ```js
   * {
   *     "<someName1>": layer1,
   *     "<someName2>": layer2
   * }
   * ```
   *
   * The layer names can contain HTML, which allows you to add additional styling to the items:
   *
   * ```js
   * {"<img src='my-layer-icon' /> <span class='my-layer-item'>My Layer</span>": myLayer}
   * ```
   */

  var Layers = Control.extend({
  	// @section
  	// @aka Control.Layers options
  	options: {
  		// @option collapsed: Boolean = true
  		// If `true`, the control will be collapsed into an icon and expanded on mouse hover or touch.
  		collapsed: true,
  		position: 'topright',

  		// @option autoZIndex: Boolean = true
  		// If `true`, the control will assign zIndexes in increasing order to all of its layers so that the order is preserved when switching them on/off.
  		autoZIndex: true,

  		// @option hideSingleBase: Boolean = false
  		// If `true`, the base layers in the control will be hidden when there is only one.
  		hideSingleBase: false,

  		// @option sortLayers: Boolean = false
  		// Whether to sort the layers. When `false`, layers will keep the order
  		// in which they were added to the control.
  		sortLayers: false,

  		// @option sortFunction: Function = *
  		// A [compare function](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)
  		// that will be used for sorting the layers, when `sortLayers` is `true`.
  		// The function receives both the `L.Layer` instances and their names, as in
  		// `sortFunction(layerA, layerB, nameA, nameB)`.
  		// By default, it sorts layers alphabetically by their name.
  		sortFunction: function (layerA, layerB, nameA, nameB) {
  			return nameA < nameB ? -1 : (nameB < nameA ? 1 : 0);
  		}
  	},

  	initialize: function (baseLayers, overlays, options) {
  		setOptions(this, options);

  		this._layerControlInputs = [];
  		this._layers = [];
  		this._lastZIndex = 0;
  		this._handlingClick = false;

  		for (var i in baseLayers) {
  			this._addLayer(baseLayers[i], i);
  		}

  		for (i in overlays) {
  			this._addLayer(overlays[i], i, true);
  		}
  	},

  	onAdd: function (map) {
  		this._initLayout();
  		this._update();

  		this._map = map;
  		map.on('zoomend', this._checkDisabledLayers, this);

  		for (var i = 0; i < this._layers.length; i++) {
  			this._layers[i].layer.on('add remove', this._onLayerChange, this);
  		}

  		return this._container;
  	},

  	addTo: function (map) {
  		Control.prototype.addTo.call(this, map);
  		// Trigger expand after Layers Control has been inserted into DOM so that is now has an actual height.
  		return this._expandIfNotCollapsed();
  	},

  	onRemove: function () {
  		this._map.off('zoomend', this._checkDisabledLayers, this);

  		for (var i = 0; i < this._layers.length; i++) {
  			this._layers[i].layer.off('add remove', this._onLayerChange, this);
  		}
  	},

  	// @method addBaseLayer(layer: Layer, name: String): this
  	// Adds a base layer (radio button entry) with the given name to the control.
  	addBaseLayer: function (layer, name) {
  		this._addLayer(layer, name);
  		return (this._map) ? this._update() : this;
  	},

  	// @method addOverlay(layer: Layer, name: String): this
  	// Adds an overlay (checkbox entry) with the given name to the control.
  	addOverlay: function (layer, name) {
  		this._addLayer(layer, name, true);
  		return (this._map) ? this._update() : this;
  	},

  	// @method removeLayer(layer: Layer): this
  	// Remove the given layer from the control.
  	removeLayer: function (layer) {
  		layer.off('add remove', this._onLayerChange, this);

  		var obj = this._getLayer(stamp(layer));
  		if (obj) {
  			this._layers.splice(this._layers.indexOf(obj), 1);
  		}
  		return (this._map) ? this._update() : this;
  	},

  	// @method expand(): this
  	// Expand the control container if collapsed.
  	expand: function () {
  		addClass(this._container, 'leaflet-control-layers-expanded');
  		this._section.style.height = null;
  		var acceptableHeight = this._map.getSize().y - (this._container.offsetTop + 50);
  		if (acceptableHeight < this._section.clientHeight) {
  			addClass(this._section, 'leaflet-control-layers-scrollbar');
  			this._section.style.height = acceptableHeight + 'px';
  		} else {
  			removeClass(this._section, 'leaflet-control-layers-scrollbar');
  		}
  		this._checkDisabledLayers();
  		return this;
  	},

  	// @method collapse(): this
  	// Collapse the control container if expanded.
  	collapse: function () {
  		removeClass(this._container, 'leaflet-control-layers-expanded');
  		return this;
  	},

  	_initLayout: function () {
  		var className = 'leaflet-control-layers',
  		    container = this._container = create$1('div', className),
  		    collapsed = this.options.collapsed;

  		// makes this work on IE touch devices by stopping it from firing a mouseout event when the touch is released
  		container.setAttribute('aria-haspopup', true);

  		disableClickPropagation(container);
  		disableScrollPropagation(container);

  		var section = this._section = create$1('section', className + '-list');

  		if (collapsed) {
  			this._map.on('click', this.collapse, this);

  			if (!android) {
  				on(container, {
  					mouseenter: this.expand,
  					mouseleave: this.collapse
  				}, this);
  			}
  		}

  		var link = this._layersLink = create$1('a', className + '-toggle', container);
  		link.href = '#';
  		link.title = 'Layers';

  		if (touch) {
  			on(link, 'click', stop);
  			on(link, 'click', this.expand, this);
  		} else {
  			on(link, 'focus', this.expand, this);
  		}

  		if (!collapsed) {
  			this.expand();
  		}

  		this._baseLayersList = create$1('div', className + '-base', section);
  		this._separator = create$1('div', className + '-separator', section);
  		this._overlaysList = create$1('div', className + '-overlays', section);

  		container.appendChild(section);
  	},

  	_getLayer: function (id) {
  		for (var i = 0; i < this._layers.length; i++) {

  			if (this._layers[i] && stamp(this._layers[i].layer) === id) {
  				return this._layers[i];
  			}
  		}
  	},

  	_addLayer: function (layer, name, overlay) {
  		if (this._map) {
  			layer.on('add remove', this._onLayerChange, this);
  		}

  		this._layers.push({
  			layer: layer,
  			name: name,
  			overlay: overlay
  		});

  		if (this.options.sortLayers) {
  			this._layers.sort(bind(function (a, b) {
  				return this.options.sortFunction(a.layer, b.layer, a.name, b.name);
  			}, this));
  		}

  		if (this.options.autoZIndex && layer.setZIndex) {
  			this._lastZIndex++;
  			layer.setZIndex(this._lastZIndex);
  		}

  		this._expandIfNotCollapsed();
  	},

  	_update: function () {
  		if (!this._container) { return this; }

  		empty(this._baseLayersList);
  		empty(this._overlaysList);

  		this._layerControlInputs = [];
  		var baseLayersPresent, overlaysPresent, i, obj, baseLayersCount = 0;

  		for (i = 0; i < this._layers.length; i++) {
  			obj = this._layers[i];
  			this._addItem(obj);
  			overlaysPresent = overlaysPresent || obj.overlay;
  			baseLayersPresent = baseLayersPresent || !obj.overlay;
  			baseLayersCount += !obj.overlay ? 1 : 0;
  		}

  		// Hide base layers section if there's only one layer.
  		if (this.options.hideSingleBase) {
  			baseLayersPresent = baseLayersPresent && baseLayersCount > 1;
  			this._baseLayersList.style.display = baseLayersPresent ? '' : 'none';
  		}

  		this._separator.style.display = overlaysPresent && baseLayersPresent ? '' : 'none';

  		return this;
  	},

  	_onLayerChange: function (e) {
  		if (!this._handlingClick) {
  			this._update();
  		}

  		var obj = this._getLayer(stamp(e.target));

  		// @namespace Map
  		// @section Layer events
  		// @event baselayerchange: LayersControlEvent
  		// Fired when the base layer is changed through the [layers control](#control-layers).
  		// @event overlayadd: LayersControlEvent
  		// Fired when an overlay is selected through the [layers control](#control-layers).
  		// @event overlayremove: LayersControlEvent
  		// Fired when an overlay is deselected through the [layers control](#control-layers).
  		// @namespace Control.Layers
  		var type = obj.overlay ?
  			(e.type === 'add' ? 'overlayadd' : 'overlayremove') :
  			(e.type === 'add' ? 'baselayerchange' : null);

  		if (type) {
  			this._map.fire(type, obj);
  		}
  	},

  	// IE7 bugs out if you create a radio dynamically, so you have to do it this hacky way (see http://bit.ly/PqYLBe)
  	_createRadioElement: function (name, checked) {

  		var radioHtml = '<input type="radio" class="leaflet-control-layers-selector" name="' +
  				name + '"' + (checked ? ' checked="checked"' : '') + '/>';

  		var radioFragment = document.createElement('div');
  		radioFragment.innerHTML = radioHtml;

  		return radioFragment.firstChild;
  	},

  	_addItem: function (obj) {
  		var label = document.createElement('label'),
  		    checked = this._map.hasLayer(obj.layer),
  		    input;

  		if (obj.overlay) {
  			input = document.createElement('input');
  			input.type = 'checkbox';
  			input.className = 'leaflet-control-layers-selector';
  			input.defaultChecked = checked;
  		} else {
  			input = this._createRadioElement('leaflet-base-layers_' + stamp(this), checked);
  		}

  		this._layerControlInputs.push(input);
  		input.layerId = stamp(obj.layer);

  		on(input, 'click', this._onInputClick, this);

  		var name = document.createElement('span');
  		name.innerHTML = ' ' + obj.name;

  		// Helps from preventing layer control flicker when checkboxes are disabled
  		// https://github.com/Leaflet/Leaflet/issues/2771
  		var holder = document.createElement('div');

  		label.appendChild(holder);
  		holder.appendChild(input);
  		holder.appendChild(name);

  		var container = obj.overlay ? this._overlaysList : this._baseLayersList;
  		container.appendChild(label);

  		this._checkDisabledLayers();
  		return label;
  	},

  	_onInputClick: function () {
  		var inputs = this._layerControlInputs,
  		    input, layer;
  		var addedLayers = [],
  		    removedLayers = [];

  		this._handlingClick = true;

  		for (var i = inputs.length - 1; i >= 0; i--) {
  			input = inputs[i];
  			layer = this._getLayer(input.layerId).layer;

  			if (input.checked) {
  				addedLayers.push(layer);
  			} else if (!input.checked) {
  				removedLayers.push(layer);
  			}
  		}

  		// Bugfix issue 2318: Should remove all old layers before readding new ones
  		for (i = 0; i < removedLayers.length; i++) {
  			if (this._map.hasLayer(removedLayers[i])) {
  				this._map.removeLayer(removedLayers[i]);
  			}
  		}
  		for (i = 0; i < addedLayers.length; i++) {
  			if (!this._map.hasLayer(addedLayers[i])) {
  				this._map.addLayer(addedLayers[i]);
  			}
  		}

  		this._handlingClick = false;

  		this._refocusOnMap();
  	},

  	_checkDisabledLayers: function () {
  		var inputs = this._layerControlInputs,
  		    input,
  		    layer,
  		    zoom = this._map.getZoom();

  		for (var i = inputs.length - 1; i >= 0; i--) {
  			input = inputs[i];
  			layer = this._getLayer(input.layerId).layer;
  			input.disabled = (layer.options.minZoom !== undefined && zoom < layer.options.minZoom) ||
  			                 (layer.options.maxZoom !== undefined && zoom > layer.options.maxZoom);

  		}
  	},

  	_expandIfNotCollapsed: function () {
  		if (this._map && !this.options.collapsed) {
  			this.expand();
  		}
  		return this;
  	},

  	_expand: function () {
  		// Backward compatibility, remove me in 1.1.
  		return this.expand();
  	},

  	_collapse: function () {
  		// Backward compatibility, remove me in 1.1.
  		return this.collapse();
  	}

  });


  // @factory L.control.layers(baselayers?: Object, overlays?: Object, options?: Control.Layers options)
  // Creates a layers control with the given layers. Base layers will be switched with radio buttons, while overlays will be switched with checkboxes. Note that all base layers should be passed in the base layers object, but only one should be added to the map during map instantiation.
  var layers = function (baseLayers, overlays, options) {
  	return new Layers(baseLayers, overlays, options);
  };

  /*
   * @class Control.Zoom
   * @aka L.Control.Zoom
   * @inherits Control
   *
   * A basic zoom control with two buttons (zoom in and zoom out). It is put on the map by default unless you set its [`zoomControl` option](#map-zoomcontrol) to `false`. Extends `Control`.
   */

  var Zoom = Control.extend({
  	// @section
  	// @aka Control.Zoom options
  	options: {
  		position: 'topleft',

  		// @option zoomInText: String = '+'
  		// The text set on the 'zoom in' button.
  		zoomInText: '+',

  		// @option zoomInTitle: String = 'Zoom in'
  		// The title set on the 'zoom in' button.
  		zoomInTitle: 'Zoom in',

  		// @option zoomOutText: String = '&#x2212;'
  		// The text set on the 'zoom out' button.
  		zoomOutText: '&#x2212;',

  		// @option zoomOutTitle: String = 'Zoom out'
  		// The title set on the 'zoom out' button.
  		zoomOutTitle: 'Zoom out'
  	},

  	onAdd: function (map) {
  		var zoomName = 'leaflet-control-zoom',
  		    container = create$1('div', zoomName + ' leaflet-bar'),
  		    options = this.options;

  		this._zoomInButton  = this._createButton(options.zoomInText, options.zoomInTitle,
  		        zoomName + '-in',  container, this._zoomIn);
  		this._zoomOutButton = this._createButton(options.zoomOutText, options.zoomOutTitle,
  		        zoomName + '-out', container, this._zoomOut);

  		this._updateDisabled();
  		map.on('zoomend zoomlevelschange', this._updateDisabled, this);

  		return container;
  	},

  	onRemove: function (map) {
  		map.off('zoomend zoomlevelschange', this._updateDisabled, this);
  	},

  	disable: function () {
  		this._disabled = true;
  		this._updateDisabled();
  		return this;
  	},

  	enable: function () {
  		this._disabled = false;
  		this._updateDisabled();
  		return this;
  	},

  	_zoomIn: function (e) {
  		if (!this._disabled && this._map._zoom < this._map.getMaxZoom()) {
  			this._map.zoomIn(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));
  		}
  	},

  	_zoomOut: function (e) {
  		if (!this._disabled && this._map._zoom > this._map.getMinZoom()) {
  			this._map.zoomOut(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));
  		}
  	},

  	_createButton: function (html, title, className, container, fn) {
  		var link = create$1('a', className, container);
  		link.innerHTML = html;
  		link.href = '#';
  		link.title = title;

  		/*
  		 * Will force screen readers like VoiceOver to read this as "Zoom in - button"
  		 */
  		link.setAttribute('role', 'button');
  		link.setAttribute('aria-label', title);

  		disableClickPropagation(link);
  		on(link, 'click', stop);
  		on(link, 'click', fn, this);
  		on(link, 'click', this._refocusOnMap, this);

  		return link;
  	},

  	_updateDisabled: function () {
  		var map = this._map,
  		    className = 'leaflet-disabled';

  		removeClass(this._zoomInButton, className);
  		removeClass(this._zoomOutButton, className);

  		if (this._disabled || map._zoom === map.getMinZoom()) {
  			addClass(this._zoomOutButton, className);
  		}
  		if (this._disabled || map._zoom === map.getMaxZoom()) {
  			addClass(this._zoomInButton, className);
  		}
  	}
  });

  // @namespace Map
  // @section Control options
  // @option zoomControl: Boolean = true
  // Whether a [zoom control](#control-zoom) is added to the map by default.
  Map.mergeOptions({
  	zoomControl: true
  });

  Map.addInitHook(function () {
  	if (this.options.zoomControl) {
  		// @section Controls
  		// @property zoomControl: Control.Zoom
  		// The default zoom control (only available if the
  		// [`zoomControl` option](#map-zoomcontrol) was `true` when creating the map).
  		this.zoomControl = new Zoom();
  		this.addControl(this.zoomControl);
  	}
  });

  // @namespace Control.Zoom
  // @factory L.control.zoom(options: Control.Zoom options)
  // Creates a zoom control
  var zoom = function (options) {
  	return new Zoom(options);
  };

  /*
   * @class Control.Scale
   * @aka L.Control.Scale
   * @inherits Control
   *
   * A simple scale control that shows the scale of the current center of screen in metric (m/km) and imperial (mi/ft) systems. Extends `Control`.
   *
   * @example
   *
   * ```js
   * L.control.scale().addTo(map);
   * ```
   */

  var Scale = Control.extend({
  	// @section
  	// @aka Control.Scale options
  	options: {
  		position: 'bottomleft',

  		// @option maxWidth: Number = 100
  		// Maximum width of the control in pixels. The width is set dynamically to show round values (e.g. 100, 200, 500).
  		maxWidth: 100,

  		// @option metric: Boolean = True
  		// Whether to show the metric scale line (m/km).
  		metric: true,

  		// @option imperial: Boolean = True
  		// Whether to show the imperial scale line (mi/ft).
  		imperial: true

  		// @option updateWhenIdle: Boolean = false
  		// If `true`, the control is updated on [`moveend`](#map-moveend), otherwise it's always up-to-date (updated on [`move`](#map-move)).
  	},

  	onAdd: function (map) {
  		var className = 'leaflet-control-scale',
  		    container = create$1('div', className),
  		    options = this.options;

  		this._addScales(options, className + '-line', container);

  		map.on(options.updateWhenIdle ? 'moveend' : 'move', this._update, this);
  		map.whenReady(this._update, this);

  		return container;
  	},

  	onRemove: function (map) {
  		map.off(this.options.updateWhenIdle ? 'moveend' : 'move', this._update, this);
  	},

  	_addScales: function (options, className, container) {
  		if (options.metric) {
  			this._mScale = create$1('div', className, container);
  		}
  		if (options.imperial) {
  			this._iScale = create$1('div', className, container);
  		}
  	},

  	_update: function () {
  		var map = this._map,
  		    y = map.getSize().y / 2;

  		var maxMeters = map.distance(
  			map.containerPointToLatLng([0, y]),
  			map.containerPointToLatLng([this.options.maxWidth, y]));

  		this._updateScales(maxMeters);
  	},

  	_updateScales: function (maxMeters) {
  		if (this.options.metric && maxMeters) {
  			this._updateMetric(maxMeters);
  		}
  		if (this.options.imperial && maxMeters) {
  			this._updateImperial(maxMeters);
  		}
  	},

  	_updateMetric: function (maxMeters) {
  		var meters = this._getRoundNum(maxMeters),
  		    label = meters < 1000 ? meters + ' m' : (meters / 1000) + ' km';

  		this._updateScale(this._mScale, label, meters / maxMeters);
  	},

  	_updateImperial: function (maxMeters) {
  		var maxFeet = maxMeters * 3.2808399,
  		    maxMiles, miles, feet;

  		if (maxFeet > 5280) {
  			maxMiles = maxFeet / 5280;
  			miles = this._getRoundNum(maxMiles);
  			this._updateScale(this._iScale, miles + ' mi', miles / maxMiles);

  		} else {
  			feet = this._getRoundNum(maxFeet);
  			this._updateScale(this._iScale, feet + ' ft', feet / maxFeet);
  		}
  	},

  	_updateScale: function (scale, text, ratio) {
  		scale.style.width = Math.round(this.options.maxWidth * ratio) + 'px';
  		scale.innerHTML = text;
  	},

  	_getRoundNum: function (num) {
  		var pow10 = Math.pow(10, (Math.floor(num) + '').length - 1),
  		    d = num / pow10;

  		d = d >= 10 ? 10 :
  		    d >= 5 ? 5 :
  		    d >= 3 ? 3 :
  		    d >= 2 ? 2 : 1;

  		return pow10 * d;
  	}
  });


  // @factory L.control.scale(options?: Control.Scale options)
  // Creates an scale control with the given options.
  var scale = function (options) {
  	return new Scale(options);
  };

  /*
   * @class Control.Attribution
   * @aka L.Control.Attribution
   * @inherits Control
   *
   * The attribution control allows you to display attribution data in a small text box on a map. It is put on the map by default unless you set its [`attributionControl` option](#map-attributioncontrol) to `false`, and it fetches attribution texts from layers with the [`getAttribution` method](#layer-getattribution) automatically. Extends Control.
   */

  var Attribution = Control.extend({
  	// @section
  	// @aka Control.Attribution options
  	options: {
  		position: 'bottomright',

  		// @option prefix: String = 'Leaflet'
  		// The HTML text shown before the attributions. Pass `false` to disable.
  		prefix: '<a href="https://leafletjs.com" title="A JS library for interactive maps">Leaflet</a>'
  	},

  	initialize: function (options) {
  		setOptions(this, options);

  		this._attributions = {};
  	},

  	onAdd: function (map) {
  		map.attributionControl = this;
  		this._container = create$1('div', 'leaflet-control-attribution');
  		disableClickPropagation(this._container);

  		// TODO ugly, refactor
  		for (var i in map._layers) {
  			if (map._layers[i].getAttribution) {
  				this.addAttribution(map._layers[i].getAttribution());
  			}
  		}

  		this._update();

  		return this._container;
  	},

  	// @method setPrefix(prefix: String): this
  	// Sets the text before the attributions.
  	setPrefix: function (prefix) {
  		this.options.prefix = prefix;
  		this._update();
  		return this;
  	},

  	// @method addAttribution(text: String): this
  	// Adds an attribution text (e.g. `'Vector data &copy; Mapbox'`).
  	addAttribution: function (text) {
  		if (!text) { return this; }

  		if (!this._attributions[text]) {
  			this._attributions[text] = 0;
  		}
  		this._attributions[text]++;

  		this._update();

  		return this;
  	},

  	// @method removeAttribution(text: String): this
  	// Removes an attribution text.
  	removeAttribution: function (text) {
  		if (!text) { return this; }

  		if (this._attributions[text]) {
  			this._attributions[text]--;
  			this._update();
  		}

  		return this;
  	},

  	_update: function () {
  		if (!this._map) { return; }

  		var attribs = [];

  		for (var i in this._attributions) {
  			if (this._attributions[i]) {
  				attribs.push(i);
  			}
  		}

  		var prefixAndAttribs = [];

  		if (this.options.prefix) {
  			prefixAndAttribs.push(this.options.prefix);
  		}
  		if (attribs.length) {
  			prefixAndAttribs.push(attribs.join(', '));
  		}

  		this._container.innerHTML = prefixAndAttribs.join(' | ');
  	}
  });

  // @namespace Map
  // @section Control options
  // @option attributionControl: Boolean = true
  // Whether a [attribution control](#control-attribution) is added to the map by default.
  Map.mergeOptions({
  	attributionControl: true
  });

  Map.addInitHook(function () {
  	if (this.options.attributionControl) {
  		new Attribution().addTo(this);
  	}
  });

  // @namespace Control.Attribution
  // @factory L.control.attribution(options: Control.Attribution options)
  // Creates an attribution control.
  var attribution = function (options) {
  	return new Attribution(options);
  };

  Control.Layers = Layers;
  Control.Zoom = Zoom;
  Control.Scale = Scale;
  Control.Attribution = Attribution;

  control.layers = layers;
  control.zoom = zoom;
  control.scale = scale;
  control.attribution = attribution;

  /*
  	L.Handler is a base class for handler classes that are used internally to inject
  	interaction features like dragging to classes like Map and Marker.
  */

  // @class Handler
  // @aka L.Handler
  // Abstract class for map interaction handlers

  var Handler = Class.extend({
  	initialize: function (map) {
  		this._map = map;
  	},

  	// @method enable(): this
  	// Enables the handler
  	enable: function () {
  		if (this._enabled) { return this; }

  		this._enabled = true;
  		this.addHooks();
  		return this;
  	},

  	// @method disable(): this
  	// Disables the handler
  	disable: function () {
  		if (!this._enabled) { return this; }

  		this._enabled = false;
  		this.removeHooks();
  		return this;
  	},

  	// @method enabled(): Boolean
  	// Returns `true` if the handler is enabled
  	enabled: function () {
  		return !!this._enabled;
  	}

  	// @section Extension methods
  	// Classes inheriting from `Handler` must implement the two following methods:
  	// @method addHooks()
  	// Called when the handler is enabled, should add event hooks.
  	// @method removeHooks()
  	// Called when the handler is disabled, should remove the event hooks added previously.
  });

  // @section There is static function which can be called without instantiating L.Handler:
  // @function addTo(map: Map, name: String): this
  // Adds a new Handler to the given map with the given name.
  Handler.addTo = function (map, name) {
  	map.addHandler(name, this);
  	return this;
  };

  var Mixin = {Events: Events};

  /*
   * @class Draggable
   * @aka L.Draggable
   * @inherits Evented
   *
   * A class for making DOM elements draggable (including touch support).
   * Used internally for map and marker dragging. Only works for elements
   * that were positioned with [`L.DomUtil.setPosition`](#domutil-setposition).
   *
   * @example
   * ```js
   * var draggable = new L.Draggable(elementToDrag);
   * draggable.enable();
   * ```
   */

  var START = touch ? 'touchstart mousedown' : 'mousedown';
  var END = {
  	mousedown: 'mouseup',
  	touchstart: 'touchend',
  	pointerdown: 'touchend',
  	MSPointerDown: 'touchend'
  };
  var MOVE = {
  	mousedown: 'mousemove',
  	touchstart: 'touchmove',
  	pointerdown: 'touchmove',
  	MSPointerDown: 'touchmove'
  };


  var Draggable = Evented.extend({

  	options: {
  		// @section
  		// @aka Draggable options
  		// @option clickTolerance: Number = 3
  		// The max number of pixels a user can shift the mouse pointer during a click
  		// for it to be considered a valid click (as opposed to a mouse drag).
  		clickTolerance: 3
  	},

  	// @constructor L.Draggable(el: HTMLElement, dragHandle?: HTMLElement, preventOutline?: Boolean, options?: Draggable options)
  	// Creates a `Draggable` object for moving `el` when you start dragging the `dragHandle` element (equals `el` itself by default).
  	initialize: function (element, dragStartTarget, preventOutline$$1, options) {
  		setOptions(this, options);

  		this._element = element;
  		this._dragStartTarget = dragStartTarget || element;
  		this._preventOutline = preventOutline$$1;
  	},

  	// @method enable()
  	// Enables the dragging ability
  	enable: function () {
  		if (this._enabled) { return; }

  		on(this._dragStartTarget, START, this._onDown, this);

  		this._enabled = true;
  	},

  	// @method disable()
  	// Disables the dragging ability
  	disable: function () {
  		if (!this._enabled) { return; }

  		// If we're currently dragging this draggable,
  		// disabling it counts as first ending the drag.
  		if (Draggable._dragging === this) {
  			this.finishDrag();
  		}

  		off(this._dragStartTarget, START, this._onDown, this);

  		this._enabled = false;
  		this._moved = false;
  	},

  	_onDown: function (e) {
  		// Ignore simulated events, since we handle both touch and
  		// mouse explicitly; otherwise we risk getting duplicates of
  		// touch events, see #4315.
  		// Also ignore the event if disabled; this happens in IE11
  		// under some circumstances, see #3666.
  		if (e._simulated || !this._enabled) { return; }

  		this._moved = false;

  		if (hasClass(this._element, 'leaflet-zoom-anim')) { return; }

  		if (Draggable._dragging || e.shiftKey || ((e.which !== 1) && (e.button !== 1) && !e.touches)) { return; }
  		Draggable._dragging = this;  // Prevent dragging multiple objects at once.

  		if (this._preventOutline) {
  			preventOutline(this._element);
  		}

  		disableImageDrag();
  		disableTextSelection();

  		if (this._moving) { return; }

  		// @event down: Event
  		// Fired when a drag is about to start.
  		this.fire('down');

  		var first = e.touches ? e.touches[0] : e,
  		    sizedParent = getSizedParentNode(this._element);

  		this._startPoint = new Point(first.clientX, first.clientY);

  		// Cache the scale, so that we can continuously compensate for it during drag (_onMove).
  		this._parentScale = getScale(sizedParent);

  		on(document, MOVE[e.type], this._onMove, this);
  		on(document, END[e.type], this._onUp, this);
  	},

  	_onMove: function (e) {
  		// Ignore simulated events, since we handle both touch and
  		// mouse explicitly; otherwise we risk getting duplicates of
  		// touch events, see #4315.
  		// Also ignore the event if disabled; this happens in IE11
  		// under some circumstances, see #3666.
  		if (e._simulated || !this._enabled) { return; }

  		if (e.touches && e.touches.length > 1) {
  			this._moved = true;
  			return;
  		}

  		var first = (e.touches && e.touches.length === 1 ? e.touches[0] : e),
  		    offset = new Point(first.clientX, first.clientY)._subtract(this._startPoint);

  		if (!offset.x && !offset.y) { return; }
  		if (Math.abs(offset.x) + Math.abs(offset.y) < this.options.clickTolerance) { return; }

  		// We assume that the parent container's position, border and scale do not change for the duration of the drag.
  		// Therefore there is no need to account for the position and border (they are eliminated by the subtraction)
  		// and we can use the cached value for the scale.
  		offset.x /= this._parentScale.x;
  		offset.y /= this._parentScale.y;

  		preventDefault(e);

  		if (!this._moved) {
  			// @event dragstart: Event
  			// Fired when a drag starts
  			this.fire('dragstart');

  			this._moved = true;
  			this._startPos = getPosition(this._element).subtract(offset);

  			addClass(document.body, 'leaflet-dragging');

  			this._lastTarget = e.target || e.srcElement;
  			// IE and Edge do not give the <use> element, so fetch it
  			// if necessary
  			if (window.SVGElementInstance && this._lastTarget instanceof window.SVGElementInstance) {
  				this._lastTarget = this._lastTarget.correspondingUseElement;
  			}
  			addClass(this._lastTarget, 'leaflet-drag-target');
  		}

  		this._newPos = this._startPos.add(offset);
  		this._moving = true;

  		cancelAnimFrame(this._animRequest);
  		this._lastEvent = e;
  		this._animRequest = requestAnimFrame(this._updatePosition, this, true);
  	},

  	_updatePosition: function () {
  		var e = {originalEvent: this._lastEvent};

  		// @event predrag: Event
  		// Fired continuously during dragging *before* each corresponding
  		// update of the element's position.
  		this.fire('predrag', e);
  		setPosition(this._element, this._newPos);

  		// @event drag: Event
  		// Fired continuously during dragging.
  		this.fire('drag', e);
  	},

  	_onUp: function (e) {
  		// Ignore simulated events, since we handle both touch and
  		// mouse explicitly; otherwise we risk getting duplicates of
  		// touch events, see #4315.
  		// Also ignore the event if disabled; this happens in IE11
  		// under some circumstances, see #3666.
  		if (e._simulated || !this._enabled) { return; }
  		this.finishDrag();
  	},

  	finishDrag: function () {
  		removeClass(document.body, 'leaflet-dragging');

  		if (this._lastTarget) {
  			removeClass(this._lastTarget, 'leaflet-drag-target');
  			this._lastTarget = null;
  		}

  		for (var i in MOVE) {
  			off(document, MOVE[i], this._onMove, this);
  			off(document, END[i], this._onUp, this);
  		}

  		enableImageDrag();
  		enableTextSelection();

  		if (this._moved && this._moving) {
  			// ensure drag is not fired after dragend
  			cancelAnimFrame(this._animRequest);

  			// @event dragend: DragEndEvent
  			// Fired when the drag ends.
  			this.fire('dragend', {
  				distance: this._newPos.distanceTo(this._startPos)
  			});
  		}

  		this._moving = false;
  		Draggable._dragging = false;
  	}

  });

  /*
   * @namespace LineUtil
   *
   * Various utility functions for polyline points processing, used by Leaflet internally to make polylines lightning-fast.
   */

  // Simplify polyline with vertex reduction and Douglas-Peucker simplification.
  // Improves rendering performance dramatically by lessening the number of points to draw.

  // @function simplify(points: Point[], tolerance: Number): Point[]
  // Dramatically reduces the number of points in a polyline while retaining
  // its shape and returns a new array of simplified points, using the
  // [Douglas-Peucker algorithm](http://en.wikipedia.org/wiki/Douglas-Peucker_algorithm).
  // Used for a huge performance boost when processing/displaying Leaflet polylines for
  // each zoom level and also reducing visual noise. tolerance affects the amount of
  // simplification (lesser value means higher quality but slower and with more points).
  // Also released as a separated micro-library [Simplify.js](http://mourner.github.com/simplify-js/).
  function simplify(points, tolerance) {
  	if (!tolerance || !points.length) {
  		return points.slice();
  	}

  	var sqTolerance = tolerance * tolerance;

  	    // stage 1: vertex reduction
  	    points = _reducePoints(points, sqTolerance);

  	    // stage 2: Douglas-Peucker simplification
  	    points = _simplifyDP(points, sqTolerance);

  	return points;
  }

  // @function pointToSegmentDistance(p: Point, p1: Point, p2: Point): Number
  // Returns the distance between point `p` and segment `p1` to `p2`.
  function pointToSegmentDistance(p, p1, p2) {
  	return Math.sqrt(_sqClosestPointOnSegment(p, p1, p2, true));
  }

  // @function closestPointOnSegment(p: Point, p1: Point, p2: Point): Number
  // Returns the closest point from a point `p` on a segment `p1` to `p2`.
  function closestPointOnSegment(p, p1, p2) {
  	return _sqClosestPointOnSegment(p, p1, p2);
  }

  // Douglas-Peucker simplification, see http://en.wikipedia.org/wiki/Douglas-Peucker_algorithm
  function _simplifyDP(points, sqTolerance) {

  	var len = points.length,
  	    ArrayConstructor = typeof Uint8Array !== undefined + '' ? Uint8Array : Array,
  	    markers = new ArrayConstructor(len);

  	    markers[0] = markers[len - 1] = 1;

  	_simplifyDPStep(points, markers, sqTolerance, 0, len - 1);

  	var i,
  	    newPoints = [];

  	for (i = 0; i < len; i++) {
  		if (markers[i]) {
  			newPoints.push(points[i]);
  		}
  	}

  	return newPoints;
  }

  function _simplifyDPStep(points, markers, sqTolerance, first, last) {

  	var maxSqDist = 0,
  	index, i, sqDist;

  	for (i = first + 1; i <= last - 1; i++) {
  		sqDist = _sqClosestPointOnSegment(points[i], points[first], points[last], true);

  		if (sqDist > maxSqDist) {
  			index = i;
  			maxSqDist = sqDist;
  		}
  	}

  	if (maxSqDist > sqTolerance) {
  		markers[index] = 1;

  		_simplifyDPStep(points, markers, sqTolerance, first, index);
  		_simplifyDPStep(points, markers, sqTolerance, index, last);
  	}
  }

  // reduce points that are too close to each other to a single point
  function _reducePoints(points, sqTolerance) {
  	var reducedPoints = [points[0]];

  	for (var i = 1, prev = 0, len = points.length; i < len; i++) {
  		if (_sqDist(points[i], points[prev]) > sqTolerance) {
  			reducedPoints.push(points[i]);
  			prev = i;
  		}
  	}
  	if (prev < len - 1) {
  		reducedPoints.push(points[len - 1]);
  	}
  	return reducedPoints;
  }

  var _lastCode;

  // @function clipSegment(a: Point, b: Point, bounds: Bounds, useLastCode?: Boolean, round?: Boolean): Point[]|Boolean
  // Clips the segment a to b by rectangular bounds with the
  // [Cohen-Sutherland algorithm](https://en.wikipedia.org/wiki/Cohen%E2%80%93Sutherland_algorithm)
  // (modifying the segment points directly!). Used by Leaflet to only show polyline
  // points that are on the screen or near, increasing performance.
  function clipSegment(a, b, bounds, useLastCode, round) {
  	var codeA = useLastCode ? _lastCode : _getBitCode(a, bounds),
  	    codeB = _getBitCode(b, bounds),

  	    codeOut, p, newCode;

  	    // save 2nd code to avoid calculating it on the next segment
  	    _lastCode = codeB;

  	while (true) {
  		// if a,b is inside the clip window (trivial accept)
  		if (!(codeA | codeB)) {
  			return [a, b];
  		}

  		// if a,b is outside the clip window (trivial reject)
  		if (codeA & codeB) {
  			return false;
  		}

  		// other cases
  		codeOut = codeA || codeB;
  		p = _getEdgeIntersection(a, b, codeOut, bounds, round);
  		newCode = _getBitCode(p, bounds);

  		if (codeOut === codeA) {
  			a = p;
  			codeA = newCode;
  		} else {
  			b = p;
  			codeB = newCode;
  		}
  	}
  }

  function _getEdgeIntersection(a, b, code, bounds, round) {
  	var dx = b.x - a.x,
  	    dy = b.y - a.y,
  	    min = bounds.min,
  	    max = bounds.max,
  	    x, y;

  	if (code & 8) { // top
  		x = a.x + dx * (max.y - a.y) / dy;
  		y = max.y;

  	} else if (code & 4) { // bottom
  		x = a.x + dx * (min.y - a.y) / dy;
  		y = min.y;

  	} else if (code & 2) { // right
  		x = max.x;
  		y = a.y + dy * (max.x - a.x) / dx;

  	} else if (code & 1) { // left
  		x = min.x;
  		y = a.y + dy * (min.x - a.x) / dx;
  	}

  	return new Point(x, y, round);
  }

  function _getBitCode(p, bounds) {
  	var code = 0;

  	if (p.x < bounds.min.x) { // left
  		code |= 1;
  	} else if (p.x > bounds.max.x) { // right
  		code |= 2;
  	}

  	if (p.y < bounds.min.y) { // bottom
  		code |= 4;
  	} else if (p.y > bounds.max.y) { // top
  		code |= 8;
  	}

  	return code;
  }

  // square distance (to avoid unnecessary Math.sqrt calls)
  function _sqDist(p1, p2) {
  	var dx = p2.x - p1.x,
  	    dy = p2.y - p1.y;
  	return dx * dx + dy * dy;
  }

  // return closest point on segment or distance to that point
  function _sqClosestPointOnSegment(p, p1, p2, sqDist) {
  	var x = p1.x,
  	    y = p1.y,
  	    dx = p2.x - x,
  	    dy = p2.y - y,
  	    dot = dx * dx + dy * dy,
  	    t;

  	if (dot > 0) {
  		t = ((p.x - x) * dx + (p.y - y) * dy) / dot;

  		if (t > 1) {
  			x = p2.x;
  			y = p2.y;
  		} else if (t > 0) {
  			x += dx * t;
  			y += dy * t;
  		}
  	}

  	dx = p.x - x;
  	dy = p.y - y;

  	return sqDist ? dx * dx + dy * dy : new Point(x, y);
  }


  // @function isFlat(latlngs: LatLng[]): Boolean
  // Returns true if `latlngs` is a flat array, false is nested.
  function isFlat(latlngs) {
  	return !isArray(latlngs[0]) || (typeof latlngs[0][0] !== 'object' && typeof latlngs[0][0] !== 'undefined');
  }

  function _flat(latlngs) {
  	console.warn('Deprecated use of _flat, please use L.LineUtil.isFlat instead.');
  	return isFlat(latlngs);
  }

  var LineUtil = ({
    simplify: simplify,
    pointToSegmentDistance: pointToSegmentDistance,
    closestPointOnSegment: closestPointOnSegment,
    clipSegment: clipSegment,
    _getEdgeIntersection: _getEdgeIntersection,
    _getBitCode: _getBitCode,
    _sqClosestPointOnSegment: _sqClosestPointOnSegment,
    isFlat: isFlat,
    _flat: _flat
  });

  /*
   * @namespace PolyUtil
   * Various utility functions for polygon geometries.
   */

  /* @function clipPolygon(points: Point[], bounds: Bounds, round?: Boolean): Point[]
   * Clips the polygon geometry defined by the given `points` by the given bounds (using the [Sutherland-Hodgman algorithm](https://en.wikipedia.org/wiki/Sutherland%E2%80%93Hodgman_algorithm)).
   * Used by Leaflet to only show polygon points that are on the screen or near, increasing
   * performance. Note that polygon points needs different algorithm for clipping
   * than polyline, so there's a separate method for it.
   */
  function clipPolygon(points, bounds, round) {
  	var clippedPoints,
  	    edges = [1, 4, 2, 8],
  	    i, j, k,
  	    a, b,
  	    len, edge, p;

  	for (i = 0, len = points.length; i < len; i++) {
  		points[i]._code = _getBitCode(points[i], bounds);
  	}

  	// for each edge (left, bottom, right, top)
  	for (k = 0; k < 4; k++) {
  		edge = edges[k];
  		clippedPoints = [];

  		for (i = 0, len = points.length, j = len - 1; i < len; j = i++) {
  			a = points[i];
  			b = points[j];

  			// if a is inside the clip window
  			if (!(a._code & edge)) {
  				// if b is outside the clip window (a->b goes out of screen)
  				if (b._code & edge) {
  					p = _getEdgeIntersection(b, a, edge, bounds, round);
  					p._code = _getBitCode(p, bounds);
  					clippedPoints.push(p);
  				}
  				clippedPoints.push(a);

  			// else if b is inside the clip window (a->b enters the screen)
  			} else if (!(b._code & edge)) {
  				p = _getEdgeIntersection(b, a, edge, bounds, round);
  				p._code = _getBitCode(p, bounds);
  				clippedPoints.push(p);
  			}
  		}
  		points = clippedPoints;
  	}

  	return points;
  }

  var PolyUtil = ({
    clipPolygon: clipPolygon
  });

  /*
   * @namespace Projection
   * @section
   * Leaflet comes with a set of already defined Projections out of the box:
   *
   * @projection L.Projection.LonLat
   *
   * Equirectangular, or Plate Carree projection  the most simple projection,
   * mostly used by GIS enthusiasts. Directly maps `x` as longitude, and `y` as
   * latitude. Also suitable for flat worlds, e.g. game maps. Used by the
   * `EPSG:4326` and `Simple` CRS.
   */

  var LonLat = {
  	project: function (latlng) {
  		return new Point(latlng.lng, latlng.lat);
  	},

  	unproject: function (point) {
  		return new LatLng(point.y, point.x);
  	},

  	bounds: new Bounds([-180, -90], [180, 90])
  };

  /*
   * @namespace Projection
   * @projection L.Projection.Mercator
   *
   * Elliptical Mercator projection  more complex than Spherical Mercator. Assumes that Earth is an ellipsoid. Used by the EPSG:3395 CRS.
   */

  var Mercator = {
  	R: 6378137,
  	R_MINOR: 6356752.314245179,

  	bounds: new Bounds([-20037508.34279, -15496570.73972], [20037508.34279, 18764656.23138]),

  	project: function (latlng) {
  		var d = Math.PI / 180,
  		    r = this.R,
  		    y = latlng.lat * d,
  		    tmp = this.R_MINOR / r,
  		    e = Math.sqrt(1 - tmp * tmp),
  		    con = e * Math.sin(y);

  		var ts = Math.tan(Math.PI / 4 - y / 2) / Math.pow((1 - con) / (1 + con), e / 2);
  		y = -r * Math.log(Math.max(ts, 1E-10));

  		return new Point(latlng.lng * d * r, y);
  	},

  	unproject: function (point) {
  		var d = 180 / Math.PI,
  		    r = this.R,
  		    tmp = this.R_MINOR / r,
  		    e = Math.sqrt(1 - tmp * tmp),
  		    ts = Math.exp(-point.y / r),
  		    phi = Math.PI / 2 - 2 * Math.atan(ts);

  		for (var i = 0, dphi = 0.1, con; i < 15 && Math.abs(dphi) > 1e-7; i++) {
  			con = e * Math.sin(phi);
  			con = Math.pow((1 - con) / (1 + con), e / 2);
  			dphi = Math.PI / 2 - 2 * Math.atan(ts * con) - phi;
  			phi += dphi;
  		}

  		return new LatLng(phi * d, point.x * d / r);
  	}
  };

  /*
   * @class Projection

   * An object with methods for projecting geographical coordinates of the world onto
   * a flat surface (and back). See [Map projection](http://en.wikipedia.org/wiki/Map_projection).

   * @property bounds: Bounds
   * The bounds (specified in CRS units) where the projection is valid

   * @method project(latlng: LatLng): Point
   * Projects geographical coordinates into a 2D point.
   * Only accepts actual `L.LatLng` instances, not arrays.

   * @method unproject(point: Point): LatLng
   * The inverse of `project`. Projects a 2D point into a geographical location.
   * Only accepts actual `L.Point` instances, not arrays.

   * Note that the projection instances do not inherit from Leaflet's `Class` object,
   * and can't be instantiated. Also, new classes can't inherit from them,
   * and methods can't be added to them with the `include` function.

   */

  var index = ({
    LonLat: LonLat,
    Mercator: Mercator,
    SphericalMercator: SphericalMercator
  });

  /*
   * @namespace CRS
   * @crs L.CRS.EPSG3395
   *
   * Rarely used by some commercial tile providers. Uses Elliptical Mercator projection.
   */
  var EPSG3395 = extend({}, Earth, {
  	code: 'EPSG:3395',
  	projection: Mercator,

  	transformation: (function () {
  		var scale = 0.5 / (Math.PI * Mercator.R);
  		return toTransformation(scale, 0.5, -scale, 0.5);
  	}())
  });

  /*
   * @namespace CRS
   * @crs L.CRS.EPSG4326
   *
   * A common CRS among GIS enthusiasts. Uses simple Equirectangular projection.
   *
   * Leaflet 1.0.x complies with the [TMS coordinate scheme for EPSG:4326](https://wiki.osgeo.org/wiki/Tile_Map_Service_Specification#global-geodetic),
   * which is a breaking change from 0.7.x behaviour.  If you are using a `TileLayer`
   * with this CRS, ensure that there are two 256x256 pixel tiles covering the
   * whole earth at zoom level zero, and that the tile coordinate origin is (-180,+90),
   * or (-180,-90) for `TileLayer`s with [the `tms` option](#tilelayer-tms) set.
   */

  var EPSG4326 = extend({}, Earth, {
  	code: 'EPSG:4326',
  	projection: LonLat,
  	transformation: toTransformation(1 / 180, 1, -1 / 180, 0.5)
  });

  /*
   * @namespace CRS
   * @crs L.CRS.Simple
   *
   * A simple CRS that maps longitude and latitude into `x` and `y` directly.
   * May be used for maps of flat surfaces (e.g. game maps). Note that the `y`
   * axis should still be inverted (going from bottom to top). `distance()` returns
   * simple euclidean distance.
   */

  var Simple = extend({}, CRS, {
  	projection: LonLat,
  	transformation: toTransformation(1, 0, -1, 0),

  	scale: function (zoom) {
  		return Math.pow(2, zoom);
  	},

  	zoom: function (scale) {
  		return Math.log(scale) / Math.LN2;
  	},

  	distance: function (latlng1, latlng2) {
  		var dx = latlng2.lng - latlng1.lng,
  		    dy = latlng2.lat - latlng1.lat;

  		return Math.sqrt(dx * dx + dy * dy);
  	},

  	infinite: true
  });

  CRS.Earth = Earth;
  CRS.EPSG3395 = EPSG3395;
  CRS.EPSG3857 = EPSG3857;
  CRS.EPSG900913 = EPSG900913;
  CRS.EPSG4326 = EPSG4326;
  CRS.Simple = Simple;

  /*
   * @class Layer
   * @inherits Evented
   * @aka L.Layer
   * @aka ILayer
   *
   * A set of methods from the Layer base class that all Leaflet layers use.
   * Inherits all methods, options and events from `L.Evented`.
   *
   * @example
   *
   * ```js
   * var layer = L.marker(latlng).addTo(map);
   * layer.addTo(map);
   * layer.remove();
   * ```
   *
   * @event add: Event
   * Fired after the layer is added to a map
   *
   * @event remove: Event
   * Fired after the layer is removed from a map
   */


  var Layer = Evented.extend({

  	// Classes extending `L.Layer` will inherit the following options:
  	options: {
  		// @option pane: String = 'overlayPane'
  		// By default the layer will be added to the map's [overlay pane](#map-overlaypane). Overriding this option will cause the layer to be placed on another pane by default.
  		pane: 'overlayPane',

  		// @option attribution: String = null
  		// String to be shown in the attribution control, e.g. " OpenStreetMap contributors". It describes the layer data and is often a legal obligation towards copyright holders and tile providers.
  		attribution: null,

  		bubblingMouseEvents: true
  	},

  	/* @section
  	 * Classes extending `L.Layer` will inherit the following methods:
  	 *
  	 * @method addTo(map: Map|LayerGroup): this
  	 * Adds the layer to the given map or layer group.
  	 */
  	addTo: function (map) {
  		map.addLayer(this);
  		return this;
  	},

  	// @method remove: this
  	// Removes the layer from the map it is currently active on.
  	remove: function () {
  		return this.removeFrom(this._map || this._mapToAdd);
  	},

  	// @method removeFrom(map: Map): this
  	// Removes the layer from the given map
  	//
  	// @alternative
  	// @method removeFrom(group: LayerGroup): this
  	// Removes the layer from the given `LayerGroup`
  	removeFrom: function (obj) {
  		if (obj) {
  			obj.removeLayer(this);
  		}
  		return this;
  	},

  	// @method getPane(name? : String): HTMLElement
  	// Returns the `HTMLElement` representing the named pane on the map. If `name` is omitted, returns the pane for this layer.
  	getPane: function (name) {
  		return this._map.getPane(name ? (this.options[name] || name) : this.options.pane);
  	},

  	addInteractiveTarget: function (targetEl) {
  		this._map._targets[stamp(targetEl)] = this;
  		return this;
  	},

  	removeInteractiveTarget: function (targetEl) {
  		delete this._map._targets[stamp(targetEl)];
  		return this;
  	},

  	// @method getAttribution: String
  	// Used by the `attribution control`, returns the [attribution option](#gridlayer-attribution).
  	getAttribution: function () {
  		return this.options.attribution;
  	},

  	_layerAdd: function (e) {
  		var map = e.target;

  		// check in case layer gets added and then removed before the map is ready
  		if (!map.hasLayer(this)) { return; }

  		this._map = map;
  		this._zoomAnimated = map._zoomAnimated;

  		if (this.getEvents) {
  			var events = this.getEvents();
  			map.on(events, this);
  			this.once('remove', function () {
  				map.off(events, this);
  			}, this);
  		}

  		this.onAdd(map);

  		if (this.getAttribution && map.attributionControl) {
  			map.attributionControl.addAttribution(this.getAttribution());
  		}

  		this.fire('add');
  		map.fire('layeradd', {layer: this});
  	}
  });

  /* @section Extension methods
   * @uninheritable
   *
   * Every layer should extend from `L.Layer` and (re-)implement the following methods.
   *
   * @method onAdd(map: Map): this
   * Should contain code that creates DOM elements for the layer, adds them to `map panes` where they should belong and puts listeners on relevant map events. Called on [`map.addLayer(layer)`](#map-addlayer).
   *
   * @method onRemove(map: Map): this
   * Should contain all clean up code that removes the layer's elements from the DOM and removes listeners previously added in [`onAdd`](#layer-onadd). Called on [`map.removeLayer(layer)`](#map-removelayer).
   *
   * @method getEvents(): Object
   * This optional method should return an object like `{ viewreset: this._reset }` for [`addEventListener`](#evented-addeventlistener). The event handlers in this object will be automatically added and removed from the map with your layer.
   *
   * @method getAttribution(): String
   * This optional method should return a string containing HTML to be shown on the `Attribution control` whenever the layer is visible.
   *
   * @method beforeAdd(map: Map): this
   * Optional method. Called on [`map.addLayer(layer)`](#map-addlayer), before the layer is added to the map, before events are initialized, without waiting until the map is in a usable state. Use for early initialization only.
   */


  /* @namespace Map
   * @section Layer events
   *
   * @event layeradd: LayerEvent
   * Fired when a new layer is added to the map.
   *
   * @event layerremove: LayerEvent
   * Fired when some layer is removed from the map
   *
   * @section Methods for Layers and Controls
   */
  Map.include({
  	// @method addLayer(layer: Layer): this
  	// Adds the given layer to the map
  	addLayer: function (layer) {
  		if (!layer._layerAdd) {
  			throw new Error('The provided object is not a Layer.');
  		}

  		var id = stamp(layer);
  		if (this._layers[id]) { return this; }
  		this._layers[id] = layer;

  		layer._mapToAdd = this;

  		if (layer.beforeAdd) {
  			layer.beforeAdd(this);
  		}

  		this.whenReady(layer._layerAdd, layer);

  		return this;
  	},

  	// @method removeLayer(layer: Layer): this
  	// Removes the given layer from the map.
  	removeLayer: function (layer) {
  		var id = stamp(layer);

  		if (!this._layers[id]) { return this; }

  		if (this._loaded) {
  			layer.onRemove(this);
  		}

  		if (layer.getAttribution && this.attributionControl) {
  			this.attributionControl.removeAttribution(layer.getAttribution());
  		}

  		delete this._layers[id];

  		if (this._loaded) {
  			this.fire('layerremove', {layer: layer});
  			layer.fire('remove');
  		}

  		layer._map = layer._mapToAdd = null;

  		return this;
  	},

  	// @method hasLayer(layer: Layer): Boolean
  	// Returns `true` if the given layer is currently added to the map
  	hasLayer: function (layer) {
  		return !!layer && (stamp(layer) in this._layers);
  	},

  	/* @method eachLayer(fn: Function, context?: Object): this
  	 * Iterates over the layers of the map, optionally specifying context of the iterator function.
  	 * ```
  	 * map.eachLayer(function(layer){
  	 *     layer.bindPopup('Hello');
  	 * });
  	 * ```
  	 */
  	eachLayer: function (method, context) {
  		for (var i in this._layers) {
  			method.call(context, this._layers[i]);
  		}
  		return this;
  	},

  	_addLayers: function (layers) {
  		layers = layers ? (isArray(layers) ? layers : [layers]) : [];

  		for (var i = 0, len = layers.length; i < len; i++) {
  			this.addLayer(layers[i]);
  		}
  	},

  	_addZoomLimit: function (layer) {
  		if (isNaN(layer.options.maxZoom) || !isNaN(layer.options.minZoom)) {
  			this._zoomBoundLayers[stamp(layer)] = layer;
  			this._updateZoomLevels();
  		}
  	},

  	_removeZoomLimit: function (layer) {
  		var id = stamp(layer);

  		if (this._zoomBoundLayers[id]) {
  			delete this._zoomBoundLayers[id];
  			this._updateZoomLevels();
  		}
  	},

  	_updateZoomLevels: function () {
  		var minZoom = Infinity,
  		    maxZoom = -Infinity,
  		    oldZoomSpan = this._getZoomSpan();

  		for (var i in this._zoomBoundLayers) {
  			var options = this._zoomBoundLayers[i].options;

  			minZoom = options.minZoom === undefined ? minZoom : Math.min(minZoom, options.minZoom);
  			maxZoom = options.maxZoom === undefined ? maxZoom : Math.max(maxZoom, options.maxZoom);
  		}

  		this._layersMaxZoom = maxZoom === -Infinity ? undefined : maxZoom;
  		this._layersMinZoom = minZoom === Infinity ? undefined : minZoom;

  		// @section Map state change events
  		// @event zoomlevelschange: Event
  		// Fired when the number of zoomlevels on the map is changed due
  		// to adding or removing a layer.
  		if (oldZoomSpan !== this._getZoomSpan()) {
  			this.fire('zoomlevelschange');
  		}

  		if (this.options.maxZoom === undefined && this._layersMaxZoom && this.getZoom() > this._layersMaxZoom) {
  			this.setZoom(this._layersMaxZoom);
  		}
  		if (this.options.minZoom === undefined && this._layersMinZoom && this.getZoom() < this._layersMinZoom) {
  			this.setZoom(this._layersMinZoom);
  		}
  	}
  });

  /*
   * @class LayerGroup
   * @aka L.LayerGroup
   * @inherits Layer
   *
   * Used to group several layers and handle them as one. If you add it to the map,
   * any layers added or removed from the group will be added/removed on the map as
   * well. Extends `Layer`.
   *
   * @example
   *
   * ```js
   * L.layerGroup([marker1, marker2])
   * 	.addLayer(polyline)
   * 	.addTo(map);
   * ```
   */

  var LayerGroup = Layer.extend({

  	initialize: function (layers, options) {
  		setOptions(this, options);

  		this._layers = {};

  		var i, len;

  		if (layers) {
  			for (i = 0, len = layers.length; i < len; i++) {
  				this.addLayer(layers[i]);
  			}
  		}
  	},

  	// @method addLayer(layer: Layer): this
  	// Adds the given layer to the group.
  	addLayer: function (layer) {
  		var id = this.getLayerId(layer);

  		this._layers[id] = layer;

  		if (this._map) {
  			this._map.addLayer(layer);
  		}

  		return this;
  	},

  	// @method removeLayer(layer: Layer): this
  	// Removes the given layer from the group.
  	// @alternative
  	// @method removeLayer(id: Number): this
  	// Removes the layer with the given internal ID from the group.
  	removeLayer: function (layer) {
  		var id = layer in this._layers ? layer : this.getLayerId(layer);

  		if (this._map && this._layers[id]) {
  			this._map.removeLayer(this._layers[id]);
  		}

  		delete this._layers[id];

  		return this;
  	},

  	// @method hasLayer(layer: Layer): Boolean
  	// Returns `true` if the given layer is currently added to the group.
  	// @alternative
  	// @method hasLayer(id: Number): Boolean
  	// Returns `true` if the given internal ID is currently added to the group.
  	hasLayer: function (layer) {
  		if (!layer) { return false; }
  		var layerId = typeof layer === 'number' ? layer : this.getLayerId(layer);
  		return layerId in this._layers;
  	},

  	// @method clearLayers(): this
  	// Removes all the layers from the group.
  	clearLayers: function () {
  		return this.eachLayer(this.removeLayer, this);
  	},

  	// @method invoke(methodName: String, ): this
  	// Calls `methodName` on every layer contained in this group, passing any
  	// additional parameters. Has no effect if the layers contained do not
  	// implement `methodName`.
  	invoke: function (methodName) {
  		var args = Array.prototype.slice.call(arguments, 1),
  		    i, layer;

  		for (i in this._layers) {
  			layer = this._layers[i];

  			if (layer[methodName]) {
  				layer[methodName].apply(layer, args);
  			}
  		}

  		return this;
  	},

  	onAdd: function (map) {
  		this.eachLayer(map.addLayer, map);
  	},

  	onRemove: function (map) {
  		this.eachLayer(map.removeLayer, map);
  	},

  	// @method eachLayer(fn: Function, context?: Object): this
  	// Iterates over the layers of the group, optionally specifying context of the iterator function.
  	// ```js
  	// group.eachLayer(function (layer) {
  	// 	layer.bindPopup('Hello');
  	// });
  	// ```
  	eachLayer: function (method, context) {
  		for (var i in this._layers) {
  			method.call(context, this._layers[i]);
  		}
  		return this;
  	},

  	// @method getLayer(id: Number): Layer
  	// Returns the layer with the given internal ID.
  	getLayer: function (id) {
  		return this._layers[id];
  	},

  	// @method getLayers(): Layer[]
  	// Returns an array of all the layers added to the group.
  	getLayers: function () {
  		var layers = [];
  		this.eachLayer(layers.push, layers);
  		return layers;
  	},

  	// @method setZIndex(zIndex: Number): this
  	// Calls `setZIndex` on every layer contained in this group, passing the z-index.
  	setZIndex: function (zIndex) {
  		return this.invoke('setZIndex', zIndex);
  	},

  	// @method getLayerId(layer: Layer): Number
  	// Returns the internal ID for a layer
  	getLayerId: function (layer) {
  		return stamp(layer);
  	}
  });


  // @factory L.layerGroup(layers?: Layer[], options?: Object)
  // Create a layer group, optionally given an initial set of layers and an `options` object.
  var layerGroup = function (layers, options) {
  	return new LayerGroup(layers, options);
  };

  /*
   * @class FeatureGroup
   * @aka L.FeatureGroup
   * @inherits LayerGroup
   *
   * Extended `LayerGroup` that makes it easier to do the same thing to all its member layers:
   *  * [`bindPopup`](#layer-bindpopup) binds a popup to all of the layers at once (likewise with [`bindTooltip`](#layer-bindtooltip))
   *  * Events are propagated to the `FeatureGroup`, so if the group has an event
   * handler, it will handle events from any of the layers. This includes mouse events
   * and custom events.
   *  * Has `layeradd` and `layerremove` events
   *
   * @example
   *
   * ```js
   * L.featureGroup([marker1, marker2, polyline])
   * 	.bindPopup('Hello world!')
   * 	.on('click', function() { alert('Clicked on a member of the group!'); })
   * 	.addTo(map);
   * ```
   */

  var FeatureGroup = LayerGroup.extend({

  	addLayer: function (layer) {
  		if (this.hasLayer(layer)) {
  			return this;
  		}

  		layer.addEventParent(this);

  		LayerGroup.prototype.addLayer.call(this, layer);

  		// @event layeradd: LayerEvent
  		// Fired when a layer is added to this `FeatureGroup`
  		return this.fire('layeradd', {layer: layer});
  	},

  	removeLayer: function (layer) {
  		if (!this.hasLayer(layer)) {
  			return this;
  		}
  		if (layer in this._layers) {
  			layer = this._layers[layer];
  		}

  		layer.removeEventParent(this);

  		LayerGroup.prototype.removeLayer.call(this, layer);

  		// @event layerremove: LayerEvent
  		// Fired when a layer is removed from this `FeatureGroup`
  		return this.fire('layerremove', {layer: layer});
  	},

  	// @method setStyle(style: Path options): this
  	// Sets the given path options to each layer of the group that has a `setStyle` method.
  	setStyle: function (style) {
  		return this.invoke('setStyle', style);
  	},

  	// @method bringToFront(): this
  	// Brings the layer group to the top of all other layers
  	bringToFront: function () {
  		return this.invoke('bringToFront');
  	},

  	// @method bringToBack(): this
  	// Brings the layer group to the back of all other layers
  	bringToBack: function () {
  		return this.invoke('bringToBack');
  	},

  	// @method getBounds(): LatLngBounds
  	// Returns the LatLngBounds of the Feature Group (created from bounds and coordinates of its children).
  	getBounds: function () {
  		var bounds = new LatLngBounds();

  		for (var id in this._layers) {
  			var layer = this._layers[id];
  			bounds.extend(layer.getBounds ? layer.getBounds() : layer.getLatLng());
  		}
  		return bounds;
  	}
  });

  // @factory L.featureGroup(layers?: Layer[], options?: Object)
  // Create a feature group, optionally given an initial set of layers and an `options` object.
  var featureGroup = function (layers, options) {
  	return new FeatureGroup(layers, options);
  };

  /*
   * @class Icon
   * @aka L.Icon
   *
   * Represents an icon to provide when creating a marker.
   *
   * @example
   *
   * ```js
   * var myIcon = L.icon({
   *     iconUrl: 'my-icon.png',
   *     iconRetinaUrl: 'my-icon@2x.png',
   *     iconSize: [38, 95],
   *     iconAnchor: [22, 94],
   *     popupAnchor: [-3, -76],
   *     shadowUrl: 'my-icon-shadow.png',
   *     shadowRetinaUrl: 'my-icon-shadow@2x.png',
   *     shadowSize: [68, 95],
   *     shadowAnchor: [22, 94]
   * });
   *
   * L.marker([50.505, 30.57], {icon: myIcon}).addTo(map);
   * ```
   *
   * `L.Icon.Default` extends `L.Icon` and is the blue icon Leaflet uses for markers by default.
   *
   */

  var Icon = Class.extend({

  	/* @section
  	 * @aka Icon options
  	 *
  	 * @option iconUrl: String = null
  	 * **(required)** The URL to the icon image (absolute or relative to your script path).
  	 *
  	 * @option iconRetinaUrl: String = null
  	 * The URL to a retina sized version of the icon image (absolute or relative to your
  	 * script path). Used for Retina screen devices.
  	 *
  	 * @option iconSize: Point = null
  	 * Size of the icon image in pixels.
  	 *
  	 * @option iconAnchor: Point = null
  	 * The coordinates of the "tip" of the icon (relative to its top left corner). The icon
  	 * will be aligned so that this point is at the marker's geographical location. Centered
  	 * by default if size is specified, also can be set in CSS with negative margins.
  	 *
  	 * @option popupAnchor: Point = [0, 0]
  	 * The coordinates of the point from which popups will "open", relative to the icon anchor.
  	 *
  	 * @option tooltipAnchor: Point = [0, 0]
  	 * The coordinates of the point from which tooltips will "open", relative to the icon anchor.
  	 *
  	 * @option shadowUrl: String = null
  	 * The URL to the icon shadow image. If not specified, no shadow image will be created.
  	 *
  	 * @option shadowRetinaUrl: String = null
  	 *
  	 * @option shadowSize: Point = null
  	 * Size of the shadow image in pixels.
  	 *
  	 * @option shadowAnchor: Point = null
  	 * The coordinates of the "tip" of the shadow (relative to its top left corner) (the same
  	 * as iconAnchor if not specified).
  	 *
  	 * @option className: String = ''
  	 * A custom class name to assign to both icon and shadow images. Empty by default.
  	 */

  	options: {
  		popupAnchor: [0, 0],
  		tooltipAnchor: [0, 0]
  	},

  	initialize: function (options) {
  		setOptions(this, options);
  	},

  	// @method createIcon(oldIcon?: HTMLElement): HTMLElement
  	// Called internally when the icon has to be shown, returns a `<img>` HTML element
  	// styled according to the options.
  	createIcon: function (oldIcon) {
  		return this._createIcon('icon', oldIcon);
  	},

  	// @method createShadow(oldIcon?: HTMLElement): HTMLElement
  	// As `createIcon`, but for the shadow beneath it.
  	createShadow: function (oldIcon) {
  		return this._createIcon('shadow', oldIcon);
  	},

  	_createIcon: function (name, oldIcon) {
  		var src = this._getIconUrl(name);

  		if (!src) {
  			if (name === 'icon') {
  				throw new Error('iconUrl not set in Icon options (see the docs).');
  			}
  			return null;
  		}

  		var img = this._createImg(src, oldIcon && oldIcon.tagName === 'IMG' ? oldIcon : null);
  		this._setIconStyles(img, name);

  		return img;
  	},

  	_setIconStyles: function (img, name) {
  		var options = this.options;
  		var sizeOption = options[name + 'Size'];

  		if (typeof sizeOption === 'number') {
  			sizeOption = [sizeOption, sizeOption];
  		}

  		var size = toPoint(sizeOption),
  		    anchor = toPoint(name === 'shadow' && options.shadowAnchor || options.iconAnchor ||
  		            size && size.divideBy(2, true));

  		img.className = 'leaflet-marker-' + name + ' ' + (options.className || '');

  		if (anchor) {
  			img.style.marginLeft = (-anchor.x) + 'px';
  			img.style.marginTop  = (-anchor.y) + 'px';
  		}

  		if (size) {
  			img.style.width  = size.x + 'px';
  			img.style.height = size.y + 'px';
  		}
  	},

  	_createImg: function (src, el) {
  		el = el || document.createElement('img');
  		el.src = src;
  		return el;
  	},

  	_getIconUrl: function (name) {
  		return retina && this.options[name + 'RetinaUrl'] || this.options[name + 'Url'];
  	}
  });


  // @factory L.icon(options: Icon options)
  // Creates an icon instance with the given options.
  function icon(options) {
  	return new Icon(options);
  }

  /*
   * @miniclass Icon.Default (Icon)
   * @aka L.Icon.Default
   * @section
   *
   * A trivial subclass of `Icon`, represents the icon to use in `Marker`s when
   * no icon is specified. Points to the blue marker image distributed with Leaflet
   * releases.
   *
   * In order to customize the default icon, just change the properties of `L.Icon.Default.prototype.options`
   * (which is a set of `Icon options`).
   *
   * If you want to _completely_ replace the default icon, override the
   * `L.Marker.prototype.options.icon` with your own icon instead.
   */

  var IconDefault = Icon.extend({

  	options: {
  		iconUrl:       'marker-icon.png',
  		iconRetinaUrl: 'marker-icon-2x.png',
  		shadowUrl:     'marker-shadow.png',
  		iconSize:    [25, 41],
  		iconAnchor:  [12, 41],
  		popupAnchor: [1, -34],
  		tooltipAnchor: [16, -28],
  		shadowSize:  [41, 41]
  	},

  	_getIconUrl: function (name) {
  		if (!IconDefault.imagePath) {	// Deprecated, backwards-compatibility only
  			IconDefault.imagePath = this._detectIconPath();
  		}

  		// @option imagePath: String
  		// `Icon.Default` will try to auto-detect the location of the
  		// blue icon images. If you are placing these images in a non-standard
  		// way, set this option to point to the right path.
  		return (this.options.imagePath || IconDefault.imagePath) + Icon.prototype._getIconUrl.call(this, name);
  	},

  	_detectIconPath: function () {
  		var el = create$1('div',  'leaflet-default-icon-path', document.body);
  		var path = getStyle(el, 'background-image') ||
  		           getStyle(el, 'backgroundImage');	// IE8

  		document.body.removeChild(el);

  		if (path === null || path.indexOf('url') !== 0) {
  			path = '';
  		} else {
  			path = path.replace(/^url\(["']?/, '').replace(/marker-icon\.png["']?\)$/, '');
  		}

  		return path;
  	}
  });

  /*
   * L.Handler.MarkerDrag is used internally by L.Marker to make the markers draggable.
   */


  /* @namespace Marker
   * @section Interaction handlers
   *
   * Interaction handlers are properties of a marker instance that allow you to control interaction behavior in runtime, enabling or disabling certain features such as dragging (see `Handler` methods). Example:
   *
   * ```js
   * marker.dragging.disable();
   * ```
   *
   * @property dragging: Handler
   * Marker dragging handler (by both mouse and touch). Only valid when the marker is on the map (Otherwise set [`marker.options.draggable`](#marker-draggable)).
   */

  var MarkerDrag = Handler.extend({
  	initialize: function (marker) {
  		this._marker = marker;
  	},

  	addHooks: function () {
  		var icon = this._marker._icon;

  		if (!this._draggable) {
  			this._draggable = new Draggable(icon, icon, true);
  		}

  		this._draggable.on({
  			dragstart: this._onDragStart,
  			predrag: this._onPreDrag,
  			drag: this._onDrag,
  			dragend: this._onDragEnd
  		}, this).enable();

  		addClass(icon, 'leaflet-marker-draggable');
  	},

  	removeHooks: function () {
  		this._draggable.off({
  			dragstart: this._onDragStart,
  			predrag: this._onPreDrag,
  			drag: this._onDrag,
  			dragend: this._onDragEnd
  		}, this).disable();

  		if (this._marker._icon) {
  			removeClass(this._marker._icon, 'leaflet-marker-draggable');
  		}
  	},

  	moved: function () {
  		return this._draggable && this._draggable._moved;
  	},

  	_adjustPan: function (e) {
  		var marker = this._marker,
  		    map = marker._map,
  		    speed = this._marker.options.autoPanSpeed,
  		    padding = this._marker.options.autoPanPadding,
  		    iconPos = getPosition(marker._icon),
  		    bounds = map.getPixelBounds(),
  		    origin = map.getPixelOrigin();

  		var panBounds = toBounds(
  			bounds.min._subtract(origin).add(padding),
  			bounds.max._subtract(origin).subtract(padding)
  		);

  		if (!panBounds.contains(iconPos)) {
  			// Compute incremental movement
  			var movement = toPoint(
  				(Math.max(panBounds.max.x, iconPos.x) - panBounds.max.x) / (bounds.max.x - panBounds.max.x) -
  				(Math.min(panBounds.min.x, iconPos.x) - panBounds.min.x) / (bounds.min.x - panBounds.min.x),

  				(Math.max(panBounds.max.y, iconPos.y) - panBounds.max.y) / (bounds.max.y - panBounds.max.y) -
  				(Math.min(panBounds.min.y, iconPos.y) - panBounds.min.y) / (bounds.min.y - panBounds.min.y)
  			).multiplyBy(speed);

  			map.panBy(movement, {animate: false});

  			this._draggable._newPos._add(movement);
  			this._draggable._startPos._add(movement);

  			setPosition(marker._icon, this._draggable._newPos);
  			this._onDrag(e);

  			this._panRequest = requestAnimFrame(this._adjustPan.bind(this, e));
  		}
  	},

  	_onDragStart: function () {
  		// @section Dragging events
  		// @event dragstart: Event
  		// Fired when the user starts dragging the marker.

  		// @event movestart: Event
  		// Fired when the marker starts moving (because of dragging).

  		this._oldLatLng = this._marker.getLatLng();

  		// When using ES6 imports it could not be set when `Popup` was not imported as well
  		this._marker.closePopup && this._marker.closePopup();

  		this._marker
  			.fire('movestart')
  			.fire('dragstart');
  	},

  	_onPreDrag: function (e) {
  		if (this._marker.options.autoPan) {
  			cancelAnimFrame(this._panRequest);
  			this._panRequest = requestAnimFrame(this._adjustPan.bind(this, e));
  		}
  	},

  	_onDrag: function (e) {
  		var marker = this._marker,
  		    shadow = marker._shadow,
  		    iconPos = getPosition(marker._icon),
  		    latlng = marker._map.layerPointToLatLng(iconPos);

  		// update shadow position
  		if (shadow) {
  			setPosition(shadow, iconPos);
  		}

  		marker._latlng = latlng;
  		e.latlng = latlng;
  		e.oldLatLng = this._oldLatLng;

  		// @event drag: Event
  		// Fired repeatedly while the user drags the marker.
  		marker
  		    .fire('move', e)
  		    .fire('drag', e);
  	},

  	_onDragEnd: function (e) {
  		// @event dragend: DragEndEvent
  		// Fired when the user stops dragging the marker.

  		 cancelAnimFrame(this._panRequest);

  		// @event moveend: Event
  		// Fired when the marker stops moving (because of dragging).
  		delete this._oldLatLng;
  		this._marker
  		    .fire('moveend')
  		    .fire('dragend', e);
  	}
  });

  /*
   * @class Marker
   * @inherits Interactive layer
   * @aka L.Marker
   * L.Marker is used to display clickable/draggable icons on the map. Extends `Layer`.
   *
   * @example
   *
   * ```js
   * L.marker([50.5, 30.5]).addTo(map);
   * ```
   */

  var Marker = Layer.extend({

  	// @section
  	// @aka Marker options
  	options: {
  		// @option icon: Icon = *
  		// Icon instance to use for rendering the marker.
  		// See [Icon documentation](#L.Icon) for details on how to customize the marker icon.
  		// If not specified, a common instance of `L.Icon.Default` is used.
  		icon: new IconDefault(),

  		// Option inherited from "Interactive layer" abstract class
  		interactive: true,

  		// @option keyboard: Boolean = true
  		// Whether the marker can be tabbed to with a keyboard and clicked by pressing enter.
  		keyboard: true,

  		// @option title: String = ''
  		// Text for the browser tooltip that appear on marker hover (no tooltip by default).
  		title: '',

  		// @option alt: String = ''
  		// Text for the `alt` attribute of the icon image (useful for accessibility).
  		alt: '',

  		// @option zIndexOffset: Number = 0
  		// By default, marker images zIndex is set automatically based on its latitude. Use this option if you want to put the marker on top of all others (or below), specifying a high value like `1000` (or high negative value, respectively).
  		zIndexOffset: 0,

  		// @option opacity: Number = 1.0
  		// The opacity of the marker.
  		opacity: 1,

  		// @option riseOnHover: Boolean = false
  		// If `true`, the marker will get on top of others when you hover the mouse over it.
  		riseOnHover: false,

  		// @option riseOffset: Number = 250
  		// The z-index offset used for the `riseOnHover` feature.
  		riseOffset: 250,

  		// @option pane: String = 'markerPane'
  		// `Map pane` where the markers icon will be added.
  		pane: 'markerPane',

  		// @option shadowPane: String = 'shadowPane'
  		// `Map pane` where the markers shadow will be added.
  		shadowPane: 'shadowPane',

  		// @option bubblingMouseEvents: Boolean = false
  		// When `true`, a mouse event on this marker will trigger the same event on the map
  		// (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).
  		bubblingMouseEvents: false,

  		// @section Draggable marker options
  		// @option draggable: Boolean = false
  		// Whether the marker is draggable with mouse/touch or not.
  		draggable: false,

  		// @option autoPan: Boolean = false
  		// Whether to pan the map when dragging this marker near its edge or not.
  		autoPan: false,

  		// @option autoPanPadding: Point = Point(50, 50)
  		// Distance (in pixels to the left/right and to the top/bottom) of the
  		// map edge to start panning the map.
  		autoPanPadding: [50, 50],

  		// @option autoPanSpeed: Number = 10
  		// Number of pixels the map should pan by.
  		autoPanSpeed: 10
  	},

  	/* @section
  	 *
  	 * In addition to [shared layer methods](#Layer) like `addTo()` and `remove()` and [popup methods](#Popup) like bindPopup() you can also use the following methods:
  	 */

  	initialize: function (latlng, options) {
  		setOptions(this, options);
  		this._latlng = toLatLng(latlng);
  	},

  	onAdd: function (map) {
  		this._zoomAnimated = this._zoomAnimated && map.options.markerZoomAnimation;

  		if (this._zoomAnimated) {
  			map.on('zoomanim', this._animateZoom, this);
  		}

  		this._initIcon();
  		this.update();
  	},

  	onRemove: function (map) {
  		if (this.dragging && this.dragging.enabled()) {
  			this.options.draggable = true;
  			this.dragging.removeHooks();
  		}
  		delete this.dragging;

  		if (this._zoomAnimated) {
  			map.off('zoomanim', this._animateZoom, this);
  		}

  		this._removeIcon();
  		this._removeShadow();
  	},

  	getEvents: function () {
  		return {
  			zoom: this.update,
  			viewreset: this.update
  		};
  	},

  	// @method getLatLng: LatLng
  	// Returns the current geographical position of the marker.
  	getLatLng: function () {
  		return this._latlng;
  	},

  	// @method setLatLng(latlng: LatLng): this
  	// Changes the marker position to the given point.
  	setLatLng: function (latlng) {
  		var oldLatLng = this._latlng;
  		this._latlng = toLatLng(latlng);
  		this.update();

  		// @event move: Event
  		// Fired when the marker is moved via [`setLatLng`](#marker-setlatlng) or by [dragging](#marker-dragging). Old and new coordinates are included in event arguments as `oldLatLng`, `latlng`.
  		return this.fire('move', {oldLatLng: oldLatLng, latlng: this._latlng});
  	},

  	// @method setZIndexOffset(offset: Number): this
  	// Changes the [zIndex offset](#marker-zindexoffset) of the marker.
  	setZIndexOffset: function (offset) {
  		this.options.zIndexOffset = offset;
  		return this.update();
  	},

  	// @method getIcon: Icon
  	// Returns the current icon used by the marker
  	getIcon: function () {
  		return this.options.icon;
  	},

  	// @method setIcon(icon: Icon): this
  	// Changes the marker icon.
  	setIcon: function (icon) {

  		this.options.icon = icon;

  		if (this._map) {
  			this._initIcon();
  			this.update();
  		}

  		if (this._popup) {
  			this.bindPopup(this._popup, this._popup.options);
  		}

  		return this;
  	},

  	getElement: function () {
  		return this._icon;
  	},

  	update: function () {

  		if (this._icon && this._map) {
  			var pos = this._map.latLngToLayerPoint(this._latlng).round();
  			this._setPos(pos);
  		}

  		return this;
  	},

  	_initIcon: function () {
  		var options = this.options,
  		    classToAdd = 'leaflet-zoom-' + (this._zoomAnimated ? 'animated' : 'hide');

  		var icon = options.icon.createIcon(this._icon),
  		    addIcon = false;

  		// if we're not reusing the icon, remove the old one and init new one
  		if (icon !== this._icon) {
  			if (this._icon) {
  				this._removeIcon();
  			}
  			addIcon = true;

  			if (options.title) {
  				icon.title = options.title;
  			}

  			if (icon.tagName === 'IMG') {
  				icon.alt = options.alt || '';
  			}
  		}

  		addClass(icon, classToAdd);

  		if (options.keyboard) {
  			icon.tabIndex = '0';
  		}

  		this._icon = icon;

  		if (options.riseOnHover) {
  			this.on({
  				mouseover: this._bringToFront,
  				mouseout: this._resetZIndex
  			});
  		}

  		var newShadow = options.icon.createShadow(this._shadow),
  		    addShadow = false;

  		if (newShadow !== this._shadow) {
  			this._removeShadow();
  			addShadow = true;
  		}

  		if (newShadow) {
  			addClass(newShadow, classToAdd);
  			newShadow.alt = '';
  		}
  		this._shadow = newShadow;


  		if (options.opacity < 1) {
  			this._updateOpacity();
  		}


  		if (addIcon) {
  			this.getPane().appendChild(this._icon);
  		}
  		this._initInteraction();
  		if (newShadow && addShadow) {
  			this.getPane(options.shadowPane).appendChild(this._shadow);
  		}
  	},

  	_removeIcon: function () {
  		if (this.options.riseOnHover) {
  			this.off({
  				mouseover: this._bringToFront,
  				mouseout: this._resetZIndex
  			});
  		}

  		remove(this._icon);
  		this.removeInteractiveTarget(this._icon);

  		this._icon = null;
  	},

  	_removeShadow: function () {
  		if (this._shadow) {
  			remove(this._shadow);
  		}
  		this._shadow = null;
  	},

  	_setPos: function (pos) {

  		if (this._icon) {
  			setPosition(this._icon, pos);
  		}

  		if (this._shadow) {
  			setPosition(this._shadow, pos);
  		}

  		this._zIndex = pos.y + this.options.zIndexOffset;

  		this._resetZIndex();
  	},

  	_updateZIndex: function (offset) {
  		if (this._icon) {
  			this._icon.style.zIndex = this._zIndex + offset;
  		}
  	},

  	_animateZoom: function (opt) {
  		var pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center).round();

  		this._setPos(pos);
  	},

  	_initInteraction: function () {

  		if (!this.options.interactive) { return; }

  		addClass(this._icon, 'leaflet-interactive');

  		this.addInteractiveTarget(this._icon);

  		if (MarkerDrag) {
  			var draggable = this.options.draggable;
  			if (this.dragging) {
  				draggable = this.dragging.enabled();
  				this.dragging.disable();
  			}

  			this.dragging = new MarkerDrag(this);

  			if (draggable) {
  				this.dragging.enable();
  			}
  		}
  	},

  	// @method setOpacity(opacity: Number): this
  	// Changes the opacity of the marker.
  	setOpacity: function (opacity) {
  		this.options.opacity = opacity;
  		if (this._map) {
  			this._updateOpacity();
  		}

  		return this;
  	},

  	_updateOpacity: function () {
  		var opacity = this.options.opacity;

  		if (this._icon) {
  			setOpacity(this._icon, opacity);
  		}

  		if (this._shadow) {
  			setOpacity(this._shadow, opacity);
  		}
  	},

  	_bringToFront: function () {
  		this._updateZIndex(this.options.riseOffset);
  	},

  	_resetZIndex: function () {
  		this._updateZIndex(0);
  	},

  	_getPopupAnchor: function () {
  		return this.options.icon.options.popupAnchor;
  	},

  	_getTooltipAnchor: function () {
  		return this.options.icon.options.tooltipAnchor;
  	}
  });


  // factory L.marker(latlng: LatLng, options? : Marker options)

  // @factory L.marker(latlng: LatLng, options? : Marker options)
  // Instantiates a Marker object given a geographical point and optionally an options object.
  function marker(latlng, options) {
  	return new Marker(latlng, options);
  }

  /*
   * @class Path
   * @aka L.Path
   * @inherits Interactive layer
   *
   * An abstract class that contains options and constants shared between vector
   * overlays (Polygon, Polyline, Circle). Do not use it directly. Extends `Layer`.
   */

  var Path = Layer.extend({

  	// @section
  	// @aka Path options
  	options: {
  		// @option stroke: Boolean = true
  		// Whether to draw stroke along the path. Set it to `false` to disable borders on polygons or circles.
  		stroke: true,

  		// @option color: String = '#3388ff'
  		// Stroke color
  		color: '#3388ff',

  		// @option weight: Number = 3
  		// Stroke width in pixels
  		weight: 3,

  		// @option opacity: Number = 1.0
  		// Stroke opacity
  		opacity: 1,

  		// @option lineCap: String= 'round'
  		// A string that defines [shape to be used at the end](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linecap) of the stroke.
  		lineCap: 'round',

  		// @option lineJoin: String = 'round'
  		// A string that defines [shape to be used at the corners](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linejoin) of the stroke.
  		lineJoin: 'round',

  		// @option dashArray: String = null
  		// A string that defines the stroke [dash pattern](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dasharray). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
  		dashArray: null,

  		// @option dashOffset: String = null
  		// A string that defines the [distance into the dash pattern to start the dash](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dashoffset). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
  		dashOffset: null,

  		// @option fill: Boolean = depends
  		// Whether to fill the path with color. Set it to `false` to disable filling on polygons or circles.
  		fill: false,

  		// @option fillColor: String = *
  		// Fill color. Defaults to the value of the [`color`](#path-color) option
  		fillColor: null,

  		// @option fillOpacity: Number = 0.2
  		// Fill opacity.
  		fillOpacity: 0.2,

  		// @option fillRule: String = 'evenodd'
  		// A string that defines [how the inside of a shape](https://developer.mozilla.org/docs/Web/SVG/Attribute/fill-rule) is determined.
  		fillRule: 'evenodd',

  		// className: '',

  		// Option inherited from "Interactive layer" abstract class
  		interactive: true,

  		// @option bubblingMouseEvents: Boolean = true
  		// When `true`, a mouse event on this path will trigger the same event on the map
  		// (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).
  		bubblingMouseEvents: true
  	},

  	beforeAdd: function (map) {
  		// Renderer is set here because we need to call renderer.getEvents
  		// before this.getEvents.
  		this._renderer = map.getRenderer(this);
  	},

  	onAdd: function () {
  		this._renderer._initPath(this);
  		this._reset();
  		this._renderer._addPath(this);
  	},

  	onRemove: function () {
  		this._renderer._removePath(this);
  	},

  	// @method redraw(): this
  	// Redraws the layer. Sometimes useful after you changed the coordinates that the path uses.
  	redraw: function () {
  		if (this._map) {
  			this._renderer._updatePath(this);
  		}
  		return this;
  	},

  	// @method setStyle(style: Path options): this
  	// Changes the appearance of a Path based on the options in the `Path options` object.
  	setStyle: function (style) {
  		setOptions(this, style);
  		if (this._renderer) {
  			this._renderer._updateStyle(this);
  			if (this.options.stroke && style && Object.prototype.hasOwnProperty.call(style, 'weight')) {
  				this._updateBounds();
  			}
  		}
  		return this;
  	},

  	// @method bringToFront(): this
  	// Brings the layer to the top of all path layers.
  	bringToFront: function () {
  		if (this._renderer) {
  			this._renderer._bringToFront(this);
  		}
  		return this;
  	},

  	// @method bringToBack(): this
  	// Brings the layer to the bottom of all path layers.
  	bringToBack: function () {
  		if (this._renderer) {
  			this._renderer._bringToBack(this);
  		}
  		return this;
  	},

  	getElement: function () {
  		return this._path;
  	},

  	_reset: function () {
  		// defined in child classes
  		this._project();
  		this._update();
  	},

  	_clickTolerance: function () {
  		// used when doing hit detection for Canvas layers
  		return (this.options.stroke ? this.options.weight / 2 : 0) + this._renderer.options.tolerance;
  	}
  });

  /*
   * @class CircleMarker
   * @aka L.CircleMarker
   * @inherits Path
   *
   * A circle of a fixed size with radius specified in pixels. Extends `Path`.
   */

  var CircleMarker = Path.extend({

  	// @section
  	// @aka CircleMarker options
  	options: {
  		fill: true,

  		// @option radius: Number = 10
  		// Radius of the circle marker, in pixels
  		radius: 10
  	},

  	initialize: function (latlng, options) {
  		setOptions(this, options);
  		this._latlng = toLatLng(latlng);
  		this._radius = this.options.radius;
  	},

  	// @method setLatLng(latLng: LatLng): this
  	// Sets the position of a circle marker to a new location.
  	setLatLng: function (latlng) {
  		var oldLatLng = this._latlng;
  		this._latlng = toLatLng(latlng);
  		this.redraw();

  		// @event move: Event
  		// Fired when the marker is moved via [`setLatLng`](#circlemarker-setlatlng). Old and new coordinates are included in event arguments as `oldLatLng`, `latlng`.
  		return this.fire('move', {oldLatLng: oldLatLng, latlng: this._latlng});
  	},

  	// @method getLatLng(): LatLng
  	// Returns the current geographical position of the circle marker
  	getLatLng: function () {
  		return this._latlng;
  	},

  	// @method setRadius(radius: Number): this
  	// Sets the radius of a circle marker. Units are in pixels.
  	setRadius: function (radius) {
  		this.options.radius = this._radius = radius;
  		return this.redraw();
  	},

  	// @method getRadius(): Number
  	// Returns the current radius of the circle
  	getRadius: function () {
  		return this._radius;
  	},

  	setStyle : function (options) {
  		var radius = options && options.radius || this._radius;
  		Path.prototype.setStyle.call(this, options);
  		this.setRadius(radius);
  		return this;
  	},

  	_project: function () {
  		this._point = this._map.latLngToLayerPoint(this._latlng);
  		this._updateBounds();
  	},

  	_updateBounds: function () {
  		var r = this._radius,
  		    r2 = this._radiusY || r,
  		    w = this._clickTolerance(),
  		    p = [r + w, r2 + w];
  		this._pxBounds = new Bounds(this._point.subtract(p), this._point.add(p));
  	},

  	_update: function () {
  		if (this._map) {
  			this._updatePath();
  		}
  	},

  	_updatePath: function () {
  		this._renderer._updateCircle(this);
  	},

  	_empty: function () {
  		return this._radius && !this._renderer._bounds.intersects(this._pxBounds);
  	},

  	// Needed by the `Canvas` renderer for interactivity
  	_containsPoint: function (p) {
  		return p.distanceTo(this._point) <= this._radius + this._clickTolerance();
  	}
  });


  // @factory L.circleMarker(latlng: LatLng, options?: CircleMarker options)
  // Instantiates a circle marker object given a geographical point, and an optional options object.
  function circleMarker(latlng, options) {
  	return new CircleMarker(latlng, options);
  }

  /*
   * @class Circle
   * @aka L.Circle
   * @inherits CircleMarker
   *
   * A class for drawing circle overlays on a map. Extends `CircleMarker`.
   *
   * It's an approximation and starts to diverge from a real circle closer to poles (due to projection distortion).
   *
   * @example
   *
   * ```js
   * L.circle([50.5, 30.5], {radius: 200}).addTo(map);
   * ```
   */

  var Circle = CircleMarker.extend({

  	initialize: function (latlng, options, legacyOptions) {
  		if (typeof options === 'number') {
  			// Backwards compatibility with 0.7.x factory (latlng, radius, options?)
  			options = extend({}, legacyOptions, {radius: options});
  		}
  		setOptions(this, options);
  		this._latlng = toLatLng(latlng);

  		if (isNaN(this.options.radius)) { throw new Error('Circle radius cannot be NaN'); }

  		// @section
  		// @aka Circle options
  		// @option radius: Number; Radius of the circle, in meters.
  		this._mRadius = this.options.radius;
  	},

  	// @method setRadius(radius: Number): this
  	// Sets the radius of a circle. Units are in meters.
  	setRadius: function (radius) {
  		this._mRadius = radius;
  		return this.redraw();
  	},

  	// @method getRadius(): Number
  	// Returns the current radius of a circle. Units are in meters.
  	getRadius: function () {
  		return this._mRadius;
  	},

  	// @method getBounds(): LatLngBounds
  	// Returns the `LatLngBounds` of the path.
  	getBounds: function () {
  		var half = [this._radius, this._radiusY || this._radius];

  		return new LatLngBounds(
  			this._map.layerPointToLatLng(this._point.subtract(half)),
  			this._map.layerPointToLatLng(this._point.add(half)));
  	},

  	setStyle: Path.prototype.setStyle,

  	_project: function () {

  		var lng = this._latlng.lng,
  		    lat = this._latlng.lat,
  		    map = this._map,
  		    crs = map.options.crs;

  		if (crs.distance === Earth.distance) {
  			var d = Math.PI / 180,
  			    latR = (this._mRadius / Earth.R) / d,
  			    top = map.project([lat + latR, lng]),
  			    bottom = map.project([lat - latR, lng]),
  			    p = top.add(bottom).divideBy(2),
  			    lat2 = map.unproject(p).lat,
  			    lngR = Math.acos((Math.cos(latR * d) - Math.sin(lat * d) * Math.sin(lat2 * d)) /
  			            (Math.cos(lat * d) * Math.cos(lat2 * d))) / d;

  			if (isNaN(lngR) || lngR === 0) {
  				lngR = latR / Math.cos(Math.PI / 180 * lat); // Fallback for edge case, #2425
  			}

  			this._point = p.subtract(map.getPixelOrigin());
  			this._radius = isNaN(lngR) ? 0 : p.x - map.project([lat2, lng - lngR]).x;
  			this._radiusY = p.y - top.y;

  		} else {
  			var latlng2 = crs.unproject(crs.project(this._latlng).subtract([this._mRadius, 0]));

  			this._point = map.latLngToLayerPoint(this._latlng);
  			this._radius = this._point.x - map.latLngToLayerPoint(latlng2).x;
  		}

  		this._updateBounds();
  	}
  });

  // @factory L.circle(latlng: LatLng, options?: Circle options)
  // Instantiates a circle object given a geographical point, and an options object
  // which contains the circle radius.
  // @alternative
  // @factory L.circle(latlng: LatLng, radius: Number, options?: Circle options)
  // Obsolete way of instantiating a circle, for compatibility with 0.7.x code.
  // Do not use in new applications or plugins.
  function circle(latlng, options, legacyOptions) {
  	return new Circle(latlng, options, legacyOptions);
  }

  /*
   * @class Polyline
   * @aka L.Polyline
   * @inherits Path
   *
   * A class for drawing polyline overlays on a map. Extends `Path`.
   *
   * @example
   *
   * ```js
   * // create a red polyline from an array of LatLng points
   * var latlngs = [
   * 	[45.51, -122.68],
   * 	[37.77, -122.43],
   * 	[34.04, -118.2]
   * ];
   *
   * var polyline = L.polyline(latlngs, {color: 'red'}).addTo(map);
   *
   * // zoom the map to the polyline
   * map.fitBounds(polyline.getBounds());
   * ```
   *
   * You can also pass a multi-dimensional array to represent a `MultiPolyline` shape:
   *
   * ```js
   * // create a red polyline from an array of arrays of LatLng points
   * var latlngs = [
   * 	[[45.51, -122.68],
   * 	 [37.77, -122.43],
   * 	 [34.04, -118.2]],
   * 	[[40.78, -73.91],
   * 	 [41.83, -87.62],
   * 	 [32.76, -96.72]]
   * ];
   * ```
   */


  var Polyline = Path.extend({

  	// @section
  	// @aka Polyline options
  	options: {
  		// @option smoothFactor: Number = 1.0
  		// How much to simplify the polyline on each zoom level. More means
  		// better performance and smoother look, and less means more accurate representation.
  		smoothFactor: 1.0,

  		// @option noClip: Boolean = false
  		// Disable polyline clipping.
  		noClip: false
  	},

  	initialize: function (latlngs, options) {
  		setOptions(this, options);
  		this._setLatLngs(latlngs);
  	},

  	// @method getLatLngs(): LatLng[]
  	// Returns an array of the points in the path, or nested arrays of points in case of multi-polyline.
  	getLatLngs: function () {
  		return this._latlngs;
  	},

  	// @method setLatLngs(latlngs: LatLng[]): this
  	// Replaces all the points in the polyline with the given array of geographical points.
  	setLatLngs: function (latlngs) {
  		this._setLatLngs(latlngs);
  		return this.redraw();
  	},

  	// @method isEmpty(): Boolean
  	// Returns `true` if the Polyline has no LatLngs.
  	isEmpty: function () {
  		return !this._latlngs.length;
  	},

  	// @method closestLayerPoint(p: Point): Point
  	// Returns the point closest to `p` on the Polyline.
  	closestLayerPoint: function (p) {
  		var minDistance = Infinity,
  		    minPoint = null,
  		    closest = _sqClosestPointOnSegment,
  		    p1, p2;

  		for (var j = 0, jLen = this._parts.length; j < jLen; j++) {
  			var points = this._parts[j];

  			for (var i = 1, len = points.length; i < len; i++) {
  				p1 = points[i - 1];
  				p2 = points[i];

  				var sqDist = closest(p, p1, p2, true);

  				if (sqDist < minDistance) {
  					minDistance = sqDist;
  					minPoint = closest(p, p1, p2);
  				}
  			}
  		}
  		if (minPoint) {
  			minPoint.distance = Math.sqrt(minDistance);
  		}
  		return minPoint;
  	},

  	// @method getCenter(): LatLng
  	// Returns the center ([centroid](http://en.wikipedia.org/wiki/Centroid)) of the polyline.
  	getCenter: function () {
  		// throws error when not yet added to map as this center calculation requires projected coordinates
  		if (!this._map) {
  			throw new Error('Must add layer to map before using getCenter()');
  		}

  		var i, halfDist, segDist, dist, p1, p2, ratio,
  		    points = this._rings[0],
  		    len = points.length;

  		if (!len) { return null; }

  		// polyline centroid algorithm; only uses the first ring if there are multiple

  		for (i = 0, halfDist = 0; i < len - 1; i++) {
  			halfDist += points[i].distanceTo(points[i + 1]) / 2;
  		}

  		// The line is so small in the current view that all points are on the same pixel.
  		if (halfDist === 0) {
  			return this._map.layerPointToLatLng(points[0]);
  		}

  		for (i = 0, dist = 0; i < len - 1; i++) {
  			p1 = points[i];
  			p2 = points[i + 1];
  			segDist = p1.distanceTo(p2);
  			dist += segDist;

  			if (dist > halfDist) {
  				ratio = (dist - halfDist) / segDist;
  				return this._map.layerPointToLatLng([
  					p2.x - ratio * (p2.x - p1.x),
  					p2.y - ratio * (p2.y - p1.y)
  				]);
  			}
  		}
  	},

  	// @method getBounds(): LatLngBounds
  	// Returns the `LatLngBounds` of the path.
  	getBounds: function () {
  		return this._bounds;
  	},

  	// @method addLatLng(latlng: LatLng, latlngs?: LatLng[]): this
  	// Adds a given point to the polyline. By default, adds to the first ring of
  	// the polyline in case of a multi-polyline, but can be overridden by passing
  	// a specific ring as a LatLng array (that you can earlier access with [`getLatLngs`](#polyline-getlatlngs)).
  	addLatLng: function (latlng, latlngs) {
  		latlngs = latlngs || this._defaultShape();
  		latlng = toLatLng(latlng);
  		latlngs.push(latlng);
  		this._bounds.extend(latlng);
  		return this.redraw();
  	},

  	_setLatLngs: function (latlngs) {
  		this._bounds = new LatLngBounds();
  		this._latlngs = this._convertLatLngs(latlngs);
  	},

  	_defaultShape: function () {
  		return isFlat(this._latlngs) ? this._latlngs : this._latlngs[0];
  	},

  	// recursively convert latlngs input into actual LatLng instances; calculate bounds along the way
  	_convertLatLngs: function (latlngs) {
  		var result = [],
  		    flat = isFlat(latlngs);

  		for (var i = 0, len = latlngs.length; i < len; i++) {
  			if (flat) {
  				result[i] = toLatLng(latlngs[i]);
  				this._bounds.extend(result[i]);
  			} else {
  				result[i] = this._convertLatLngs(latlngs[i]);
  			}
  		}

  		return result;
  	},

  	_project: function () {
  		var pxBounds = new Bounds();
  		this._rings = [];
  		this._projectLatlngs(this._latlngs, this._rings, pxBounds);

  		if (this._bounds.isValid() && pxBounds.isValid()) {
  			this._rawPxBounds = pxBounds;
  			this._updateBounds();
  		}
  	},

  	_updateBounds: function () {
  		var w = this._clickTolerance(),
  		    p = new Point(w, w);
  		this._pxBounds = new Bounds([
  			this._rawPxBounds.min.subtract(p),
  			this._rawPxBounds.max.add(p)
  		]);
  	},

  	// recursively turns latlngs into a set of rings with projected coordinates
  	_projectLatlngs: function (latlngs, result, projectedBounds) {
  		var flat = latlngs[0] instanceof LatLng,
  		    len = latlngs.length,
  		    i, ring;

  		if (flat) {
  			ring = [];
  			for (i = 0; i < len; i++) {
  				ring[i] = this._map.latLngToLayerPoint(latlngs[i]);
  				projectedBounds.extend(ring[i]);
  			}
  			result.push(ring);
  		} else {
  			for (i = 0; i < len; i++) {
  				this._projectLatlngs(latlngs[i], result, projectedBounds);
  			}
  		}
  	},

  	// clip polyline by renderer bounds so that we have less to render for performance
  	_clipPoints: function () {
  		var bounds = this._renderer._bounds;

  		this._parts = [];
  		if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {
  			return;
  		}

  		if (this.options.noClip) {
  			this._parts = this._rings;
  			return;
  		}

  		var parts = this._parts,
  		    i, j, k, len, len2, segment, points;

  		for (i = 0, k = 0, len = this._rings.length; i < len; i++) {
  			points = this._rings[i];

  			for (j = 0, len2 = points.length; j < len2 - 1; j++) {
  				segment = clipSegment(points[j], points[j + 1], bounds, j, true);

  				if (!segment) { continue; }

  				parts[k] = parts[k] || [];
  				parts[k].push(segment[0]);

  				// if segment goes out of screen, or it's the last one, it's the end of the line part
  				if ((segment[1] !== points[j + 1]) || (j === len2 - 2)) {
  					parts[k].push(segment[1]);
  					k++;
  				}
  			}
  		}
  	},

  	// simplify each clipped part of the polyline for performance
  	_simplifyPoints: function () {
  		var parts = this._parts,
  		    tolerance = this.options.smoothFactor;

  		for (var i = 0, len = parts.length; i < len; i++) {
  			parts[i] = simplify(parts[i], tolerance);
  		}
  	},

  	_update: function () {
  		if (!this._map) { return; }

  		this._clipPoints();
  		this._simplifyPoints();
  		this._updatePath();
  	},

  	_updatePath: function () {
  		this._renderer._updatePoly(this);
  	},

  	// Needed by the `Canvas` renderer for interactivity
  	_containsPoint: function (p, closed) {
  		var i, j, k, len, len2, part,
  		    w = this._clickTolerance();

  		if (!this._pxBounds || !this._pxBounds.contains(p)) { return false; }

  		// hit detection for polylines
  		for (i = 0, len = this._parts.length; i < len; i++) {
  			part = this._parts[i];

  			for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
  				if (!closed && (j === 0)) { continue; }

  				if (pointToSegmentDistance(p, part[k], part[j]) <= w) {
  					return true;
  				}
  			}
  		}
  		return false;
  	}
  });

  // @factory L.polyline(latlngs: LatLng[], options?: Polyline options)
  // Instantiates a polyline object given an array of geographical points and
  // optionally an options object. You can create a `Polyline` object with
  // multiple separate lines (`MultiPolyline`) by passing an array of arrays
  // of geographic points.
  function polyline(latlngs, options) {
  	return new Polyline(latlngs, options);
  }

  // Retrocompat. Allow plugins to support Leaflet versions before and after 1.1.
  Polyline._flat = _flat;

  /*
   * @class Polygon
   * @aka L.Polygon
   * @inherits Polyline
   *
   * A class for drawing polygon overlays on a map. Extends `Polyline`.
   *
   * Note that points you pass when creating a polygon shouldn't have an additional last point equal to the first one  it's better to filter out such points.
   *
   *
   * @example
   *
   * ```js
   * // create a red polygon from an array of LatLng points
   * var latlngs = [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]];
   *
   * var polygon = L.polygon(latlngs, {color: 'red'}).addTo(map);
   *
   * // zoom the map to the polygon
   * map.fitBounds(polygon.getBounds());
   * ```
   *
   * You can also pass an array of arrays of latlngs, with the first array representing the outer shape and the other arrays representing holes in the outer shape:
   *
   * ```js
   * var latlngs = [
   *   [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]], // outer ring
   *   [[37.29, -108.58],[40.71, -108.58],[40.71, -102.50],[37.29, -102.50]] // hole
   * ];
   * ```
   *
   * Additionally, you can pass a multi-dimensional array to represent a MultiPolygon shape.
   *
   * ```js
   * var latlngs = [
   *   [ // first polygon
   *     [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]], // outer ring
   *     [[37.29, -108.58],[40.71, -108.58],[40.71, -102.50],[37.29, -102.50]] // hole
   *   ],
   *   [ // second polygon
   *     [[41, -111.03],[45, -111.04],[45, -104.05],[41, -104.05]]
   *   ]
   * ];
   * ```
   */

  var Polygon = Polyline.extend({

  	options: {
  		fill: true
  	},

  	isEmpty: function () {
  		return !this._latlngs.length || !this._latlngs[0].length;
  	},

  	getCenter: function () {
  		// throws error when not yet added to map as this center calculation requires projected coordinates
  		if (!this._map) {
  			throw new Error('Must add layer to map before using getCenter()');
  		}

  		var i, j, p1, p2, f, area, x, y, center,
  		    points = this._rings[0],
  		    len = points.length;

  		if (!len) { return null; }

  		// polygon centroid algorithm; only uses the first ring if there are multiple

  		area = x = y = 0;

  		for (i = 0, j = len - 1; i < len; j = i++) {
  			p1 = points[i];
  			p2 = points[j];

  			f = p1.y * p2.x - p2.y * p1.x;
  			x += (p1.x + p2.x) * f;
  			y += (p1.y + p2.y) * f;
  			area += f * 3;
  		}

  		if (area === 0) {
  			// Polygon is so small that all points are on same pixel.
  			center = points[0];
  		} else {
  			center = [x / area, y / area];
  		}
  		return this._map.layerPointToLatLng(center);
  	},

  	_convertLatLngs: function (latlngs) {
  		var result = Polyline.prototype._convertLatLngs.call(this, latlngs),
  		    len = result.length;

  		// remove last point if it equals first one
  		if (len >= 2 && result[0] instanceof LatLng && result[0].equals(result[len - 1])) {
  			result.pop();
  		}
  		return result;
  	},

  	_setLatLngs: function (latlngs) {
  		Polyline.prototype._setLatLngs.call(this, latlngs);
  		if (isFlat(this._latlngs)) {
  			this._latlngs = [this._latlngs];
  		}
  	},

  	_defaultShape: function () {
  		return isFlat(this._latlngs[0]) ? this._latlngs[0] : this._latlngs[0][0];
  	},

  	_clipPoints: function () {
  		// polygons need a different clipping algorithm so we redefine that

  		var bounds = this._renderer._bounds,
  		    w = this.options.weight,
  		    p = new Point(w, w);

  		// increase clip padding by stroke width to avoid stroke on clip edges
  		bounds = new Bounds(bounds.min.subtract(p), bounds.max.add(p));

  		this._parts = [];
  		if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {
  			return;
  		}

  		if (this.options.noClip) {
  			this._parts = this._rings;
  			return;
  		}

  		for (var i = 0, len = this._rings.length, clipped; i < len; i++) {
  			clipped = clipPolygon(this._rings[i], bounds, true);
  			if (clipped.length) {
  				this._parts.push(clipped);
  			}
  		}
  	},

  	_updatePath: function () {
  		this._renderer._updatePoly(this, true);
  	},

  	// Needed by the `Canvas` renderer for interactivity
  	_containsPoint: function (p) {
  		var inside = false,
  		    part, p1, p2, i, j, k, len, len2;

  		if (!this._pxBounds || !this._pxBounds.contains(p)) { return false; }

  		// ray casting algorithm for detecting if point is in polygon
  		for (i = 0, len = this._parts.length; i < len; i++) {
  			part = this._parts[i];

  			for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
  				p1 = part[j];
  				p2 = part[k];

  				if (((p1.y > p.y) !== (p2.y > p.y)) && (p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x)) {
  					inside = !inside;
  				}
  			}
  		}

  		// also check if it's on polygon stroke
  		return inside || Polyline.prototype._containsPoint.call(this, p, true);
  	}

  });


  // @factory L.polygon(latlngs: LatLng[], options?: Polyline options)
  function polygon(latlngs, options) {
  	return new Polygon(latlngs, options);
  }

  /*
   * @class GeoJSON
   * @aka L.GeoJSON
   * @inherits FeatureGroup
   *
   * Represents a GeoJSON object or an array of GeoJSON objects. Allows you to parse
   * GeoJSON data and display it on the map. Extends `FeatureGroup`.
   *
   * @example
   *
   * ```js
   * L.geoJSON(data, {
   * 	style: function (feature) {
   * 		return {color: feature.properties.color};
   * 	}
   * }).bindPopup(function (layer) {
   * 	return layer.feature.properties.description;
   * }).addTo(map);
   * ```
   */

  var GeoJSON = FeatureGroup.extend({

  	/* @section
  	 * @aka GeoJSON options
  	 *
  	 * @option pointToLayer: Function = *
  	 * A `Function` defining how GeoJSON points spawn Leaflet layers. It is internally
  	 * called when data is added, passing the GeoJSON point feature and its `LatLng`.
  	 * The default is to spawn a default `Marker`:
  	 * ```js
  	 * function(geoJsonPoint, latlng) {
  	 * 	return L.marker(latlng);
  	 * }
  	 * ```
  	 *
  	 * @option style: Function = *
  	 * A `Function` defining the `Path options` for styling GeoJSON lines and polygons,
  	 * called internally when data is added.
  	 * The default value is to not override any defaults:
  	 * ```js
  	 * function (geoJsonFeature) {
  	 * 	return {}
  	 * }
  	 * ```
  	 *
  	 * @option onEachFeature: Function = *
  	 * A `Function` that will be called once for each created `Feature`, after it has
  	 * been created and styled. Useful for attaching events and popups to features.
  	 * The default is to do nothing with the newly created layers:
  	 * ```js
  	 * function (feature, layer) {}
  	 * ```
  	 *
  	 * @option filter: Function = *
  	 * A `Function` that will be used to decide whether to include a feature or not.
  	 * The default is to include all features:
  	 * ```js
  	 * function (geoJsonFeature) {
  	 * 	return true;
  	 * }
  	 * ```
  	 * Note: dynamically changing the `filter` option will have effect only on newly
  	 * added data. It will _not_ re-evaluate already included features.
  	 *
  	 * @option coordsToLatLng: Function = *
  	 * A `Function` that will be used for converting GeoJSON coordinates to `LatLng`s.
  	 * The default is the `coordsToLatLng` static method.
  	 *
  	 * @option markersInheritOptions: Boolean = false
  	 * Whether default Markers for "Point" type Features inherit from group options.
  	 */

  	initialize: function (geojson, options) {
  		setOptions(this, options);

  		this._layers = {};

  		if (geojson) {
  			this.addData(geojson);
  		}
  	},

  	// @method addData( <GeoJSON> data ): this
  	// Adds a GeoJSON object to the layer.
  	addData: function (geojson) {
  		var features = isArray(geojson) ? geojson : geojson.features,
  		    i, len, feature;

  		if (features) {
  			for (i = 0, len = features.length; i < len; i++) {
  				// only add this if geometry or geometries are set and not null
  				feature = features[i];
  				if (feature.geometries || feature.geometry || feature.features || feature.coordinates) {
  					this.addData(feature);
  				}
  			}
  			return this;
  		}

  		var options = this.options;

  		if (options.filter && !options.filter(geojson)) { return this; }

  		var layer = geometryToLayer(geojson, options);
  		if (!layer) {
  			return this;
  		}
  		layer.feature = asFeature(geojson);

  		layer.defaultOptions = layer.options;
  		this.resetStyle(layer);

  		if (options.onEachFeature) {
  			options.onEachFeature(geojson, layer);
  		}

  		return this.addLayer(layer);
  	},

  	// @method resetStyle( <Path> layer? ): this
  	// Resets the given vector layer's style to the original GeoJSON style, useful for resetting style after hover events.
  	// If `layer` is omitted, the style of all features in the current layer is reset.
  	resetStyle: function (layer) {
  		if (layer === undefined) {
  			return this.eachLayer(this.resetStyle, this);
  		}
  		// reset any custom styles
  		layer.options = extend({}, layer.defaultOptions);
  		this._setLayerStyle(layer, this.options.style);
  		return this;
  	},

  	// @method setStyle( <Function> style ): this
  	// Changes styles of GeoJSON vector layers with the given style function.
  	setStyle: function (style) {
  		return this.eachLayer(function (layer) {
  			this._setLayerStyle(layer, style);
  		}, this);
  	},

  	_setLayerStyle: function (layer, style) {
  		if (layer.setStyle) {
  			if (typeof style === 'function') {
  				style = style(layer.feature);
  			}
  			layer.setStyle(style);
  		}
  	}
  });

  // @section
  // There are several static functions which can be called without instantiating L.GeoJSON:

  // @function geometryToLayer(featureData: Object, options?: GeoJSON options): Layer
  // Creates a `Layer` from a given GeoJSON feature. Can use a custom
  // [`pointToLayer`](#geojson-pointtolayer) and/or [`coordsToLatLng`](#geojson-coordstolatlng)
  // functions if provided as options.
  function geometryToLayer(geojson, options) {

  	var geometry = geojson.type === 'Feature' ? geojson.geometry : geojson,
  	    coords = geometry ? geometry.coordinates : null,
  	    layers = [],
  	    pointToLayer = options && options.pointToLayer,
  	    _coordsToLatLng = options && options.coordsToLatLng || coordsToLatLng,
  	    latlng, latlngs, i, len;

  	if (!coords && !geometry) {
  		return null;
  	}

  	switch (geometry.type) {
  	case 'Point':
  		latlng = _coordsToLatLng(coords);
  		return _pointToLayer(pointToLayer, geojson, latlng, options);

  	case 'MultiPoint':
  		for (i = 0, len = coords.length; i < len; i++) {
  			latlng = _coordsToLatLng(coords[i]);
  			layers.push(_pointToLayer(pointToLayer, geojson, latlng, options));
  		}
  		return new FeatureGroup(layers);

  	case 'LineString':
  	case 'MultiLineString':
  		latlngs = coordsToLatLngs(coords, geometry.type === 'LineString' ? 0 : 1, _coordsToLatLng);
  		return new Polyline(latlngs, options);

  	case 'Polygon':
  	case 'MultiPolygon':
  		latlngs = coordsToLatLngs(coords, geometry.type === 'Polygon' ? 1 : 2, _coordsToLatLng);
  		return new Polygon(latlngs, options);

  	case 'GeometryCollection':
  		for (i = 0, len = geometry.geometries.length; i < len; i++) {
  			var layer = geometryToLayer({
  				geometry: geometry.geometries[i],
  				type: 'Feature',
  				properties: geojson.properties
  			}, options);

  			if (layer) {
  				layers.push(layer);
  			}
  		}
  		return new FeatureGroup(layers);

  	default:
  		throw new Error('Invalid GeoJSON object.');
  	}
  }

  function _pointToLayer(pointToLayerFn, geojson, latlng, options) {
  	return pointToLayerFn ?
  		pointToLayerFn(geojson, latlng) :
  		new Marker(latlng, options && options.markersInheritOptions && options);
  }

  // @function coordsToLatLng(coords: Array): LatLng
  // Creates a `LatLng` object from an array of 2 numbers (longitude, latitude)
  // or 3 numbers (longitude, latitude, altitude) used in GeoJSON for points.
  function coordsToLatLng(coords) {
  	return new LatLng(coords[1], coords[0], coords[2]);
  }

  // @function coordsToLatLngs(coords: Array, levelsDeep?: Number, coordsToLatLng?: Function): Array
  // Creates a multidimensional array of `LatLng`s from a GeoJSON coordinates array.
  // `levelsDeep` specifies the nesting level (0 is for an array of points, 1 for an array of arrays of points, etc., 0 by default).
  // Can use a custom [`coordsToLatLng`](#geojson-coordstolatlng) function.
  function coordsToLatLngs(coords, levelsDeep, _coordsToLatLng) {
  	var latlngs = [];

  	for (var i = 0, len = coords.length, latlng; i < len; i++) {
  		latlng = levelsDeep ?
  			coordsToLatLngs(coords[i], levelsDeep - 1, _coordsToLatLng) :
  			(_coordsToLatLng || coordsToLatLng)(coords[i]);

  		latlngs.push(latlng);
  	}

  	return latlngs;
  }

  // @function latLngToCoords(latlng: LatLng, precision?: Number): Array
  // Reverse of [`coordsToLatLng`](#geojson-coordstolatlng)
  function latLngToCoords(latlng, precision) {
  	precision = typeof precision === 'number' ? precision : 6;
  	return latlng.alt !== undefined ?
  		[formatNum(latlng.lng, precision), formatNum(latlng.lat, precision), formatNum(latlng.alt, precision)] :
  		[formatNum(latlng.lng, precision), formatNum(latlng.lat, precision)];
  }

  // @function latLngsToCoords(latlngs: Array, levelsDeep?: Number, closed?: Boolean): Array
  // Reverse of [`coordsToLatLngs`](#geojson-coordstolatlngs)
  // `closed` determines whether the first point should be appended to the end of the array to close the feature, only used when `levelsDeep` is 0. False by default.
  function latLngsToCoords(latlngs, levelsDeep, closed, precision) {
  	var coords = [];

  	for (var i = 0, len = latlngs.length; i < len; i++) {
  		coords.push(levelsDeep ?
  			latLngsToCoords(latlngs[i], levelsDeep - 1, closed, precision) :
  			latLngToCoords(latlngs[i], precision));
  	}

  	if (!levelsDeep && closed) {
  		coords.push(coords[0]);
  	}

  	return coords;
  }

  function getFeature(layer, newGeometry) {
  	return layer.feature ?
  		extend({}, layer.feature, {geometry: newGeometry}) :
  		asFeature(newGeometry);
  }

  // @function asFeature(geojson: Object): Object
  // Normalize GeoJSON geometries/features into GeoJSON features.
  function asFeature(geojson) {
  	if (geojson.type === 'Feature' || geojson.type === 'FeatureCollection') {
  		return geojson;
  	}

  	return {
  		type: 'Feature',
  		properties: {},
  		geometry: geojson
  	};
  }

  var PointToGeoJSON = {
  	toGeoJSON: function (precision) {
  		return getFeature(this, {
  			type: 'Point',
  			coordinates: latLngToCoords(this.getLatLng(), precision)
  		});
  	}
  };

  // @namespace Marker
  // @section Other methods
  // @method toGeoJSON(precision?: Number): Object
  // `precision` is the number of decimal places for coordinates.
  // The default value is 6 places.
  // Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the marker (as a GeoJSON `Point` Feature).
  Marker.include(PointToGeoJSON);

  // @namespace CircleMarker
  // @method toGeoJSON(precision?: Number): Object
  // `precision` is the number of decimal places for coordinates.
  // The default value is 6 places.
  // Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the circle marker (as a GeoJSON `Point` Feature).
  Circle.include(PointToGeoJSON);
  CircleMarker.include(PointToGeoJSON);


  // @namespace Polyline
  // @method toGeoJSON(precision?: Number): Object
  // `precision` is the number of decimal places for coordinates.
  // The default value is 6 places.
  // Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the polyline (as a GeoJSON `LineString` or `MultiLineString` Feature).
  Polyline.include({
  	toGeoJSON: function (precision) {
  		var multi = !isFlat(this._latlngs);

  		var coords = latLngsToCoords(this._latlngs, multi ? 1 : 0, false, precision);

  		return getFeature(this, {
  			type: (multi ? 'Multi' : '') + 'LineString',
  			coordinates: coords
  		});
  	}
  });

  // @namespace Polygon
  // @method toGeoJSON(precision?: Number): Object
  // `precision` is the number of decimal places for coordinates.
  // The default value is 6 places.
  // Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the polygon (as a GeoJSON `Polygon` or `MultiPolygon` Feature).
  Polygon.include({
  	toGeoJSON: function (precision) {
  		var holes = !isFlat(this._latlngs),
  		    multi = holes && !isFlat(this._latlngs[0]);

  		var coords = latLngsToCoords(this._latlngs, multi ? 2 : holes ? 1 : 0, true, precision);

  		if (!holes) {
  			coords = [coords];
  		}

  		return getFeature(this, {
  			type: (multi ? 'Multi' : '') + 'Polygon',
  			coordinates: coords
  		});
  	}
  });


  // @namespace LayerGroup
  LayerGroup.include({
  	toMultiPoint: function (precision) {
  		var coords = [];

  		this.eachLayer(function (layer) {
  			coords.push(layer.toGeoJSON(precision).geometry.coordinates);
  		});

  		return getFeature(this, {
  			type: 'MultiPoint',
  			coordinates: coords
  		});
  	},

  	// @method toGeoJSON(precision?: Number): Object
  	// `precision` is the number of decimal places for coordinates.
  	// The default value is 6 places.
  	// Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the layer group (as a GeoJSON `FeatureCollection`, `GeometryCollection`, or `MultiPoint`).
  	toGeoJSON: function (precision) {

  		var type = this.feature && this.feature.geometry && this.feature.geometry.type;

  		if (type === 'MultiPoint') {
  			return this.toMultiPoint(precision);
  		}

  		var isGeometryCollection = type === 'GeometryCollection',
  		    jsons = [];

  		this.eachLayer(function (layer) {
  			if (layer.toGeoJSON) {
  				var json = layer.toGeoJSON(precision);
  				if (isGeometryCollection) {
  					jsons.push(json.geometry);
  				} else {
  					var feature = asFeature(json);
  					// Squash nested feature collections
  					if (feature.type === 'FeatureCollection') {
  						jsons.push.apply(jsons, feature.features);
  					} else {
  						jsons.push(feature);
  					}
  				}
  			}
  		});

  		if (isGeometryCollection) {
  			return getFeature(this, {
  				geometries: jsons,
  				type: 'GeometryCollection'
  			});
  		}

  		return {
  			type: 'FeatureCollection',
  			features: jsons
  		};
  	}
  });

  // @namespace GeoJSON
  // @factory L.geoJSON(geojson?: Object, options?: GeoJSON options)
  // Creates a GeoJSON layer. Optionally accepts an object in
  // [GeoJSON format](https://tools.ietf.org/html/rfc7946) to display on the map
  // (you can alternatively add it later with `addData` method) and an `options` object.
  function geoJSON(geojson, options) {
  	return new GeoJSON(geojson, options);
  }

  // Backward compatibility.
  var geoJson = geoJSON;

  /*
   * @class ImageOverlay
   * @aka L.ImageOverlay
   * @inherits Interactive layer
   *
   * Used to load and display a single image over specific bounds of the map. Extends `Layer`.
   *
   * @example
   *
   * ```js
   * var imageUrl = 'http://www.lib.utexas.edu/maps/historical/newark_nj_1922.jpg',
   * 	imageBounds = [[40.712216, -74.22655], [40.773941, -74.12544]];
   * L.imageOverlay(imageUrl, imageBounds).addTo(map);
   * ```
   */

  var ImageOverlay = Layer.extend({

  	// @section
  	// @aka ImageOverlay options
  	options: {
  		// @option opacity: Number = 1.0
  		// The opacity of the image overlay.
  		opacity: 1,

  		// @option alt: String = ''
  		// Text for the `alt` attribute of the image (useful for accessibility).
  		alt: '',

  		// @option interactive: Boolean = false
  		// If `true`, the image overlay will emit [mouse events](#interactive-layer) when clicked or hovered.
  		interactive: false,

  		// @option crossOrigin: Boolean|String = false
  		// Whether the crossOrigin attribute will be added to the image.
  		// If a String is provided, the image will have its crossOrigin attribute set to the String provided. This is needed if you want to access image pixel data.
  		// Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.
  		crossOrigin: false,

  		// @option errorOverlayUrl: String = ''
  		// URL to the overlay image to show in place of the overlay that failed to load.
  		errorOverlayUrl: '',

  		// @option zIndex: Number = 1
  		// The explicit [zIndex](https://developer.mozilla.org/docs/Web/CSS/CSS_Positioning/Understanding_z_index) of the overlay layer.
  		zIndex: 1,

  		// @option className: String = ''
  		// A custom class name to assign to the image. Empty by default.
  		className: ''
  	},

  	initialize: function (url, bounds, options) { // (String, LatLngBounds, Object)
  		this._url = url;
  		this._bounds = toLatLngBounds(bounds);

  		setOptions(this, options);
  	},

  	onAdd: function () {
  		if (!this._image) {
  			this._initImage();

  			if (this.options.opacity < 1) {
  				this._updateOpacity();
  			}
  		}

  		if (this.options.interactive) {
  			addClass(this._image, 'leaflet-interactive');
  			this.addInteractiveTarget(this._image);
  		}

  		this.getPane().appendChild(this._image);
  		this._reset();
  	},

  	onRemove: function () {
  		remove(this._image);
  		if (this.options.interactive) {
  			this.removeInteractiveTarget(this._image);
  		}
  	},

  	// @method setOpacity(opacity: Number): this
  	// Sets the opacity of the overlay.
  	setOpacity: function (opacity) {
  		this.options.opacity = opacity;

  		if (this._image) {
  			this._updateOpacity();
  		}
  		return this;
  	},

  	setStyle: function (styleOpts) {
  		if (styleOpts.opacity) {
  			this.setOpacity(styleOpts.opacity);
  		}
  		return this;
  	},

  	// @method bringToFront(): this
  	// Brings the layer to the top of all overlays.
  	bringToFront: function () {
  		if (this._map) {
  			toFront(this._image);
  		}
  		return this;
  	},

  	// @method bringToBack(): this
  	// Brings the layer to the bottom of all overlays.
  	bringToBack: function () {
  		if (this._map) {
  			toBack(this._image);
  		}
  		return this;
  	},

  	// @method setUrl(url: String): this
  	// Changes the URL of the image.
  	setUrl: function (url) {
  		this._url = url;

  		if (this._image) {
  			this._image.src = url;
  		}
  		return this;
  	},

  	// @method setBounds(bounds: LatLngBounds): this
  	// Update the bounds that this ImageOverlay covers
  	setBounds: function (bounds) {
  		this._bounds = toLatLngBounds(bounds);

  		if (this._map) {
  			this._reset();
  		}
  		return this;
  	},

  	getEvents: function () {
  		var events = {
  			zoom: this._reset,
  			viewreset: this._reset
  		};

  		if (this._zoomAnimated) {
  			events.zoomanim = this._animateZoom;
  		}

  		return events;
  	},

  	// @method setZIndex(value: Number): this
  	// Changes the [zIndex](#imageoverlay-zindex) of the image overlay.
  	setZIndex: function (value) {
  		this.options.zIndex = value;
  		this._updateZIndex();
  		return this;
  	},

  	// @method getBounds(): LatLngBounds
  	// Get the bounds that this ImageOverlay covers
  	getBounds: function () {
  		return this._bounds;
  	},

  	// @method getElement(): HTMLElement
  	// Returns the instance of [`HTMLImageElement`](https://developer.mozilla.org/docs/Web/API/HTMLImageElement)
  	// used by this overlay.
  	getElement: function () {
  		return this._image;
  	},

  	_initImage: function () {
  		var wasElementSupplied = this._url.tagName === 'IMG';
  		var img = this._image = wasElementSupplied ? this._url : create$1('img');

  		addClass(img, 'leaflet-image-layer');
  		if (this._zoomAnimated) { addClass(img, 'leaflet-zoom-animated'); }
  		if (this.options.className) { addClass(img, this.options.className); }

  		img.onselectstart = falseFn;
  		img.onmousemove = falseFn;

  		// @event load: Event
  		// Fired when the ImageOverlay layer has loaded its image
  		img.onload = bind(this.fire, this, 'load');
  		img.onerror = bind(this._overlayOnError, this, 'error');

  		if (this.options.crossOrigin || this.options.crossOrigin === '') {
  			img.crossOrigin = this.options.crossOrigin === true ? '' : this.options.crossOrigin;
  		}

  		if (this.options.zIndex) {
  			this._updateZIndex();
  		}

  		if (wasElementSupplied) {
  			this._url = img.src;
  			return;
  		}

  		img.src = this._url;
  		img.alt = this.options.alt;
  	},

  	_animateZoom: function (e) {
  		var scale = this._map.getZoomScale(e.zoom),
  		    offset = this._map._latLngBoundsToNewLayerBounds(this._bounds, e.zoom, e.center).min;

  		setTransform(this._image, offset, scale);
  	},

  	_reset: function () {
  		var image = this._image,
  		    bounds = new Bounds(
  		        this._map.latLngToLayerPoint(this._bounds.getNorthWest()),
  		        this._map.latLngToLayerPoint(this._bounds.getSouthEast())),
  		    size = bounds.getSize();

  		setPosition(image, bounds.min);

  		image.style.width  = size.x + 'px';
  		image.style.height = size.y + 'px';
  	},

  	_updateOpacity: function () {
  		setOpacity(this._image, this.options.opacity);
  	},

  	_updateZIndex: function () {
  		if (this._image && this.options.zIndex !== undefined && this.options.zIndex !== null) {
  			this._image.style.zIndex = this.options.zIndex;
  		}
  	},

  	_overlayOnError: function () {
  		// @event error: Event
  		// Fired when the ImageOverlay layer fails to load its image
  		this.fire('error');

  		var errorUrl = this.options.errorOverlayUrl;
  		if (errorUrl && this._url !== errorUrl) {
  			this._url = errorUrl;
  			this._image.src = errorUrl;
  		}
  	}
  });

  // @factory L.imageOverlay(imageUrl: String, bounds: LatLngBounds, options?: ImageOverlay options)
  // Instantiates an image overlay object given the URL of the image and the
  // geographical bounds it is tied to.
  var imageOverlay = function (url, bounds, options) {
  	return new ImageOverlay(url, bounds, options);
  };

  /*
   * @class VideoOverlay
   * @aka L.VideoOverlay
   * @inherits ImageOverlay
   *
   * Used to load and display a video player over specific bounds of the map. Extends `ImageOverlay`.
   *
   * A video overlay uses the [`<video>`](https://developer.mozilla.org/docs/Web/HTML/Element/video)
   * HTML5 element.
   *
   * @example
   *
   * ```js
   * var videoUrl = 'https://www.mapbox.com/bites/00188/patricia_nasa.webm',
   * 	videoBounds = [[ 32, -130], [ 13, -100]];
   * L.videoOverlay(videoUrl, videoBounds ).addTo(map);
   * ```
   */

  var VideoOverlay = ImageOverlay.extend({

  	// @section
  	// @aka VideoOverlay options
  	options: {
  		// @option autoplay: Boolean = true
  		// Whether the video starts playing automatically when loaded.
  		autoplay: true,

  		// @option loop: Boolean = true
  		// Whether the video will loop back to the beginning when played.
  		loop: true,

  		// @option keepAspectRatio: Boolean = true
  		// Whether the video will save aspect ratio after the projection.
  		// Relevant for supported browsers. Browser compatibility- https://developer.mozilla.org/en-US/docs/Web/CSS/object-fit
  		keepAspectRatio: true,

  		// @option muted: Boolean = false
  		// Whether the video starts on mute when loaded.
  		muted: false
  	},

  	_initImage: function () {
  		var wasElementSupplied = this._url.tagName === 'VIDEO';
  		var vid = this._image = wasElementSupplied ? this._url : create$1('video');

  		addClass(vid, 'leaflet-image-layer');
  		if (this._zoomAnimated) { addClass(vid, 'leaflet-zoom-animated'); }
  		if (this.options.className) { addClass(vid, this.options.className); }

  		vid.onselectstart = falseFn;
  		vid.onmousemove = falseFn;

  		// @event load: Event
  		// Fired when the video has finished loading the first frame
  		vid.onloadeddata = bind(this.fire, this, 'load');

  		if (wasElementSupplied) {
  			var sourceElements = vid.getElementsByTagName('source');
  			var sources = [];
  			for (var j = 0; j < sourceElements.length; j++) {
  				sources.push(sourceElements[j].src);
  			}

  			this._url = (sourceElements.length > 0) ? sources : [vid.src];
  			return;
  		}

  		if (!isArray(this._url)) { this._url = [this._url]; }

  		if (!this.options.keepAspectRatio && Object.prototype.hasOwnProperty.call(vid.style, 'objectFit')) {
  			vid.style['objectFit'] = 'fill';
  		}
  		vid.autoplay = !!this.options.autoplay;
  		vid.loop = !!this.options.loop;
  		vid.muted = !!this.options.muted;
  		for (var i = 0; i < this._url.length; i++) {
  			var source = create$1('source');
  			source.src = this._url[i];
  			vid.appendChild(source);
  		}
  	}

  	// @method getElement(): HTMLVideoElement
  	// Returns the instance of [`HTMLVideoElement`](https://developer.mozilla.org/docs/Web/API/HTMLVideoElement)
  	// used by this overlay.
  });


  // @factory L.videoOverlay(video: String|Array|HTMLVideoElement, bounds: LatLngBounds, options?: VideoOverlay options)
  // Instantiates an image overlay object given the URL of the video (or array of URLs, or even a video element) and the
  // geographical bounds it is tied to.

  function videoOverlay(video, bounds, options) {
  	return new VideoOverlay(video, bounds, options);
  }

  /*
   * @class SVGOverlay
   * @aka L.SVGOverlay
   * @inherits ImageOverlay
   *
   * Used to load, display and provide DOM access to an SVG file over specific bounds of the map. Extends `ImageOverlay`.
   *
   * An SVG overlay uses the [`<svg>`](https://developer.mozilla.org/docs/Web/SVG/Element/svg) element.
   *
   * @example
   *
   * ```js
   * var svgElement = document.createElementNS("http://www.w3.org/2000/svg", "svg");
   * svgElement.setAttribute('xmlns', "http://www.w3.org/2000/svg");
   * svgElement.setAttribute('viewBox', "0 0 200 200");
   * svgElement.innerHTML = '<rect width="200" height="200"/><rect x="75" y="23" width="50" height="50" style="fill:red"/><rect x="75" y="123" width="50" height="50" style="fill:#0013ff"/>';
   * var svgElementBounds = [ [ 32, -130 ], [ 13, -100 ] ];
   * L.svgOverlay(svgElement, svgElementBounds).addTo(map);
   * ```
   */

  var SVGOverlay = ImageOverlay.extend({
  	_initImage: function () {
  		var el = this._image = this._url;

  		addClass(el, 'leaflet-image-layer');
  		if (this._zoomAnimated) { addClass(el, 'leaflet-zoom-animated'); }
  		if (this.options.className) { addClass(el, this.options.className); }

  		el.onselectstart = falseFn;
  		el.onmousemove = falseFn;
  	}

  	// @method getElement(): SVGElement
  	// Returns the instance of [`SVGElement`](https://developer.mozilla.org/docs/Web/API/SVGElement)
  	// used by this overlay.
  });


  // @factory L.svgOverlay(svg: String|SVGElement, bounds: LatLngBounds, options?: SVGOverlay options)
  // Instantiates an image overlay object given an SVG element and the geographical bounds it is tied to.
  // A viewBox attribute is required on the SVG element to zoom in and out properly.

  function svgOverlay(el, bounds, options) {
  	return new SVGOverlay(el, bounds, options);
  }

  /*
   * @class DivOverlay
   * @inherits Layer
   * @aka L.DivOverlay
   * Base model for L.Popup and L.Tooltip. Inherit from it for custom popup like plugins.
   */

  // @namespace DivOverlay
  var DivOverlay = Layer.extend({

  	// @section
  	// @aka DivOverlay options
  	options: {
  		// @option offset: Point = Point(0, 7)
  		// The offset of the popup position. Useful to control the anchor
  		// of the popup when opening it on some overlays.
  		offset: [0, 7],

  		// @option className: String = ''
  		// A custom CSS class name to assign to the popup.
  		className: '',

  		// @option pane: String = 'popupPane'
  		// `Map pane` where the popup will be added.
  		pane: 'popupPane'
  	},

  	initialize: function (options, source) {
  		setOptions(this, options);

  		this._source = source;
  	},

  	onAdd: function (map) {
  		this._zoomAnimated = map._zoomAnimated;

  		if (!this._container) {
  			this._initLayout();
  		}

  		if (map._fadeAnimated) {
  			setOpacity(this._container, 0);
  		}

  		clearTimeout(this._removeTimeout);
  		this.getPane().appendChild(this._container);
  		this.update();

  		if (map._fadeAnimated) {
  			setOpacity(this._container, 1);
  		}

  		this.bringToFront();
  	},

  	onRemove: function (map) {
  		if (map._fadeAnimated) {
  			setOpacity(this._container, 0);
  			this._removeTimeout = setTimeout(bind(remove, undefined, this._container), 200);
  		} else {
  			remove(this._container);
  		}
  	},

  	// @namespace Popup
  	// @method getLatLng: LatLng
  	// Returns the geographical point of popup.
  	getLatLng: function () {
  		return this._latlng;
  	},

  	// @method setLatLng(latlng: LatLng): this
  	// Sets the geographical point where the popup will open.
  	setLatLng: function (latlng) {
  		this._latlng = toLatLng(latlng);
  		if (this._map) {
  			this._updatePosition();
  			this._adjustPan();
  		}
  		return this;
  	},

  	// @method getContent: String|HTMLElement
  	// Returns the content of the popup.
  	getContent: function () {
  		return this._content;
  	},

  	// @method setContent(htmlContent: String|HTMLElement|Function): this
  	// Sets the HTML content of the popup. If a function is passed the source layer will be passed to the function. The function should return a `String` or `HTMLElement` to be used in the popup.
  	setContent: function (content) {
  		this._content = content;
  		this.update();
  		return this;
  	},

  	// @method getElement: String|HTMLElement
  	// Returns the HTML container of the popup.
  	getElement: function () {
  		return this._container;
  	},

  	// @method update: null
  	// Updates the popup content, layout and position. Useful for updating the popup after something inside changed, e.g. image loaded.
  	update: function () {
  		if (!this._map) { return; }

  		this._container.style.visibility = 'hidden';

  		this._updateContent();
  		this._updateLayout();
  		this._updatePosition();

  		this._container.style.visibility = '';

  		this._adjustPan();
  	},

  	getEvents: function () {
  		var events = {
  			zoom: this._updatePosition,
  			viewreset: this._updatePosition
  		};

  		if (this._zoomAnimated) {
  			events.zoomanim = this._animateZoom;
  		}
  		return events;
  	},

  	// @method isOpen: Boolean
  	// Returns `true` when the popup is visible on the map.
  	isOpen: function () {
  		return !!this._map && this._map.hasLayer(this);
  	},

  	// @method bringToFront: this
  	// Brings this popup in front of other popups (in the same map pane).
  	bringToFront: function () {
  		if (this._map) {
  			toFront(this._container);
  		}
  		return this;
  	},

  	// @method bringToBack: this
  	// Brings this popup to the back of other popups (in the same map pane).
  	bringToBack: function () {
  		if (this._map) {
  			toBack(this._container);
  		}
  		return this;
  	},

  	_prepareOpen: function (parent, layer, latlng) {
  		if (!(layer instanceof Layer)) {
  			latlng = layer;
  			layer = parent;
  		}

  		if (layer instanceof FeatureGroup) {
  			for (var id in parent._layers) {
  				layer = parent._layers[id];
  				break;
  			}
  		}

  		if (!latlng) {
  			if (layer.getCenter) {
  				latlng = layer.getCenter();
  			} else if (layer.getLatLng) {
  				latlng = layer.getLatLng();
  			} else {
  				throw new Error('Unable to get source layer LatLng.');
  			}
  		}

  		// set overlay source to this layer
  		this._source = layer;

  		// update the overlay (content, layout, ect...)
  		this.update();

  		return latlng;
  	},

  	_updateContent: function () {
  		if (!this._content) { return; }

  		var node = this._contentNode;
  		var content = (typeof this._content === 'function') ? this._content(this._source || this) : this._content;

  		if (typeof content === 'string') {
  			node.innerHTML = content;
  		} else {
  			while (node.hasChildNodes()) {
  				node.removeChild(node.firstChild);
  			}
  			node.appendChild(content);
  		}
  		this.fire('contentupdate');
  	},

  	_updatePosition: function () {
  		if (!this._map) { return; }

  		var pos = this._map.latLngToLayerPoint(this._latlng),
  		    offset = toPoint(this.options.offset),
  		    anchor = this._getAnchor();

  		if (this._zoomAnimated) {
  			setPosition(this._container, pos.add(anchor));
  		} else {
  			offset = offset.add(pos).add(anchor);
  		}

  		var bottom = this._containerBottom = -offset.y,
  		    left = this._containerLeft = -Math.round(this._containerWidth / 2) + offset.x;

  		// bottom position the popup in case the height of the popup changes (images loading etc)
  		this._container.style.bottom = bottom + 'px';
  		this._container.style.left = left + 'px';
  	},

  	_getAnchor: function () {
  		return [0, 0];
  	}

  });

  /*
   * @class Popup
   * @inherits DivOverlay
   * @aka L.Popup
   * Used to open popups in certain places of the map. Use [Map.openPopup](#map-openpopup) to
   * open popups while making sure that only one popup is open at one time
   * (recommended for usability), or use [Map.addLayer](#map-addlayer) to open as many as you want.
   *
   * @example
   *
   * If you want to just bind a popup to marker click and then open it, it's really easy:
   *
   * ```js
   * marker.bindPopup(popupContent).openPopup();
   * ```
   * Path overlays like polylines also have a `bindPopup` method.
   * Here's a more complicated way to open a popup on a map:
   *
   * ```js
   * var popup = L.popup()
   * 	.setLatLng(latlng)
   * 	.setContent('<p>Hello world!<br />This is a nice popup.</p>')
   * 	.openOn(map);
   * ```
   */


  // @namespace Popup
  var Popup = DivOverlay.extend({

  	// @section
  	// @aka Popup options
  	options: {
  		// @option maxWidth: Number = 300
  		// Max width of the popup, in pixels.
  		maxWidth: 300,

  		// @option minWidth: Number = 50
  		// Min width of the popup, in pixels.
  		minWidth: 50,

  		// @option maxHeight: Number = null
  		// If set, creates a scrollable container of the given height
  		// inside a popup if its content exceeds it.
  		maxHeight: null,

  		// @option autoPan: Boolean = true
  		// Set it to `false` if you don't want the map to do panning animation
  		// to fit the opened popup.
  		autoPan: true,

  		// @option autoPanPaddingTopLeft: Point = null
  		// The margin between the popup and the top left corner of the map
  		// view after autopanning was performed.
  		autoPanPaddingTopLeft: null,

  		// @option autoPanPaddingBottomRight: Point = null
  		// The margin between the popup and the bottom right corner of the map
  		// view after autopanning was performed.
  		autoPanPaddingBottomRight: null,

  		// @option autoPanPadding: Point = Point(5, 5)
  		// Equivalent of setting both top left and bottom right autopan padding to the same value.
  		autoPanPadding: [5, 5],

  		// @option keepInView: Boolean = false
  		// Set it to `true` if you want to prevent users from panning the popup
  		// off of the screen while it is open.
  		keepInView: false,

  		// @option closeButton: Boolean = true
  		// Controls the presence of a close button in the popup.
  		closeButton: true,

  		// @option autoClose: Boolean = true
  		// Set it to `false` if you want to override the default behavior of
  		// the popup closing when another popup is opened.
  		autoClose: true,

  		// @option closeOnEscapeKey: Boolean = true
  		// Set it to `false` if you want to override the default behavior of
  		// the ESC key for closing of the popup.
  		closeOnEscapeKey: true,

  		// @option closeOnClick: Boolean = *
  		// Set it if you want to override the default behavior of the popup closing when user clicks
  		// on the map. Defaults to the map's [`closePopupOnClick`](#map-closepopuponclick) option.

  		// @option className: String = ''
  		// A custom CSS class name to assign to the popup.
  		className: ''
  	},

  	// @namespace Popup
  	// @method openOn(map: Map): this
  	// Adds the popup to the map and closes the previous one. The same as `map.openPopup(popup)`.
  	openOn: function (map) {
  		map.openPopup(this);
  		return this;
  	},

  	onAdd: function (map) {
  		DivOverlay.prototype.onAdd.call(this, map);

  		// @namespace Map
  		// @section Popup events
  		// @event popupopen: PopupEvent
  		// Fired when a popup is opened in the map
  		map.fire('popupopen', {popup: this});

  		if (this._source) {
  			// @namespace Layer
  			// @section Popup events
  			// @event popupopen: PopupEvent
  			// Fired when a popup bound to this layer is opened
  			this._source.fire('popupopen', {popup: this}, true);
  			// For non-path layers, we toggle the popup when clicking
  			// again the layer, so prevent the map to reopen it.
  			if (!(this._source instanceof Path)) {
  				this._source.on('preclick', stopPropagation);
  			}
  		}
  	},

  	onRemove: function (map) {
  		DivOverlay.prototype.onRemove.call(this, map);

  		// @namespace Map
  		// @section Popup events
  		// @event popupclose: PopupEvent
  		// Fired when a popup in the map is closed
  		map.fire('popupclose', {popup: this});

  		if (this._source) {
  			// @namespace Layer
  			// @section Popup events
  			// @event popupclose: PopupEvent
  			// Fired when a popup bound to this layer is closed
  			this._source.fire('popupclose', {popup: this}, true);
  			if (!(this._source instanceof Path)) {
  				this._source.off('preclick', stopPropagation);
  			}
  		}
  	},

  	getEvents: function () {
  		var events = DivOverlay.prototype.getEvents.call(this);

  		if (this.options.closeOnClick !== undefined ? this.options.closeOnClick : this._map.options.closePopupOnClick) {
  			events.preclick = this._close;
  		}

  		if (this.options.keepInView) {
  			events.moveend = this._adjustPan;
  		}

  		return events;
  	},

  	_close: function () {
  		if (this._map) {
  			this._map.closePopup(this);
  		}
  	},

  	_initLayout: function () {
  		var prefix = 'leaflet-popup',
  		    container = this._container = create$1('div',
  			prefix + ' ' + (this.options.className || '') +
  			' leaflet-zoom-animated');

  		var wrapper = this._wrapper = create$1('div', prefix + '-content-wrapper', container);
  		this._contentNode = create$1('div', prefix + '-content', wrapper);

  		disableClickPropagation(container);
  		disableScrollPropagation(this._contentNode);
  		on(container, 'contextmenu', stopPropagation);

  		this._tipContainer = create$1('div', prefix + '-tip-container', container);
  		this._tip = create$1('div', prefix + '-tip', this._tipContainer);

  		if (this.options.closeButton) {
  			var closeButton = this._closeButton = create$1('a', prefix + '-close-button', container);
  			closeButton.href = '#close';
  			closeButton.innerHTML = '&#215;';

  			on(closeButton, 'click', this._onCloseButtonClick, this);
  		}
  	},

  	_updateLayout: function () {
  		var container = this._contentNode,
  		    style = container.style;

  		style.width = '';
  		style.whiteSpace = 'nowrap';

  		var width = container.offsetWidth;
  		width = Math.min(width, this.options.maxWidth);
  		width = Math.max(width, this.options.minWidth);

  		style.width = (width + 1) + 'px';
  		style.whiteSpace = '';

  		style.height = '';

  		var height = container.offsetHeight,
  		    maxHeight = this.options.maxHeight,
  		    scrolledClass = 'leaflet-popup-scrolled';

  		if (maxHeight && height > maxHeight) {
  			style.height = maxHeight + 'px';
  			addClass(container, scrolledClass);
  		} else {
  			removeClass(container, scrolledClass);
  		}

  		this._containerWidth = this._container.offsetWidth;
  	},

  	_animateZoom: function (e) {
  		var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center),
  		    anchor = this._getAnchor();
  		setPosition(this._container, pos.add(anchor));
  	},

  	_adjustPan: function () {
  		if (!this.options.autoPan) { return; }
  		if (this._map._panAnim) { this._map._panAnim.stop(); }

  		var map = this._map,
  		    marginBottom = parseInt(getStyle(this._container, 'marginBottom'), 10) || 0,
  		    containerHeight = this._container.offsetHeight + marginBottom,
  		    containerWidth = this._containerWidth,
  		    layerPos = new Point(this._containerLeft, -containerHeight - this._containerBottom);

  		layerPos._add(getPosition(this._container));

  		var containerPos = map.layerPointToContainerPoint(layerPos),
  		    padding = toPoint(this.options.autoPanPadding),
  		    paddingTL = toPoint(this.options.autoPanPaddingTopLeft || padding),
  		    paddingBR = toPoint(this.options.autoPanPaddingBottomRight || padding),
  		    size = map.getSize(),
  		    dx = 0,
  		    dy = 0;

  		if (containerPos.x + containerWidth + paddingBR.x > size.x) { // right
  			dx = containerPos.x + containerWidth - size.x + paddingBR.x;
  		}
  		if (containerPos.x - dx - paddingTL.x < 0) { // left
  			dx = containerPos.x - paddingTL.x;
  		}
  		if (containerPos.y + containerHeight + paddingBR.y > size.y) { // bottom
  			dy = containerPos.y + containerHeight - size.y + paddingBR.y;
  		}
  		if (containerPos.y - dy - paddingTL.y < 0) { // top
  			dy = containerPos.y - paddingTL.y;
  		}

  		// @namespace Map
  		// @section Popup events
  		// @event autopanstart: Event
  		// Fired when the map starts autopanning when opening a popup.
  		if (dx || dy) {
  			map
  			    .fire('autopanstart')
  			    .panBy([dx, dy]);
  		}
  	},

  	_onCloseButtonClick: function (e) {
  		this._close();
  		stop(e);
  	},

  	_getAnchor: function () {
  		// Where should we anchor the popup on the source layer?
  		return toPoint(this._source && this._source._getPopupAnchor ? this._source._getPopupAnchor() : [0, 0]);
  	}

  });

  // @namespace Popup
  // @factory L.popup(options?: Popup options, source?: Layer)
  // Instantiates a `Popup` object given an optional `options` object that describes its appearance and location and an optional `source` object that is used to tag the popup with a reference to the Layer to which it refers.
  var popup = function (options, source) {
  	return new Popup(options, source);
  };


  /* @namespace Map
   * @section Interaction Options
   * @option closePopupOnClick: Boolean = true
   * Set it to `false` if you don't want popups to close when user clicks the map.
   */
  Map.mergeOptions({
  	closePopupOnClick: true
  });


  // @namespace Map
  // @section Methods for Layers and Controls
  Map.include({
  	// @method openPopup(popup: Popup): this
  	// Opens the specified popup while closing the previously opened (to make sure only one is opened at one time for usability).
  	// @alternative
  	// @method openPopup(content: String|HTMLElement, latlng: LatLng, options?: Popup options): this
  	// Creates a popup with the specified content and options and opens it in the given point on a map.
  	openPopup: function (popup, latlng, options) {
  		if (!(popup instanceof Popup)) {
  			popup = new Popup(options).setContent(popup);
  		}

  		if (latlng) {
  			popup.setLatLng(latlng);
  		}

  		if (this.hasLayer(popup)) {
  			return this;
  		}

  		if (this._popup && this._popup.options.autoClose) {
  			this.closePopup();
  		}

  		this._popup = popup;
  		return this.addLayer(popup);
  	},

  	// @method closePopup(popup?: Popup): this
  	// Closes the popup previously opened with [openPopup](#map-openpopup) (or the given one).
  	closePopup: function (popup) {
  		if (!popup || popup === this._popup) {
  			popup = this._popup;
  			this._popup = null;
  		}
  		if (popup) {
  			this.removeLayer(popup);
  		}
  		return this;
  	}
  });

  /*
   * @namespace Layer
   * @section Popup methods example
   *
   * All layers share a set of methods convenient for binding popups to it.
   *
   * ```js
   * var layer = L.Polygon(latlngs).bindPopup('Hi There!').addTo(map);
   * layer.openPopup();
   * layer.closePopup();
   * ```
   *
   * Popups will also be automatically opened when the layer is clicked on and closed when the layer is removed from the map or another popup is opened.
   */

  // @section Popup methods
  Layer.include({

  	// @method bindPopup(content: String|HTMLElement|Function|Popup, options?: Popup options): this
  	// Binds a popup to the layer with the passed `content` and sets up the
  	// necessary event listeners. If a `Function` is passed it will receive
  	// the layer as the first argument and should return a `String` or `HTMLElement`.
  	bindPopup: function (content, options) {

  		if (content instanceof Popup) {
  			setOptions(content, options);
  			this._popup = content;
  			content._source = this;
  		} else {
  			if (!this._popup || options) {
  				this._popup = new Popup(options, this);
  			}
  			this._popup.setContent(content);
  		}

  		if (!this._popupHandlersAdded) {
  			this.on({
  				click: this._openPopup,
  				keypress: this._onKeyPress,
  				remove: this.closePopup,
  				move: this._movePopup
  			});
  			this._popupHandlersAdded = true;
  		}

  		return this;
  	},

  	// @method unbindPopup(): this
  	// Removes the popup previously bound with `bindPopup`.
  	unbindPopup: function () {
  		if (this._popup) {
  			this.off({
  				click: this._openPopup,
  				keypress: this._onKeyPress,
  				remove: this.closePopup,
  				move: this._movePopup
  			});
  			this._popupHandlersAdded = false;
  			this._popup = null;
  		}
  		return this;
  	},

  	// @method openPopup(latlng?: LatLng): this
  	// Opens the bound popup at the specified `latlng` or at the default popup anchor if no `latlng` is passed.
  	openPopup: function (layer, latlng) {
  		if (this._popup && this._map) {
  			latlng = this._popup._prepareOpen(this, layer, latlng);

  			// open the popup on the map
  			this._map.openPopup(this._popup, latlng);
  		}

  		return this;
  	},

  	// @method closePopup(): this
  	// Closes the popup bound to this layer if it is open.
  	closePopup: function () {
  		if (this._popup) {
  			this._popup._close();
  		}
  		return this;
  	},

  	// @method togglePopup(): this
  	// Opens or closes the popup bound to this layer depending on its current state.
  	togglePopup: function (target) {
  		if (this._popup) {
  			if (this._popup._map) {
  				this.closePopup();
  			} else {
  				this.openPopup(target);
  			}
  		}
  		return this;
  	},

  	// @method isPopupOpen(): boolean
  	// Returns `true` if the popup bound to this layer is currently open.
  	isPopupOpen: function () {
  		return (this._popup ? this._popup.isOpen() : false);
  	},

  	// @method setPopupContent(content: String|HTMLElement|Popup): this
  	// Sets the content of the popup bound to this layer.
  	setPopupContent: function (content) {
  		if (this._popup) {
  			this._popup.setContent(content);
  		}
  		return this;
  	},

  	// @method getPopup(): Popup
  	// Returns the popup bound to this layer.
  	getPopup: function () {
  		return this._popup;
  	},

  	_openPopup: function (e) {
  		var layer = e.layer || e.target;

  		if (!this._popup) {
  			return;
  		}

  		if (!this._map) {
  			return;
  		}

  		// prevent map click
  		stop(e);

  		// if this inherits from Path its a vector and we can just
  		// open the popup at the new location
  		if (layer instanceof Path) {
  			this.openPopup(e.layer || e.target, e.latlng);
  			return;
  		}

  		// otherwise treat it like a marker and figure out
  		// if we should toggle it open/closed
  		if (this._map.hasLayer(this._popup) && this._popup._source === layer) {
  			this.closePopup();
  		} else {
  			this.openPopup(layer, e.latlng);
  		}
  	},

  	_movePopup: function (e) {
  		this._popup.setLatLng(e.latlng);
  	},

  	_onKeyPress: function (e) {
  		if (e.originalEvent.keyCode === 13) {
  			this._openPopup(e);
  		}
  	}
  });

  /*
   * @class Tooltip
   * @inherits DivOverlay
   * @aka L.Tooltip
   * Used to display small texts on top of map layers.
   *
   * @example
   *
   * ```js
   * marker.bindTooltip("my tooltip text").openTooltip();
   * ```
   * Note about tooltip offset. Leaflet takes two options in consideration
   * for computing tooltip offsetting:
   * - the `offset` Tooltip option: it defaults to [0, 0], and it's specific to one tooltip.
   *   Add a positive x offset to move the tooltip to the right, and a positive y offset to
   *   move it to the bottom. Negatives will move to the left and top.
   * - the `tooltipAnchor` Icon option: this will only be considered for Marker. You
   *   should adapt this value if you use a custom icon.
   */


  // @namespace Tooltip
  var Tooltip = DivOverlay.extend({

  	// @section
  	// @aka Tooltip options
  	options: {
  		// @option pane: String = 'tooltipPane'
  		// `Map pane` where the tooltip will be added.
  		pane: 'tooltipPane',

  		// @option offset: Point = Point(0, 0)
  		// Optional offset of the tooltip position.
  		offset: [0, 0],

  		// @option direction: String = 'auto'
  		// Direction where to open the tooltip. Possible values are: `right`, `left`,
  		// `top`, `bottom`, `center`, `auto`.
  		// `auto` will dynamically switch between `right` and `left` according to the tooltip
  		// position on the map.
  		direction: 'auto',

  		// @option permanent: Boolean = false
  		// Whether to open the tooltip permanently or only on mouseover.
  		permanent: false,

  		// @option sticky: Boolean = false
  		// If true, the tooltip will follow the mouse instead of being fixed at the feature center.
  		sticky: false,

  		// @option interactive: Boolean = false
  		// If true, the tooltip will listen to the feature events.
  		interactive: false,

  		// @option opacity: Number = 0.9
  		// Tooltip container opacity.
  		opacity: 0.9
  	},

  	onAdd: function (map) {
  		DivOverlay.prototype.onAdd.call(this, map);
  		this.setOpacity(this.options.opacity);

  		// @namespace Map
  		// @section Tooltip events
  		// @event tooltipopen: TooltipEvent
  		// Fired when a tooltip is opened in the map.
  		map.fire('tooltipopen', {tooltip: this});

  		if (this._source) {
  			// @namespace Layer
  			// @section Tooltip events
  			// @event tooltipopen: TooltipEvent
  			// Fired when a tooltip bound to this layer is opened.
  			this._source.fire('tooltipopen', {tooltip: this}, true);
  		}
  	},

  	onRemove: function (map) {
  		DivOverlay.prototype.onRemove.call(this, map);

  		// @namespace Map
  		// @section Tooltip events
  		// @event tooltipclose: TooltipEvent
  		// Fired when a tooltip in the map is closed.
  		map.fire('tooltipclose', {tooltip: this});

  		if (this._source) {
  			// @namespace Layer
  			// @section Tooltip events
  			// @event tooltipclose: TooltipEvent
  			// Fired when a tooltip bound to this layer is closed.
  			this._source.fire('tooltipclose', {tooltip: this}, true);
  		}
  	},

  	getEvents: function () {
  		var events = DivOverlay.prototype.getEvents.call(this);

  		if (touch && !this.options.permanent) {
  			events.preclick = this._close;
  		}

  		return events;
  	},

  	_close: function () {
  		if (this._map) {
  			this._map.closeTooltip(this);
  		}
  	},

  	_initLayout: function () {
  		var prefix = 'leaflet-tooltip',
  		    className = prefix + ' ' + (this.options.className || '') + ' leaflet-zoom-' + (this._zoomAnimated ? 'animated' : 'hide');

  		this._contentNode = this._container = create$1('div', className);
  	},

  	_updateLayout: function () {},

  	_adjustPan: function () {},

  	_setPosition: function (pos) {
  		var subX, subY,
  		    map = this._map,
  		    container = this._container,
  		    centerPoint = map.latLngToContainerPoint(map.getCenter()),
  		    tooltipPoint = map.layerPointToContainerPoint(pos),
  		    direction = this.options.direction,
  		    tooltipWidth = container.offsetWidth,
  		    tooltipHeight = container.offsetHeight,
  		    offset = toPoint(this.options.offset),
  		    anchor = this._getAnchor();

  		if (direction === 'top') {
  			subX = tooltipWidth / 2;
  			subY = tooltipHeight;
  		} else if (direction === 'bottom') {
  			subX = tooltipWidth / 2;
  			subY = 0;
  		} else if (direction === 'center') {
  			subX = tooltipWidth / 2;
  			subY = tooltipHeight / 2;
  		} else if (direction === 'right') {
  			subX = 0;
  			subY = tooltipHeight / 2;
  		} else if (direction === 'left') {
  			subX = tooltipWidth;
  			subY = tooltipHeight / 2;
  		} else if (tooltipPoint.x < centerPoint.x) {
  			direction = 'right';
  			subX = 0;
  			subY = tooltipHeight / 2;
  		} else {
  			direction = 'left';
  			subX = tooltipWidth + (offset.x + anchor.x) * 2;
  			subY = tooltipHeight / 2;
  		}

  		pos = pos.subtract(toPoint(subX, subY, true)).add(offset).add(anchor);

  		removeClass(container, 'leaflet-tooltip-right');
  		removeClass(container, 'leaflet-tooltip-left');
  		removeClass(container, 'leaflet-tooltip-top');
  		removeClass(container, 'leaflet-tooltip-bottom');
  		addClass(container, 'leaflet-tooltip-' + direction);
  		setPosition(container, pos);
  	},

  	_updatePosition: function () {
  		var pos = this._map.latLngToLayerPoint(this._latlng);
  		this._setPosition(pos);
  	},

  	setOpacity: function (opacity) {
  		this.options.opacity = opacity;

  		if (this._container) {
  			setOpacity(this._container, opacity);
  		}
  	},

  	_animateZoom: function (e) {
  		var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center);
  		this._setPosition(pos);
  	},

  	_getAnchor: function () {
  		// Where should we anchor the tooltip on the source layer?
  		return toPoint(this._source && this._source._getTooltipAnchor && !this.options.sticky ? this._source._getTooltipAnchor() : [0, 0]);
  	}

  });

  // @namespace Tooltip
  // @factory L.tooltip(options?: Tooltip options, source?: Layer)
  // Instantiates a Tooltip object given an optional `options` object that describes its appearance and location and an optional `source` object that is used to tag the tooltip with a reference to the Layer to which it refers.
  var tooltip = function (options, source) {
  	return new Tooltip(options, source);
  };

  // @namespace Map
  // @section Methods for Layers and Controls
  Map.include({

  	// @method openTooltip(tooltip: Tooltip): this
  	// Opens the specified tooltip.
  	// @alternative
  	// @method openTooltip(content: String|HTMLElement, latlng: LatLng, options?: Tooltip options): this
  	// Creates a tooltip with the specified content and options and open it.
  	openTooltip: function (tooltip, latlng, options) {
  		if (!(tooltip instanceof Tooltip)) {
  			tooltip = new Tooltip(options).setContent(tooltip);
  		}

  		if (latlng) {
  			tooltip.setLatLng(latlng);
  		}

  		if (this.hasLayer(tooltip)) {
  			return this;
  		}

  		return this.addLayer(tooltip);
  	},

  	// @method closeTooltip(tooltip?: Tooltip): this
  	// Closes the tooltip given as parameter.
  	closeTooltip: function (tooltip) {
  		if (tooltip) {
  			this.removeLayer(tooltip);
  		}
  		return this;
  	}

  });

  /*
   * @namespace Layer
   * @section Tooltip methods example
   *
   * All layers share a set of methods convenient for binding tooltips to it.
   *
   * ```js
   * var layer = L.Polygon(latlngs).bindTooltip('Hi There!').addTo(map);
   * layer.openTooltip();
   * layer.closeTooltip();
   * ```
   */

  // @section Tooltip methods
  Layer.include({

  	// @method bindTooltip(content: String|HTMLElement|Function|Tooltip, options?: Tooltip options): this
  	// Binds a tooltip to the layer with the passed `content` and sets up the
  	// necessary event listeners. If a `Function` is passed it will receive
  	// the layer as the first argument and should return a `String` or `HTMLElement`.
  	bindTooltip: function (content, options) {

  		if (content instanceof Tooltip) {
  			setOptions(content, options);
  			this._tooltip = content;
  			content._source = this;
  		} else {
  			if (!this._tooltip || options) {
  				this._tooltip = new Tooltip(options, this);
  			}
  			this._tooltip.setContent(content);

  		}

  		this._initTooltipInteractions();

  		if (this._tooltip.options.permanent && this._map && this._map.hasLayer(this)) {
  			this.openTooltip();
  		}

  		return this;
  	},

  	// @method unbindTooltip(): this
  	// Removes the tooltip previously bound with `bindTooltip`.
  	unbindTooltip: function () {
  		if (this._tooltip) {
  			this._initTooltipInteractions(true);
  			this.closeTooltip();
  			this._tooltip = null;
  		}
  		return this;
  	},

  	_initTooltipInteractions: function (remove$$1) {
  		if (!remove$$1 && this._tooltipHandlersAdded) { return; }
  		var onOff = remove$$1 ? 'off' : 'on',
  		    events = {
  			remove: this.closeTooltip,
  			move: this._moveTooltip
  		    };
  		if (!this._tooltip.options.permanent) {
  			events.mouseover = this._openTooltip;
  			events.mouseout = this.closeTooltip;
  			if (this._tooltip.options.sticky) {
  				events.mousemove = this._moveTooltip;
  			}
  			if (touch) {
  				events.click = this._openTooltip;
  			}
  		} else {
  			events.add = this._openTooltip;
  		}
  		this[onOff](events);
  		this._tooltipHandlersAdded = !remove$$1;
  	},

  	// @method openTooltip(latlng?: LatLng): this
  	// Opens the bound tooltip at the specified `latlng` or at the default tooltip anchor if no `latlng` is passed.
  	openTooltip: function (layer, latlng) {
  		if (this._tooltip && this._map) {
  			latlng = this._tooltip._prepareOpen(this, layer, latlng);

  			// open the tooltip on the map
  			this._map.openTooltip(this._tooltip, latlng);

  			// Tooltip container may not be defined if not permanent and never
  			// opened.
  			if (this._tooltip.options.interactive && this._tooltip._container) {
  				addClass(this._tooltip._container, 'leaflet-clickable');
  				this.addInteractiveTarget(this._tooltip._container);
  			}
  		}

  		return this;
  	},

  	// @method closeTooltip(): this
  	// Closes the tooltip bound to this layer if it is open.
  	closeTooltip: function () {
  		if (this._tooltip) {
  			this._tooltip._close();
  			if (this._tooltip.options.interactive && this._tooltip._container) {
  				removeClass(this._tooltip._container, 'leaflet-clickable');
  				this.removeInteractiveTarget(this._tooltip._container);
  			}
  		}
  		return this;
  	},

  	// @method toggleTooltip(): this
  	// Opens or closes the tooltip bound to this layer depending on its current state.
  	toggleTooltip: function (target) {
  		if (this._tooltip) {
  			if (this._tooltip._map) {
  				this.closeTooltip();
  			} else {
  				this.openTooltip(target);
  			}
  		}
  		return this;
  	},

  	// @method isTooltipOpen(): boolean
  	// Returns `true` if the tooltip bound to this layer is currently open.
  	isTooltipOpen: function () {
  		return this._tooltip.isOpen();
  	},

  	// @method setTooltipContent(content: String|HTMLElement|Tooltip): this
  	// Sets the content of the tooltip bound to this layer.
  	setTooltipContent: function (content) {
  		if (this._tooltip) {
  			this._tooltip.setContent(content);
  		}
  		return this;
  	},

  	// @method getTooltip(): Tooltip
  	// Returns the tooltip bound to this layer.
  	getTooltip: function () {
  		return this._tooltip;
  	},

  	_openTooltip: function (e) {
  		var layer = e.layer || e.target;

  		if (!this._tooltip || !this._map) {
  			return;
  		}
  		this.openTooltip(layer, this._tooltip.options.sticky ? e.latlng : undefined);
  	},

  	_moveTooltip: function (e) {
  		var latlng = e.latlng, containerPoint, layerPoint;
  		if (this._tooltip.options.sticky && e.originalEvent) {
  			containerPoint = this._map.mouseEventToContainerPoint(e.originalEvent);
  			layerPoint = this._map.containerPointToLayerPoint(containerPoint);
  			latlng = this._map.layerPointToLatLng(layerPoint);
  		}
  		this._tooltip.setLatLng(latlng);
  	}
  });

  /*
   * @class DivIcon
   * @aka L.DivIcon
   * @inherits Icon
   *
   * Represents a lightweight icon for markers that uses a simple `<div>`
   * element instead of an image. Inherits from `Icon` but ignores the `iconUrl` and shadow options.
   *
   * @example
   * ```js
   * var myIcon = L.divIcon({className: 'my-div-icon'});
   * // you can set .my-div-icon styles in CSS
   *
   * L.marker([50.505, 30.57], {icon: myIcon}).addTo(map);
   * ```
   *
   * By default, it has a 'leaflet-div-icon' CSS class and is styled as a little white square with a shadow.
   */

  var DivIcon = Icon.extend({
  	options: {
  		// @section
  		// @aka DivIcon options
  		iconSize: [12, 12], // also can be set through CSS

  		// iconAnchor: (Point),
  		// popupAnchor: (Point),

  		// @option html: String|HTMLElement = ''
  		// Custom HTML code to put inside the div element, empty by default. Alternatively,
  		// an instance of `HTMLElement`.
  		html: false,

  		// @option bgPos: Point = [0, 0]
  		// Optional relative position of the background, in pixels
  		bgPos: null,

  		className: 'leaflet-div-icon'
  	},

  	createIcon: function (oldIcon) {
  		var div = (oldIcon && oldIcon.tagName === 'DIV') ? oldIcon : document.createElement('div'),
  		    options = this.options;

  		if (options.html instanceof Element) {
  			empty(div);
  			div.appendChild(options.html);
  		} else {
  			div.innerHTML = options.html !== false ? options.html : '';
  		}

  		if (options.bgPos) {
  			var bgPos = toPoint(options.bgPos);
  			div.style.backgroundPosition = (-bgPos.x) + 'px ' + (-bgPos.y) + 'px';
  		}
  		this._setIconStyles(div, 'icon');

  		return div;
  	},

  	createShadow: function () {
  		return null;
  	}
  });

  // @factory L.divIcon(options: DivIcon options)
  // Creates a `DivIcon` instance with the given options.
  function divIcon(options) {
  	return new DivIcon(options);
  }

  Icon.Default = IconDefault;

  /*
   * @class GridLayer
   * @inherits Layer
   * @aka L.GridLayer
   *
   * Generic class for handling a tiled grid of HTML elements. This is the base class for all tile layers and replaces `TileLayer.Canvas`.
   * GridLayer can be extended to create a tiled grid of HTML elements like `<canvas>`, `<img>` or `<div>`. GridLayer will handle creating and animating these DOM elements for you.
   *
   *
   * @section Synchronous usage
   * @example
   *
   * To create a custom layer, extend GridLayer and implement the `createTile()` method, which will be passed a `Point` object with the `x`, `y`, and `z` (zoom level) coordinates to draw your tile.
   *
   * ```js
   * var CanvasLayer = L.GridLayer.extend({
   *     createTile: function(coords){
   *         // create a <canvas> element for drawing
   *         var tile = L.DomUtil.create('canvas', 'leaflet-tile');
   *
   *         // setup tile width and height according to the options
   *         var size = this.getTileSize();
   *         tile.width = size.x;
   *         tile.height = size.y;
   *
   *         // get a canvas context and draw something on it using coords.x, coords.y and coords.z
   *         var ctx = tile.getContext('2d');
   *
   *         // return the tile so it can be rendered on screen
   *         return tile;
   *     }
   * });
   * ```
   *
   * @section Asynchronous usage
   * @example
   *
   * Tile creation can also be asynchronous, this is useful when using a third-party drawing library. Once the tile is finished drawing it can be passed to the `done()` callback.
   *
   * ```js
   * var CanvasLayer = L.GridLayer.extend({
   *     createTile: function(coords, done){
   *         var error;
   *
   *         // create a <canvas> element for drawing
   *         var tile = L.DomUtil.create('canvas', 'leaflet-tile');
   *
   *         // setup tile width and height according to the options
   *         var size = this.getTileSize();
   *         tile.width = size.x;
   *         tile.height = size.y;
   *
   *         // draw something asynchronously and pass the tile to the done() callback
   *         setTimeout(function() {
   *             done(error, tile);
   *         }, 1000);
   *
   *         return tile;
   *     }
   * });
   * ```
   *
   * @section
   */


  var GridLayer = Layer.extend({

  	// @section
  	// @aka GridLayer options
  	options: {
  		// @option tileSize: Number|Point = 256
  		// Width and height of tiles in the grid. Use a number if width and height are equal, or `L.point(width, height)` otherwise.
  		tileSize: 256,

  		// @option opacity: Number = 1.0
  		// Opacity of the tiles. Can be used in the `createTile()` function.
  		opacity: 1,

  		// @option updateWhenIdle: Boolean = (depends)
  		// Load new tiles only when panning ends.
  		// `true` by default on mobile browsers, in order to avoid too many requests and keep smooth navigation.
  		// `false` otherwise in order to display new tiles _during_ panning, since it is easy to pan outside the
  		// [`keepBuffer`](#gridlayer-keepbuffer) option in desktop browsers.
  		updateWhenIdle: mobile,

  		// @option updateWhenZooming: Boolean = true
  		// By default, a smooth zoom animation (during a [touch zoom](#map-touchzoom) or a [`flyTo()`](#map-flyto)) will update grid layers every integer zoom level. Setting this option to `false` will update the grid layer only when the smooth animation ends.
  		updateWhenZooming: true,

  		// @option updateInterval: Number = 200
  		// Tiles will not update more than once every `updateInterval` milliseconds when panning.
  		updateInterval: 200,

  		// @option zIndex: Number = 1
  		// The explicit zIndex of the tile layer.
  		zIndex: 1,

  		// @option bounds: LatLngBounds = undefined
  		// If set, tiles will only be loaded inside the set `LatLngBounds`.
  		bounds: null,

  		// @option minZoom: Number = 0
  		// The minimum zoom level down to which this layer will be displayed (inclusive).
  		minZoom: 0,

  		// @option maxZoom: Number = undefined
  		// The maximum zoom level up to which this layer will be displayed (inclusive).
  		maxZoom: undefined,

  		// @option maxNativeZoom: Number = undefined
  		// Maximum zoom number the tile source has available. If it is specified,
  		// the tiles on all zoom levels higher than `maxNativeZoom` will be loaded
  		// from `maxNativeZoom` level and auto-scaled.
  		maxNativeZoom: undefined,

  		// @option minNativeZoom: Number = undefined
  		// Minimum zoom number the tile source has available. If it is specified,
  		// the tiles on all zoom levels lower than `minNativeZoom` will be loaded
  		// from `minNativeZoom` level and auto-scaled.
  		minNativeZoom: undefined,

  		// @option noWrap: Boolean = false
  		// Whether the layer is wrapped around the antimeridian. If `true`, the
  		// GridLayer will only be displayed once at low zoom levels. Has no
  		// effect when the [map CRS](#map-crs) doesn't wrap around. Can be used
  		// in combination with [`bounds`](#gridlayer-bounds) to prevent requesting
  		// tiles outside the CRS limits.
  		noWrap: false,

  		// @option pane: String = 'tilePane'
  		// `Map pane` where the grid layer will be added.
  		pane: 'tilePane',

  		// @option className: String = ''
  		// A custom class name to assign to the tile layer. Empty by default.
  		className: '',

  		// @option keepBuffer: Number = 2
  		// When panning the map, keep this many rows and columns of tiles before unloading them.
  		keepBuffer: 2
  	},

  	initialize: function (options) {
  		setOptions(this, options);
  	},

  	onAdd: function () {
  		this._initContainer();

  		this._levels = {};
  		this._tiles = {};

  		this._resetView();
  		this._update();
  	},

  	beforeAdd: function (map) {
  		map._addZoomLimit(this);
  	},

  	onRemove: function (map) {
  		this._removeAllTiles();
  		remove(this._container);
  		map._removeZoomLimit(this);
  		this._container = null;
  		this._tileZoom = undefined;
  	},

  	// @method bringToFront: this
  	// Brings the tile layer to the top of all tile layers.
  	bringToFront: function () {
  		if (this._map) {
  			toFront(this._container);
  			this._setAutoZIndex(Math.max);
  		}
  		return this;
  	},

  	// @method bringToBack: this
  	// Brings the tile layer to the bottom of all tile layers.
  	bringToBack: function () {
  		if (this._map) {
  			toBack(this._container);
  			this._setAutoZIndex(Math.min);
  		}
  		return this;
  	},

  	// @method getContainer: HTMLElement
  	// Returns the HTML element that contains the tiles for this layer.
  	getContainer: function () {
  		return this._container;
  	},

  	// @method setOpacity(opacity: Number): this
  	// Changes the [opacity](#gridlayer-opacity) of the grid layer.
  	setOpacity: function (opacity) {
  		this.options.opacity = opacity;
  		this._updateOpacity();
  		return this;
  	},

  	// @method setZIndex(zIndex: Number): this
  	// Changes the [zIndex](#gridlayer-zindex) of the grid layer.
  	setZIndex: function (zIndex) {
  		this.options.zIndex = zIndex;
  		this._updateZIndex();

  		return this;
  	},

  	// @method isLoading: Boolean
  	// Returns `true` if any tile in the grid layer has not finished loading.
  	isLoading: function () {
  		return this._loading;
  	},

  	// @method redraw: this
  	// Causes the layer to clear all the tiles and request them again.
  	redraw: function () {
  		if (this._map) {
  			this._removeAllTiles();
  			this._update();
  		}
  		return this;
  	},

  	getEvents: function () {
  		var events = {
  			viewprereset: this._invalidateAll,
  			viewreset: this._resetView,
  			zoom: this._resetView,
  			moveend: this._onMoveEnd
  		};

  		if (!this.options.updateWhenIdle) {
  			// update tiles on move, but not more often than once per given interval
  			if (!this._onMove) {
  				this._onMove = throttle(this._onMoveEnd, this.options.updateInterval, this);
  			}

  			events.move = this._onMove;
  		}

  		if (this._zoomAnimated) {
  			events.zoomanim = this._animateZoom;
  		}

  		return events;
  	},

  	// @section Extension methods
  	// Layers extending `GridLayer` shall reimplement the following method.
  	// @method createTile(coords: Object, done?: Function): HTMLElement
  	// Called only internally, must be overridden by classes extending `GridLayer`.
  	// Returns the `HTMLElement` corresponding to the given `coords`. If the `done` callback
  	// is specified, it must be called when the tile has finished loading and drawing.
  	createTile: function () {
  		return document.createElement('div');
  	},

  	// @section
  	// @method getTileSize: Point
  	// Normalizes the [tileSize option](#gridlayer-tilesize) into a point. Used by the `createTile()` method.
  	getTileSize: function () {
  		var s = this.options.tileSize;
  		return s instanceof Point ? s : new Point(s, s);
  	},

  	_updateZIndex: function () {
  		if (this._container && this.options.zIndex !== undefined && this.options.zIndex !== null) {
  			this._container.style.zIndex = this.options.zIndex;
  		}
  	},

  	_setAutoZIndex: function (compare) {
  		// go through all other layers of the same pane, set zIndex to max + 1 (front) or min - 1 (back)

  		var layers = this.getPane().children,
  		    edgeZIndex = -compare(-Infinity, Infinity); // -Infinity for max, Infinity for min

  		for (var i = 0, len = layers.length, zIndex; i < len; i++) {

  			zIndex = layers[i].style.zIndex;

  			if (layers[i] !== this._container && zIndex) {
  				edgeZIndex = compare(edgeZIndex, +zIndex);
  			}
  		}

  		if (isFinite(edgeZIndex)) {
  			this.options.zIndex = edgeZIndex + compare(-1, 1);
  			this._updateZIndex();
  		}
  	},

  	_updateOpacity: function () {
  		if (!this._map) { return; }

  		// IE doesn't inherit filter opacity properly, so we're forced to set it on tiles
  		if (ielt9) { return; }

  		setOpacity(this._container, this.options.opacity);

  		var now = +new Date(),
  		    nextFrame = false,
  		    willPrune = false;

  		for (var key in this._tiles) {
  			var tile = this._tiles[key];
  			if (!tile.current || !tile.loaded) { continue; }

  			var fade = Math.min(1, (now - tile.loaded) / 200);

  			setOpacity(tile.el, fade);
  			if (fade < 1) {
  				nextFrame = true;
  			} else {
  				if (tile.active) {
  					willPrune = true;
  				} else {
  					this._onOpaqueTile(tile);
  				}
  				tile.active = true;
  			}
  		}

  		if (willPrune && !this._noPrune) { this._pruneTiles(); }

  		if (nextFrame) {
  			cancelAnimFrame(this._fadeFrame);
  			this._fadeFrame = requestAnimFrame(this._updateOpacity, this);
  		}
  	},

  	_onOpaqueTile: falseFn,

  	_initContainer: function () {
  		if (this._container) { return; }

  		this._container = create$1('div', 'leaflet-layer ' + (this.options.className || ''));
  		this._updateZIndex();

  		if (this.options.opacity < 1) {
  			this._updateOpacity();
  		}

  		this.getPane().appendChild(this._container);
  	},

  	_updateLevels: function () {

  		var zoom = this._tileZoom,
  		    maxZoom = this.options.maxZoom;

  		if (zoom === undefined) { return undefined; }

  		for (var z in this._levels) {
  			z = Number(z);
  			if (this._levels[z].el.children.length || z === zoom) {
  				this._levels[z].el.style.zIndex = maxZoom - Math.abs(zoom - z);
  				this._onUpdateLevel(z);
  			} else {
  				remove(this._levels[z].el);
  				this._removeTilesAtZoom(z);
  				this._onRemoveLevel(z);
  				delete this._levels[z];
  			}
  		}

  		var level = this._levels[zoom],
  		    map = this._map;

  		if (!level) {
  			level = this._levels[zoom] = {};

  			level.el = create$1('div', 'leaflet-tile-container leaflet-zoom-animated', this._container);
  			level.el.style.zIndex = maxZoom;

  			level.origin = map.project(map.unproject(map.getPixelOrigin()), zoom).round();
  			level.zoom = zoom;

  			this._setZoomTransform(level, map.getCenter(), map.getZoom());

  			// force the browser to consider the newly added element for transition
  			falseFn(level.el.offsetWidth);

  			this._onCreateLevel(level);
  		}

  		this._level = level;

  		return level;
  	},

  	_onUpdateLevel: falseFn,

  	_onRemoveLevel: falseFn,

  	_onCreateLevel: falseFn,

  	_pruneTiles: function () {
  		if (!this._map) {
  			return;
  		}

  		var key, tile;

  		var zoom = this._map.getZoom();
  		if (zoom > this.options.maxZoom ||
  			zoom < this.options.minZoom) {
  			this._removeAllTiles();
  			return;
  		}

  		for (key in this._tiles) {
  			tile = this._tiles[key];
  			tile.retain = tile.current;
  		}

  		for (key in this._tiles) {
  			tile = this._tiles[key];
  			if (tile.current && !tile.active) {
  				var coords = tile.coords;
  				if (!this._retainParent(coords.x, coords.y, coords.z, coords.z - 5)) {
  					this._retainChildren(coords.x, coords.y, coords.z, coords.z + 2);
  				}
  			}
  		}

  		for (key in this._tiles) {
  			if (!this._tiles[key].retain) {
  				this._removeTile(key);
  			}
  		}
  	},

  	_removeTilesAtZoom: function (zoom) {
  		for (var key in this._tiles) {
  			if (this._tiles[key].coords.z !== zoom) {
  				continue;
  			}
  			this._removeTile(key);
  		}
  	},

  	_removeAllTiles: function () {
  		for (var key in this._tiles) {
  			this._removeTile(key);
  		}
  	},

  	_invalidateAll: function () {
  		for (var z in this._levels) {
  			remove(this._levels[z].el);
  			this._onRemoveLevel(Number(z));
  			delete this._levels[z];
  		}
  		this._removeAllTiles();

  		this._tileZoom = undefined;
  	},

  	_retainParent: function (x, y, z, minZoom) {
  		var x2 = Math.floor(x / 2),
  		    y2 = Math.floor(y / 2),
  		    z2 = z - 1,
  		    coords2 = new Point(+x2, +y2);
  		coords2.z = +z2;

  		var key = this._tileCoordsToKey(coords2),
  		    tile = this._tiles[key];

  		if (tile && tile.active) {
  			tile.retain = true;
  			return true;

  		} else if (tile && tile.loaded) {
  			tile.retain = true;
  		}

  		if (z2 > minZoom) {
  			return this._retainParent(x2, y2, z2, minZoom);
  		}

  		return false;
  	},

  	_retainChildren: function (x, y, z, maxZoom) {

  		for (var i = 2 * x; i < 2 * x + 2; i++) {
  			for (var j = 2 * y; j < 2 * y + 2; j++) {

  				var coords = new Point(i, j);
  				coords.z = z + 1;

  				var key = this._tileCoordsToKey(coords),
  				    tile = this._tiles[key];

  				if (tile && tile.active) {
  					tile.retain = true;
  					continue;

  				} else if (tile && tile.loaded) {
  					tile.retain = true;
  				}

  				if (z + 1 < maxZoom) {
  					this._retainChildren(i, j, z + 1, maxZoom);
  				}
  			}
  		}
  	},

  	_resetView: function (e) {
  		var animating = e && (e.pinch || e.flyTo);
  		this._setView(this._map.getCenter(), this._map.getZoom(), animating, animating);
  	},

  	_animateZoom: function (e) {
  		this._setView(e.center, e.zoom, true, e.noUpdate);
  	},

  	_clampZoom: function (zoom) {
  		var options = this.options;

  		if (undefined !== options.minNativeZoom && zoom < options.minNativeZoom) {
  			return options.minNativeZoom;
  		}

  		if (undefined !== options.maxNativeZoom && options.maxNativeZoom < zoom) {
  			return options.maxNativeZoom;
  		}

  		return zoom;
  	},

  	_setView: function (center, zoom, noPrune, noUpdate) {
  		var tileZoom = Math.round(zoom);
  		if ((this.options.maxZoom !== undefined && tileZoom > this.options.maxZoom) ||
  		    (this.options.minZoom !== undefined && tileZoom < this.options.minZoom)) {
  			tileZoom = undefined;
  		} else {
  			tileZoom = this._clampZoom(tileZoom);
  		}

  		var tileZoomChanged = this.options.updateWhenZooming && (tileZoom !== this._tileZoom);

  		if (!noUpdate || tileZoomChanged) {

  			this._tileZoom = tileZoom;

  			if (this._abortLoading) {
  				this._abortLoading();
  			}

  			this._updateLevels();
  			this._resetGrid();

  			if (tileZoom !== undefined) {
  				this._update(center);
  			}

  			if (!noPrune) {
  				this._pruneTiles();
  			}

  			// Flag to prevent _updateOpacity from pruning tiles during
  			// a zoom anim or a pinch gesture
  			this._noPrune = !!noPrune;
  		}

  		this._setZoomTransforms(center, zoom);
  	},

  	_setZoomTransforms: function (center, zoom) {
  		for (var i in this._levels) {
  			this._setZoomTransform(this._levels[i], center, zoom);
  		}
  	},

  	_setZoomTransform: function (level, center, zoom) {
  		var scale = this._map.getZoomScale(zoom, level.zoom),
  		    translate = level.origin.multiplyBy(scale)
  		        .subtract(this._map._getNewPixelOrigin(center, zoom)).round();

  		if (any3d) {
  			setTransform(level.el, translate, scale);
  		} else {
  			setPosition(level.el, translate);
  		}
  	},

  	_resetGrid: function () {
  		var map = this._map,
  		    crs = map.options.crs,
  		    tileSize = this._tileSize = this.getTileSize(),
  		    tileZoom = this._tileZoom;

  		var bounds = this._map.getPixelWorldBounds(this._tileZoom);
  		if (bounds) {
  			this._globalTileRange = this._pxBoundsToTileRange(bounds);
  		}

  		this._wrapX = crs.wrapLng && !this.options.noWrap && [
  			Math.floor(map.project([0, crs.wrapLng[0]], tileZoom).x / tileSize.x),
  			Math.ceil(map.project([0, crs.wrapLng[1]], tileZoom).x / tileSize.y)
  		];
  		this._wrapY = crs.wrapLat && !this.options.noWrap && [
  			Math.floor(map.project([crs.wrapLat[0], 0], tileZoom).y / tileSize.x),
  			Math.ceil(map.project([crs.wrapLat[1], 0], tileZoom).y / tileSize.y)
  		];
  	},

  	_onMoveEnd: function () {
  		if (!this._map || this._map._animatingZoom) { return; }

  		this._update();
  	},

  	_getTiledPixelBounds: function (center) {
  		var map = this._map,
  		    mapZoom = map._animatingZoom ? Math.max(map._animateToZoom, map.getZoom()) : map.getZoom(),
  		    scale = map.getZoomScale(mapZoom, this._tileZoom),
  		    pixelCenter = map.project(center, this._tileZoom).floor(),
  		    halfSize = map.getSize().divideBy(scale * 2);

  		return new Bounds(pixelCenter.subtract(halfSize), pixelCenter.add(halfSize));
  	},

  	// Private method to load tiles in the grid's active zoom level according to map bounds
  	_update: function (center) {
  		var map = this._map;
  		if (!map) { return; }
  		var zoom = this._clampZoom(map.getZoom());

  		if (center === undefined) { center = map.getCenter(); }
  		if (this._tileZoom === undefined) { return; }	// if out of minzoom/maxzoom

  		var pixelBounds = this._getTiledPixelBounds(center),
  		    tileRange = this._pxBoundsToTileRange(pixelBounds),
  		    tileCenter = tileRange.getCenter(),
  		    queue = [],
  		    margin = this.options.keepBuffer,
  		    noPruneRange = new Bounds(tileRange.getBottomLeft().subtract([margin, -margin]),
  		                              tileRange.getTopRight().add([margin, -margin]));

  		// Sanity check: panic if the tile range contains Infinity somewhere.
  		if (!(isFinite(tileRange.min.x) &&
  		      isFinite(tileRange.min.y) &&
  		      isFinite(tileRange.max.x) &&
  		      isFinite(tileRange.max.y))) { throw new Error('Attempted to load an infinite number of tiles'); }

  		for (var key in this._tiles) {
  			var c = this._tiles[key].coords;
  			if (c.z !== this._tileZoom || !noPruneRange.contains(new Point(c.x, c.y))) {
  				this._tiles[key].current = false;
  			}
  		}

  		// _update just loads more tiles. If the tile zoom level differs too much
  		// from the map's, let _setView reset levels and prune old tiles.
  		if (Math.abs(zoom - this._tileZoom) > 1) { this._setView(center, zoom); return; }

  		// create a queue of coordinates to load tiles from
  		for (var j = tileRange.min.y; j <= tileRange.max.y; j++) {
  			for (var i = tileRange.min.x; i <= tileRange.max.x; i++) {
  				var coords = new Point(i, j);
  				coords.z = this._tileZoom;

  				if (!this._isValidTile(coords)) { continue; }

  				var tile = this._tiles[this._tileCoordsToKey(coords)];
  				if (tile) {
  					tile.current = true;
  				} else {
  					queue.push(coords);
  				}
  			}
  		}

  		// sort tile queue to load tiles in order of their distance to center
  		queue.sort(function (a, b) {
  			return a.distanceTo(tileCenter) - b.distanceTo(tileCenter);
  		});

  		if (queue.length !== 0) {
  			// if it's the first batch of tiles to load
  			if (!this._loading) {
  				this._loading = true;
  				// @event loading: Event
  				// Fired when the grid layer starts loading tiles.
  				this.fire('loading');
  			}

  			// create DOM fragment to append tiles in one batch
  			var fragment = document.createDocumentFragment();

  			for (i = 0; i < queue.length; i++) {
  				this._addTile(queue[i], fragment);
  			}

  			this._level.el.appendChild(fragment);
  		}
  	},

  	_isValidTile: function (coords) {
  		var crs = this._map.options.crs;

  		if (!crs.infinite) {
  			// don't load tile if it's out of bounds and not wrapped
  			var bounds = this._globalTileRange;
  			if ((!crs.wrapLng && (coords.x < bounds.min.x || coords.x > bounds.max.x)) ||
  			    (!crs.wrapLat && (coords.y < bounds.min.y || coords.y > bounds.max.y))) { return false; }
  		}

  		if (!this.options.bounds) { return true; }

  		// don't load tile if it doesn't intersect the bounds in options
  		var tileBounds = this._tileCoordsToBounds(coords);
  		return toLatLngBounds(this.options.bounds).overlaps(tileBounds);
  	},

  	_keyToBounds: function (key) {
  		return this._tileCoordsToBounds(this._keyToTileCoords(key));
  	},

  	_tileCoordsToNwSe: function (coords) {
  		var map = this._map,
  		    tileSize = this.getTileSize(),
  		    nwPoint = coords.scaleBy(tileSize),
  		    sePoint = nwPoint.add(tileSize),
  		    nw = map.unproject(nwPoint, coords.z),
  		    se = map.unproject(sePoint, coords.z);
  		return [nw, se];
  	},

  	// converts tile coordinates to its geographical bounds
  	_tileCoordsToBounds: function (coords) {
  		var bp = this._tileCoordsToNwSe(coords),
  		    bounds = new LatLngBounds(bp[0], bp[1]);

  		if (!this.options.noWrap) {
  			bounds = this._map.wrapLatLngBounds(bounds);
  		}
  		return bounds;
  	},
  	// converts tile coordinates to key for the tile cache
  	_tileCoordsToKey: function (coords) {
  		return coords.x + ':' + coords.y + ':' + coords.z;
  	},

  	// converts tile cache key to coordinates
  	_keyToTileCoords: function (key) {
  		var k = key.split(':'),
  		    coords = new Point(+k[0], +k[1]);
  		coords.z = +k[2];
  		return coords;
  	},

  	_removeTile: function (key) {
  		var tile = this._tiles[key];
  		if (!tile) { return; }

  		remove(tile.el);

  		delete this._tiles[key];

  		// @event tileunload: TileEvent
  		// Fired when a tile is removed (e.g. when a tile goes off the screen).
  		this.fire('tileunload', {
  			tile: tile.el,
  			coords: this._keyToTileCoords(key)
  		});
  	},

  	_initTile: function (tile) {
  		addClass(tile, 'leaflet-tile');

  		var tileSize = this.getTileSize();
  		tile.style.width = tileSize.x + 'px';
  		tile.style.height = tileSize.y + 'px';

  		tile.onselectstart = falseFn;
  		tile.onmousemove = falseFn;

  		// update opacity on tiles in IE7-8 because of filter inheritance problems
  		if (ielt9 && this.options.opacity < 1) {
  			setOpacity(tile, this.options.opacity);
  		}

  		// without this hack, tiles disappear after zoom on Chrome for Android
  		// https://github.com/Leaflet/Leaflet/issues/2078
  		if (android && !android23) {
  			tile.style.WebkitBackfaceVisibility = 'hidden';
  		}
  	},

  	_addTile: function (coords, container) {
  		var tilePos = this._getTilePos(coords),
  		    key = this._tileCoordsToKey(coords);

  		var tile = this.createTile(this._wrapCoords(coords), bind(this._tileReady, this, coords));

  		this._initTile(tile);

  		// if createTile is defined with a second argument ("done" callback),
  		// we know that tile is async and will be ready later; otherwise
  		if (this.createTile.length < 2) {
  			// mark tile as ready, but delay one frame for opacity animation to happen
  			requestAnimFrame(bind(this._tileReady, this, coords, null, tile));
  		}

  		setPosition(tile, tilePos);

  		// save tile in cache
  		this._tiles[key] = {
  			el: tile,
  			coords: coords,
  			current: true
  		};

  		container.appendChild(tile);
  		// @event tileloadstart: TileEvent
  		// Fired when a tile is requested and starts loading.
  		this.fire('tileloadstart', {
  			tile: tile,
  			coords: coords
  		});
  	},

  	_tileReady: function (coords, err, tile) {
  		if (err) {
  			// @event tileerror: TileErrorEvent
  			// Fired when there is an error loading a tile.
  			this.fire('tileerror', {
  				error: err,
  				tile: tile,
  				coords: coords
  			});
  		}

  		var key = this._tileCoordsToKey(coords);

  		tile = this._tiles[key];
  		if (!tile) { return; }

  		tile.loaded = +new Date();
  		if (this._map._fadeAnimated) {
  			setOpacity(tile.el, 0);
  			cancelAnimFrame(this._fadeFrame);
  			this._fadeFrame = requestAnimFrame(this._updateOpacity, this);
  		} else {
  			tile.active = true;
  			this._pruneTiles();
  		}

  		if (!err) {
  			addClass(tile.el, 'leaflet-tile-loaded');

  			// @event tileload: TileEvent
  			// Fired when a tile loads.
  			this.fire('tileload', {
  				tile: tile.el,
  				coords: coords
  			});
  		}

  		if (this._noTilesToLoad()) {
  			this._loading = false;
  			// @event load: Event
  			// Fired when the grid layer loaded all visible tiles.
  			this.fire('load');

  			if (ielt9 || !this._map._fadeAnimated) {
  				requestAnimFrame(this._pruneTiles, this);
  			} else {
  				// Wait a bit more than 0.2 secs (the duration of the tile fade-in)
  				// to trigger a pruning.
  				setTimeout(bind(this._pruneTiles, this), 250);
  			}
  		}
  	},

  	_getTilePos: function (coords) {
  		return coords.scaleBy(this.getTileSize()).subtract(this._level.origin);
  	},

  	_wrapCoords: function (coords) {
  		var newCoords = new Point(
  			this._wrapX ? wrapNum(coords.x, this._wrapX) : coords.x,
  			this._wrapY ? wrapNum(coords.y, this._wrapY) : coords.y);
  		newCoords.z = coords.z;
  		return newCoords;
  	},

  	_pxBoundsToTileRange: function (bounds) {
  		var tileSize = this.getTileSize();
  		return new Bounds(
  			bounds.min.unscaleBy(tileSize).floor(),
  			bounds.max.unscaleBy(tileSize).ceil().subtract([1, 1]));
  	},

  	_noTilesToLoad: function () {
  		for (var key in this._tiles) {
  			if (!this._tiles[key].loaded) { return false; }
  		}
  		return true;
  	}
  });

  // @factory L.gridLayer(options?: GridLayer options)
  // Creates a new instance of GridLayer with the supplied options.
  function gridLayer(options) {
  	return new GridLayer(options);
  }

  /*
   * @class TileLayer
   * @inherits GridLayer
   * @aka L.TileLayer
   * Used to load and display tile layers on the map. Note that most tile servers require attribution, which you can set under `Layer`. Extends `GridLayer`.
   *
   * @example
   *
   * ```js
   * L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png?{foo}', {foo: 'bar', attribution: 'Map data &copy; <a href="https://www.openstreetmap.org/">OpenStreetMap</a> contributors, <a href="https://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>'}).addTo(map);
   * ```
   *
   * @section URL template
   * @example
   *
   * A string of the following form:
   *
   * ```
   * 'http://{s}.somedomain.com/blabla/{z}/{x}/{y}{r}.png'
   * ```
   *
   * `{s}` means one of the available subdomains (used sequentially to help with browser parallel requests per domain limitation; subdomain values are specified in options; `a`, `b` or `c` by default, can be omitted), `{z}`  zoom level, `{x}` and `{y}`  tile coordinates. `{r}` can be used to add "&commat;2x" to the URL to load retina tiles.
   *
   * You can use custom keys in the template, which will be [evaluated](#util-template) from TileLayer options, like this:
   *
   * ```
   * L.tileLayer('http://{s}.somedomain.com/{foo}/{z}/{x}/{y}.png', {foo: 'bar'});
   * ```
   */


  var TileLayer = GridLayer.extend({

  	// @section
  	// @aka TileLayer options
  	options: {
  		// @option minZoom: Number = 0
  		// The minimum zoom level down to which this layer will be displayed (inclusive).
  		minZoom: 0,

  		// @option maxZoom: Number = 18
  		// The maximum zoom level up to which this layer will be displayed (inclusive).
  		maxZoom: 18,

  		// @option subdomains: String|String[] = 'abc'
  		// Subdomains of the tile service. Can be passed in the form of one string (where each letter is a subdomain name) or an array of strings.
  		subdomains: 'abc',

  		// @option errorTileUrl: String = ''
  		// URL to the tile image to show in place of the tile that failed to load.
  		errorTileUrl: '',

  		// @option zoomOffset: Number = 0
  		// The zoom number used in tile URLs will be offset with this value.
  		zoomOffset: 0,

  		// @option tms: Boolean = false
  		// If `true`, inverses Y axis numbering for tiles (turn this on for [TMS](https://en.wikipedia.org/wiki/Tile_Map_Service) services).
  		tms: false,

  		// @option zoomReverse: Boolean = false
  		// If set to true, the zoom number used in tile URLs will be reversed (`maxZoom - zoom` instead of `zoom`)
  		zoomReverse: false,

  		// @option detectRetina: Boolean = false
  		// If `true` and user is on a retina display, it will request four tiles of half the specified size and a bigger zoom level in place of one to utilize the high resolution.
  		detectRetina: false,

  		// @option crossOrigin: Boolean|String = false
  		// Whether the crossOrigin attribute will be added to the tiles.
  		// If a String is provided, all tiles will have their crossOrigin attribute set to the String provided. This is needed if you want to access tile pixel data.
  		// Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.
  		crossOrigin: false
  	},

  	initialize: function (url, options) {

  		this._url = url;

  		options = setOptions(this, options);

  		// detecting retina displays, adjusting tileSize and zoom levels
  		if (options.detectRetina && retina && options.maxZoom > 0) {

  			options.tileSize = Math.floor(options.tileSize / 2);

  			if (!options.zoomReverse) {
  				options.zoomOffset++;
  				options.maxZoom--;
  			} else {
  				options.zoomOffset--;
  				options.minZoom++;
  			}

  			options.minZoom = Math.max(0, options.minZoom);
  		}

  		if (typeof options.subdomains === 'string') {
  			options.subdomains = options.subdomains.split('');
  		}

  		// for https://github.com/Leaflet/Leaflet/issues/137
  		if (!android) {
  			this.on('tileunload', this._onTileRemove);
  		}
  	},

  	// @method setUrl(url: String, noRedraw?: Boolean): this
  	// Updates the layer's URL template and redraws it (unless `noRedraw` is set to `true`).
  	// If the URL does not change, the layer will not be redrawn unless
  	// the noRedraw parameter is set to false.
  	setUrl: function (url, noRedraw) {
  		if (this._url === url && noRedraw === undefined) {
  			noRedraw = true;
  		}

  		this._url = url;

  		if (!noRedraw) {
  			this.redraw();
  		}
  		return this;
  	},

  	// @method createTile(coords: Object, done?: Function): HTMLElement
  	// Called only internally, overrides GridLayer's [`createTile()`](#gridlayer-createtile)
  	// to return an `<img>` HTML element with the appropriate image URL given `coords`. The `done`
  	// callback is called when the tile has been loaded.
  	createTile: function (coords, done) {
  		var tile = document.createElement('img');

  		on(tile, 'load', bind(this._tileOnLoad, this, done, tile));
  		on(tile, 'error', bind(this._tileOnError, this, done, tile));

  		if (this.options.crossOrigin || this.options.crossOrigin === '') {
  			tile.crossOrigin = this.options.crossOrigin === true ? '' : this.options.crossOrigin;
  		}

  		/*
  		 Alt tag is set to empty string to keep screen readers from reading URL and for compliance reasons
  		 http://www.w3.org/TR/WCAG20-TECHS/H67
  		*/
  		tile.alt = '';

  		/*
  		 Set role="presentation" to force screen readers to ignore this
  		 https://www.w3.org/TR/wai-aria/roles#textalternativecomputation
  		*/
  		tile.setAttribute('role', 'presentation');

  		tile.src = this.getTileUrl(coords);

  		return tile;
  	},

  	// @section Extension methods
  	// @uninheritable
  	// Layers extending `TileLayer` might reimplement the following method.
  	// @method getTileUrl(coords: Object): String
  	// Called only internally, returns the URL for a tile given its coordinates.
  	// Classes extending `TileLayer` can override this function to provide custom tile URL naming schemes.
  	getTileUrl: function (coords) {
  		var data = {
  			r: retina ? '@2x' : '',
  			s: this._getSubdomain(coords),
  			x: coords.x,
  			y: coords.y,
  			z: this._getZoomForUrl()
  		};
  		if (this._map && !this._map.options.crs.infinite) {
  			var invertedY = this._globalTileRange.max.y - coords.y;
  			if (this.options.tms) {
  				data['y'] = invertedY;
  			}
  			data['-y'] = invertedY;
  		}

  		return template(this._url, extend(data, this.options));
  	},

  	_tileOnLoad: function (done, tile) {
  		// For https://github.com/Leaflet/Leaflet/issues/3332
  		if (ielt9) {
  			setTimeout(bind(done, this, null, tile), 0);
  		} else {
  			done(null, tile);
  		}
  	},

  	_tileOnError: function (done, tile, e) {
  		var errorUrl = this.options.errorTileUrl;
  		if (errorUrl && tile.getAttribute('src') !== errorUrl) {
  			tile.src = errorUrl;
  		}
  		done(e, tile);
  	},

  	_onTileRemove: function (e) {
  		e.tile.onload = null;
  	},

  	_getZoomForUrl: function () {
  		var zoom = this._tileZoom,
  		maxZoom = this.options.maxZoom,
  		zoomReverse = this.options.zoomReverse,
  		zoomOffset = this.options.zoomOffset;

  		if (zoomReverse) {
  			zoom = maxZoom - zoom;
  		}

  		return zoom + zoomOffset;
  	},

  	_getSubdomain: function (tilePoint) {
  		var index = Math.abs(tilePoint.x + tilePoint.y) % this.options.subdomains.length;
  		return this.options.subdomains[index];
  	},

  	// stops loading all tiles in the background layer
  	_abortLoading: function () {
  		var i, tile;
  		for (i in this._tiles) {
  			if (this._tiles[i].coords.z !== this._tileZoom) {
  				tile = this._tiles[i].el;

  				tile.onload = falseFn;
  				tile.onerror = falseFn;

  				if (!tile.complete) {
  					tile.src = emptyImageUrl;
  					remove(tile);
  					delete this._tiles[i];
  				}
  			}
  		}
  	},

  	_removeTile: function (key) {
  		var tile = this._tiles[key];
  		if (!tile) { return; }

  		// Cancels any pending http requests associated with the tile
  		// unless we're on Android's stock browser,
  		// see https://github.com/Leaflet/Leaflet/issues/137
  		if (!androidStock) {
  			tile.el.setAttribute('src', emptyImageUrl);
  		}

  		return GridLayer.prototype._removeTile.call(this, key);
  	},

  	_tileReady: function (coords, err, tile) {
  		if (!this._map || (tile && tile.getAttribute('src') === emptyImageUrl)) {
  			return;
  		}

  		return GridLayer.prototype._tileReady.call(this, coords, err, tile);
  	}
  });


  // @factory L.tilelayer(urlTemplate: String, options?: TileLayer options)
  // Instantiates a tile layer object given a `URL template` and optionally an options object.

  function tileLayer(url, options) {
  	return new TileLayer(url, options);
  }

  /*
   * @class TileLayer.WMS
   * @inherits TileLayer
   * @aka L.TileLayer.WMS
   * Used to display [WMS](https://en.wikipedia.org/wiki/Web_Map_Service) services as tile layers on the map. Extends `TileLayer`.
   *
   * @example
   *
   * ```js
   * var nexrad = L.tileLayer.wms("http://mesonet.agron.iastate.edu/cgi-bin/wms/nexrad/n0r.cgi", {
   * 	layers: 'nexrad-n0r-900913',
   * 	format: 'image/png',
   * 	transparent: true,
   * 	attribution: "Weather data  2012 IEM Nexrad"
   * });
   * ```
   */

  var TileLayerWMS = TileLayer.extend({

  	// @section
  	// @aka TileLayer.WMS options
  	// If any custom options not documented here are used, they will be sent to the
  	// WMS server as extra parameters in each request URL. This can be useful for
  	// [non-standard vendor WMS parameters](http://docs.geoserver.org/stable/en/user/services/wms/vendor.html).
  	defaultWmsParams: {
  		service: 'WMS',
  		request: 'GetMap',

  		// @option layers: String = ''
  		// **(required)** Comma-separated list of WMS layers to show.
  		layers: '',

  		// @option styles: String = ''
  		// Comma-separated list of WMS styles.
  		styles: '',

  		// @option format: String = 'image/jpeg'
  		// WMS image format (use `'image/png'` for layers with transparency).
  		format: 'image/jpeg',

  		// @option transparent: Boolean = false
  		// If `true`, the WMS service will return images with transparency.
  		transparent: false,

  		// @option version: String = '1.1.1'
  		// Version of the WMS service to use
  		version: '1.1.1'
  	},

  	options: {
  		// @option crs: CRS = null
  		// Coordinate Reference System to use for the WMS requests, defaults to
  		// map CRS. Don't change this if you're not sure what it means.
  		crs: null,

  		// @option uppercase: Boolean = false
  		// If `true`, WMS request parameter keys will be uppercase.
  		uppercase: false
  	},

  	initialize: function (url, options) {

  		this._url = url;

  		var wmsParams = extend({}, this.defaultWmsParams);

  		// all keys that are not TileLayer options go to WMS params
  		for (var i in options) {
  			if (!(i in this.options)) {
  				wmsParams[i] = options[i];
  			}
  		}

  		options = setOptions(this, options);

  		var realRetina = options.detectRetina && retina ? 2 : 1;
  		var tileSize = this.getTileSize();
  		wmsParams.width = tileSize.x * realRetina;
  		wmsParams.height = tileSize.y * realRetina;

  		this.wmsParams = wmsParams;
  	},

  	onAdd: function (map) {

  		this._crs = this.options.crs || map.options.crs;
  		this._wmsVersion = parseFloat(this.wmsParams.version);

  		var projectionKey = this._wmsVersion >= 1.3 ? 'crs' : 'srs';
  		this.wmsParams[projectionKey] = this._crs.code;

  		TileLayer.prototype.onAdd.call(this, map);
  	},

  	getTileUrl: function (coords) {

  		var tileBounds = this._tileCoordsToNwSe(coords),
  		    crs = this._crs,
  		    bounds = toBounds(crs.project(tileBounds[0]), crs.project(tileBounds[1])),
  		    min = bounds.min,
  		    max = bounds.max,
  		    bbox = (this._wmsVersion >= 1.3 && this._crs === EPSG4326 ?
  		    [min.y, min.x, max.y, max.x] :
  		    [min.x, min.y, max.x, max.y]).join(','),
  		    url = TileLayer.prototype.getTileUrl.call(this, coords);
  		return url +
  			getParamString(this.wmsParams, url, this.options.uppercase) +
  			(this.options.uppercase ? '&BBOX=' : '&bbox=') + bbox;
  	},

  	// @method setParams(params: Object, noRedraw?: Boolean): this
  	// Merges an object with the new parameters and re-requests tiles on the current screen (unless `noRedraw` was set to true).
  	setParams: function (params, noRedraw) {

  		extend(this.wmsParams, params);

  		if (!noRedraw) {
  			this.redraw();
  		}

  		return this;
  	}
  });


  // @factory L.tileLayer.wms(baseUrl: String, options: TileLayer.WMS options)
  // Instantiates a WMS tile layer object given a base URL of the WMS service and a WMS parameters/options object.
  function tileLayerWMS(url, options) {
  	return new TileLayerWMS(url, options);
  }

  TileLayer.WMS = TileLayerWMS;
  tileLayer.wms = tileLayerWMS;

  /*
   * @class Renderer
   * @inherits Layer
   * @aka L.Renderer
   *
   * Base class for vector renderer implementations (`SVG`, `Canvas`). Handles the
   * DOM container of the renderer, its bounds, and its zoom animation.
   *
   * A `Renderer` works as an implicit layer group for all `Path`s - the renderer
   * itself can be added or removed to the map. All paths use a renderer, which can
   * be implicit (the map will decide the type of renderer and use it automatically)
   * or explicit (using the [`renderer`](#path-renderer) option of the path).
   *
   * Do not use this class directly, use `SVG` and `Canvas` instead.
   *
   * @event update: Event
   * Fired when the renderer updates its bounds, center and zoom, for example when
   * its map has moved
   */

  var Renderer = Layer.extend({

  	// @section
  	// @aka Renderer options
  	options: {
  		// @option padding: Number = 0.1
  		// How much to extend the clip area around the map view (relative to its size)
  		// e.g. 0.1 would be 10% of map view in each direction
  		padding: 0.1,

  		// @option tolerance: Number = 0
  		// How much to extend click tolerance round a path/object on the map
  		tolerance : 0
  	},

  	initialize: function (options) {
  		setOptions(this, options);
  		stamp(this);
  		this._layers = this._layers || {};
  	},

  	onAdd: function () {
  		if (!this._container) {
  			this._initContainer(); // defined by renderer implementations

  			if (this._zoomAnimated) {
  				addClass(this._container, 'leaflet-zoom-animated');
  			}
  		}

  		this.getPane().appendChild(this._container);
  		this._update();
  		this.on('update', this._updatePaths, this);
  	},

  	onRemove: function () {
  		this.off('update', this._updatePaths, this);
  		this._destroyContainer();
  	},

  	getEvents: function () {
  		var events = {
  			viewreset: this._reset,
  			zoom: this._onZoom,
  			moveend: this._update,
  			zoomend: this._onZoomEnd
  		};
  		if (this._zoomAnimated) {
  			events.zoomanim = this._onAnimZoom;
  		}
  		return events;
  	},

  	_onAnimZoom: function (ev) {
  		this._updateTransform(ev.center, ev.zoom);
  	},

  	_onZoom: function () {
  		this._updateTransform(this._map.getCenter(), this._map.getZoom());
  	},

  	_updateTransform: function (center, zoom) {
  		var scale = this._map.getZoomScale(zoom, this._zoom),
  		    position = getPosition(this._container),
  		    viewHalf = this._map.getSize().multiplyBy(0.5 + this.options.padding),
  		    currentCenterPoint = this._map.project(this._center, zoom),
  		    destCenterPoint = this._map.project(center, zoom),
  		    centerOffset = destCenterPoint.subtract(currentCenterPoint),

  		    topLeftOffset = viewHalf.multiplyBy(-scale).add(position).add(viewHalf).subtract(centerOffset);

  		if (any3d) {
  			setTransform(this._container, topLeftOffset, scale);
  		} else {
  			setPosition(this._container, topLeftOffset);
  		}
  	},

  	_reset: function () {
  		this._update();
  		this._updateTransform(this._center, this._zoom);

  		for (var id in this._layers) {
  			this._layers[id]._reset();
  		}
  	},

  	_onZoomEnd: function () {
  		for (var id in this._layers) {
  			this._layers[id]._project();
  		}
  	},

  	_updatePaths: function () {
  		for (var id in this._layers) {
  			this._layers[id]._update();
  		}
  	},

  	_update: function () {
  		// Update pixel bounds of renderer container (for positioning/sizing/clipping later)
  		// Subclasses are responsible of firing the 'update' event.
  		var p = this.options.padding,
  		    size = this._map.getSize(),
  		    min = this._map.containerPointToLayerPoint(size.multiplyBy(-p)).round();

  		this._bounds = new Bounds(min, min.add(size.multiplyBy(1 + p * 2)).round());

  		this._center = this._map.getCenter();
  		this._zoom = this._map.getZoom();
  	}
  });

  /*
   * @class Canvas
   * @inherits Renderer
   * @aka L.Canvas
   *
   * Allows vector layers to be displayed with [`<canvas>`](https://developer.mozilla.org/docs/Web/API/Canvas_API).
   * Inherits `Renderer`.
   *
   * Due to [technical limitations](http://caniuse.com/#search=canvas), Canvas is not
   * available in all web browsers, notably IE8, and overlapping geometries might
   * not display properly in some edge cases.
   *
   * @example
   *
   * Use Canvas by default for all paths in the map:
   *
   * ```js
   * var map = L.map('map', {
   * 	renderer: L.canvas()
   * });
   * ```
   *
   * Use a Canvas renderer with extra padding for specific vector geometries:
   *
   * ```js
   * var map = L.map('map');
   * var myRenderer = L.canvas({ padding: 0.5 });
   * var line = L.polyline( coordinates, { renderer: myRenderer } );
   * var circle = L.circle( center, { renderer: myRenderer } );
   * ```
   */

  var Canvas = Renderer.extend({
  	getEvents: function () {
  		var events = Renderer.prototype.getEvents.call(this);
  		events.viewprereset = this._onViewPreReset;
  		return events;
  	},

  	_onViewPreReset: function () {
  		// Set a flag so that a viewprereset+moveend+viewreset only updates&redraws once
  		this._postponeUpdatePaths = true;
  	},

  	onAdd: function () {
  		Renderer.prototype.onAdd.call(this);

  		// Redraw vectors since canvas is cleared upon removal,
  		// in case of removing the renderer itself from the map.
  		this._draw();
  	},

  	_initContainer: function () {
  		var container = this._container = document.createElement('canvas');

  		on(container, 'mousemove', this._onMouseMove, this);
  		on(container, 'click dblclick mousedown mouseup contextmenu', this._onClick, this);
  		on(container, 'mouseout', this._handleMouseOut, this);

  		this._ctx = container.getContext('2d');
  	},

  	_destroyContainer: function () {
  		cancelAnimFrame(this._redrawRequest);
  		delete this._ctx;
  		remove(this._container);
  		off(this._container);
  		delete this._container;
  	},

  	_updatePaths: function () {
  		if (this._postponeUpdatePaths) { return; }

  		var layer;
  		this._redrawBounds = null;
  		for (var id in this._layers) {
  			layer = this._layers[id];
  			layer._update();
  		}
  		this._redraw();
  	},

  	_update: function () {
  		if (this._map._animatingZoom && this._bounds) { return; }

  		Renderer.prototype._update.call(this);

  		var b = this._bounds,
  		    container = this._container,
  		    size = b.getSize(),
  		    m = retina ? 2 : 1;

  		setPosition(container, b.min);

  		// set canvas size (also clearing it); use double size on retina
  		container.width = m * size.x;
  		container.height = m * size.y;
  		container.style.width = size.x + 'px';
  		container.style.height = size.y + 'px';

  		if (retina) {
  			this._ctx.scale(2, 2);
  		}

  		// translate so we use the same path coordinates after canvas element moves
  		this._ctx.translate(-b.min.x, -b.min.y);

  		// Tell paths to redraw themselves
  		this.fire('update');
  	},

  	_reset: function () {
  		Renderer.prototype._reset.call(this);

  		if (this._postponeUpdatePaths) {
  			this._postponeUpdatePaths = false;
  			this._updatePaths();
  		}
  	},

  	_initPath: function (layer) {
  		this._updateDashArray(layer);
  		this._layers[stamp(layer)] = layer;

  		var order = layer._order = {
  			layer: layer,
  			prev: this._drawLast,
  			next: null
  		};
  		if (this._drawLast) { this._drawLast.next = order; }
  		this._drawLast = order;
  		this._drawFirst = this._drawFirst || this._drawLast;
  	},

  	_addPath: function (layer) {
  		this._requestRedraw(layer);
  	},

  	_removePath: function (layer) {
  		var order = layer._order;
  		var next = order.next;
  		var prev = order.prev;

  		if (next) {
  			next.prev = prev;
  		} else {
  			this._drawLast = prev;
  		}
  		if (prev) {
  			prev.next = next;
  		} else {
  			this._drawFirst = next;
  		}

  		delete layer._order;

  		delete this._layers[stamp(layer)];

  		this._requestRedraw(layer);
  	},

  	_updatePath: function (layer) {
  		// Redraw the union of the layer's old pixel
  		// bounds and the new pixel bounds.
  		this._extendRedrawBounds(layer);
  		layer._project();
  		layer._update();
  		// The redraw will extend the redraw bounds
  		// with the new pixel bounds.
  		this._requestRedraw(layer);
  	},

  	_updateStyle: function (layer) {
  		this._updateDashArray(layer);
  		this._requestRedraw(layer);
  	},

  	_updateDashArray: function (layer) {
  		if (typeof layer.options.dashArray === 'string') {
  			var parts = layer.options.dashArray.split(/[, ]+/),
  			    dashArray = [],
  			    dashValue,
  			    i;
  			for (i = 0; i < parts.length; i++) {
  				dashValue = Number(parts[i]);
  				// Ignore dash array containing invalid lengths
  				if (isNaN(dashValue)) { return; }
  				dashArray.push(dashValue);
  			}
  			layer.options._dashArray = dashArray;
  		} else {
  			layer.options._dashArray = layer.options.dashArray;
  		}
  	},

  	_requestRedraw: function (layer) {
  		if (!this._map) { return; }

  		this._extendRedrawBounds(layer);
  		this._redrawRequest = this._redrawRequest || requestAnimFrame(this._redraw, this);
  	},

  	_extendRedrawBounds: function (layer) {
  		if (layer._pxBounds) {
  			var padding = (layer.options.weight || 0) + 1;
  			this._redrawBounds = this._redrawBounds || new Bounds();
  			this._redrawBounds.extend(layer._pxBounds.min.subtract([padding, padding]));
  			this._redrawBounds.extend(layer._pxBounds.max.add([padding, padding]));
  		}
  	},

  	_redraw: function () {
  		this._redrawRequest = null;

  		if (this._redrawBounds) {
  			this._redrawBounds.min._floor();
  			this._redrawBounds.max._ceil();
  		}

  		this._clear(); // clear layers in redraw bounds
  		this._draw(); // draw layers

  		this._redrawBounds = null;
  	},

  	_clear: function () {
  		var bounds = this._redrawBounds;
  		if (bounds) {
  			var size = bounds.getSize();
  			this._ctx.clearRect(bounds.min.x, bounds.min.y, size.x, size.y);
  		} else {
  			this._ctx.save();
  			this._ctx.setTransform(1, 0, 0, 1, 0, 0);
  			this._ctx.clearRect(0, 0, this._container.width, this._container.height);
  			this._ctx.restore();
  		}
  	},

  	_draw: function () {
  		var layer, bounds = this._redrawBounds;
  		this._ctx.save();
  		if (bounds) {
  			var size = bounds.getSize();
  			this._ctx.beginPath();
  			this._ctx.rect(bounds.min.x, bounds.min.y, size.x, size.y);
  			this._ctx.clip();
  		}

  		this._drawing = true;

  		for (var order = this._drawFirst; order; order = order.next) {
  			layer = order.layer;
  			if (!bounds || (layer._pxBounds && layer._pxBounds.intersects(bounds))) {
  				layer._updatePath();
  			}
  		}

  		this._drawing = false;

  		this._ctx.restore();  // Restore state before clipping.
  	},

  	_updatePoly: function (layer, closed) {
  		if (!this._drawing) { return; }

  		var i, j, len2, p,
  		    parts = layer._parts,
  		    len = parts.length,
  		    ctx = this._ctx;

  		if (!len) { return; }

  		ctx.beginPath();

  		for (i = 0; i < len; i++) {
  			for (j = 0, len2 = parts[i].length; j < len2; j++) {
  				p = parts[i][j];
  				ctx[j ? 'lineTo' : 'moveTo'](p.x, p.y);
  			}
  			if (closed) {
  				ctx.closePath();
  			}
  		}

  		this._fillStroke(ctx, layer);

  		// TODO optimization: 1 fill/stroke for all features with equal style instead of 1 for each feature
  	},

  	_updateCircle: function (layer) {

  		if (!this._drawing || layer._empty()) { return; }

  		var p = layer._point,
  		    ctx = this._ctx,
  		    r = Math.max(Math.round(layer._radius), 1),
  		    s = (Math.max(Math.round(layer._radiusY), 1) || r) / r;

  		if (s !== 1) {
  			ctx.save();
  			ctx.scale(1, s);
  		}

  		ctx.beginPath();
  		ctx.arc(p.x, p.y / s, r, 0, Math.PI * 2, false);

  		if (s !== 1) {
  			ctx.restore();
  		}

  		this._fillStroke(ctx, layer);
  	},

  	_fillStroke: function (ctx, layer) {
  		var options = layer.options;

  		if (options.fill) {
  			ctx.globalAlpha = options.fillOpacity;
  			ctx.fillStyle = options.fillColor || options.color;
  			ctx.fill(options.fillRule || 'evenodd');
  		}

  		if (options.stroke && options.weight !== 0) {
  			if (ctx.setLineDash) {
  				ctx.setLineDash(layer.options && layer.options._dashArray || []);
  			}
  			ctx.globalAlpha = options.opacity;
  			ctx.lineWidth = options.weight;
  			ctx.strokeStyle = options.color;
  			ctx.lineCap = options.lineCap;
  			ctx.lineJoin = options.lineJoin;
  			ctx.stroke();
  		}
  	},

  	// Canvas obviously doesn't have mouse events for individual drawn objects,
  	// so we emulate that by calculating what's under the mouse on mousemove/click manually

  	_onClick: function (e) {
  		var point = this._map.mouseEventToLayerPoint(e), layer, clickedLayer;

  		for (var order = this._drawFirst; order; order = order.next) {
  			layer = order.layer;
  			if (layer.options.interactive && layer._containsPoint(point)) {
  				if (!(e.type === 'click' || e.type !== 'preclick') || !this._map._draggableMoved(layer)) {
  					clickedLayer = layer;
  				}
  			}
  		}
  		if (clickedLayer)  {
  			fakeStop(e);
  			this._fireEvent([clickedLayer], e);
  		}
  	},

  	_onMouseMove: function (e) {
  		if (!this._map || this._map.dragging.moving() || this._map._animatingZoom) { return; }

  		var point = this._map.mouseEventToLayerPoint(e);
  		this._handleMouseHover(e, point);
  	},


  	_handleMouseOut: function (e) {
  		var layer = this._hoveredLayer;
  		if (layer) {
  			// if we're leaving the layer, fire mouseout
  			removeClass(this._container, 'leaflet-interactive');
  			this._fireEvent([layer], e, 'mouseout');
  			this._hoveredLayer = null;
  			this._mouseHoverThrottled = false;
  		}
  	},

  	_handleMouseHover: function (e, point) {
  		if (this._mouseHoverThrottled) {
  			return;
  		}

  		var layer, candidateHoveredLayer;

  		for (var order = this._drawFirst; order; order = order.next) {
  			layer = order.layer;
  			if (layer.options.interactive && layer._containsPoint(point)) {
  				candidateHoveredLayer = layer;
  			}
  		}

  		if (candidateHoveredLayer !== this._hoveredLayer) {
  			this._handleMouseOut(e);

  			if (candidateHoveredLayer) {
  				addClass(this._container, 'leaflet-interactive'); // change cursor
  				this._fireEvent([candidateHoveredLayer], e, 'mouseover');
  				this._hoveredLayer = candidateHoveredLayer;
  			}
  		}

  		if (this._hoveredLayer) {
  			this._fireEvent([this._hoveredLayer], e);
  		}

  		this._mouseHoverThrottled = true;
  		setTimeout(bind(function () {
  			this._mouseHoverThrottled = false;
  		}, this), 32);
  	},

  	_fireEvent: function (layers, e, type) {
  		this._map._fireDOMEvent(e, type || e.type, layers);
  	},

  	_bringToFront: function (layer) {
  		var order = layer._order;

  		if (!order) { return; }

  		var next = order.next;
  		var prev = order.prev;

  		if (next) {
  			next.prev = prev;
  		} else {
  			// Already last
  			return;
  		}
  		if (prev) {
  			prev.next = next;
  		} else if (next) {
  			// Update first entry unless this is the
  			// single entry
  			this._drawFirst = next;
  		}

  		order.prev = this._drawLast;
  		this._drawLast.next = order;

  		order.next = null;
  		this._drawLast = order;

  		this._requestRedraw(layer);
  	},

  	_bringToBack: function (layer) {
  		var order = layer._order;

  		if (!order) { return; }

  		var next = order.next;
  		var prev = order.prev;

  		if (prev) {
  			prev.next = next;
  		} else {
  			// Already first
  			return;
  		}
  		if (next) {
  			next.prev = prev;
  		} else if (prev) {
  			// Update last entry unless this is the
  			// single entry
  			this._drawLast = prev;
  		}

  		order.prev = null;

  		order.next = this._drawFirst;
  		this._drawFirst.prev = order;
  		this._drawFirst = order;

  		this._requestRedraw(layer);
  	}
  });

  // @factory L.canvas(options?: Renderer options)
  // Creates a Canvas renderer with the given options.
  function canvas$1(options) {
  	return canvas ? new Canvas(options) : null;
  }

  /*
   * Thanks to Dmitry Baranovsky and his Raphael library for inspiration!
   */


  var vmlCreate = (function () {
  	try {
  		document.namespaces.add('lvml', 'urn:schemas-microsoft-com:vml');
  		return function (name) {
  			return document.createElement('<lvml:' + name + ' class="lvml">');
  		};
  	} catch (e) {
  		return function (name) {
  			return document.createElement('<' + name + ' xmlns="urn:schemas-microsoft.com:vml" class="lvml">');
  		};
  	}
  })();


  /*
   * @class SVG
   *
   *
   * VML was deprecated in 2012, which means VML functionality exists only for backwards compatibility
   * with old versions of Internet Explorer.
   */

  // mixin to redefine some SVG methods to handle VML syntax which is similar but with some differences
  var vmlMixin = {

  	_initContainer: function () {
  		this._container = create$1('div', 'leaflet-vml-container');
  	},

  	_update: function () {
  		if (this._map._animatingZoom) { return; }
  		Renderer.prototype._update.call(this);
  		this.fire('update');
  	},

  	_initPath: function (layer) {
  		var container = layer._container = vmlCreate('shape');

  		addClass(container, 'leaflet-vml-shape ' + (this.options.className || ''));

  		container.coordsize = '1 1';

  		layer._path = vmlCreate('path');
  		container.appendChild(layer._path);

  		this._updateStyle(layer);
  		this._layers[stamp(layer)] = layer;
  	},

  	_addPath: function (layer) {
  		var container = layer._container;
  		this._container.appendChild(container);

  		if (layer.options.interactive) {
  			layer.addInteractiveTarget(container);
  		}
  	},

  	_removePath: function (layer) {
  		var container = layer._container;
  		remove(container);
  		layer.removeInteractiveTarget(container);
  		delete this._layers[stamp(layer)];
  	},

  	_updateStyle: function (layer) {
  		var stroke = layer._stroke,
  		    fill = layer._fill,
  		    options = layer.options,
  		    container = layer._container;

  		container.stroked = !!options.stroke;
  		container.filled = !!options.fill;

  		if (options.stroke) {
  			if (!stroke) {
  				stroke = layer._stroke = vmlCreate('stroke');
  			}
  			container.appendChild(stroke);
  			stroke.weight = options.weight + 'px';
  			stroke.color = options.color;
  			stroke.opacity = options.opacity;

  			if (options.dashArray) {
  				stroke.dashStyle = isArray(options.dashArray) ?
  				    options.dashArray.join(' ') :
  				    options.dashArray.replace(/( *, *)/g, ' ');
  			} else {
  				stroke.dashStyle = '';
  			}
  			stroke.endcap = options.lineCap.replace('butt', 'flat');
  			stroke.joinstyle = options.lineJoin;

  		} else if (stroke) {
  			container.removeChild(stroke);
  			layer._stroke = null;
  		}

  		if (options.fill) {
  			if (!fill) {
  				fill = layer._fill = vmlCreate('fill');
  			}
  			container.appendChild(fill);
  			fill.color = options.fillColor || options.color;
  			fill.opacity = options.fillOpacity;

  		} else if (fill) {
  			container.removeChild(fill);
  			layer._fill = null;
  		}
  	},

  	_updateCircle: function (layer) {
  		var p = layer._point.round(),
  		    r = Math.round(layer._radius),
  		    r2 = Math.round(layer._radiusY || r);

  		this._setPath(layer, layer._empty() ? 'M0 0' :
  			'AL ' + p.x + ',' + p.y + ' ' + r + ',' + r2 + ' 0,' + (65535 * 360));
  	},

  	_setPath: function (layer, path) {
  		layer._path.v = path;
  	},

  	_bringToFront: function (layer) {
  		toFront(layer._container);
  	},

  	_bringToBack: function (layer) {
  		toBack(layer._container);
  	}
  };

  var create$2 = vml ? vmlCreate : svgCreate;

  /*
   * @class SVG
   * @inherits Renderer
   * @aka L.SVG
   *
   * Allows vector layers to be displayed with [SVG](https://developer.mozilla.org/docs/Web/SVG).
   * Inherits `Renderer`.
   *
   * Due to [technical limitations](http://caniuse.com/#search=svg), SVG is not
   * available in all web browsers, notably Android 2.x and 3.x.
   *
   * Although SVG is not available on IE7 and IE8, these browsers support
   * [VML](https://en.wikipedia.org/wiki/Vector_Markup_Language)
   * (a now deprecated technology), and the SVG renderer will fall back to VML in
   * this case.
   *
   * @example
   *
   * Use SVG by default for all paths in the map:
   *
   * ```js
   * var map = L.map('map', {
   * 	renderer: L.svg()
   * });
   * ```
   *
   * Use a SVG renderer with extra padding for specific vector geometries:
   *
   * ```js
   * var map = L.map('map');
   * var myRenderer = L.svg({ padding: 0.5 });
   * var line = L.polyline( coordinates, { renderer: myRenderer } );
   * var circle = L.circle( center, { renderer: myRenderer } );
   * ```
   */

  var SVG = Renderer.extend({

  	getEvents: function () {
  		var events = Renderer.prototype.getEvents.call(this);
  		events.zoomstart = this._onZoomStart;
  		return events;
  	},

  	_initContainer: function () {
  		this._container = create$2('svg');

  		// makes it possible to click through svg root; we'll reset it back in individual paths
  		this._container.setAttribute('pointer-events', 'none');

  		this._rootGroup = create$2('g');
  		this._container.appendChild(this._rootGroup);
  	},

  	_destroyContainer: function () {
  		remove(this._container);
  		off(this._container);
  		delete this._container;
  		delete this._rootGroup;
  		delete this._svgSize;
  	},

  	_onZoomStart: function () {
  		// Drag-then-pinch interactions might mess up the center and zoom.
  		// In this case, the easiest way to prevent this is re-do the renderer
  		//   bounds and padding when the zooming starts.
  		this._update();
  	},

  	_update: function () {
  		if (this._map._animatingZoom && this._bounds) { return; }

  		Renderer.prototype._update.call(this);

  		var b = this._bounds,
  		    size = b.getSize(),
  		    container = this._container;

  		// set size of svg-container if changed
  		if (!this._svgSize || !this._svgSize.equals(size)) {
  			this._svgSize = size;
  			container.setAttribute('width', size.x);
  			container.setAttribute('height', size.y);
  		}

  		// movement: update container viewBox so that we don't have to change coordinates of individual layers
  		setPosition(container, b.min);
  		container.setAttribute('viewBox', [b.min.x, b.min.y, size.x, size.y].join(' '));

  		this.fire('update');
  	},

  	// methods below are called by vector layers implementations

  	_initPath: function (layer) {
  		var path = layer._path = create$2('path');

  		// @namespace Path
  		// @option className: String = null
  		// Custom class name set on an element. Only for SVG renderer.
  		if (layer.options.className) {
  			addClass(path, layer.options.className);
  		}

  		if (layer.options.interactive) {
  			addClass(path, 'leaflet-interactive');
  		}

  		this._updateStyle(layer);
  		this._layers[stamp(layer)] = layer;
  	},

  	_addPath: function (layer) {
  		if (!this._rootGroup) { this._initContainer(); }
  		this._rootGroup.appendChild(layer._path);
  		layer.addInteractiveTarget(layer._path);
  	},

  	_removePath: function (layer) {
  		remove(layer._path);
  		layer.removeInteractiveTarget(layer._path);
  		delete this._layers[stamp(layer)];
  	},

  	_updatePath: function (layer) {
  		layer._project();
  		layer._update();
  	},

  	_updateStyle: function (layer) {
  		var path = layer._path,
  		    options = layer.options;

  		if (!path) { return; }

  		if (options.stroke) {
  			path.setAttribute('stroke', options.color);
  			path.setAttribute('stroke-opacity', options.opacity);
  			path.setAttribute('stroke-width', options.weight);
  			path.setAttribute('stroke-linecap', options.lineCap);
  			path.setAttribute('stroke-linejoin', options.lineJoin);

  			if (options.dashArray) {
  				path.setAttribute('stroke-dasharray', options.dashArray);
  			} else {
  				path.removeAttribute('stroke-dasharray');
  			}

  			if (options.dashOffset) {
  				path.setAttribute('stroke-dashoffset', options.dashOffset);
  			} else {
  				path.removeAttribute('stroke-dashoffset');
  			}
  		} else {
  			path.setAttribute('stroke', 'none');
  		}

  		if (options.fill) {
  			path.setAttribute('fill', options.fillColor || options.color);
  			path.setAttribute('fill-opacity', options.fillOpacity);
  			path.setAttribute('fill-rule', options.fillRule || 'evenodd');
  		} else {
  			path.setAttribute('fill', 'none');
  		}
  	},

  	_updatePoly: function (layer, closed) {
  		this._setPath(layer, pointsToPath(layer._parts, closed));
  	},

  	_updateCircle: function (layer) {
  		var p = layer._point,
  		    r = Math.max(Math.round(layer._radius), 1),
  		    r2 = Math.max(Math.round(layer._radiusY), 1) || r,
  		    arc = 'a' + r + ',' + r2 + ' 0 1,0 ';

  		// drawing a circle with two half-arcs
  		var d = layer._empty() ? 'M0 0' :
  			'M' + (p.x - r) + ',' + p.y +
  			arc + (r * 2) + ',0 ' +
  			arc + (-r * 2) + ',0 ';

  		this._setPath(layer, d);
  	},

  	_setPath: function (layer, path) {
  		layer._path.setAttribute('d', path);
  	},

  	// SVG does not have the concept of zIndex so we resort to changing the DOM order of elements
  	_bringToFront: function (layer) {
  		toFront(layer._path);
  	},

  	_bringToBack: function (layer) {
  		toBack(layer._path);
  	}
  });

  if (vml) {
  	SVG.include(vmlMixin);
  }

  // @namespace SVG
  // @factory L.svg(options?: Renderer options)
  // Creates a SVG renderer with the given options.
  function svg$1(options) {
  	return svg || vml ? new SVG(options) : null;
  }

  Map.include({
  	// @namespace Map; @method getRenderer(layer: Path): Renderer
  	// Returns the instance of `Renderer` that should be used to render the given
  	// `Path`. It will ensure that the `renderer` options of the map and paths
  	// are respected, and that the renderers do exist on the map.
  	getRenderer: function (layer) {
  		// @namespace Path; @option renderer: Renderer
  		// Use this specific instance of `Renderer` for this path. Takes
  		// precedence over the map's [default renderer](#map-renderer).
  		var renderer = layer.options.renderer || this._getPaneRenderer(layer.options.pane) || this.options.renderer || this._renderer;

  		if (!renderer) {
  			renderer = this._renderer = this._createRenderer();
  		}

  		if (!this.hasLayer(renderer)) {
  			this.addLayer(renderer);
  		}
  		return renderer;
  	},

  	_getPaneRenderer: function (name) {
  		if (name === 'overlayPane' || name === undefined) {
  			return false;
  		}

  		var renderer = this._paneRenderers[name];
  		if (renderer === undefined) {
  			renderer = this._createRenderer({pane: name});
  			this._paneRenderers[name] = renderer;
  		}
  		return renderer;
  	},

  	_createRenderer: function (options) {
  		// @namespace Map; @option preferCanvas: Boolean = false
  		// Whether `Path`s should be rendered on a `Canvas` renderer.
  		// By default, all `Path`s are rendered in a `SVG` renderer.
  		return (this.options.preferCanvas && canvas$1(options)) || svg$1(options);
  	}
  });

  /*
   * L.Rectangle extends Polygon and creates a rectangle when passed a LatLngBounds object.
   */

  /*
   * @class Rectangle
   * @aka L.Rectangle
   * @inherits Polygon
   *
   * A class for drawing rectangle overlays on a map. Extends `Polygon`.
   *
   * @example
   *
   * ```js
   * // define rectangle geographical bounds
   * var bounds = [[54.559322, -5.767822], [56.1210604, -3.021240]];
   *
   * // create an orange rectangle
   * L.rectangle(bounds, {color: "#ff7800", weight: 1}).addTo(map);
   *
   * // zoom the map to the rectangle bounds
   * map.fitBounds(bounds);
   * ```
   *
   */


  var Rectangle = Polygon.extend({
  	initialize: function (latLngBounds, options) {
  		Polygon.prototype.initialize.call(this, this._boundsToLatLngs(latLngBounds), options);
  	},

  	// @method setBounds(latLngBounds: LatLngBounds): this
  	// Redraws the rectangle with the passed bounds.
  	setBounds: function (latLngBounds) {
  		return this.setLatLngs(this._boundsToLatLngs(latLngBounds));
  	},

  	_boundsToLatLngs: function (latLngBounds) {
  		latLngBounds = toLatLngBounds(latLngBounds);
  		return [
  			latLngBounds.getSouthWest(),
  			latLngBounds.getNorthWest(),
  			latLngBounds.getNorthEast(),
  			latLngBounds.getSouthEast()
  		];
  	}
  });


  // @factory L.rectangle(latLngBounds: LatLngBounds, options?: Polyline options)
  function rectangle(latLngBounds, options) {
  	return new Rectangle(latLngBounds, options);
  }

  SVG.create = create$2;
  SVG.pointsToPath = pointsToPath;

  GeoJSON.geometryToLayer = geometryToLayer;
  GeoJSON.coordsToLatLng = coordsToLatLng;
  GeoJSON.coordsToLatLngs = coordsToLatLngs;
  GeoJSON.latLngToCoords = latLngToCoords;
  GeoJSON.latLngsToCoords = latLngsToCoords;
  GeoJSON.getFeature = getFeature;
  GeoJSON.asFeature = asFeature;

  /*
   * L.Handler.BoxZoom is used to add shift-drag zoom interaction to the map
   * (zoom to a selected bounding box), enabled by default.
   */

  // @namespace Map
  // @section Interaction Options
  Map.mergeOptions({
  	// @option boxZoom: Boolean = true
  	// Whether the map can be zoomed to a rectangular area specified by
  	// dragging the mouse while pressing the shift key.
  	boxZoom: true
  });

  var BoxZoom = Handler.extend({
  	initialize: function (map) {
  		this._map = map;
  		this._container = map._container;
  		this._pane = map._panes.overlayPane;
  		this._resetStateTimeout = 0;
  		map.on('unload', this._destroy, this);
  	},

  	addHooks: function () {
  		on(this._container, 'mousedown', this._onMouseDown, this);
  	},

  	removeHooks: function () {
  		off(this._container, 'mousedown', this._onMouseDown, this);
  	},

  	moved: function () {
  		return this._moved;
  	},

  	_destroy: function () {
  		remove(this._pane);
  		delete this._pane;
  	},

  	_resetState: function () {
  		this._resetStateTimeout = 0;
  		this._moved = false;
  	},

  	_clearDeferredResetState: function () {
  		if (this._resetStateTimeout !== 0) {
  			clearTimeout(this._resetStateTimeout);
  			this._resetStateTimeout = 0;
  		}
  	},

  	_onMouseDown: function (e) {
  		if (!e.shiftKey || ((e.which !== 1) && (e.button !== 1))) { return false; }

  		// Clear the deferred resetState if it hasn't executed yet, otherwise it
  		// will interrupt the interaction and orphan a box element in the container.
  		this._clearDeferredResetState();
  		this._resetState();

  		disableTextSelection();
  		disableImageDrag();

  		this._startPoint = this._map.mouseEventToContainerPoint(e);

  		on(document, {
  			contextmenu: stop,
  			mousemove: this._onMouseMove,
  			mouseup: this._onMouseUp,
  			keydown: this._onKeyDown
  		}, this);
  	},

  	_onMouseMove: function (e) {
  		if (!this._moved) {
  			this._moved = true;

  			this._box = create$1('div', 'leaflet-zoom-box', this._container);
  			addClass(this._container, 'leaflet-crosshair');

  			this._map.fire('boxzoomstart');
  		}

  		this._point = this._map.mouseEventToContainerPoint(e);

  		var bounds = new Bounds(this._point, this._startPoint),
  		    size = bounds.getSize();

  		setPosition(this._box, bounds.min);

  		this._box.style.width  = size.x + 'px';
  		this._box.style.height = size.y + 'px';
  	},

  	_finish: function () {
  		if (this._moved) {
  			remove(this._box);
  			removeClass(this._container, 'leaflet-crosshair');
  		}

  		enableTextSelection();
  		enableImageDrag();

  		off(document, {
  			contextmenu: stop,
  			mousemove: this._onMouseMove,
  			mouseup: this._onMouseUp,
  			keydown: this._onKeyDown
  		}, this);
  	},

  	_onMouseUp: function (e) {
  		if ((e.which !== 1) && (e.button !== 1)) { return; }

  		this._finish();

  		if (!this._moved) { return; }
  		// Postpone to next JS tick so internal click event handling
  		// still see it as "moved".
  		this._clearDeferredResetState();
  		this._resetStateTimeout = setTimeout(bind(this._resetState, this), 0);

  		var bounds = new LatLngBounds(
  		        this._map.containerPointToLatLng(this._startPoint),
  		        this._map.containerPointToLatLng(this._point));

  		this._map
  			.fitBounds(bounds)
  			.fire('boxzoomend', {boxZoomBounds: bounds});
  	},

  	_onKeyDown: function (e) {
  		if (e.keyCode === 27) {
  			this._finish();
  		}
  	}
  });

  // @section Handlers
  // @property boxZoom: Handler
  // Box (shift-drag with mouse) zoom handler.
  Map.addInitHook('addHandler', 'boxZoom', BoxZoom);

  /*
   * L.Handler.DoubleClickZoom is used to handle double-click zoom on the map, enabled by default.
   */

  // @namespace Map
  // @section Interaction Options

  Map.mergeOptions({
  	// @option doubleClickZoom: Boolean|String = true
  	// Whether the map can be zoomed in by double clicking on it and
  	// zoomed out by double clicking while holding shift. If passed
  	// `'center'`, double-click zoom will zoom to the center of the
  	//  view regardless of where the mouse was.
  	doubleClickZoom: true
  });

  var DoubleClickZoom = Handler.extend({
  	addHooks: function () {
  		this._map.on('dblclick', this._onDoubleClick, this);
  	},

  	removeHooks: function () {
  		this._map.off('dblclick', this._onDoubleClick, this);
  	},

  	_onDoubleClick: function (e) {
  		var map = this._map,
  		    oldZoom = map.getZoom(),
  		    delta = map.options.zoomDelta,
  		    zoom = e.originalEvent.shiftKey ? oldZoom - delta : oldZoom + delta;

  		if (map.options.doubleClickZoom === 'center') {
  			map.setZoom(zoom);
  		} else {
  			map.setZoomAround(e.containerPoint, zoom);
  		}
  	}
  });

  // @section Handlers
  //
  // Map properties include interaction handlers that allow you to control
  // interaction behavior in runtime, enabling or disabling certain features such
  // as dragging or touch zoom (see `Handler` methods). For example:
  //
  // ```js
  // map.doubleClickZoom.disable();
  // ```
  //
  // @property doubleClickZoom: Handler
  // Double click zoom handler.
  Map.addInitHook('addHandler', 'doubleClickZoom', DoubleClickZoom);

  /*
   * L.Handler.MapDrag is used to make the map draggable (with panning inertia), enabled by default.
   */

  // @namespace Map
  // @section Interaction Options
  Map.mergeOptions({
  	// @option dragging: Boolean = true
  	// Whether the map be draggable with mouse/touch or not.
  	dragging: true,

  	// @section Panning Inertia Options
  	// @option inertia: Boolean = *
  	// If enabled, panning of the map will have an inertia effect where
  	// the map builds momentum while dragging and continues moving in
  	// the same direction for some time. Feels especially nice on touch
  	// devices. Enabled by default unless running on old Android devices.
  	inertia: !android23,

  	// @option inertiaDeceleration: Number = 3000
  	// The rate with which the inertial movement slows down, in pixels/second.
  	inertiaDeceleration: 3400, // px/s^2

  	// @option inertiaMaxSpeed: Number = Infinity
  	// Max speed of the inertial movement, in pixels/second.
  	inertiaMaxSpeed: Infinity, // px/s

  	// @option easeLinearity: Number = 0.2
  	easeLinearity: 0.2,

  	// TODO refactor, move to CRS
  	// @option worldCopyJump: Boolean = false
  	// With this option enabled, the map tracks when you pan to another "copy"
  	// of the world and seamlessly jumps to the original one so that all overlays
  	// like markers and vector layers are still visible.
  	worldCopyJump: false,

  	// @option maxBoundsViscosity: Number = 0.0
  	// If `maxBounds` is set, this option will control how solid the bounds
  	// are when dragging the map around. The default value of `0.0` allows the
  	// user to drag outside the bounds at normal speed, higher values will
  	// slow down map dragging outside bounds, and `1.0` makes the bounds fully
  	// solid, preventing the user from dragging outside the bounds.
  	maxBoundsViscosity: 0.0
  });

  var Drag = Handler.extend({
  	addHooks: function () {
  		if (!this._draggable) {
  			var map = this._map;

  			this._draggable = new Draggable(map._mapPane, map._container);

  			this._draggable.on({
  				dragstart: this._onDragStart,
  				drag: this._onDrag,
  				dragend: this._onDragEnd
  			}, this);

  			this._draggable.on('predrag', this._onPreDragLimit, this);
  			if (map.options.worldCopyJump) {
  				this._draggable.on('predrag', this._onPreDragWrap, this);
  				map.on('zoomend', this._onZoomEnd, this);

  				map.whenReady(this._onZoomEnd, this);
  			}
  		}
  		addClass(this._map._container, 'leaflet-grab leaflet-touch-drag');
  		this._draggable.enable();
  		this._positions = [];
  		this._times = [];
  	},

  	removeHooks: function () {
  		removeClass(this._map._container, 'leaflet-grab');
  		removeClass(this._map._container, 'leaflet-touch-drag');
  		this._draggable.disable();
  	},

  	moved: function () {
  		return this._draggable && this._draggable._moved;
  	},

  	moving: function () {
  		return this._draggable && this._draggable._moving;
  	},

  	_onDragStart: function () {
  		var map = this._map;

  		map._stop();
  		if (this._map.options.maxBounds && this._map.options.maxBoundsViscosity) {
  			var bounds = toLatLngBounds(this._map.options.maxBounds);

  			this._offsetLimit = toBounds(
  				this._map.latLngToContainerPoint(bounds.getNorthWest()).multiplyBy(-1),
  				this._map.latLngToContainerPoint(bounds.getSouthEast()).multiplyBy(-1)
  					.add(this._map.getSize()));

  			this._viscosity = Math.min(1.0, Math.max(0.0, this._map.options.maxBoundsViscosity));
  		} else {
  			this._offsetLimit = null;
  		}

  		map
  		    .fire('movestart')
  		    .fire('dragstart');

  		if (map.options.inertia) {
  			this._positions = [];
  			this._times = [];
  		}
  	},

  	_onDrag: function (e) {
  		if (this._map.options.inertia) {
  			var time = this._lastTime = +new Date(),
  			    pos = this._lastPos = this._draggable._absPos || this._draggable._newPos;

  			this._positions.push(pos);
  			this._times.push(time);

  			this._prunePositions(time);
  		}

  		this._map
  		    .fire('move', e)
  		    .fire('drag', e);
  	},

  	_prunePositions: function (time) {
  		while (this._positions.length > 1 && time - this._times[0] > 50) {
  			this._positions.shift();
  			this._times.shift();
  		}
  	},

  	_onZoomEnd: function () {
  		var pxCenter = this._map.getSize().divideBy(2),
  		    pxWorldCenter = this._map.latLngToLayerPoint([0, 0]);

  		this._initialWorldOffset = pxWorldCenter.subtract(pxCenter).x;
  		this._worldWidth = this._map.getPixelWorldBounds().getSize().x;
  	},

  	_viscousLimit: function (value, threshold) {
  		return value - (value - threshold) * this._viscosity;
  	},

  	_onPreDragLimit: function () {
  		if (!this._viscosity || !this._offsetLimit) { return; }

  		var offset = this._draggable._newPos.subtract(this._draggable._startPos);

  		var limit = this._offsetLimit;
  		if (offset.x < limit.min.x) { offset.x = this._viscousLimit(offset.x, limit.min.x); }
  		if (offset.y < limit.min.y) { offset.y = this._viscousLimit(offset.y, limit.min.y); }
  		if (offset.x > limit.max.x) { offset.x = this._viscousLimit(offset.x, limit.max.x); }
  		if (offset.y > limit.max.y) { offset.y = this._viscousLimit(offset.y, limit.max.y); }

  		this._draggable._newPos = this._draggable._startPos.add(offset);
  	},

  	_onPreDragWrap: function () {
  		// TODO refactor to be able to adjust map pane position after zoom
  		var worldWidth = this._worldWidth,
  		    halfWidth = Math.round(worldWidth / 2),
  		    dx = this._initialWorldOffset,
  		    x = this._draggable._newPos.x,
  		    newX1 = (x - halfWidth + dx) % worldWidth + halfWidth - dx,
  		    newX2 = (x + halfWidth + dx) % worldWidth - halfWidth - dx,
  		    newX = Math.abs(newX1 + dx) < Math.abs(newX2 + dx) ? newX1 : newX2;

  		this._draggable._absPos = this._draggable._newPos.clone();
  		this._draggable._newPos.x = newX;
  	},

  	_onDragEnd: function (e) {
  		var map = this._map,
  		    options = map.options,

  		    noInertia = !options.inertia || this._times.length < 2;

  		map.fire('dragend', e);

  		if (noInertia) {
  			map.fire('moveend');

  		} else {
  			this._prunePositions(+new Date());

  			var direction = this._lastPos.subtract(this._positions[0]),
  			    duration = (this._lastTime - this._times[0]) / 1000,
  			    ease = options.easeLinearity,

  			    speedVector = direction.multiplyBy(ease / duration),
  			    speed = speedVector.distanceTo([0, 0]),

  			    limitedSpeed = Math.min(options.inertiaMaxSpeed, speed),
  			    limitedSpeedVector = speedVector.multiplyBy(limitedSpeed / speed),

  			    decelerationDuration = limitedSpeed / (options.inertiaDeceleration * ease),
  			    offset = limitedSpeedVector.multiplyBy(-decelerationDuration / 2).round();

  			if (!offset.x && !offset.y) {
  				map.fire('moveend');

  			} else {
  				offset = map._limitOffset(offset, map.options.maxBounds);

  				requestAnimFrame(function () {
  					map.panBy(offset, {
  						duration: decelerationDuration,
  						easeLinearity: ease,
  						noMoveStart: true,
  						animate: true
  					});
  				});
  			}
  		}
  	}
  });

  // @section Handlers
  // @property dragging: Handler
  // Map dragging handler (by both mouse and touch).
  Map.addInitHook('addHandler', 'dragging', Drag);

  /*
   * L.Map.Keyboard is handling keyboard interaction with the map, enabled by default.
   */

  // @namespace Map
  // @section Keyboard Navigation Options
  Map.mergeOptions({
  	// @option keyboard: Boolean = true
  	// Makes the map focusable and allows users to navigate the map with keyboard
  	// arrows and `+`/`-` keys.
  	keyboard: true,

  	// @option keyboardPanDelta: Number = 80
  	// Amount of pixels to pan when pressing an arrow key.
  	keyboardPanDelta: 80
  });

  var Keyboard = Handler.extend({

  	keyCodes: {
  		left:    [37],
  		right:   [39],
  		down:    [40],
  		up:      [38],
  		zoomIn:  [187, 107, 61, 171],
  		zoomOut: [189, 109, 54, 173]
  	},

  	initialize: function (map) {
  		this._map = map;

  		this._setPanDelta(map.options.keyboardPanDelta);
  		this._setZoomDelta(map.options.zoomDelta);
  	},

  	addHooks: function () {
  		var container = this._map._container;

  		// make the container focusable by tabbing
  		if (container.tabIndex <= 0) {
  			container.tabIndex = '0';
  		}

  		on(container, {
  			focus: this._onFocus,
  			blur: this._onBlur,
  			mousedown: this._onMouseDown
  		}, this);

  		this._map.on({
  			focus: this._addHooks,
  			blur: this._removeHooks
  		}, this);
  	},

  	removeHooks: function () {
  		this._removeHooks();

  		off(this._map._container, {
  			focus: this._onFocus,
  			blur: this._onBlur,
  			mousedown: this._onMouseDown
  		}, this);

  		this._map.off({
  			focus: this._addHooks,
  			blur: this._removeHooks
  		}, this);
  	},

  	_onMouseDown: function () {
  		if (this._focused) { return; }

  		var body = document.body,
  		    docEl = document.documentElement,
  		    top = body.scrollTop || docEl.scrollTop,
  		    left = body.scrollLeft || docEl.scrollLeft;

  		this._map._container.focus();

  		window.scrollTo(left, top);
  	},

  	_onFocus: function () {
  		this._focused = true;
  		this._map.fire('focus');
  	},

  	_onBlur: function () {
  		this._focused = false;
  		this._map.fire('blur');
  	},

  	_setPanDelta: function (panDelta) {
  		var keys = this._panKeys = {},
  		    codes = this.keyCodes,
  		    i, len;

  		for (i = 0, len = codes.left.length; i < len; i++) {
  			keys[codes.left[i]] = [-1 * panDelta, 0];
  		}
  		for (i = 0, len = codes.right.length; i < len; i++) {
  			keys[codes.right[i]] = [panDelta, 0];
  		}
  		for (i = 0, len = codes.down.length; i < len; i++) {
  			keys[codes.down[i]] = [0, panDelta];
  		}
  		for (i = 0, len = codes.up.length; i < len; i++) {
  			keys[codes.up[i]] = [0, -1 * panDelta];
  		}
  	},

  	_setZoomDelta: function (zoomDelta) {
  		var keys = this._zoomKeys = {},
  		    codes = this.keyCodes,
  		    i, len;

  		for (i = 0, len = codes.zoomIn.length; i < len; i++) {
  			keys[codes.zoomIn[i]] = zoomDelta;
  		}
  		for (i = 0, len = codes.zoomOut.length; i < len; i++) {
  			keys[codes.zoomOut[i]] = -zoomDelta;
  		}
  	},

  	_addHooks: function () {
  		on(document, 'keydown', this._onKeyDown, this);
  	},

  	_removeHooks: function () {
  		off(document, 'keydown', this._onKeyDown, this);
  	},

  	_onKeyDown: function (e) {
  		if (e.altKey || e.ctrlKey || e.metaKey) { return; }

  		var key = e.keyCode,
  		    map = this._map,
  		    offset;

  		if (key in this._panKeys) {
  			if (!map._panAnim || !map._panAnim._inProgress) {
  				offset = this._panKeys[key];
  				if (e.shiftKey) {
  					offset = toPoint(offset).multiplyBy(3);
  				}

  				map.panBy(offset);

  				if (map.options.maxBounds) {
  					map.panInsideBounds(map.options.maxBounds);
  				}
  			}
  		} else if (key in this._zoomKeys) {
  			map.setZoom(map.getZoom() + (e.shiftKey ? 3 : 1) * this._zoomKeys[key]);

  		} else if (key === 27 && map._popup && map._popup.options.closeOnEscapeKey) {
  			map.closePopup();

  		} else {
  			return;
  		}

  		stop(e);
  	}
  });

  // @section Handlers
  // @section Handlers
  // @property keyboard: Handler
  // Keyboard navigation handler.
  Map.addInitHook('addHandler', 'keyboard', Keyboard);

  /*
   * L.Handler.ScrollWheelZoom is used by L.Map to enable mouse scroll wheel zoom on the map.
   */

  // @namespace Map
  // @section Interaction Options
  Map.mergeOptions({
  	// @section Mouse wheel options
  	// @option scrollWheelZoom: Boolean|String = true
  	// Whether the map can be zoomed by using the mouse wheel. If passed `'center'`,
  	// it will zoom to the center of the view regardless of where the mouse was.
  	scrollWheelZoom: true,

  	// @option wheelDebounceTime: Number = 40
  	// Limits the rate at which a wheel can fire (in milliseconds). By default
  	// user can't zoom via wheel more often than once per 40 ms.
  	wheelDebounceTime: 40,

  	// @option wheelPxPerZoomLevel: Number = 60
  	// How many scroll pixels (as reported by [L.DomEvent.getWheelDelta](#domevent-getwheeldelta))
  	// mean a change of one full zoom level. Smaller values will make wheel-zooming
  	// faster (and vice versa).
  	wheelPxPerZoomLevel: 60
  });

  var ScrollWheelZoom = Handler.extend({
  	addHooks: function () {
  		on(this._map._container, 'wheel', this._onWheelScroll, this);

  		this._delta = 0;
  	},

  	removeHooks: function () {
  		off(this._map._container, 'wheel', this._onWheelScroll, this);
  	},

  	_onWheelScroll: function (e) {
  		var delta = getWheelDelta(e);

  		var debounce = this._map.options.wheelDebounceTime;

  		this._delta += delta;
  		this._lastMousePos = this._map.mouseEventToContainerPoint(e);

  		if (!this._startTime) {
  			this._startTime = +new Date();
  		}

  		var left = Math.max(debounce - (+new Date() - this._startTime), 0);

  		clearTimeout(this._timer);
  		this._timer = setTimeout(bind(this._performZoom, this), left);

  		stop(e);
  	},

  	_performZoom: function () {
  		var map = this._map,
  		    zoom = map.getZoom(),
  		    snap = this._map.options.zoomSnap || 0;

  		map._stop(); // stop panning and fly animations if any

  		// map the delta with a sigmoid function to -4..4 range leaning on -1..1
  		var d2 = this._delta / (this._map.options.wheelPxPerZoomLevel * 4),
  		    d3 = 4 * Math.log(2 / (1 + Math.exp(-Math.abs(d2)))) / Math.LN2,
  		    d4 = snap ? Math.ceil(d3 / snap) * snap : d3,
  		    delta = map._limitZoom(zoom + (this._delta > 0 ? d4 : -d4)) - zoom;

  		this._delta = 0;
  		this._startTime = null;

  		if (!delta) { return; }

  		if (map.options.scrollWheelZoom === 'center') {
  			map.setZoom(zoom + delta);
  		} else {
  			map.setZoomAround(this._lastMousePos, zoom + delta);
  		}
  	}
  });

  // @section Handlers
  // @property scrollWheelZoom: Handler
  // Scroll wheel zoom handler.
  Map.addInitHook('addHandler', 'scrollWheelZoom', ScrollWheelZoom);

  /*
   * L.Map.Tap is used to enable mobile hacks like quick taps and long hold.
   */

  // @namespace Map
  // @section Interaction Options
  Map.mergeOptions({
  	// @section Touch interaction options
  	// @option tap: Boolean = true
  	// Enables mobile hacks for supporting instant taps (fixing 200ms click
  	// delay on iOS/Android) and touch holds (fired as `contextmenu` events).
  	tap: true,

  	// @option tapTolerance: Number = 15
  	// The max number of pixels a user can shift his finger during touch
  	// for it to be considered a valid tap.
  	tapTolerance: 15
  });

  var Tap = Handler.extend({
  	addHooks: function () {
  		on(this._map._container, 'touchstart', this._onDown, this);
  	},

  	removeHooks: function () {
  		off(this._map._container, 'touchstart', this._onDown, this);
  	},

  	_onDown: function (e) {
  		if (!e.touches) { return; }

  		preventDefault(e);

  		this._fireClick = true;

  		// don't simulate click or track longpress if more than 1 touch
  		if (e.touches.length > 1) {
  			this._fireClick = false;
  			clearTimeout(this._holdTimeout);
  			return;
  		}

  		var first = e.touches[0],
  		    el = first.target;

  		this._startPos = this._newPos = new Point(first.clientX, first.clientY);

  		// if touching a link, highlight it
  		if (el.tagName && el.tagName.toLowerCase() === 'a') {
  			addClass(el, 'leaflet-active');
  		}

  		// simulate long hold but setting a timeout
  		this._holdTimeout = setTimeout(bind(function () {
  			if (this._isTapValid()) {
  				this._fireClick = false;
  				this._onUp();
  				this._simulateEvent('contextmenu', first);
  			}
  		}, this), 1000);

  		this._simulateEvent('mousedown', first);

  		on(document, {
  			touchmove: this._onMove,
  			touchend: this._onUp
  		}, this);
  	},

  	_onUp: function (e) {
  		clearTimeout(this._holdTimeout);

  		off(document, {
  			touchmove: this._onMove,
  			touchend: this._onUp
  		}, this);

  		if (this._fireClick && e && e.changedTouches) {

  			var first = e.changedTouches[0],
  			    el = first.target;

  			if (el && el.tagName && el.tagName.toLowerCase() === 'a') {
  				removeClass(el, 'leaflet-active');
  			}

  			this._simulateEvent('mouseup', first);

  			// simulate click if the touch didn't move too much
  			if (this._isTapValid()) {
  				this._simulateEvent('click', first);
  			}
  		}
  	},

  	_isTapValid: function () {
  		return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance;
  	},

  	_onMove: function (e) {
  		var first = e.touches[0];
  		this._newPos = new Point(first.clientX, first.clientY);
  		this._simulateEvent('mousemove', first);
  	},

  	_simulateEvent: function (type, e) {
  		var simulatedEvent = document.createEvent('MouseEvents');

  		simulatedEvent._simulated = true;
  		e.target._simulatedClick = true;

  		simulatedEvent.initMouseEvent(
  		        type, true, true, window, 1,
  		        e.screenX, e.screenY,
  		        e.clientX, e.clientY,
  		        false, false, false, false, 0, null);

  		e.target.dispatchEvent(simulatedEvent);
  	}
  });

  // @section Handlers
  // @property tap: Handler
  // Mobile touch hacks (quick tap and touch hold) handler.
  if (touch && (!pointer || safari)) {
  	Map.addInitHook('addHandler', 'tap', Tap);
  }

  /*
   * L.Handler.TouchZoom is used by L.Map to add pinch zoom on supported mobile browsers.
   */

  // @namespace Map
  // @section Interaction Options
  Map.mergeOptions({
  	// @section Touch interaction options
  	// @option touchZoom: Boolean|String = *
  	// Whether the map can be zoomed by touch-dragging with two fingers. If
  	// passed `'center'`, it will zoom to the center of the view regardless of
  	// where the touch events (fingers) were. Enabled for touch-capable web
  	// browsers except for old Androids.
  	touchZoom: touch && !android23,

  	// @option bounceAtZoomLimits: Boolean = true
  	// Set it to false if you don't want the map to zoom beyond min/max zoom
  	// and then bounce back when pinch-zooming.
  	bounceAtZoomLimits: true
  });

  var TouchZoom = Handler.extend({
  	addHooks: function () {
  		addClass(this._map._container, 'leaflet-touch-zoom');
  		on(this._map._container, 'touchstart', this._onTouchStart, this);
  	},

  	removeHooks: function () {
  		removeClass(this._map._container, 'leaflet-touch-zoom');
  		off(this._map._container, 'touchstart', this._onTouchStart, this);
  	},

  	_onTouchStart: function (e) {
  		var map = this._map;
  		if (!e.touches || e.touches.length !== 2 || map._animatingZoom || this._zooming) { return; }

  		var p1 = map.mouseEventToContainerPoint(e.touches[0]),
  		    p2 = map.mouseEventToContainerPoint(e.touches[1]);

  		this._centerPoint = map.getSize()._divideBy(2);
  		this._startLatLng = map.containerPointToLatLng(this._centerPoint);
  		if (map.options.touchZoom !== 'center') {
  			this._pinchStartLatLng = map.containerPointToLatLng(p1.add(p2)._divideBy(2));
  		}

  		this._startDist = p1.distanceTo(p2);
  		this._startZoom = map.getZoom();

  		this._moved = false;
  		this._zooming = true;

  		map._stop();

  		on(document, 'touchmove', this._onTouchMove, this);
  		on(document, 'touchend', this._onTouchEnd, this);

  		preventDefault(e);
  	},

  	_onTouchMove: function (e) {
  		if (!e.touches || e.touches.length !== 2 || !this._zooming) { return; }

  		var map = this._map,
  		    p1 = map.mouseEventToContainerPoint(e.touches[0]),
  		    p2 = map.mouseEventToContainerPoint(e.touches[1]),
  		    scale = p1.distanceTo(p2) / this._startDist;

  		this._zoom = map.getScaleZoom(scale, this._startZoom);

  		if (!map.options.bounceAtZoomLimits && (
  			(this._zoom < map.getMinZoom() && scale < 1) ||
  			(this._zoom > map.getMaxZoom() && scale > 1))) {
  			this._zoom = map._limitZoom(this._zoom);
  		}

  		if (map.options.touchZoom === 'center') {
  			this._center = this._startLatLng;
  			if (scale === 1) { return; }
  		} else {
  			// Get delta from pinch to center, so centerLatLng is delta applied to initial pinchLatLng
  			var delta = p1._add(p2)._divideBy(2)._subtract(this._centerPoint);
  			if (scale === 1 && delta.x === 0 && delta.y === 0) { return; }
  			this._center = map.unproject(map.project(this._pinchStartLatLng, this._zoom).subtract(delta), this._zoom);
  		}

  		if (!this._moved) {
  			map._moveStart(true, false);
  			this._moved = true;
  		}

  		cancelAnimFrame(this._animRequest);

  		var moveFn = bind(map._move, map, this._center, this._zoom, {pinch: true, round: false});
  		this._animRequest = requestAnimFrame(moveFn, this, true);

  		preventDefault(e);
  	},

  	_onTouchEnd: function () {
  		if (!this._moved || !this._zooming) {
  			this._zooming = false;
  			return;
  		}

  		this._zooming = false;
  		cancelAnimFrame(this._animRequest);

  		off(document, 'touchmove', this._onTouchMove, this);
  		off(document, 'touchend', this._onTouchEnd, this);

  		// Pinch updates GridLayers' levels only when zoomSnap is off, so zoomSnap becomes noUpdate.
  		if (this._map.options.zoomAnimation) {
  			this._map._animateZoom(this._center, this._map._limitZoom(this._zoom), true, this._map.options.zoomSnap);
  		} else {
  			this._map._resetView(this._center, this._map._limitZoom(this._zoom));
  		}
  	}
  });

  // @section Handlers
  // @property touchZoom: Handler
  // Touch zoom handler.
  Map.addInitHook('addHandler', 'touchZoom', TouchZoom);

  Map.BoxZoom = BoxZoom;
  Map.DoubleClickZoom = DoubleClickZoom;
  Map.Drag = Drag;
  Map.Keyboard = Keyboard;
  Map.ScrollWheelZoom = ScrollWheelZoom;
  Map.Tap = Tap;
  Map.TouchZoom = TouchZoom;

  exports.version = version;
  exports.Control = Control;
  exports.control = control;
  exports.Browser = Browser;
  exports.Evented = Evented;
  exports.Mixin = Mixin;
  exports.Util = Util;
  exports.Class = Class;
  exports.Handler = Handler;
  exports.extend = extend;
  exports.bind = bind;
  exports.stamp = stamp;
  exports.setOptions = setOptions;
  exports.DomEvent = DomEvent;
  exports.DomUtil = DomUtil;
  exports.PosAnimation = PosAnimation;
  exports.Draggable = Draggable;
  exports.LineUtil = LineUtil;
  exports.PolyUtil = PolyUtil;
  exports.Point = Point;
  exports.point = toPoint;
  exports.Bounds = Bounds;
  exports.bounds = toBounds;
  exports.Transformation = Transformation;
  exports.transformation = toTransformation;
  exports.Projection = index;
  exports.LatLng = LatLng;
  exports.latLng = toLatLng;
  exports.LatLngBounds = LatLngBounds;
  exports.latLngBounds = toLatLngBounds;
  exports.CRS = CRS;
  exports.GeoJSON = GeoJSON;
  exports.geoJSON = geoJSON;
  exports.geoJson = geoJson;
  exports.Layer = Layer;
  exports.LayerGroup = LayerGroup;
  exports.layerGroup = layerGroup;
  exports.FeatureGroup = FeatureGroup;
  exports.featureGroup = featureGroup;
  exports.ImageOverlay = ImageOverlay;
  exports.imageOverlay = imageOverlay;
  exports.VideoOverlay = VideoOverlay;
  exports.videoOverlay = videoOverlay;
  exports.SVGOverlay = SVGOverlay;
  exports.svgOverlay = svgOverlay;
  exports.DivOverlay = DivOverlay;
  exports.Popup = Popup;
  exports.popup = popup;
  exports.Tooltip = Tooltip;
  exports.tooltip = tooltip;
  exports.Icon = Icon;
  exports.icon = icon;
  exports.DivIcon = DivIcon;
  exports.divIcon = divIcon;
  exports.Marker = Marker;
  exports.marker = marker;
  exports.TileLayer = TileLayer;
  exports.tileLayer = tileLayer;
  exports.GridLayer = GridLayer;
  exports.gridLayer = gridLayer;
  exports.SVG = SVG;
  exports.svg = svg$1;
  exports.Renderer = Renderer;
  exports.Canvas = Canvas;
  exports.canvas = canvas$1;
  exports.Path = Path;
  exports.CircleMarker = CircleMarker;
  exports.circleMarker = circleMarker;
  exports.Circle = Circle;
  exports.circle = circle;
  exports.Polyline = Polyline;
  exports.polyline = polyline;
  exports.Polygon = Polygon;
  exports.polygon = polygon;
  exports.Rectangle = Rectangle;
  exports.rectangle = rectangle;
  exports.Map = Map;
  exports.map = createMap;

  var oldL = window.L;
  exports.noConflict = function() {
  	window.L = oldL;
  	return this;
  }

  // Always export us to window global (see #2364)
  window.L = exports;

})));
//# sourceMappingURL=leaflet-src.js.map


/***/ }),

/***/ "./src/css/energieatlas.scss":
/*!***********************************!*\
  !*** ./src/css/energieatlas.scss ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./node_modules/ste-core/dist/dispatching.js":
/*!***************************************************!*\
  !*** ./node_modules/ste-core/dist/dispatching.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DispatcherWrapper = exports.EventListBase = exports.DispatcherBase = void 0;
var management_1 = __webpack_require__(/*! ./management */ "./node_modules/ste-core/dist/management.js");
var subscription_1 = __webpack_require__(/*! ./subscription */ "./node_modules/ste-core/dist/subscription.js");
/**
 * Base class for implementation of the dispatcher. It facilitates the subscribe
 * and unsubscribe methods based on generic handlers. The TEventType specifies
 * the type of event that should be exposed. Use the asEvent to expose the
 * dispatcher as event.
 */
var DispatcherBase = /** @class */ (function () {
    function DispatcherBase() {
        this._wrap = new DispatcherWrapper(this);
        this._subscriptions = new Array();
    }
    Object.defineProperty(DispatcherBase.prototype, "count", {
        /**
         * Returns the number of subscriptions.
         *
         * @readonly
         *
         * @memberOf DispatcherBase
         */
        get: function () {
            return this._subscriptions.length;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Subscribe to the event dispatcher.
     * @param fn The event handler that is called when the event is dispatched.
     * @returns A function that unsubscribes the event handler from the event.
     */
    DispatcherBase.prototype.subscribe = function (fn) {
        var _this = this;
        if (fn) {
            this._subscriptions.push(new subscription_1.Subscription(fn, false));
        }
        return function () {
            _this.unsubscribe(fn);
        };
    };
    /**
     * Subscribe to the event dispatcher.
     * @param fn The event handler that is called when the event is dispatched.
     * @returns A function that unsubscribes the event handler from the event.
     */
    DispatcherBase.prototype.sub = function (fn) {
        return this.subscribe(fn);
    };
    /**
     * Subscribe once to the event with the specified name.
     * @param fn The event handler that is called when the event is dispatched.
     * @returns A function that unsubscribes the event handler from the event.
     */
    DispatcherBase.prototype.one = function (fn) {
        var _this = this;
        if (fn) {
            this._subscriptions.push(new subscription_1.Subscription(fn, true));
        }
        return function () {
            _this.unsubscribe(fn);
        };
    };
    /**
     * Checks it the event has a subscription for the specified handler.
     * @param fn The event handler.
     */
    DispatcherBase.prototype.has = function (fn) {
        if (!fn)
            return false;
        return this._subscriptions.some(function (sub) { return sub.handler == fn; });
    };
    /**
     * Unsubscribes the handler from the dispatcher.
     * @param fn The event handler.
     */
    DispatcherBase.prototype.unsubscribe = function (fn) {
        if (!fn)
            return;
        for (var i = 0; i < this._subscriptions.length; i++) {
            if (this._subscriptions[i].handler == fn) {
                this._subscriptions.splice(i, 1);
                break;
            }
        }
    };
    /**
     * Unsubscribes the handler from the dispatcher.
     * @param fn The event handler.
     */
    DispatcherBase.prototype.unsub = function (fn) {
        this.unsubscribe(fn);
    };
    /**
     * Generic dispatch will dispatch the handlers with the given arguments.
     *
     * @protected
     * @param {boolean} executeAsync True if the even should be executed async.
     * @param {*} The scope the scope of the event. The scope becomes the "this" for handler.
     * @param {IArguments} args The arguments for the event.
     */
    DispatcherBase.prototype._dispatch = function (executeAsync, scope, args) {
        var _this = this;
        var _loop_1 = function (sub) {
            var ev = new management_1.EventManagement(function () { return _this.unsub(sub.handler); });
            var nargs = Array.prototype.slice.call(args);
            nargs.push(ev);
            sub.execute(executeAsync, scope, nargs);
            //cleanup subs that are no longer needed
            this_1.cleanup(sub);
            if (!executeAsync && ev.propagationStopped) {
                return "break";
            }
        };
        var this_1 = this;
        //execute on a copy because of bug #9
        for (var _i = 0, _a = __spreadArrays(this._subscriptions); _i < _a.length; _i++) {
            var sub = _a[_i];
            var state_1 = _loop_1(sub);
            if (state_1 === "break")
                break;
        }
    };
    /**
     * Cleans up subs that ran and should run only once.
     */
    DispatcherBase.prototype.cleanup = function (sub) {
        if (sub.isOnce && sub.isExecuted) {
            var i = this._subscriptions.indexOf(sub);
            if (i > -1) {
                this._subscriptions.splice(i, 1);
            }
        }
    };
    /**
     * Creates an event from the dispatcher. Will return the dispatcher
     * in a wrapper. This will prevent exposure of any dispatcher methods.
     */
    DispatcherBase.prototype.asEvent = function () {
        return this._wrap;
    };
    /**
     * Clears all the subscriptions.
     */
    DispatcherBase.prototype.clear = function () {
        this._subscriptions.splice(0, this._subscriptions.length);
    };
    return DispatcherBase;
}());
exports.DispatcherBase = DispatcherBase;
/**
 * Base class for event lists classes. Implements the get and remove.
 */
var EventListBase = /** @class */ (function () {
    function EventListBase() {
        this._events = {};
    }
    /**
     * Gets the dispatcher associated with the name.
     * @param name The name of the event.
     */
    EventListBase.prototype.get = function (name) {
        var event = this._events[name];
        if (event) {
            return event;
        }
        event = this.createDispatcher();
        this._events[name] = event;
        return event;
    };
    /**
     * Removes the dispatcher associated with the name.
     * @param name The name of the event.
     */
    EventListBase.prototype.remove = function (name) {
        delete this._events[name];
    };
    return EventListBase;
}());
exports.EventListBase = EventListBase;
/**
 * Hides the implementation of the event dispatcher. Will expose methods that
 * are relevent to the event.
 */
var DispatcherWrapper = /** @class */ (function () {
    /**
     * Creates a new EventDispatcherWrapper instance.
     * @param dispatcher The dispatcher.
     */
    function DispatcherWrapper(dispatcher) {
        this._subscribe = function (fn) { return dispatcher.subscribe(fn); };
        this._unsubscribe = function (fn) { return dispatcher.unsubscribe(fn); };
        this._one = function (fn) { return dispatcher.one(fn); };
        this._has = function (fn) { return dispatcher.has(fn); };
        this._clear = function () { return dispatcher.clear(); };
        this._count = function () { return dispatcher.count; };
    }
    Object.defineProperty(DispatcherWrapper.prototype, "count", {
        /**
         * Returns the number of subscriptions.
         *
         * @readonly
         * @type {number}
         * @memberOf DispatcherWrapper
         */
        get: function () {
            return this._count();
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Subscribe to the event dispatcher.
     * @param fn The event handler that is called when the event is dispatched.
     * @returns A function that unsubscribes the event handler from the event.
     */
    DispatcherWrapper.prototype.subscribe = function (fn) {
        return this._subscribe(fn);
    };
    /**
     * Subscribe to the event dispatcher.
     * @param fn The event handler that is called when the event is dispatched.
     * @returns A function that unsubscribes the event handler from the event.
     */
    DispatcherWrapper.prototype.sub = function (fn) {
        return this.subscribe(fn);
    };
    /**
     * Unsubscribe from the event dispatcher.
     * @param fn The event handler that is called when the event is dispatched.
     */
    DispatcherWrapper.prototype.unsubscribe = function (fn) {
        this._unsubscribe(fn);
    };
    /**
     * Unsubscribe from the event dispatcher.
     * @param fn The event handler that is called when the event is dispatched.
     */
    DispatcherWrapper.prototype.unsub = function (fn) {
        this.unsubscribe(fn);
    };
    /**
     * Subscribe once to the event with the specified name.
     * @param fn The event handler that is called when the event is dispatched.
     */
    DispatcherWrapper.prototype.one = function (fn) {
        return this._one(fn);
    };
    /**
     * Checks it the event has a subscription for the specified handler.
     * @param fn The event handler.
     */
    DispatcherWrapper.prototype.has = function (fn) {
        return this._has(fn);
    };
    /**
     * Clears all the subscriptions.
     */
    DispatcherWrapper.prototype.clear = function () {
        this._clear();
    };
    return DispatcherWrapper;
}());
exports.DispatcherWrapper = DispatcherWrapper;


/***/ }),

/***/ "./node_modules/ste-core/dist/index.js":
/*!*********************************************!*\
  !*** ./node_modules/ste-core/dist/index.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*!
 * Strongly Typed Events for TypeScript - Core
 * https://github.com/KeesCBakker/StronlyTypedEvents/
 * http://keestalkstech.com
 *
 * Copyright Kees C. Bakker / KeesTalksTech
 * Released under the MIT license
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Subscription = exports.EventListBase = exports.DispatcherWrapper = exports.DispatcherBase = void 0;
var dispatching_1 = __webpack_require__(/*! ./dispatching */ "./node_modules/ste-core/dist/dispatching.js");
Object.defineProperty(exports, "DispatcherBase", ({ enumerable: true, get: function () { return dispatching_1.DispatcherBase; } }));
Object.defineProperty(exports, "DispatcherWrapper", ({ enumerable: true, get: function () { return dispatching_1.DispatcherWrapper; } }));
Object.defineProperty(exports, "EventListBase", ({ enumerable: true, get: function () { return dispatching_1.EventListBase; } }));
var subscription_1 = __webpack_require__(/*! ./subscription */ "./node_modules/ste-core/dist/subscription.js");
Object.defineProperty(exports, "Subscription", ({ enumerable: true, get: function () { return subscription_1.Subscription; } }));


/***/ }),

/***/ "./node_modules/ste-core/dist/management.js":
/*!**************************************************!*\
  !*** ./node_modules/ste-core/dist/management.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EventManagement = void 0;
/**
 * Allows the user to interact with the event.
 *
 * @class EventManagement
 * @implements {IEventManagement}
 */
var EventManagement = /** @class */ (function () {
    function EventManagement(unsub) {
        this.unsub = unsub;
        this.propagationStopped = false;
    }
    EventManagement.prototype.stopPropagation = function () {
        this.propagationStopped = true;
    };
    return EventManagement;
}());
exports.EventManagement = EventManagement;


/***/ }),

/***/ "./node_modules/ste-core/dist/subscription.js":
/*!****************************************************!*\
  !*** ./node_modules/ste-core/dist/subscription.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Subscription = void 0;
/**
 * Stores a handler. Manages execution meta data.
 * @class Subscription
 * @template TEventHandler
 */
var Subscription = /** @class */ (function () {
    /**
     * Creates an instance of Subscription.
     *
     * @param {TEventHandler} handler The handler for the subscription.
     * @param {boolean} isOnce Indicates if the handler should only be executed once.
     */
    function Subscription(handler, isOnce) {
        this.handler = handler;
        this.isOnce = isOnce;
        /**
         * Indicates if the subscription has been executed before.
         */
        this.isExecuted = false;
    }
    /**
     * Executes the handler.
     *
     * @param {boolean} executeAsync True if the even should be executed async.
     * @param {*} scope The scope the scope of the event.
     * @param {IArguments} args The arguments for the event.
     */
    Subscription.prototype.execute = function (executeAsync, scope, args) {
        if (!this.isOnce || !this.isExecuted) {
            this.isExecuted = true;
            var fn = this.handler;
            if (executeAsync) {
                setTimeout(function () {
                    fn.apply(scope, args);
                }, 1);
            }
            else {
                fn.apply(scope, args);
            }
        }
    };
    return Subscription;
}());
exports.Subscription = Subscription;


/***/ }),

/***/ "./node_modules/ste-events/dist/events.js":
/*!************************************************!*\
  !*** ./node_modules/ste-events/dist/events.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EventHandlingBase = exports.EventList = exports.NonUniformEventList = exports.EventDispatcher = void 0;
var ste_core_1 = __webpack_require__(/*! ste-core */ "./node_modules/ste-core/dist/index.js");
/**
 * Dispatcher implementation for events. Can be used to subscribe, unsubscribe
 * or dispatch events. Use the ToEvent() method to expose the event.
 */
var EventDispatcher = /** @class */ (function (_super) {
    __extends(EventDispatcher, _super);
    /**
     * Creates a new EventDispatcher instance.
     */
    function EventDispatcher() {
        return _super.call(this) || this;
    }
    /**
     * Dispatches the event.
     * @param sender The sender.
     * @param args The arguments object.
     */
    EventDispatcher.prototype.dispatch = function (sender, args) {
        this._dispatch(false, this, arguments);
    };
    /**
     * Dispatches the events thread.
     * @param sender The sender.
     * @param args The arguments object.
     */
    EventDispatcher.prototype.dispatchAsync = function (sender, args) {
        this._dispatch(true, this, arguments);
    };
    /**
     * Creates an event from the dispatcher. Will return the dispatcher
     * in a wrapper. This will prevent exposure of any dispatcher methods.
     */
    EventDispatcher.prototype.asEvent = function () {
        return _super.prototype.asEvent.call(this);
    };
    return EventDispatcher;
}(ste_core_1.DispatcherBase));
exports.EventDispatcher = EventDispatcher;
/**
 * Similar to EventList, but instead of TArgs, a map of event names ang argument types is provided with TArgsMap.
 */
var NonUniformEventList = /** @class */ (function () {
    function NonUniformEventList() {
        this._events = {};
    }
    /**
     * Gets the dispatcher associated with the name.
     * @param name The name of the event.
     */
    NonUniformEventList.prototype.get = function (name) {
        if (this._events[name]) {
            // @TODO avoid typecasting. Not sure why TS thinks this._events[name] could still be undefined.
            return this._events[name];
        }
        var event = this.createDispatcher();
        this._events[name] = event;
        return event;
    };
    /**
     * Removes the dispatcher associated with the name.
     * @param name The name of the event.
     */
    NonUniformEventList.prototype.remove = function (name) {
        delete this._events[name];
    };
    /**
     * Creates a new dispatcher instance.
     */
    NonUniformEventList.prototype.createDispatcher = function () {
        return new EventDispatcher();
    };
    return NonUniformEventList;
}());
exports.NonUniformEventList = NonUniformEventList;
/**
 * Storage class for multiple events that are accessible by name.
 * Events dispatchers are automatically created.
 */
var EventList = /** @class */ (function (_super) {
    __extends(EventList, _super);
    /**
     * Creates a new EventList instance.
     */
    function EventList() {
        return _super.call(this) || this;
    }
    /**
     * Creates a new dispatcher instance.
     */
    EventList.prototype.createDispatcher = function () {
        return new EventDispatcher();
    };
    return EventList;
}(ste_core_1.EventListBase));
exports.EventList = EventList;
/**
 * Extends objects with event handling capabilities.
 */
var EventHandlingBase = /** @class */ (function () {
    function EventHandlingBase() {
        this._events = new EventList();
    }
    Object.defineProperty(EventHandlingBase.prototype, "events", {
        /**
         * Gets the list with all the event dispatchers.
         */
        get: function () {
            return this._events;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Subscribes to the event with the specified name.
     * @param name The name of the event.
     * @param fn The event handler.
     */
    EventHandlingBase.prototype.subscribe = function (name, fn) {
        this._events.get(name).subscribe(fn);
    };
    /**
     * Subscribes to the event with the specified name.
     * @param name The name of the event.
     * @param fn The event handler.
     */
    EventHandlingBase.prototype.sub = function (name, fn) {
        this.subscribe(name, fn);
    };
    /**
     * Unsubscribes from the event with the specified name.
     * @param name The name of the event.
     * @param fn The event handler.
     */
    EventHandlingBase.prototype.unsubscribe = function (name, fn) {
        this._events.get(name).unsubscribe(fn);
    };
    /**
     * Unsubscribes from the event with the specified name.
     * @param name The name of the event.
     * @param fn The event handler.
     */
    EventHandlingBase.prototype.unsub = function (name, fn) {
        this.unsubscribe(name, fn);
    };
    /**
     * Subscribes to once the event with the specified name.
     * @param name The name of the event.
     * @param fn The event handler.
     */
    EventHandlingBase.prototype.one = function (name, fn) {
        this._events.get(name).one(fn);
    };
    /**
     * Subscribes to once the event with the specified name.
     * @param name The name of the event.
     * @param fn The event handler.
     */
    EventHandlingBase.prototype.has = function (name, fn) {
        return this._events.get(name).has(fn);
    };
    return EventHandlingBase;
}());
exports.EventHandlingBase = EventHandlingBase;


/***/ }),

/***/ "./node_modules/ste-events/dist/index.js":
/*!***********************************************!*\
  !*** ./node_modules/ste-events/dist/index.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NonUniformEventList = exports.EventList = exports.EventHandlingBase = exports.EventDispatcher = void 0;
var events_1 = __webpack_require__(/*! ./events */ "./node_modules/ste-events/dist/events.js");
Object.defineProperty(exports, "EventDispatcher", ({ enumerable: true, get: function () { return events_1.EventDispatcher; } }));
Object.defineProperty(exports, "EventHandlingBase", ({ enumerable: true, get: function () { return events_1.EventHandlingBase; } }));
Object.defineProperty(exports, "EventList", ({ enumerable: true, get: function () { return events_1.EventList; } }));
Object.defineProperty(exports, "NonUniformEventList", ({ enumerable: true, get: function () { return events_1.NonUniformEventList; } }));


/***/ }),

/***/ "./node_modules/ste-signals/dist/index.js":
/*!************************************************!*\
  !*** ./node_modules/ste-signals/dist/index.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SignalList = exports.SignalHandlingBase = exports.SignalDispatcher = void 0;
var signals_1 = __webpack_require__(/*! ./signals */ "./node_modules/ste-signals/dist/signals.js");
Object.defineProperty(exports, "SignalDispatcher", ({ enumerable: true, get: function () { return signals_1.SignalDispatcher; } }));
Object.defineProperty(exports, "SignalHandlingBase", ({ enumerable: true, get: function () { return signals_1.SignalHandlingBase; } }));
Object.defineProperty(exports, "SignalList", ({ enumerable: true, get: function () { return signals_1.SignalList; } }));


/***/ }),

/***/ "./node_modules/ste-signals/dist/signals.js":
/*!**************************************************!*\
  !*** ./node_modules/ste-signals/dist/signals.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SignalHandlingBase = exports.SignalList = exports.SignalDispatcher = void 0;
var ste_core_1 = __webpack_require__(/*! ste-core */ "./node_modules/ste-core/dist/index.js");
/**
 * The dispatcher handles the storage of subsciptions and facilitates
 * subscription, unsubscription and dispatching of a signal event.
 */
var SignalDispatcher = /** @class */ (function (_super) {
    __extends(SignalDispatcher, _super);
    /**
     * Creates a new SignalDispatcher instance.
     */
    function SignalDispatcher() {
        return _super.call(this) || this;
    }
    /**
     * Dispatches the signal.
     */
    SignalDispatcher.prototype.dispatch = function () {
        this._dispatch(false, this, arguments);
    };
    /**
     * Dispatches the signal threaded.
     */
    SignalDispatcher.prototype.dispatchAsync = function () {
        this._dispatch(true, this, arguments);
    };
    /**
     * Creates an event from the dispatcher. Will return the dispatcher
     * in a wrapper. This will prevent exposure of any dispatcher methods.
     */
    SignalDispatcher.prototype.asEvent = function () {
        return _super.prototype.asEvent.call(this);
    };
    return SignalDispatcher;
}(ste_core_1.DispatcherBase));
exports.SignalDispatcher = SignalDispatcher;
/**
 * Storage class for multiple signal events that are accessible by name.
 * Events dispatchers are automatically created.
 */
var SignalList = /** @class */ (function (_super) {
    __extends(SignalList, _super);
    /**
     * Creates a new SignalList instance.
     */
    function SignalList() {
        return _super.call(this) || this;
    }
    /**
     * Creates a new dispatcher instance.
     */
    SignalList.prototype.createDispatcher = function () {
        return new SignalDispatcher();
    };
    return SignalList;
}(ste_core_1.EventListBase));
exports.SignalList = SignalList;
/**
 * Extends objects with signal event handling capabilities.
 */
var SignalHandlingBase = /** @class */ (function () {
    function SignalHandlingBase() {
        this._events = new SignalList();
    }
    Object.defineProperty(SignalHandlingBase.prototype, "events", {
        get: function () {
            return this._events;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Subscribes once to the event with the specified name.
     * @param name The name of the event.
     * @param fn The event handler.
     */
    SignalHandlingBase.prototype.one = function (name, fn) {
        this._events.get(name).one(fn);
    };
    /**
     * Checks it the event has a subscription for the specified handler.
     * @param name The name of the event.
     * @param fn The event handler.
     */
    SignalHandlingBase.prototype.has = function (name, fn) {
        return this._events.get(name).has(fn);
    };
    /**
     * Subscribes to the event with the specified name.
     * @param name The name of the event.
     * @param fn The event handler.
     */
    SignalHandlingBase.prototype.subscribe = function (name, fn) {
        this._events.get(name).subscribe(fn);
    };
    /**
     * Subscribes to the event with the specified name.
     * @param name The name of the event.
     * @param fn The event handler.
     */
    SignalHandlingBase.prototype.sub = function (name, fn) {
        this.subscribe(name, fn);
    };
    /**
     * Unsubscribes from the event with the specified name.
     * @param name The name of the event.
     * @param fn The event handler.
     */
    SignalHandlingBase.prototype.unsubscribe = function (name, fn) {
        this._events.get(name).unsubscribe(fn);
    };
    /**
     * Unsubscribes from the event with the specified name.
     * @param name The name of the event.
     * @param fn The event handler.
     */
    SignalHandlingBase.prototype.unsub = function (name, fn) {
        this.unsubscribe(name, fn);
    };
    return SignalHandlingBase;
}());
exports.SignalHandlingBase = SignalHandlingBase;


/***/ }),

/***/ "./node_modules/ste-simple-events/dist/index.js":
/*!******************************************************!*\
  !*** ./node_modules/ste-simple-events/dist/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NonUniformSimpleEventList = exports.SimpleEventList = exports.SimpleEventHandlingBase = exports.SimpleEventDispatcher = void 0;
var simple_events_1 = __webpack_require__(/*! ./simple-events */ "./node_modules/ste-simple-events/dist/simple-events.js");
Object.defineProperty(exports, "SimpleEventDispatcher", ({ enumerable: true, get: function () { return simple_events_1.SimpleEventDispatcher; } }));
Object.defineProperty(exports, "SimpleEventHandlingBase", ({ enumerable: true, get: function () { return simple_events_1.SimpleEventHandlingBase; } }));
Object.defineProperty(exports, "SimpleEventList", ({ enumerable: true, get: function () { return simple_events_1.SimpleEventList; } }));
Object.defineProperty(exports, "NonUniformSimpleEventList", ({ enumerable: true, get: function () { return simple_events_1.NonUniformSimpleEventList; } }));


/***/ }),

/***/ "./node_modules/ste-simple-events/dist/simple-events.js":
/*!**************************************************************!*\
  !*** ./node_modules/ste-simple-events/dist/simple-events.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SimpleEventHandlingBase = exports.SimpleEventList = exports.NonUniformSimpleEventList = exports.SimpleEventDispatcher = void 0;
var ste_core_1 = __webpack_require__(/*! ste-core */ "./node_modules/ste-core/dist/index.js");
/**
 * The dispatcher handles the storage of subsciptions and facilitates
 * subscription, unsubscription and dispatching of a simple event
 */
var SimpleEventDispatcher = /** @class */ (function (_super) {
    __extends(SimpleEventDispatcher, _super);
    /**
     * Creates a new SimpleEventDispatcher instance.
     */
    function SimpleEventDispatcher() {
        return _super.call(this) || this;
    }
    /**
     * Dispatches the event.
     * @param args The arguments object.
     */
    SimpleEventDispatcher.prototype.dispatch = function (args) {
        this._dispatch(false, this, arguments);
    };
    /**
     * Dispatches the events thread.
     * @param args The arguments object.
     */
    SimpleEventDispatcher.prototype.dispatchAsync = function (args) {
        this._dispatch(true, this, arguments);
    };
    /**
     * Creates an event from the dispatcher. Will return the dispatcher
     * in a wrapper. This will prevent exposure of any dispatcher methods.
     */
    SimpleEventDispatcher.prototype.asEvent = function () {
        return _super.prototype.asEvent.call(this);
    };
    return SimpleEventDispatcher;
}(ste_core_1.DispatcherBase));
exports.SimpleEventDispatcher = SimpleEventDispatcher;
/**
 * Similar to EventList, but instead of TArgs, a map of event names ang argument types is provided with TArgsMap.
 */
var NonUniformSimpleEventList = /** @class */ (function () {
    function NonUniformSimpleEventList() {
        this._events = {};
    }
    /**
     * Gets the dispatcher associated with the name.
     * @param name The name of the event.
     */
    NonUniformSimpleEventList.prototype.get = function (name) {
        if (this._events[name]) {
            // @TODO avoid typecasting. Not sure why TS thinks this._events[name] could still be undefined.
            return this._events[name];
        }
        var event = this.createDispatcher();
        this._events[name] = event;
        return event;
    };
    /**
     * Removes the dispatcher associated with the name.
     * @param name The name of the event.
     */
    NonUniformSimpleEventList.prototype.remove = function (name) {
        delete this._events[name];
    };
    /**
     * Creates a new dispatcher instance.
     */
    NonUniformSimpleEventList.prototype.createDispatcher = function () {
        return new SimpleEventDispatcher();
    };
    return NonUniformSimpleEventList;
}());
exports.NonUniformSimpleEventList = NonUniformSimpleEventList;
/**
 * Storage class for multiple simple events that are accessible by name.
 * Events dispatchers are automatically created.
 */
var SimpleEventList = /** @class */ (function (_super) {
    __extends(SimpleEventList, _super);
    /**
     * Creates a new SimpleEventList instance.
     */
    function SimpleEventList() {
        return _super.call(this) || this;
    }
    /**
     * Creates a new dispatcher instance.
     */
    SimpleEventList.prototype.createDispatcher = function () {
        return new SimpleEventDispatcher();
    };
    return SimpleEventList;
}(ste_core_1.EventListBase));
exports.SimpleEventList = SimpleEventList;
/**
 * Extends objects with simple event handling capabilities.
 */
var SimpleEventHandlingBase = /** @class */ (function () {
    function SimpleEventHandlingBase() {
        this._events = new SimpleEventList();
    }
    Object.defineProperty(SimpleEventHandlingBase.prototype, "events", {
        get: function () {
            return this._events;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Subscribes to the event with the specified name.
     * @param name The name of the event.
     * @param fn The event handler.
     */
    SimpleEventHandlingBase.prototype.subscribe = function (name, fn) {
        this._events.get(name).subscribe(fn);
    };
    /**
     * Subscribes to the event with the specified name.
     * @param name The name of the event.
     * @param fn The event handler.
     */
    SimpleEventHandlingBase.prototype.sub = function (name, fn) {
        this.subscribe(name, fn);
    };
    /**
     * Subscribes once to the event with the specified name.
     * @param name The name of the event.
     * @param fn The event handler.
     */
    SimpleEventHandlingBase.prototype.one = function (name, fn) {
        this._events.get(name).one(fn);
    };
    /**
     * Checks it the event has a subscription for the specified handler.
     * @param name The name of the event.
     * @param fn The event handler.
     */
    SimpleEventHandlingBase.prototype.has = function (name, fn) {
        return this._events.get(name).has(fn);
    };
    /**
     * Unsubscribes from the event with the specified name.
     * @param name The name of the event.
     * @param fn The event handler.
     */
    SimpleEventHandlingBase.prototype.unsubscribe = function (name, fn) {
        this._events.get(name).unsubscribe(fn);
    };
    /**
     * Unsubscribes from the event with the specified name.
     * @param name The name of the event.
     * @param fn The event handler.
     */
    SimpleEventHandlingBase.prototype.unsub = function (name, fn) {
        this.unsubscribe(name, fn);
    };
    return SimpleEventHandlingBase;
}());
exports.SimpleEventHandlingBase = SimpleEventHandlingBase;


/***/ }),

/***/ "./node_modules/strongly-typed-events/dist/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/strongly-typed-events/dist/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*!
 * Strongly Typed Events for TypeScript
 * https://github.com/KeesCBakker/StronlyTypedEvents/
 * http://keestalkstech.com
 *
 * Copyright Kees C. Bakker / KeesTalksTech
 * Released under the MIT license
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SignalList = exports.SignalHandlingBase = exports.SignalDispatcher = exports.NonUniformSimpleEventList = exports.SimpleEventList = exports.SimpleEventHandlingBase = exports.SimpleEventDispatcher = exports.NonUniformEventList = exports.EventList = exports.EventHandlingBase = exports.EventDispatcher = exports.Subscription = exports.EventListBase = exports.DispatcherWrapper = exports.DispatcherBase = void 0;
var ste_core_1 = __webpack_require__(/*! ste-core */ "./node_modules/ste-core/dist/index.js");
Object.defineProperty(exports, "DispatcherBase", ({ enumerable: true, get: function () { return ste_core_1.DispatcherBase; } }));
Object.defineProperty(exports, "DispatcherWrapper", ({ enumerable: true, get: function () { return ste_core_1.DispatcherWrapper; } }));
Object.defineProperty(exports, "EventListBase", ({ enumerable: true, get: function () { return ste_core_1.EventListBase; } }));
Object.defineProperty(exports, "Subscription", ({ enumerable: true, get: function () { return ste_core_1.Subscription; } }));
var ste_events_1 = __webpack_require__(/*! ste-events */ "./node_modules/ste-events/dist/index.js");
Object.defineProperty(exports, "EventDispatcher", ({ enumerable: true, get: function () { return ste_events_1.EventDispatcher; } }));
Object.defineProperty(exports, "EventHandlingBase", ({ enumerable: true, get: function () { return ste_events_1.EventHandlingBase; } }));
Object.defineProperty(exports, "EventList", ({ enumerable: true, get: function () { return ste_events_1.EventList; } }));
Object.defineProperty(exports, "NonUniformEventList", ({ enumerable: true, get: function () { return ste_events_1.NonUniformEventList; } }));
var ste_simple_events_1 = __webpack_require__(/*! ste-simple-events */ "./node_modules/ste-simple-events/dist/index.js");
Object.defineProperty(exports, "SimpleEventDispatcher", ({ enumerable: true, get: function () { return ste_simple_events_1.SimpleEventDispatcher; } }));
Object.defineProperty(exports, "SimpleEventHandlingBase", ({ enumerable: true, get: function () { return ste_simple_events_1.SimpleEventHandlingBase; } }));
Object.defineProperty(exports, "SimpleEventList", ({ enumerable: true, get: function () { return ste_simple_events_1.SimpleEventList; } }));
Object.defineProperty(exports, "NonUniformSimpleEventList", ({ enumerable: true, get: function () { return ste_simple_events_1.NonUniformSimpleEventList; } }));
var ste_signals_1 = __webpack_require__(/*! ste-signals */ "./node_modules/ste-signals/dist/index.js");
Object.defineProperty(exports, "SignalDispatcher", ({ enumerable: true, get: function () { return ste_signals_1.SignalDispatcher; } }));
Object.defineProperty(exports, "SignalHandlingBase", ({ enumerable: true, get: function () { return ste_signals_1.SignalHandlingBase; } }));
Object.defineProperty(exports, "SignalList", ({ enumerable: true, get: function () { return ste_signals_1.SignalList; } }));


/***/ }),

/***/ "./src/EnergieAtlas.ts":
/*!*****************************!*\
  !*** ./src/EnergieAtlas.ts ***!
  \*****************************/
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(/*! ./ts/MapApp */ "./src/ts/MapApp.ts")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports, MapApp_1) {
    "use strict";
    exports.__esModule = true;
    __webpack_require__(/*! ./css/energieatlas.scss */ "./src/css/energieatlas.scss");
    function switchSidebar() {
        document.getElementById("main").classList.toggle("sidebar-collapsed");
    }
    function init() {
        document.getElementById("sidebar-switch").addEventListener("click", switchSidebar);
        var url;
        if (typeof LAYERDEFURL !== "undefined") {
            url = LAYERDEFURL;
        }
        (0, MapApp_1.initMap)(url);
    }
    if (document.readyState === "interactive" || document.readyState === "complete") {
        init();
    }
    else {
        document.addEventListener("DOMContentLoaded", init);
    }
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./src/ts/LayerLoader.ts":
/*!*******************************!*\
  !*** ./src/ts/LayerLoader.ts ***!
  \*******************************/
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(/*! ./controls/MapControl */ "./src/ts/controls/MapControl.ts"), __webpack_require__(/*! ./MapClassParser */ "./src/ts/MapClassParser.ts"), __webpack_require__(/*! leaflet */ "./node_modules/leaflet/dist/leaflet-src.js"), __webpack_require__(/*! ./controls/CategorieLayer */ "./src/ts/controls/CategorieLayer.ts"), __webpack_require__(/*! ./util/FormatExpression */ "./src/ts/util/FormatExpression.ts"), __webpack_require__(/*! ./Util */ "./src/ts/Util.ts"), __webpack_require__(/*! ./PiechartLayer */ "./src/ts/PiechartLayer.ts")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports, MapControl_1, MapClassParser_1, L, CategorieLayer_1, FormatExpression_1, Util_1, PiechartLayer_1) {
    "use strict";
    exports.__esModule = true;
    exports.LayerLoader = void 0;
    function _createClassifiers(claszes) {
        var result = { classifiers: [] };
        claszes.forEach(function (clasz) {
            var icon = clasz.icon ? L.icon(clasz.icon) : undefined;
            if (clasz.def) {
                var r = (0, MapClassParser_1.parseExpression)(clasz.def);
                result.classifiers.push({ exp: r, style: clasz.style, icon: icon });
            }
            else {
                result.standardStyle = clasz.style ? clasz.style : { icon: icon };
            }
        });
        return result;
    }
    function _createStyleFct(layerDescr) {
        var _a;
        if (layerDescr.classes) {
            var styles_1 = _createClassifiers(layerDescr.classes);
            return function (feature) {
                for (var i = 0, count = styles_1.classifiers.length; i < count; i++) {
                    if (styles_1.classifiers[i].exp.eval(feature.properties)) {
                        if (styles_1.classifiers[i].icon) {
                            return { icon: styles_1.classifiers[i].icon };
                        }
                        else {
                            return styles_1.classifiers[i].style;
                        }
                    }
                }
                return styles_1.standardStyle ? styles_1.standardStyle : layerDescr.style || { color: "#3388ff", fillColor: "#3388ff" };
            };
        }
        else {
            if (layerDescr.style && !layerDescr.style.fillColor) {
                layerDescr.style.fillColor = (_a = layerDescr.style) === null || _a === void 0 ? void 0 : _a.color;
            }
            return function (feature) { return layerDescr.style; };
        }
    }
    function getHighlightFct(layerDescr) {
        if (layerDescr.geomType === "Linestring") {
            return function (feature, highlight) {
                console.info("hFct Linestring", this, feature, highlight);
                if (highlight) {
                    feature.setStyle({ color: "black" });
                }
                else {
                    var style = this.options.style;
                    if (typeof style === "function") {
                        style = style(feature.feature);
                    }
                    console.info(style);
                    feature.setStyle(style);
                }
            };
        }
        else if (layerDescr.geomType === "Polygon") {
            return function (feature, highlight) {
                // console.error("hFct Polygon", this, feature, highlight);
                if (highlight) {
                    feature.setStyle({ fillColor: "red" });
                }
                else {
                    var style = feature.options.style;
                    if (typeof style === "function") {
                        style = style(feature.feature);
                    }
                    console.info(style);
                    feature.setStyle(style);
                }
            };
        }
    }
    var LayerLoader = /** @class */ (function () {
        function LayerLoader(map) {
            var _this = this;
            this.loadedLayers = [];
            this.layerNr = 401;
            MapControl_1.MapDispatcher.onLayerRequest.subscribe(function (sender, evt) { return _this._layerRequested(sender, evt); });
            this.map = map;
        }
        LayerLoader.prototype._layerRequested = function (sender, evt) {
            var _this = this;
            console.info("_layerRequested id=".concat(evt.layer.layerDescription.id, " label=").concat(evt.layer.layerDescription.label));
            if (!this.loadedLayers.includes(evt.layer)) {
                this.createLayer(evt.layer.layerDescription)
                    .then(function (layer) {
                    evt.layer.layer = layer;
                    evt.layer.loadError = false;
                    _this.loadedLayers.push(evt.layer);
                    MapControl_1.MapDispatcher.onLayerReady.dispatch(_this, {
                        type: "layer-ready",
                        layer: evt.layer
                    });
                })["catch"](function (reason) {
                    console.error("layer \"".concat(evt.layer.layerDescription.label, "\" konnte nicht geladen werden"), reason);
                    evt.layer.loadError = true;
                    MapControl_1.MapDispatcher.onLayerError.dispatch(_this, {
                        type: "layer-error",
                        layer: evt.layer
                    });
                });
            }
            else {
                console.error("already requested");
            }
        };
        LayerLoader.prototype._createPiechartLayer = function (layerDescr, geoJson) {
            var layer = new PiechartLayer_1.PiechartLayer(null, {
                attribution: layerDescr.options.attribution,
                layerDescription: layerDescr
            });
            layer["LayerDescription"] = layerDescr;
            layer.on("click", function (evt) {
                MapControl_1.MapDispatcher.onMapFeatureClick.dispatch(layer, evt);
            });
            geoJson.features.forEach(function (feature, idx) {
                var _a;
                if ((_a = feature === null || feature === void 0 ? void 0 : feature.geometry) === null || _a === void 0 ? void 0 : _a.coordinates) {
                    layer.addLayer(new PiechartLayer_1.PiechartMarker(layer, {
                        lng: feature.geometry.coordinates[0],
                        lat: feature.geometry.coordinates[1]
                    }, feature.properties));
                }
            });
            return layer;
        };
        /**
         *
         * @param layerDescr create a PointLayer
         * @param geoJson
         * @returns
         */
        LayerLoader.prototype._createPointLayer = function (layerDescr, geoJson) {
            console.info("_createPointLayer", layerDescr);
            var paneId = this._createPane();
            var layer = new CategorieLayer_1.GeojsonLayer({
                maxClusterRadius: function (zoom) {
                    // return 15;
                    return 50;
                },
                attribution: layerDescr.options.attribution,
                pane: paneId,
                layerDescription: layerDescr
            });
            layer["LayerDescription"] = layerDescr;
            // layer.on('featureclicked', (evt:FeatureClickEvent)=>{MapDispatcher.onMapFeatureClick.dispatch(evt.feature, evt)})
            layer.on("click", function (evt) {
                MapControl_1.MapDispatcher.onMapFeatureClick.dispatch(layer, evt);
            });
            if (layerDescr.icon) {
                var myIcon = L.icon(layerDescr.icon);
                var markerOpt_1 = { icon: myIcon, pane: paneId };
                console.info("geoJson", geoJson);
                geoJson.features.forEach(function (feature, idx) {
                    // const feature = <geoJson.Feature<geoJson.Point>>geoJson.features[i];
                    try {
                        layer.addLayer(new CategorieLayer_1.CategoryMarker(layer, {
                            lng: feature.geometry.coordinates[0],
                            lat: feature.geometry.coordinates[1]
                        }, feature.properties, markerOpt_1));
                    }
                    catch (ex) {
                        console.error(ex);
                    }
                });
            }
            else {
                var styleFct_1 = _createStyleFct(layerDescr);
                geoJson.features.forEach(function (feature, idx) {
                    var _a;
                    // TODO  const markerOpt = {...styleFct(feature), pane:paneId};
                    if ((_a = feature === null || feature === void 0 ? void 0 : feature.geometry) === null || _a === void 0 ? void 0 : _a.coordinates) {
                        var markerOpt = __assign({}, styleFct_1(feature));
                        if (markerOpt.icon) {
                            layer.addLayer(new CategorieLayer_1.CategoryMarker(layer, {
                                lng: feature.geometry.coordinates[0],
                                lat: feature.geometry.coordinates[1]
                            }, feature.properties, markerOpt));
                        }
                        else {
                            layer.addLayer(new CategorieLayer_1.CategoryCircleMarker(layer, {
                                lng: feature.geometry.coordinates[0],
                                lat: feature.geometry.coordinates[1]
                            }, feature.properties, markerOpt));
                        }
                        // console.info(feature);
                    }
                    else {
                        console.error("Featur without coordinates", feature);
                    }
                });
            }
            return layer;
        };
        LayerLoader.prototype.createWMSLayer = function (layerDescr) {
            return __awaiter(this, void 0, void 0, function () {
                var doc, l;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, getCapabilities(layerDescr.url, layerDescr.options)];
                        case 1:
                            doc = _a.sent();
                            if (doc) {
                                console.info("sddsjhak");
                                console.info(doc);
                                l = new L.TileLayer.WMS(layerDescr.url, __assign({}, layerDescr.options));
                                console.info("WMS", l);
                                return [2 /*return*/, l];
                            }
                            return [2 /*return*/];
                    }
                });
            });
        };
        LayerLoader.prototype.createGeoJSONLayer = function (layerDescr) {
            return __awaiter(this, void 0, void 0, function () {
                var json, fFeatureClicked, styleFct, layer, expFct_1, fctPopup;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, Util_1.loadJson)(layerDescr.url, layerDescr.params)];
                        case 1:
                            json = _a.sent();
                            fFeatureClicked = function (evt) {
                                MapControl_1.MapDispatcher.onMapFeatureClick.dispatch(evt.target, evt);
                            };
                            if (layerDescr.geomType == "Point") {
                                return [2 /*return*/, this._createPointLayer(layerDescr, json)];
                            }
                            else if (layerDescr.geomType == "Chart") {
                                return [2 /*return*/, this._createPiechartLayer(layerDescr, json)];
                            }
                            else {
                                styleFct = _createStyleFct(layerDescr);
                                layer = new L.GeoJSON(json, {
                                    style: styleFct,
                                    pane: this._createPane()
                                });
                                if (layerDescr.popup) {
                                    expFct_1 = (0, FormatExpression_1.createExpressionFct)(layerDescr.popup);
                                    fctPopup = function (layer) {
                                        var f = layer.feature;
                                        // console.info('popupFct', f);
                                        if (f) {
                                            return expFct_1(f.properties);
                                        }
                                    };
                                    layer.bindPopup(fctPopup);
                                    layer.on("click", fFeatureClicked);
                                }
                                else {
                                    layer.on("click", fFeatureClicked);
                                }
                                layer["highlightMarker"] = getHighlightFct(layerDescr);
                                layer["LayerDescription"] = layerDescr;
                                return [2 /*return*/, layer];
                            }
                            return [2 /*return*/];
                    }
                });
            });
        };
        LayerLoader.prototype._createPane = function () {
            var paneId = "lp_" + this.layerNr;
            var pane = this.map.createPane("lp_" + this.layerNr);
            console.info("this.layerNr.toString()=" + this.layerNr, pane);
            pane.style.zIndex = this.layerNr.toString();
            this.layerNr++;
            return paneId;
        };
        LayerLoader.prototype.createLayer = function (layerDescr) {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    // console.error(`createLayer ${layerDescr.label}`);
                    if (layerDescr.type == "GeoJSON") {
                        return [2 /*return*/, this.createGeoJSONLayer(layerDescr)];
                    }
                    else if (layerDescr.type == "WMS") {
                        return [2 /*return*/, this.createWMSLayer(layerDescr)];
                        // return getCapabilities(layerDescr.url, <L.WMSOptions>layerDescr.options).then((v) => {
                        //     console.info("sddsjhak");
                        //     console.info(v);
                        //     const l = new L.TileLayer.WMS(layerDescr.url, {
                        //         ...(<L.WMSOptions>layerDescr.options),
                        //     });
                        //     console.info("WMS", l);
                        //     return l;
                        // });
                    }
                    else {
                        console.error("not supported Layertype: ".concat(layerDescr.type));
                    }
                    return [2 /*return*/, undefined];
                });
            });
        };
        return LayerLoader;
    }());
    exports.LayerLoader = LayerLoader;
    function getCapabilities(url, options) {
        return __awaiter(this, void 0, void 0, function () {
            var cUrl, result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        cUrl = url + "?version=1.3.0&request=GetCapabilities&service=WMS";
                        return [4 /*yield*/, window
                                .fetch(cUrl)
                                .then(function (response) { return response.text(); })
                                .then(function (text) {
                                var xml;
                                try {
                                    if (window.DOMParser) {
                                        var parser = new window.DOMParser();
                                        xml = parser.parseFromString(text, "text/xml");
                                        // } else if (window.ActiveXObject) {
                                        //     xml = new window.ActiveXObject("Microsoft.XMLDOM");
                                        //     xml.async = "false";
                                        //     xml.loadXML(text);
                                    }
                                    return xml;
                                }
                                catch (e) {
                                    return null;
                                }
                            })];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, result];
                }
            });
        });
    }
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./src/ts/MapApp.ts":
/*!**************************!*\
  !*** ./src/ts/MapApp.ts ***!
  \**************************/
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(/*! leaflet */ "./node_modules/leaflet/dist/leaflet-src.js"), __webpack_require__(/*! ./controls/MapControl */ "./src/ts/controls/MapControl.ts"), __webpack_require__(/*! ./util/L.GeocoderMV */ "./src/ts/util/L.GeocoderMV.ts"), __webpack_require__(/*! ./LayerLoader */ "./src/ts/LayerLoader.ts"), __webpack_require__(/*! ./controls/AttributionCtrl */ "./src/ts/controls/AttributionCtrl.ts"), __webpack_require__(/*! ./controls/LegendControl */ "./src/ts/controls/LegendControl.ts"), __webpack_require__(/*! ./conf/MapDescription */ "./src/ts/conf/MapDescription.ts"), __webpack_require__(/*! fuse.js */ "./node_modules/fuse.js/dist/fuse.esm.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports, L, MapControl_1, L_GeocoderMV_1, LayerLoader_1, AttributionCtrl_1, LegendControl_1, MapDescription_1, fuse_js_1) {
    "use strict";
    exports.__esModule = true;
    exports.MapApp = exports.initMap = void 0;
    // import { mv } from "./MV";
    function createGeoCoder(objclass, limit) {
        return new L_GeocoderMV_1.Geocoder("esDtb7H5Kh8zl5YXJ3iIP6xPnKEIb5Ch", {
            serviceUrl: "https://geo.sv.rostock.de/geocodr/query",
            geocodingQueryParams: {
                "class": objclass,
                out_epsg: "4326",
                shape: "geometry",
                limit: limit
            },
            reverseQueryParams: {
                "class": objclass,
                in_epsg: "4326",
                limit: limit,
                shape: "centroid",
                out_epsg: "4326"
            }
        });
    }
    /**
     *
     * @param mapDescriptionUrl initialized the map with the map description file (Standard: layerdef.json) see:{@link MapDescription}
     * @returns
     */
    function initMap(mapDescriptionUrl) {
        var mapApp = new MapApp(mapDescriptionUrl || "layerdef.json");
        mapApp.init();
    }
    exports.initMap = initMap;
    var MapApp = /** @class */ (function () {
        /**
         *
         * @param mapDescription url to the mapdescription-file see:{@link MapDescription}
         *
         */
        function MapApp(mapDescription) {
            this.currentLayers = [];
            this.mapDescriptionUrl = mapDescription;
        }
        MapApp.prototype.init = function () {
            var _this = this;
            (0, MapDescription_1.getConf)(this.mapDescriptionUrl).then(function (mapDescr) { return _this._init(mapDescr); });
            this._attachHomeCloseBttns();
            var urlParams = new URLSearchParams(window.location.search);
            var selL = urlParams.get("layers");
            if (selL) {
                this.selectedLayerIds = selL.split(",");
            }
            this.mapCtrl = new MapControl_1.MapControl({
                position: "topleft",
                parentNode: document.getElementById("sidebar-mapctrl"),
                searchFct: function (s) { return _this._search(s); },
                resetMap: function () { return _this._resetMap(); }
            });
        };
        MapApp.prototype._resetMap = function () {
            console.info("resetMap");
            if (this.mapDescription.mapOptions.center) {
                this.map.setZoom(this.mapDescription.mapOptions.zoom);
                this.map.panTo(this.mapDescription.mapOptions.center);
            }
        };
        MapApp.prototype._attachHomeCloseBttns = function () {
            var bttn1 = document.getElementById("close-home-overlay1");
            if (bttn1) {
                var bttn2 = document.getElementById("close-home-overlay2");
                var f = function (ev) {
                    var home = document.getElementById("home-overlay");
                    home.style.display = "none";
                };
                var fCloseOverlayByClick_1 = function (ev) {
                    if (ev.currentTarget === ev.target) {
                        ev.currentTarget.style.display = "none";
                    }
                };
                var fCloseOverlayByEscape = function (ev) {
                    if (ev.key === "Escape") {
                        document.querySelectorAll(".home-overlay").forEach(function (item) {
                            item.style.display = "none";
                        });
                    }
                };
                bttn1.addEventListener("click", f);
                bttn2.addEventListener("click", f);
                document.getElementById("close-datenschutz-overlay").addEventListener("click", function () {
                    var home = document.getElementById("datenschutz-overlay");
                    home.style.display = "none";
                });
                document.getElementById("close-impressum-overlay").addEventListener("click", function () {
                    var home = document.getElementById("impressum-overlay");
                    home.style.display = "none";
                });
                document.getElementById("close-faq-overlay").addEventListener("click", function () {
                    var home = document.getElementById("faq-overlay");
                    home.style.display = "none";
                });
                document.getElementById("bttn_impressum").addEventListener("click", function () {
                    var home = document.getElementById("impressum-overlay");
                    home.style.display = "block";
                });
                document.getElementById("bttn_datenschutz").addEventListener("click", function () {
                    var home = document.getElementById("datenschutz-overlay");
                    home.style.display = "block";
                });
                document.getElementById("bttn_faq").addEventListener("click", function () {
                    var home = document.getElementById("faq-overlay");
                    home.style.display = "block";
                });
                document.querySelectorAll(".home-overlay").forEach(function (item) {
                    item.addEventListener("click", fCloseOverlayByClick_1);
                });
                window.addEventListener("keydown", fCloseOverlayByEscape);
            }
        };
        MapApp.prototype._init = function (mapDescr) {
            this.mapDescription = mapDescr;
            console.info("mapoptions", mapDescr.mapOptions);
            var mapOptions = __assign(__assign({}, mapDescr.mapOptions), { 
                // preferCanvas: true,
                renderer: new L.SVG(), zoomControl: false, attributionControl: false });
            var map = (this.map = new L.Map("map", mapOptions));
            this.layerLoader = new LayerLoader_1.LayerLoader(map);
            map.addControl(new L.Control.Scale({ position: "bottomright", imperial: false }));
            map.addControl(this.mapCtrl);
            map.addControl(new AttributionCtrl_1.AttributionCtrl());
            map.addControl(new LegendControl_1.LegendControl({ position: "bottomright" }));
            map.addControl(new L.Control.Zoom({ position: "bottomright" }));
            map.on("click", function (ev) {
                console.info("zoomLevel=" + map.getZoom());
            });
            this.initLayer(mapDescr);
            // window.setTimeout(()=>this.initLayer(mapDescr), 10);
        };
        MapApp.prototype.getOverlays = function (themes) {
            var overlays = [];
            for (var i = 0; i < themes.length; i++) {
                if (themes[i].layers) {
                    overlays = overlays.concat(themes[i].layers);
                }
                if (themes[i].themes) {
                    overlays = overlays.concat(this.getOverlays(themes[i].themes));
                }
            }
            return overlays;
        };
        MapApp.prototype._search = function (s) {
            var _this = this;
            console.info("MapApp._search");
            if (!this.geocoderAdress) {
                this.geocoderAdress = createGeoCoder("address,parcel", 30);
                var overlays = this.getOverlays(this.mapDescription.themes);
                console.info("overlays.length", overlays.length);
                this.fuseSearch = new fuse_js_1["default"](overlays, {
                    isCaseSensitive: false,
                    ignoreLocation: true,
                    useExtendedSearch: true,
                    includeScore: true,
                    keys: ["layerDescription.abstract"]
                });
            }
            var geoCodePromise = this.geocoderAdress.geocode(s);
            // const geoCodePromise = new Promise<any[]>((resolve, reject) => {
            //     this.geocoderAdress.geocode(s).then(
            //         (result: any) => resolve(result)
            //     ).catch(
            //         (reason: any) => reject(reason)
            //     );
            // })
            var promiseCollector = Promise.all([
                new Promise(function (resolve, reject) {
                    var fuseResults = _this.fuseSearch.search(s);
                    console.info("fuseResults", fuseResults);
                    var results = [];
                    fuseResults.forEach(function (element) {
                        if (element.score < 0.1) {
                            results.push({
                                name: element.item.layerDescription.label,
                                group: "Thema",
                                layer: element.item
                            });
                        }
                    });
                    resolve(results);
                }),
                geoCodePromise,
            ]);
            var p = new Promise(function (resolve, reject) {
                promiseCollector
                    .then(function (result) {
                    var totalResult;
                    for (var i = 0; i < result.length; i++) {
                        if (result[i]) {
                            totalResult = totalResult ? totalResult.concat(result[i]) : result[i];
                        }
                    }
                    resolve(totalResult);
                })["catch"](function (reason) { return reject(reason); });
            });
            p["cancel"] = function () {
                geoCodePromise["cancel"]();
                console.info("promise canceled");
            };
            return p;
            // return new Promise<any[]>((resolve, reject) => {
            //     this.geocoderAdress.geocode(s).then(
            //         (result: any) => resolve(result)
            //     ).catch(
            //         (reason: any) => reject(reason)
            //     );
            // });
        };
        MapApp.prototype.initLayer = function (mapDescr) {
            var _this = this;
            mapDescr.baseLayers.forEach(function (layerDescr) {
                var layer = L.tileLayer(layerDescr.url, layerDescr.options);
                layerDescr["layer"] = layer;
            });
            this.mapCtrl.setBaseLayers(mapDescr.baseLayers, { labelAttribute: "label" });
            this.mapCtrl.categorieLayerCtrl.addThemes(mapDescr.themes);
            if (this.selectedLayerIds) {
                if (this.selectedLayerIds.length === 1 && this.selectedLayerIds[0] === "all") {
                    this.showAllThemes(mapDescr.themes);
                }
                else {
                    this.showThemes(mapDescr.themes);
                }
            }
            this.map.addEventListener("zoomend", function (ev) {
                console.info("resize", ev, _this.map.getZoom());
            });
            // this.map.addLayer(new L.Polygon(mv));
        };
        MapApp.prototype.showAllThemes = function (themes) {
            var _this = this;
            themes.forEach(function (theme) {
                theme.layers.forEach(function (layer) {
                    layer.isSelected = true;
                    MapControl_1.MapDispatcher.onLayerRequest.dispatch(_this.mapCtrl, {
                        type: "request-layer",
                        layer: layer
                    });
                });
                if (theme.themes) {
                    _this.showThemes(theme.themes);
                }
            });
        };
        MapApp.prototype.showThemes = function (themes) {
            var _this = this;
            themes.forEach(function (theme) {
                theme.layers.forEach(function (layer) {
                    if (_this.selectedLayerIds.indexOf(layer.layerDescription.label) >= 0) {
                        layer.isSelected = true;
                        MapControl_1.MapDispatcher.onLayerRequest.dispatch(_this.mapCtrl, {
                            type: "request-layer",
                            layer: layer
                        });
                    }
                });
                if (theme.themes) {
                    _this.showThemes(theme.themes);
                }
            });
        };
        return MapApp;
    }());
    exports.MapApp = MapApp;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./src/ts/MapClassParser.ts":
/*!**********************************!*\
  !*** ./src/ts/MapClassParser.ts ***!
  \**********************************/
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// const CLOSING_TO_OPENING_CHARACTER = {
//     ')': '(',
//     ']': '[',
//     '>': '<',
//     '"': '"'
// };
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports) {
    "use strict";
    exports.__esModule = true;
    exports.parseExpression = exports.FormulaParserX = exports.Expression = void 0;
    function andOperator() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        // console.info('andOp', args);
        for (var i = 0; i < args.length; i++) {
            if (!args[i]) {
                return false;
            }
        }
        return true;
    }
    function orOperator() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        for (var i = 0; i < args.length; i++) {
            if (args[i]) {
                return true;
            }
        }
        return false;
    }
    function eqOperator(arg01, arg02) {
        // console.info(`eqOperator ${arg01} ${arg02}`);
        return arg01 == arg02;
    }
    function ltOperator(arg01, arg02) {
        // console.info(`ltOperator ${arg01} ${arg02}`);
        return arg01 < arg02;
    }
    function gtOperator(arg01, arg02) {
        // console.info(`gtOperator ${arg01} ${arg02}`);
        return arg01 > arg02;
    }
    function leOperator(arg01, arg02) {
        // console.info(`leOperator ${arg01} ${arg02}`);
        return arg01 <= arg02;
    }
    function geOperator(arg01, arg02) {
        // console.info(`geOperator ${arg01} ${arg02}`);
        return arg01 >= arg02;
    }
    function neOperator(arg01, arg02) {
        // console.info(`neOperator ${arg01} ${arg02}`);
        return arg01 != arg02;
    }
    var Operators = [
        { symbols: ["and", "&&"], fct: andOperator, precedence: 1, associativity: 'left' },
        { symbols: ["or", "||"], fct: orOperator, precedence: 2, associativity: 'left' },
        { symbols: ["eq", "="], fct: eqOperator, precedence: 3, associativity: 'left' },
        { symbols: ["lt", "<"], fct: ltOperator, precedence: 3, associativity: 'left' },
        { symbols: ["gt", ">"], fct: gtOperator, precedence: 3, associativity: 'left' },
        { symbols: ["le", "<="], fct: leOperator, precedence: 3, associativity: 'left' },
        { symbols: ["ge", ">="], fct: geOperator, precedence: 3, associativity: 'left' },
        { symbols: ["ne", "!="], fct: neOperator, precedence: 3, associativity: 'left' }
    ];
    function createBinaries(operators) {
        var ops = [];
        operators.forEach(function (element) {
            element.symbols.forEach(function (symbol) {
                ops.push({
                    symbol: symbol,
                    key: element.symbols[0],
                    fct: element.fct,
                    precedence: element.fct,
                    associativity: element.associativity
                });
            });
        });
        return ops;
    }
    var binaries = createBinaries(Operators);
    var Value = /** @class */ (function () {
        function Value() {
        }
        return Value;
    }());
    var Expression = /** @class */ (function () {
        function Expression(key, fct, param) {
            this.key = key;
            this.params = param;
            this.fct = fct;
        }
        Expression.prototype._evalExpression = function (expression, values) {
            return expression.eval(values);
        };
        Expression.prototype._evalValue = function (val, values) {
            // console.info("_evalValue", val, values);
            var result;
            if (typeof val === 'string') {
                if (val.startsWith("[")) {
                    var key = val.substring(1, val.length - 1);
                    // console.info("_evalValue"+key);
                    result = values[val.substring(1, val.length - 1)];
                }
                else {
                    if (val.startsWith("'")) {
                        result = val.substring(1, val.length - 1);
                    }
                    else {
                        result = val;
                    }
                }
            }
            else {
                result = val;
            }
            return result;
        };
        Expression.prototype.eval = function (values) {
            var _this = this;
            var params = [];
            this.params.forEach(function (element) {
                if (element instanceof Expression) {
                    params.push(_this._evalExpression(element, values));
                }
                else {
                    params.push(_this._evalValue(element["var"], values));
                }
            });
            return this.fct.apply(this, params);
        };
        return Expression;
    }());
    exports.Expression = Expression;
    var MIN_PRECEDENCE = 0;
    /**
     * Returns the remainder of a given string after slicing off
     * the length of a given symbol and any following whitespace.
     * (Does not verify that the symbol is an initial substring.)
     *
     * @private
     * @static
     * @param {string} str    - a string to slice
     * @param {string} symbol - an initial substring
     * @returns {string}
     */
    function sliceSymbol(str, symbol) {
        return str.slice(symbol.length).trim();
    }
    /**
     * Attempts to match a given list of operators against the head of a given string.
     * Returns the first match if successful, otherwise null.
     *
     * @private
     * @static
     * @param {string}   str          - a string to match against
     * @param {Object[]} operatorList - an array of operator definitions, sorted by longest symbol
     * @returns {?Object}
     */
    function matchOperator(str, operatorList) {
        var s = str.toLowerCase();
        return operatorList.reduce(function (match, operator) {
            return match ||
                (s.startsWith(operator.symbol) ? operator : undefined);
        }, undefined);
    }
    /**
     * A parser class for "operator-precedence languages", i.e.,
     * context-free languages which have only variables, unary operators, and binary operators.
     *
     * The grammar for a parser instance is thus wholly specified by the operator definitions
     * (as well as a key with which to label variable nodes).
     *
     * An operator definition is an object like the following:
     *   { symbol: '+', key: 'plus', precedence: 1, associativity: 'left' }
     * It specifies a symbol, a key for its AST node, a precedence level,
     * and (for binaries) an associativity direction.
     */
    var FormulaParserX = /** @class */ (function () {
        /**
         * @param {string}   variableKey - key to use for a variable's AST node
         * @param {Object[]} unaries     - an array of unary operator definitions
         * @param {Object[]} binaries    - an array of binary operator definitions
         */
        function FormulaParserX(variableKey, unaries, binaries) {
            if (variableKey === void 0) { variableKey = 'var'; }
            if (unaries === void 0) { unaries = []; }
            if (binaries === void 0) { binaries = []; }
            var byLongestSymbol = function (x, y) { return y.symbol.length - x.symbol.length; };
            this.variableKey = variableKey,
                this.unaries = unaries.slice().sort(byLongestSymbol),
                this.binaries = binaries.slice().sort(byLongestSymbol);
        }
        /**
         * Attempts to parse a binary subformula at the head of a given string,
         * given a lower precedence bound and an AST node to be used as a left operand.
         * Returns an AST node and string remainder if successful, otherwise null.
         *
         * @private
         * @param {FormulaParser} self
         * @param {string}        currentString     - remainder of input string left to parse
         * @param {number}        currentPrecedence - lowest binary precedence allowable at current parse stage
         * @param {Object}        leftOperandJSON   - AST node for already-parsed left operand
         * @returns {?Object}
         */
        FormulaParserX.prototype._parseBinarySubformula = function (currentString, currentPrecedence, leftOperandJSON) {
            var binary = matchOperator(currentString, this.binaries);
            if (!binary || binary.precedence < currentPrecedence) {
                return null;
            }
            var nextPrecedence = (binary.associativity === 'left') ? binary.precedence + 1 : binary.precedence;
            var parsedRightOperand = this._parseFormula(sliceSymbol(currentString, binary.symbol), nextPrecedence);
            return {
                // json: { [binary.key]: [leftOperandJSON, parsedRightOperand.json] },
                formula: new Expression(binary.key, binary.fct, [leftOperandJSON, parsedRightOperand.formula]),
                remainder: parsedRightOperand.remainder
            };
        };
        /**
         * Attempts to parse a unary subformula at the head of a given string.
         * Returns an AST node and string remainder if successful, otherwise null.
         *
         * @private
         * @param {string}        currentString - remainder of input string left to parse
         * @returns {?Object}
         */
        FormulaParserX.prototype._parseUnarySubformula = function (currentString) {
            var unary = matchOperator(currentString, this.unaries);
            if (!unary) {
                return null;
            }
            var parsedSubformula = this._parseFormula(sliceSymbol(currentString, unary.symbol), unary.precedence);
            return {
                // TODO UNARY
                formula: new Expression(unary.key, undefined, [parsedSubformula.formula]),
                remainder: parsedSubformula.remainder
            };
        };
        /**
         * Recursively parses a formula according to this parser's parameters.
         * Returns an complete AST and a (hopefully empty) string remainder.
         *
         * @private
         * @param {FormulaParser} self
         * @param {string}        currentString     - remainder of input string left to parse
         * @param {number}        currentPrecedence - lowest binary precedence allowable at current parse stage
         * @param {Object}        [currentJSON]     - AST node retained from previous parse stage
         * @returns {Object}
         */
        FormulaParserX.prototype._parseFormula = function (currentString, currentPrecedence, currentJSON) {
            // console.info(`parse ${currentString}`, currentJSON);
            if (!currentString.length && !currentJSON) {
                throw new SyntaxError('Invalid formula! Unexpected end of input.');
            }
            // First, we need an initial subformula.
            // A valid formula can't start with a binary operator, but anything else is possible.
            var parsedHead = currentJSON ? { formula: currentJSON, remainder: currentString } :
                this._parseUnarySubformula(currentString) ||
                    this._parseParenthesizedSubformula(currentString) ||
                    this._parseVariable(currentString) ||
                    this._parseStringLiteral(currentString);
            if (!parsedHead) {
                throw new SyntaxError('Invalid formula! Could not find an initial subformula.');
            }
            // Having found an initial subformula, let's see if it's the left operand to a binary operator...
            var parsedBinary = this._parseBinarySubformula(parsedHead.remainder, currentPrecedence, parsedHead.formula);
            if (!parsedBinary) {
                // ...if it isn't, we're done!
                return parsedHead;
            }
            // ...if it is, we parse onward, with our new binary subformula as the next initial subformula.
            return this._parseFormula(parsedBinary.remainder, currentPrecedence, parsedBinary.formula);
        };
        /**
         * Attempts to parse a variable (i.e., any alphanumeric substring) at the head of a given string.
         * Returns an AST node and string remainder if successful, otherwise null.
         *
         * @private
         * @param {string}        currentString - remainder of input string left to parse
         * @returns {?Object}
         */
        FormulaParserX.prototype._parseVariable = function (currentString) {
            var variable = (currentString.match(/^[\[\]\w]+/) || [])[0];
            if (!variable) {
                return null;
            }
            return {
                formula: { "var": variable },
                remainder: sliceSymbol(currentString, variable)
            };
        };
        FormulaParserX.prototype._parseStringLiteral = function (currentString) {
            if (currentString.startsWith("'")) {
                var variable = "'";
                for (var i = 1; i < currentString.length; i++) {
                    if (currentString.charAt(i) != "'") {
                        variable += currentString.charAt(i);
                    }
                    else {
                        variable += "'";
                        return {
                            formula: { "var": variable },
                            remainder: sliceSymbol(currentString, variable)
                        };
                    }
                }
            }
            return null;
        };
        /**
         * Attempts to parse a parenthesized subformula at the head of a given string.
         * Returns an AST node and string remainder if successful, otherwise null.
         *
         * @private
         * @param {string}        currentString - remainder of input string left to parse
         * @returns {?Object}
         */
        FormulaParserX.prototype._parseParenthesizedSubformula = function (currentString) {
            if (currentString.charAt(0) !== '(') {
                return null;
            }
            var parsedSubformula = this._parseFormula(sliceSymbol(currentString, '('), MIN_PRECEDENCE);
            if (parsedSubformula.remainder.charAt(0) !== ')') {
                throw new SyntaxError('Invalid formula! Found unmatched parenthesis.');
            }
            return {
                formula: parsedSubformula.formula,
                remainder: sliceSymbol(parsedSubformula.remainder, ')')
            };
        };
        /**
         * Parses a formula according to this parser's parameters.
         * Returns an AST in JSON format.
         *
         * @param {string} input - a formula to parse
         * @returns {Object}
         */
        FormulaParserX.prototype.parse = function (input) {
            if (typeof input !== 'string') {
                throw new SyntaxError('Invalid formula! Found non-string input.');
            }
            var parsedFormula = this._parseFormula(input.trim(), MIN_PRECEDENCE);
            if (parsedFormula.remainder.length) {
                throw new SyntaxError('Invalid formula! Unexpected continuation of input.');
            }
            return parsedFormula.formula;
        };
        return FormulaParserX;
    }());
    exports.FormulaParserX = FormulaParserX;
    var FormularParser = new FormulaParserX('var', [], binaries);
    function parseExpression(s) {
        try {
            return FormularParser.parse(s);
        }
        catch (error) {
            console.error("could not parse expression {s}");
        }
    }
    exports.parseExpression = parseExpression;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./src/ts/PiechartLayer.ts":
/*!*********************************!*\
  !*** ./src/ts/PiechartLayer.ts ***!
  \*********************************/
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(/*! leaflet */ "./node_modules/leaflet/dist/leaflet-src.js"), __webpack_require__(/*! ./controls/MapControl */ "./src/ts/controls/MapControl.ts"), __webpack_require__(/*! ./controls/MarkerListView */ "./src/ts/controls/MarkerListView.ts"), __webpack_require__(/*! ./svg/piechart */ "./src/ts/svg/piechart.ts")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports, leaflet_1, MapControl_1, MarkerListView_1, piechart_1) {
    "use strict";
    exports.__esModule = true;
    exports.PiechartLayer = exports.PiechartMarker = exports.PiechartIcon = void 0;
    var PiechartIcon = /** @class */ (function (_super) {
        __extends(PiechartIcon, _super);
        function PiechartIcon(data, options) {
            var _this = _super.call(this, options) || this;
            _this.data = data;
            console.info("PiechartIcon", options, data);
            return _this;
            // this.data = data;
        }
        PiechartIcon.prototype.createIcon = function () {
            if (!this.piechart) {
                var param = __assign({}, this.options);
                param.segments = [];
                // for (let k in this.options) {}
                //     radius: this.options.radius, //set radius of pie
                //     fillOpacity: this.options.fillOpacity,
                //     segments: [],
                // };
                console.info("PiechartIcon.createIcon param", param);
                console.info("PiechartIcon.createIcon options", this.options);
                // for (let i = 0, count = this.options.piechart.length; i < count; i++) {
                for (var k in this.options.piechart) {
                    // const p = this.options.piechart[i];
                    // param.segments.push({ value: this.data[p.attN], color: p.color });
                    param.segments.push({ value: parseFloat(this.data[k]), style: this.options.piechart[k] });
                }
                this.piechart = (0, piechart_1.createPiechart)(param);
            }
            return this.piechart;
        };
        return PiechartIcon;
    }(leaflet_1.Icon));
    exports.PiechartIcon = PiechartIcon;
    var PiechartMarker = /** @class */ (function (_super) {
        __extends(PiechartMarker, _super);
        // icon:L.Icon;
        function PiechartMarker(parentLayer, coord, data, options) {
            var _this = _super.call(this, coord, options) || this;
            _this.visible = false;
            _this.selected = false;
            // console.info("PiechartMarker", options, data);
            _this.options.icon = new PiechartIcon(data, parentLayer.getPiechartMarkerOptions());
            _this.data = data;
            _this.parentLayer = parentLayer;
            return _this;
            // this.options = options;
        }
        PiechartMarker.prototype.setVisible = function (visible) {
            this.visible = visible;
        };
        PiechartMarker.prototype.isVisible = function () {
            return this.visible;
        };
        PiechartMarker.prototype.highlight = function (highlight) {
            console.info("CategoryMarker.highlight", this.data["id"], highlight);
            this.selected = highlight;
            if (this._icon) {
                if (highlight) {
                    this._icon.classList.add("icon-highlighted");
                }
                else {
                    this._icon.classList.remove("icon-highlighted");
                }
            }
            console.info("this", this);
        };
        PiechartMarker.prototype.getPiechart = function () {
            return this.options.icon.piechart.cloneNode(true);
        };
        return PiechartMarker;
    }(leaflet_1.Marker));
    exports.PiechartMarker = PiechartMarker;
    var PiechartLayer = /** @class */ (function (_super) {
        __extends(PiechartLayer, _super);
        function PiechartLayer(layers, options) {
            var _this = _super.call(this, layers, options) || this;
            _this.layerDescription = options.layerDescription;
            return _this;
        }
        PiechartLayer.prototype.highlightMarker = function (marker, highlight) {
            marker.highlight(highlight);
        };
        PiechartLayer.prototype.mapItemClicked = function (marker, ev) {
            // MapDispatcher.onMapFeatureClick.dispatch(marker, {...ev, layer:this, feature:marker});
            MapControl_1.MapDispatcher.onMapFeatureClick.dispatch(marker, ev);
        };
        PiechartLayer.prototype.renderData = function (marker) {
            return new MarkerListView_1.MarkerView(this, marker);
        };
        PiechartLayer.prototype.getPiechartMarkerOptions = function () {
            var _a, _b, _c, _d, _e, _f, _g;
            if (!this.piechartMarkerOptions) {
                var options = (this.piechartMarkerOptions = {
                    radius: (_a = this.layerDescription.processing.style.radius) !== null && _a !== void 0 ? _a : 15,
                    color: (_b = this.layerDescription.processing.style.color) !== null && _b !== void 0 ? _b : "darkgray",
                    strokeOpacity: (_c = this.layerDescription.processing.style.strokeOpacity) !== null && _c !== void 0 ? _c : 1,
                    strokeWeight: (_d = this.layerDescription.processing.style.strokeWeight) !== null && _d !== void 0 ? _d : 1,
                    piechart: {}
                });
                var lDescrClasses = this.layerDescription.classes;
                for (var i = 0, count = lDescrClasses.length; i < count; i++) {
                    var clasz = lDescrClasses[i];
                    options.piechart[clasz.style.size] = {
                        fill: clasz.style.fillColor,
                        opacity: clasz.style.fillOpacity,
                        stroke: (_e = clasz.style.color) !== null && _e !== void 0 ? _e : "#bbb",
                        strokeOpacity: (_f = clasz.style.strokeOpacity) !== null && _f !== void 0 ? _f : "0.6",
                        strokeWidth: (_g = clasz.style.strokeWeight) !== null && _g !== void 0 ? _g : "1"
                    };
                }
            }
            console.info(this.piechartMarkerOptions);
            return this.piechartMarkerOptions;
        };
        return PiechartLayer;
    }(leaflet_1.FeatureGroup));
    exports.PiechartLayer = PiechartLayer;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./src/ts/Util.ts":
/*!************************!*\
  !*** ./src/ts/Util.ts ***!
  \************************/
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(/*! leaflet */ "./node_modules/leaflet/dist/leaflet-src.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports, leaflet_1) {
    "use strict";
    exports.__esModule = true;
    exports.createCSSSelector = exports.disableEvtPropagation = exports.createRow = exports.createCloseButton = exports.createHtmlElement = exports.createSlider = exports.getParamString = exports.makeRequest = exports.loadJson = exports.createCancellablePromise = void 0;
    function createCancellablePromise(executor) {
        var t = new Promise(executor);
        t.onCancel = function (cb) {
            t.cancelMethod = cb;
            return t;
        };
        t.cancel = function () {
            console.info("cancel called");
            if (t.cancelMethod) {
                t.cancelMethod();
            }
        };
        return t;
    }
    exports.createCancellablePromise = createCancellablePromise;
    function loadJson(url, params) {
        var promise;
        return createCancellablePromise(function (resolve, reject) {
            var sUrl = url + getParamString(params);
            promise = makeRequest(sUrl);
            promise
                .then(function (value) {
                try {
                    var result = JSON.parse(value);
                    resolve(result);
                }
                catch (ex) {
                    reject("Error parsing response from \"".concat(sUrl, "\" reason:\"").concat(ex, "\""));
                }
            })["catch"](function (reason) {
                reject(reason);
            });
        }).onCancel(function () {
            console.info("cancel");
            if (promise) {
                promise.cancel();
            }
        });
        // let value = await makeRequest(url + getParamString(params));
        // return JSON.parse(value);
    }
    exports.loadJson = loadJson;
    function makeRequest(url, auth) {
        var xhr = new XMLHttpRequest();
        return createCancellablePromise(function (resolve, reject) {
            xhr.onloadend = function () {
                if (this.status === 200) {
                    resolve(xhr.responseText);
                }
                else {
                    reject({
                        status: this.status,
                        statusText: xhr.statusText
                    });
                }
            };
            xhr.onerror = function (ev) {
                reject({
                    status: this.status,
                    statusText: xhr.statusText,
                    event: ev
                });
            };
            xhr.open("GET", url);
            if (auth) {
                xhr.setRequestHeader("Authorization", auth);
            }
            console.info("run request \"".concat(url, "\""));
            xhr.send();
        }).onCancel(function () {
            console.debug("xhr abort", xhr);
            xhr.abort();
        });
    }
    exports.makeRequest = makeRequest;
    function getParamString(obj, existingUrl, uppercase) {
        if (!obj) {
            return "";
        }
        var params = [];
        for (var i in obj) {
            var key = encodeURIComponent(uppercase ? i.toUpperCase() : i);
            var value = obj[i];
            if (!Array.isArray(value)) {
                params.push(key + "=" + encodeURIComponent(value));
            }
            else {
                for (var j = 0; j < value.length; j++) {
                    params.push(key + "=" + encodeURIComponent(value[j]));
                }
            }
        }
        return (!existingUrl || existingUrl.indexOf("?") === -1 ? "?" : "&") + params.join("&");
    }
    exports.getParamString = getParamString;
    function createSlider(min, max, value, onchange, className) {
        // <input type="range" min="1" max="100" value="50" class="slider" id="myRange">
        var input = document.createElement("input");
        input.type = "range";
        input.min = min;
        input.max = max;
        input.value = value;
        if (onchange) {
            input.addEventListener("input", onchange);
        }
        if (className) {
            input.className = className;
        }
        return input;
    }
    exports.createSlider = createSlider;
    function createHtmlElement(tag, parent, className, mixin) {
        var el = document.createElement(tag);
        if (parent) {
            parent.appendChild(el);
        }
        if (className) {
            el.className = className;
        }
        if (mixin) {
            for (var k in mixin) {
                el[k] = mixin[k];
            }
        }
        return el;
    }
    exports.createHtmlElement = createHtmlElement;
    function createCloseButton(cb) {
        var closeBttn = document.createElement("span");
        closeBttn.className = "close-button";
        /* closeBttn.innerHTML = '&#xf00d;'; */
        closeBttn.addEventListener("click", cb);
        return closeBttn;
    }
    exports.createCloseButton = createCloseButton;
    function createRow(attName, value, parent) {
        var row = document.createElement("tr");
        var c1 = document.createElement("td");
        c1.innerText = attName;
        var c2 = document.createElement("td");
        c2.innerText = value;
        row.appendChild(c1);
        row.appendChild(c2);
        parent.appendChild(row);
        return row;
    }
    exports.createRow = createRow;
    var fnStopPropagation = function (ev) {
        if (ev.stopPropagation) {
            ev.stopPropagation();
        }
        else {
            ev.cancelBubble = true;
        }
        ev.stopPropagation();
        if (ev.preventDefault) {
            ev.preventDefault();
        }
        else {
            ev.returnValue = false;
        }
        return false;
    };
    // if (type === 'touchstart' || type === 'touchmove' || type === 'wheel' ||  type === 'mousewheel') {
    function disableEvtPropagation(dom) {
        var passiveEvents = leaflet_1.Browser.passiveEvents;
        dom.addEventListener("pointermove", fnStopPropagation);
        dom.addEventListener("mousedown", fnStopPropagation);
        dom.addEventListener("dblclick", fnStopPropagation);
        dom.addEventListener("dragstart", fnStopPropagation);
        dom.addEventListener("drag", fnStopPropagation);
        dom.addEventListener("wheel", fnStopPropagation, passiveEvents ? { passive: false } : false);
    }
    exports.disableEvtPropagation = disableEvtPropagation;
    /**/
    function createCSSSelector(selector, style) {
        console.info("createCSSSelector(".concat(selector, ", ").concat(style, ")"));
        if (!document.styleSheets)
            return;
        if (document.getElementsByTagName("head").length == 0)
            return;
        var styleSheet;
        // let mediaType;
        for (var i = 0, count = document.styleSheets.length; i < count && styleSheet; i++) {
            if (!document.styleSheets[i].disabled) {
                var media = document.styleSheets[i].media;
                if (typeof media == "object") {
                    if (media.mediaText === "" || media.mediaText.indexOf("screen") !== -1) {
                        styleSheet = document.styleSheets[i];
                    }
                }
            }
        }
        if (!styleSheet) {
            var styleSheetElement = document.createElement("style");
            styleSheetElement.type = "text/css";
            document.getElementsByTagName("head")[0].appendChild(styleSheetElement);
            for (var i = 0; i < document.styleSheets.length; i++) {
                if (document.styleSheets[i].disabled) {
                    continue;
                }
                styleSheet = document.styleSheets[i];
            }
        }
        var styleSheetLength = styleSheet.cssRules ? styleSheet.cssRules.length : 0;
        for (var i = 0; i < styleSheetLength; i++) {
            var rule = styleSheet.cssRules[i];
            if (rule instanceof CSSStyleRule) {
                if (rule.selectorText && rule.selectorText.toLowerCase() == selector.toLowerCase()) {
                    rule.style.cssText = style;
                    return;
                }
            }
        }
        styleSheet.insertRule(selector + "{" + style + "}", styleSheetLength);
    }
    exports.createCSSSelector = createCSSSelector;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./src/ts/conf/MapDescription.ts":
/*!***************************************!*\
  !*** ./src/ts/conf/MapDescription.ts ***!
  \***************************************/
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(/*! leaflet */ "./node_modules/leaflet/dist/leaflet-src.js"), __webpack_require__(/*! ../controls/MapControl */ "./src/ts/controls/MapControl.ts"), __webpack_require__(/*! ../Util */ "./src/ts/Util.ts")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports, leaflet_1, MapControl_1, Util_1) {
    "use strict";
    exports.__esModule = true;
    exports.StandardCircleMarkerOptions = exports.StandardPathOptions = exports.PathOptions = exports.getMapDescription = exports.getConf = void 0;
    var mapDescr;
    function getConf(url) {
        return __awaiter(this, void 0, void 0, function () {
            var json, mapThemes_1, parse_1, i, count, overlay, theme;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!!mapDescr) return [3 /*break*/, 2];
                        return [4 /*yield*/, (0, Util_1.loadJson)(url)];
                    case 1:
                        json = _a.sent();
                        mapDescr = {
                            default_wms_legend_icon: json.default_wms_legend_icon,
                            mapOptions: json.mapOptions,
                            baseLayers: json.baseLayers,
                            themes: []
                        };
                        mapThemes_1 = {};
                        parse_1 = function (themes) {
                            for (var i = 0; i < themes.length; i++) {
                                var theme = themes[i];
                                theme.layers = [];
                                if (theme.themes) {
                                    parse_1(theme.themes);
                                }
                                mapThemes_1[theme.thema] = theme;
                                var themesArr = theme.thema.split("|");
                                theme.thema = themesArr[themesArr.length - 1];
                            }
                        };
                        parse_1(json.themes);
                        mapDescr.themes = json.themes;
                        for (i = 0, count = json.overlays.length; i < count; i++) {
                            overlay = json.overlays[i];
                            theme = mapThemes_1[overlay.thema];
                            if (theme) {
                                if (overlay.type === "WMS") {
                                    overlay.options["crs"] = leaflet_1.CRS[overlay.options["crs"]];
                                }
                                theme.layers.push(new MapControl_1.LayerWrapper(overlay));
                                overlay.theme = theme;
                            }
                            else {
                                console.error("Thema not defined", overlay);
                            }
                        }
                        _a.label = 2;
                    case 2: return [2 /*return*/, mapDescr];
                }
            });
        });
    }
    exports.getConf = getConf;
    /*
    export async function getConfOld(url: string): Promise<MapDescription> {
    
        if (!mapDescr) {
            const json = await Util.loadJson(url);
            mapDescr = {
                default_wms_legend_icon: json.default_wms_legend_icon,
                mapOptions: json.mapOptions,
                baseLayers: json.baseLayers,
                themes: []
            };
    
            const themes: { [id: string]: Theme } = {};
            for (let i = 0, count = json.overlays.length; i < count; i++) {
                const overlay: LayerDescription = json.overlays[i];
                
                let theme = themes[overlay.thema];
    
                if (!theme) {
                    const themesArr = overlay.thema.split('|');
                    let themesId:string;
                    let currentTheme:Theme;
                    for (let i=0; i<themesArr.length; i++) {
                        themesId = themesId ? (themesId+'|'+themesArr[i]) : themesArr[i];
                        theme = themes[themesId];
                        if (!theme) {
                            theme = themes[themesId] = { thema: themesArr[i], layers: [] };
                            if (currentTheme) {
                                if (!currentTheme.themes) {
                                    currentTheme.themes = [];
                                }
                                currentTheme.themes.push(theme);
                            } else {
                                mapDescr.themes.push(theme);
                            }
                        }
                        currentTheme = theme;
                    }
                }
                if (overlay.type === "WMS") {
                    overlay.options["crs"] = CRS[<string>overlay.options["crs"]];
                }
                theme.layers.push(new LayerWrapper(overlay));
            }
    
            for (let i=0, count = json.themes.length; i<count; i++) {
                const t = json.themes[i];
                const thema = themes[t["thema"]];
                if (thema) {
                    thema['icon'] = t["icon"];
                }
            }
        }
        return mapDescr;
    }*/
    function getMapDescription() {
        if (!mapDescr) {
            throw new Error("Mapdescription not initializied");
        }
        return mapDescr;
    }
    exports.getMapDescription = getMapDescription;
    var PathOptions = /** @class */ (function () {
        function PathOptions() {
            /**
             * Set it to `false` to disable borders on polygons or circles.
             */
            this.stroke = true;
            /**
             * Stroke color
             */
            this.color = "#3388ff";
            /**
             * Stroke width in pixels
             */
            this.weight = 3;
            /**
             * Stroke opacity
             */
            this.opacity = 1;
            /**
             * A string that defines [shape to be used at the end](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linecap) of the stroke.
             */
            this.lineCap = "round";
            /**
             * A string that defines the stroke [dash pattern](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dasharray). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
             */
            this.dashArray = null;
            /**
             * A string that defines the [distance into the dash pattern to start the dash](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dashoffset). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
             */
            this.dashOffset = null;
            /**
             * Whether to fill the path with color. Set it to `false` to disable filling on polygons or circles.
             */
            this.fill = false;
            /**
             * Fill color. Defaults to the value of the [`color`](#path-color) option
             */
            this.fillColor = null;
            /**
             * Fill opacity. Standard = 0.2
             */
            this.fillOpacity = 0.2;
            /**
             * A string that defines [how the inside of a shape](https://developer.mozilla.org/docs/Web/SVG/Attribute/fill-rule) is determined.
             */
            this.fillRule = "evenodd";
            /**
             * When `true`, a mouse event on this path will trigger the same event on the map
             * (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).
             */
            this.bubblingMouseEvents = true;
        }
        return PathOptions;
    }());
    exports.PathOptions = PathOptions;
    var CircleMarkerOptions = /** @class */ (function (_super) {
        __extends(CircleMarkerOptions, _super);
        function CircleMarkerOptions() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.fill = true;
            return _this;
        }
        return CircleMarkerOptions;
    }(PathOptions));
    exports.StandardPathOptions = new PathOptions();
    exports.StandardCircleMarkerOptions = new CircleMarkerOptions();
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./src/ts/controls/AttributionCtrl.ts":
/*!********************************************!*\
  !*** ./src/ts/controls/AttributionCtrl.ts ***!
  \********************************************/
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(/*! leaflet */ "./node_modules/leaflet/dist/leaflet-src.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports, leaflet_1) {
    "use strict";
    exports.__esModule = true;
    exports.AttributionCtrl = void 0;
    // import * as Util from '../core/Util';
    // import * as DomEvent from '../dom/DomEvent';
    // import * as DomUtil from '../dom/DomUtil';
    /*
     * @class Control.Attribution
     * @aka L.Control.Attribution
     * @inherits Control
     *
     * The attribution control allows you to display attribution data in a small text box on a map. It is put on the map by default unless you set its [`attributionControl` option](#map-attributioncontrol) to `false`, and it fetches attribution texts from layers with the [`getAttribution` method](#layer-getattribution) automatically. Extends Control.
     */
    exports.AttributionCtrl = leaflet_1.Control.extend({
        // @section
        // @aka Control.Attribution options
        options: {
            position: 'bottomright',
            // @option prefix: String = 'Leaflet'
            // The HTML text shown before the attributions. Pass `false` to disable.
            prefix: '<a href="https://leafletjs.com" title="A JS library for interactive maps">Leaflet</a>'
        },
        initialize: function (options) {
            leaflet_1.Util.setOptions(this, options);
            this._open = false;
            this._attributions = {};
        },
        onAdd: function (map) {
            map.attributionControl = this;
            this._container = leaflet_1.DomUtil.create('div', 'control-attribution');
            this._DivAttribution = leaflet_1.DomUtil.create('div', 'div-attribution', this._container);
            var bttn = this._Bttn = leaflet_1.DomUtil.create('button', 'ctrl-icon', this._container);
            bttn.innerHTML = "&copy;";
            this.clickFct = function (evt) {
                var isOpened = bttn.parentElement.classList.toggle('open');
                // bttn.innerHTML = isOpened? "" : "&copy;"
                bttn.innerHTML = isOpened ? "<span>&#xbb;</span>" : "<span>&copy;</span>";
            };
            bttn.addEventListener('click', this.clickFct);
            leaflet_1.DomEvent.disableClickPropagation(this._container);
            // TODO ugly, refactor
            for (var i in map._layers) {
                if (map._layers[i].getAttribution) {
                    this.addAttribution(map._layers[i].getAttribution());
                }
            }
            this._update();
            return this._container;
        },
        // @method setPrefix(prefix: String): this
        // Sets the text before the attributions.
        setPrefix: function (prefix) {
            this.options.prefix = prefix;
            this._update();
            return this;
        },
        // @method addAttribution(text: String): this
        // Adds an attribution text (e.g. `'Vector data &copy; Mapbox'`).
        addAttribution: function (text) {
            // console.error(`addAttribution ${text}`)
            if (!text) {
                return this;
            }
            if (!this._attributions[text]) {
                this._attributions[text] = 0;
            }
            this._attributions[text]++;
            this._update();
            return this;
        },
        // @method removeAttribution(text: String): this
        // Removes an attribution text.
        removeAttribution: function (text) {
            // console.error(`removeAttribution ${text}`)
            if (!text) {
                return this;
            }
            if (this._attributions[text]) {
                this._attributions[text]--;
                this._update();
            }
            return this;
        },
        _update: function () {
            if (!this._map) {
                return;
            }
            var attribs = [];
            for (var i in this._attributions) {
                if (this._attributions[i]) {
                    attribs.push(i);
                }
            }
            var prefixAndAttribs = [];
            if (this.options.prefix) {
                prefixAndAttribs.push(this.options.prefix);
            }
            if (attribs.length) {
                prefixAndAttribs.push(attribs.join(', '));
            }
            // this._DivAttribution.innerHTML = prefixAndAttribs.join(' | ');
            this._DivAttribution.innerHTML = prefixAndAttribs.join('<br>');
        }
    });
    // @namespace Map
    // @section Control options
    // @option attributionControl: Boolean = true
    // Whether a [attribution control](#control-attribution) is added to the map by default.
    leaflet_1.Map.mergeOptions({
        attributionControl: true
    });
    leaflet_1.Map.addInitHook(function () {
        if (this.options.attributionControl) {
            new exports.AttributionCtrl().addTo(this);
        }
    });
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./src/ts/controls/BaselayerSelectorCtrl.ts":
/*!**************************************************!*\
  !*** ./src/ts/controls/BaselayerSelectorCtrl.ts ***!
  \**************************************************/
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(/*! leaflet */ "./node_modules/leaflet/dist/leaflet-src.js"), __webpack_require__(/*! ../Util */ "./src/ts/Util.ts"), __webpack_require__(/*! ./MapControl */ "./src/ts/controls/MapControl.ts")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports, L, Util_1, MapControl_1) {
    "use strict";
    exports.__esModule = true;
    exports.BaseLayerSelectorCtrl = void 0;
    var BaseLayerSelectorCtrl = /** @class */ (function (_super) {
        __extends(BaseLayerSelectorCtrl, _super);
        function BaseLayerSelectorCtrl(options) {
            var _this = _super.call(this, options) || this;
            _this.mapId2IconNode = {};
            _this.isOpen = false;
            return _this;
        }
        BaseLayerSelectorCtrl.prototype.createIcons = function () {
            var _this = this;
            if (!this.iconContainer) {
                var c = (this.iconContainer = (0, Util_1.createHtmlElement)("div", undefined, "baselayerctrl-iconcontainer"));
                var _loop_1 = function (i) {
                    var item = this_1.baseLayerDefinitions[i];
                    var d = (0, Util_1.createHtmlElement)("div", c, "baselayerctrl-bttn");
                    var icon = (0, Util_1.createHtmlElement)("div", d, "baselayerctrl-item");
                    var span = (0, Util_1.createHtmlElement)("span", d);
                    var label = item["shortLabel"];
                    span.innerHTML = label;
                    d.title = label;
                    // console.info('item', item, "url(\""+ item.img +"\")");
                    icon.style.backgroundImage = 'url("' + item.img + '")';
                    d.addEventListener("click", function (evt) {
                        // if (this.isOpen) {
                        _this.baseLayerIconClicked(evt, item);
                        // } else {
                        //     this.dom.classList.toggle("open");
                        //     this.isOpen = true;
                        // }
                    });
                    if (this_1.baseLayerDefinition === item) {
                        d.classList.add("current");
                    }
                    if (this_1.visibleBaseLayerDefinition === item) {
                        d.classList.add("selected");
                    }
                    this_1.mapId2IconNode[label] = d;
                };
                var this_1 = this;
                // this.baseLayerDefinitions.forEach((item) => {
                for (var i = this.baseLayerDefinitions.length - 1; i >= 0; i--) {
                    _loop_1(i);
                }
                var closeBttn = (0, Util_1.createHtmlElement)("div", c, "baselayerctrl-close-bttn");
                closeBttn.addEventListener("click", function () {
                    _this.dom.classList.toggle("open");
                });
                return c;
            }
        };
        BaseLayerSelectorCtrl.prototype.onAdd = function (map) {
            if (!this.dom) {
                var div = (0, Util_1.createHtmlElement)("div", undefined, "baselayerctrl");
                if (this.baseLayerDefinitions) {
                    this.dom.insertBefore(this.createIcons(), this.dom.firstChild);
                }
                this.dom = div;
            }
            return this.dom;
        };
        BaseLayerSelectorCtrl.prototype.setBaseLayers = function (baseLayers, options) {
            var _this = this;
            this.baseLayerDefinitions = baseLayers;
            this.baseLayerDefOptions = options;
            // this.labelAttribute = options?.labelAttribute || 'label';
            if (this.dom) {
                this.dom.insertBefore(this.createIcons(), this.dom.firstChild);
                var openBttn = (0, Util_1.createHtmlElement)("div", this.dom, "baselayerctrl-open-bttn");
                openBttn.addEventListener("click", function () {
                    _this.dom.classList.toggle("open");
                });
            }
            this.selectBaseLayer(this.baseLayerDefinitions[0]);
        };
        BaseLayerSelectorCtrl.prototype._updateItemIcon = function (baseLayer) {
            // console.error("_updateItemIcon vis=" + (this.visibleBaseLayerDefinition ? this.visibleBaseLayerDefinition["shortLabel"] : "") + "  newBaseL=" + baseLayer["shortLabel"]);
            if (!baseLayer) {
                return;
            }
            if (this.baseLayerDefinition) {
                var node_1 = this.mapId2IconNode[this.baseLayerDefinition["shortLabel"]];
                node_1.classList.remove("current");
            }
            var node = this.mapId2IconNode[baseLayer["shortLabel"]];
            if (node) {
                node.classList.add("current");
            }
            var visibleNode;
            if (this.visibleBaseLayerDefinition) {
                console.info("vis ");
                var node_2 = this.mapId2IconNode[this.visibleBaseLayerDefinition["shortLabel"]];
                node_2.classList.remove("selected");
                if (baseLayer === this.baseLayerDefinitions[1]) {
                    visibleNode = this.mapId2IconNode[this.baseLayerDefinitions[0]["shortLabel"]];
                    // node.classList.add("selected");
                    // node.parentElement.in
                    this.visibleBaseLayerDefinition = this.baseLayerDefinitions[0];
                    console.info("visibleBaseLayerDefinition");
                }
                else {
                    visibleNode = this.mapId2IconNode[this.baseLayerDefinitions[1]["shortLabel"]];
                    // node.classList.add("selected");
                    this.visibleBaseLayerDefinition = this.baseLayerDefinitions[1];
                }
            }
            else {
                visibleNode = this.mapId2IconNode[this.baseLayerDefinitions[1]["shortLabel"]];
                this.visibleBaseLayerDefinition = this.baseLayerDefinitions[1];
            }
            visibleNode.classList.add("selected");
            visibleNode.parentElement.appendChild(visibleNode);
        };
        BaseLayerSelectorCtrl.prototype.selectBaseLayer = function (newBaseLayer) {
            console.info("selectBaseLayer", this.baseLayerDefinitions, newBaseLayer);
            // const bsl = baseLayer.img === "mapicons/sat.png" ? this.baseLayerDefinitions[0] : this.baseLayerDefinitions[2];
            // this._selectItemIcon(this.baseLayerDefinition, false);
            var baseLayer;
            if (typeof newBaseLayer === "number") {
                baseLayer = this.baseLayerDefinitions[0];
            }
            else {
                baseLayer = newBaseLayer;
            }
            this._updateItemIcon(baseLayer);
            this.baseLayerDefinition = baseLayer;
            MapControl_1.MapDispatcher.onBaseLayerSelection.dispatch(this, baseLayer.layer);
            MapControl_1.MapDispatcher.onBaseLayerSelection.dispatch(this, baseLayer.layer);
        };
        BaseLayerSelectorCtrl.prototype.baseLayerIconClicked = function (evt, baseLDef) {
            if (!baseLDef.layer) {
                this.baseLayerDefOptions.createLayer(baseLDef).then(function (layer) {
                    baseLDef.layer = layer;
                });
            }
            this.selectBaseLayer(baseLDef);
            // this.dom.classList.toggle("open");
        };
        return BaseLayerSelectorCtrl;
    }(L.Control));
    exports.BaseLayerSelectorCtrl = BaseLayerSelectorCtrl;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./src/ts/controls/CategorieLayer.ts":
/*!*******************************************!*\
  !*** ./src/ts/controls/CategorieLayer.ts ***!
  \*******************************************/
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(/*! leaflet */ "./node_modules/leaflet/dist/leaflet-src.js"), __webpack_require__(/*! ./MapControl */ "./src/ts/controls/MapControl.ts"), __webpack_require__(/*! ./MarkerListView */ "./src/ts/controls/MarkerListView.ts"), __webpack_require__(/*! ../Util */ "./src/ts/Util.ts")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports, L, MapControl_1, MarkerListView_1, Util_1) {
    "use strict";
    exports.__esModule = true;
    exports.CategorieLayer = exports.GeojsonLayer = exports.CategoryMarker = exports.CategoryCircleMarker = void 0;
    __webpack_require__(/*! leaflet */ "./node_modules/leaflet/dist/leaflet-src.js");
    __webpack_require__(/*! @glartek/leaflet.markercluster */ "./node_modules/@glartek/leaflet.markercluster/dist/leaflet.markercluster-src.js");
    // import {MarkerClusterGroup} from "@glartek/leaflet.markercluster";
    function createIcon(code) {
        return L.divIcon({ html: '<i class="afas">' + String.fromCharCode(code) + "</i>", iconSize: new L.Point(20, 20), iconAnchor: new L.Point(10, 10), className: "mapDivIcon" });
    }
    function createSelectedIcon(code) {
        return L.divIcon({ html: '<i class="afas">' + String.fromCharCode(code) + "</i>", iconSize: new L.Point(40, 40), iconAnchor: new L.Point(20, 20), className: "mapDivIconHighligted" });
    }
    var CategoryCircleMarker = /** @class */ (function (_super) {
        __extends(CategoryCircleMarker, _super);
        function CategoryCircleMarker(parentLayer, coord, data, options) {
            var _this = _super.call(this, coord, options) || this;
            _this.visible = false;
            _this.selected = false;
            _this.data = data;
            return _this;
        }
        CategoryCircleMarker.prototype.setVisible = function (visible) {
            this.visible = visible;
        };
        CategoryCircleMarker.prototype.isVisible = function () {
            return this.visible;
        };
        CategoryCircleMarker.prototype.highlight = function (highlight) {
            console.info("CategoryCircleMarker.highlight ".concat(highlight, " ").concat(this.data["id"]));
            if (highlight) {
                this["fillColor"] = this.options.fillColor || this.options.color;
                this.setStyle({ fillColor: "red" });
            }
            else {
                var fillColor = this["fillColor"];
                this.setStyle({ fillColor: fillColor });
            }
        };
        return CategoryCircleMarker;
    }(L.CircleMarker));
    exports.CategoryCircleMarker = CategoryCircleMarker;
    var CategoryMarker = /** @class */ (function (_super) {
        __extends(CategoryMarker, _super);
        // icon:L.Icon;
        function CategoryMarker(parentLayer, coord, data, options) {
            var _this = _super.call(this, coord, options) || this;
            _this.visible = false;
            // private _clickClosure: (ev: any) => void;
            _this.selected = false;
            // if (!this.getLatLng()) {
            //     debugger;
            // }
            _this.data = data;
            _this.parentLayer = parentLayer;
            if (!options || !options.icon) {
                _this.options["standardIcon"] = CategoryMarker.icon;
                _this.setIcon(CategoryMarker.icon);
            }
            if (!options || !options.selectIcon) {
                _this.options["selectIcon"] = CategoryMarker.selectedIcon;
            }
            return _this;
        }
        CategoryMarker.prototype.setVisible = function (visible) {
            this.visible = visible;
        };
        CategoryMarker.prototype.isVisible = function () {
            return this.visible;
        };
        // highLight(highlight: boolean) {
        //     console.info('CategoryMarker.highlight', this.data['id'], highlight);
        //     this.selected = highlight;
        //     try {
        //         if (highlight) {
        //             (<HTMLElement>(<any>this)._icon).classList.add('highlight');
        //         }
        //         else {
        //             (<HTMLElement>(<any>this)._icon).classList.remove('highlight');
        //         }
        //     } catch (ex) {
        //         // console.error(ex);
        //     }
        // }
        CategoryMarker.prototype.highlight = function (highlight) {
            console.info("CategoryMarker.highlight", this.data["id"], highlight);
            this.selected = highlight;
            if (this._icon) {
                if (highlight) {
                    this._icon.classList.add("icon-highlighted");
                }
                else {
                    this._icon.classList.remove("icon-highlighted");
                }
            }
            console.info("this", this);
            // if (highlight) {
            //     this.setIcon((<CategoryMarkerOptions>this.options).selectIcon);
            // } else {
            //     this.setIcon((<CategoryMarkerOptions>this.options).standardIcon);
            // }
        };
        CategoryMarker.icon = createIcon(0xf024);
        CategoryMarker.selectedIcon = createSelectedIcon(0xf024);
        return CategoryMarker;
    }(L.Marker));
    exports.CategoryMarker = CategoryMarker;
    var nrCSSSelector = 0;
    var GeojsonLayer = /** @class */ (function (_super) {
        __extends(GeojsonLayer, _super);
        function GeojsonLayer(options) {
            var _this = _super.call(this, options) || this;
            _this.layerDescription = options.layerDescription;
            return _this;
        }
        GeojsonLayer.prototype.highlightMarker = function (marker, highlight) {
            marker.highlight(highlight);
        };
        GeojsonLayer.prototype.mapItemClicked = function (marker, ev) {
            // MapDispatcher.onMapFeatureClick.dispatch(marker, {...ev, layer:this, feature:marker});
            MapControl_1.MapDispatcher.onMapFeatureClick.dispatch(marker, ev);
        };
        GeojsonLayer.prototype.renderData = function (marker) {
            return new MarkerListView_1.MarkerView(this, marker);
        };
        GeojsonLayer.prototype._defaultIconCreateFunction = function (cluster) {
            var _a, _b, _c;
            var childCount = cluster.getChildCount();
            // var c = " marker-cluster-";
            // if (childCount < 10) {
            //     c += "small";
            // } else if (childCount < 100) {
            //     c += "medium";
            // } else {
            //     c += "large";
            // }
            if (!this.markerClass) {
                var c = void 0;
                if ((_a = this.layerDescription.icon) === null || _a === void 0 ? void 0 : _a.iconUrl) {
                    // c = "cluster_" + this.layerDescription.label.replace(/[^\w]/g, "");
                    c = "cluster_" + nrCSSSelector++;
                    (0, Util_1.createCSSSelector)("." + c, "background-image: url(\"".concat(this.layerDescription.icon.iconUrl, "\");"));
                }
                else if ((_b = this.layerDescription.theme) === null || _b === void 0 ? void 0 : _b.icon) {
                    // c = "cluster_" + this.layerDescription.theme.thema.replace(" ", "");
                    c = "cluster_" + nrCSSSelector++;
                    (0, Util_1.createCSSSelector)("." + c, "background-image: url(\"".concat(this.layerDescription.theme.icon, "\");"));
                }
                else if (this.layerDescription.classes) {
                    if ((_c = this.layerDescription.theme) === null || _c === void 0 ? void 0 : _c.icon) {
                        c = "cluster_" + nrCSSSelector++;
                        // c = "cluster_" + this.layerDescription.theme.thema.replace(" ", "");
                        (0, Util_1.createCSSSelector)("." + c, "background-image: url(\"".concat(this.layerDescription.theme.icon, "\");"));
                    }
                }
                if (c) {
                    this.markerClass = "marker-cluster marker-cluster-icon marker-cluster-small " + c;
                }
                else {
                    this.markerClass = "marker-cluster marker-cluster-small";
                }
            }
            return new L.DivIcon({ html: "<div><span>" + childCount + "</span></div>", className: this.markerClass, iconSize: new L.Point(40, 40) });
            // return new L.DivIcon({ html: "<div><span>" + childCount + "</span></div>", className: "marker-cluster marker-cluster-small " + c, iconSize: new L.Point(40, 40) });
            // return new L.DivIcon({ html: "<div><span>" + childCount + "</span></div>", className: "marker-cluster-small", iconSize: new L.Point(40, 40) });
        };
        return GeojsonLayer;
    }(L.MarkerClusterGroup));
    exports.GeojsonLayer = GeojsonLayer;
    // export class CategorieLayer<T extends L.LatLngExpression> extends L.LayerGroup {
    var CategorieLayer = /** @class */ (function (_super) {
        __extends(CategorieLayer, _super);
        function CategorieLayer(options) {
            var _this = _super.call(this, options) || this;
            _this.markerMap = {};
            _this.markers = [];
            _this.categorieUrl = options.categorieUrl;
            _this.url = options.url;
            _this.selector = options.selector;
            _this.popupFactory = options.popupFactory;
            return _this;
        }
        CategorieLayer.prototype.loadCategories = function () {
            var _this = this;
            window.fetch(this.categorieUrl).then(function (response) {
                response.json().then(function (data) {
                    _this.categories = data;
                    _this.fire("CategoriesLoaded");
                    _this._loadData();
                });
            });
        };
        CategorieLayer.prototype._loadData = function () {
            var _this = this;
            window.fetch(this.url).then(function (response) {
                response.json().then(function (data) {
                    _this.data = data;
                    for (var i = 0; i < data.length; i++) {
                        var marker = new CategoryMarker(_this, { lat: data[i].lat, lng: data[i].lng }, data[i]);
                        _this.markers.push(marker);
                        _this.markerMap[data[i].id] = marker;
                    }
                    _this._update();
                });
            });
        };
        CategorieLayer.prototype.onAdd = function (map) {
            var _this = this;
            console.info("o0nAdd", this);
            _super.prototype.onAdd.call(this, map);
            this.map = map;
            map.on("zoomend", function (evt) {
                _this.enqueueSpiderfy = true;
            });
            return this;
        };
        CategorieLayer.prototype.onRemove = function (map) {
            _super.prototype.onRemove.call(this, map);
            this.map = undefined;
            return this;
        };
        CategorieLayer.prototype._findMarker = function (value, prop) {
            var markers = this.markers;
            for (var i = 0, count = markers.length; i < count; i++) {
                var marker = markers[i];
                if (marker.data[prop] === value) {
                    return marker;
                }
            }
        };
        CategorieLayer.prototype.findMarkers = function (att, value) {
            return __awaiter(this, void 0, void 0, function () {
                var response, data, result, i, marker;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, window.fetch(this.url + "/search?" + att + "=" + value)];
                        case 1:
                            response = _a.sent();
                            return [4 /*yield*/, response.json()];
                        case 2:
                            data = _a.sent();
                            result = [];
                            for (i = 0; i < data.length; i++) {
                                marker = this.markerMap[data[i]];
                                if (marker) {
                                    result.push(marker);
                                    if (!marker.isVisible()) {
                                        if (!this.foundMarkers) {
                                            this.foundMarkers = [];
                                        }
                                        this.foundMarkers.push(marker);
                                        this.addLayer(marker);
                                    }
                                }
                            }
                            return [2 /*return*/, result];
                    }
                });
            });
        };
        CategorieLayer.prototype.removeSearchResults = function () {
            var _this = this;
            console.info("removeSearchResults");
            if (this.foundMarkers) {
                this.foundMarkers.forEach(function (item) {
                    _this.removeLayer(item);
                });
                this.foundMarkers = undefined;
            }
        };
        // mapItemClickedOrg(marker: CategoryMapObject<T>, ev: L.LeafletMouseEvent): void {
        //     console.info("mapItemClicked", marker.data['id'], ev);
        //     MapDispatcher.onMapFeatureClick.dispatch(marker, ev);
        // }
        CategorieLayer.prototype.mapItemClicked = function (marker, ev) {
            var _this = this;
            console.error("mapItemClicked", marker, ev);
            if (marker.selected) {
                if (this.map.getZoom()) {
                    var lat = marker.data.lat;
                    var lng = marker.data.lng;
                    var c_1 = new L.LatLng(lat, lng);
                    this._map.setView(c_1, 18);
                    this.once("animationend", function (evt) {
                        console.info("animationend=>map.setView(".concat(c_1, ")"));
                        window.setTimeout(function () {
                            _this.map.setView(c_1);
                        });
                    });
                }
                else {
                    // MapDispatcher.onMapFeatureClick.dispatch(marker, {...ev, layer:this, feature:marker});
                    // MapDispatcher.onItemOnMapUnselection.dispatch(this, marker);
                    MapControl_1.MapDispatcher.onMapFeatureClick.dispatch(marker, ev);
                }
            }
            else {
                // MapDispatcher.onItemOnMapSelection.dispatch(this, marker);
                // MapDispatcher.onMapFeatureClick.dispatch(marker, {...ev, layer:this, feature:marker});
                MapControl_1.MapDispatcher.onMapFeatureClick.dispatch(marker, ev);
                this.selectedMarker = marker;
            }
        };
        CategorieLayer.prototype.highlightMarker = function (marker, highlight) {
            console.info("CategorieLayer.highlightMarker ".concat(marker.data["id"], " ").concat(highlight));
            if (highlight) {
                this.removeLayer(marker);
                console.info("marker.options.pane=" + marker.options.pane);
                marker.options["oldPane"] = marker.options.pane;
                marker.options.pane = "highlightPane";
                this._map.addLayer(marker);
                marker.highlight(highlight);
            }
            else {
                this._map.removeLayer(marker);
                var oldPane = marker.options["oldPane"];
                if (oldPane) {
                    marker.options.pane = oldPane;
                }
                this.addLayer(marker);
                marker.highlight(highlight);
            }
        };
        CategorieLayer.prototype.findMarker = function (value, prop) {
            return this._findMarker(value, prop);
        };
        CategorieLayer.prototype.showMarker = function (value, prop) {
            console.info("showMarker");
            var marker = this._findMarker(value, prop);
            if (marker) {
                if (!marker.isVisible()) {
                    this.addLayer(marker);
                }
                if (this._map.getZoom() < 12) {
                    this._map.setZoomAround(marker.getLatLng(), 12);
                }
                else {
                    this._map.panTo(marker.getLatLng());
                }
            }
            return marker;
        };
        CategorieLayer.prototype.renderData = function (marker) {
            return new MarkerListView_1.MarkerView(this, marker);
        };
        CategorieLayer.prototype.getItems = function (path) {
            console.info("_update");
            var selector = this.selector;
            var markers = this.markers;
            var results = [];
            for (var i = 0, count = markers.length; i < count; i++) {
                var marker = markers[i];
                if (selector.isOfCategory(marker.data, [path])) {
                    results.push(marker);
                }
            }
            return results;
        };
        CategorieLayer.prototype._update = function () {
            console.info("_update");
            var selector = this.selector;
            var markers = this.markers;
            if (this.selectedCategories) {
                var selectedCats = this.selectedCategories;
                // let s = "\n";
                // for (let i=0; i<selectedCats.length; i++) {
                //     s += i.toString()+"\t"+selectedCats[i]+"\n";
                // }
                // console.info("_categorieSelected", s, "markers.length="+markers.length);
                for (var i = 0, count = markers.length; i < count; i++) {
                    var marker = markers[i];
                    if (selector.isOfCategory(marker.data, selectedCats)) {
                        if (!marker.isVisible()) {
                            // console.info(marker.data["id"], selector.isOfCategory(marker.data, this.selectedCategories));
                            this.addLayer(marker);
                            marker.setVisible(true);
                        }
                    }
                    else {
                        if (marker.isVisible()) {
                            // console.info(marker.data["id"], selector.isOfCategory(marker.data, this.selectedCategories));
                            this.removeLayer(marker);
                            marker.setVisible(false);
                        }
                    }
                }
            }
            else {
                for (var i = 0, count = markers.length; i < count; i++) {
                    var marker = markers[i];
                    if (marker.isVisible()) {
                        this.removeLayer(marker);
                        marker.setVisible(false);
                    }
                }
            }
        };
        CategorieLayer.prototype.setKategories = function (ids) {
            this.selectedCategories = ids;
            this._update();
        };
        CategorieLayer.prototype.getCategories = function () {
            return this.categories;
        };
        return CategorieLayer;
    }(L.MarkerClusterGroup));
    exports.CategorieLayer = CategorieLayer;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./src/ts/controls/IconAction.ts":
/*!***************************************!*\
  !*** ./src/ts/controls/IconAction.ts ***!
  \***************************************/
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(/*! leaflet */ "./node_modules/leaflet/dist/leaflet-src.js"), __webpack_require__(/*! ../Util */ "./src/ts/Util.ts")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports, leaflet_1, Util_1) {
    "use strict";
    exports.__esModule = true;
    exports.ChangeFontSizeCtrl = exports.IconActionCtrl = void 0;
    var IconActionCtrl = /** @class */ (function (_super) {
        __extends(IconActionCtrl, _super);
        function IconActionCtrl(options) {
            var _this = _super.call(this, options) || this;
            _this.options = options;
            return _this;
        }
        IconActionCtrl.prototype.onAdd = function (map) {
            var _this = this;
            //         console.info("IconAction.onAdd")
            this._map = map;
            if (!this.dom) {
                var div = (0, Util_1.createHtmlElement)('div', undefined, this.options.className + ' ctrl-icon');
                var f = this._clickFct = function (ev) {
                    ev.cancelBubble = true;
                    ev.stopPropagation();
                    _this.options.action(_this);
                    return true;
                };
                div.addEventListener("click", f);
                this.dom = div;
            }
            return this.dom;
        };
        IconActionCtrl.prototype.onRemove = function (map) {
            this._map = null;
            this.dom.removeEventListener("click", this._clickFct);
        };
        return IconActionCtrl;
    }(leaflet_1.Control));
    exports.IconActionCtrl = IconActionCtrl;
    var ChangeFontSizeCtrl = /** @class */ (function (_super) {
        __extends(ChangeFontSizeCtrl, _super);
        function ChangeFontSizeCtrl(options) {
            var _this = _super.call(this, options) || this;
            _this.options = options;
            return _this;
        }
        ChangeFontSizeCtrl.prototype.onAdd = function (map) {
            var _this = this;
            // console.info("IconAction.onAdd")
            this._map = map;
            if (!this.dom) {
                var div = (0, Util_1.createHtmlElement)('div', undefined, 'ctrl-fontsize');
                var divPlus = this.divPlus = (0, Util_1.createHtmlElement)('div', div, 'ctrl-icon font-plus');
                // const span1 = createHtmlElement('span', divPlus);
                divPlus.innerText = "A";
                // const span2 = createHtmlElement('sup', span1);            
                // span2.innerText = '+';
                leaflet_1.DomEvent.disableClickPropagation(divPlus);
                var fPlus = this._clickFct = function (ev) {
                    _this.changeFontSize(_this, true);
                    return true;
                };
                divPlus.addEventListener("click", fPlus);
                divPlus.addEventListener("doubleclick", fPlus);
                divPlus.addEventListener("mouseup", fPlus);
                divPlus.addEventListener("pointerup", fPlus);
                var divMinus = this.divMinus = (0, Util_1.createHtmlElement)('div', div, 'ctrl-icon font-minus');
                // const spanMinus1 = createHtmlElement('span', divMinus);
                divMinus.innerText = "A";
                // const spanMinus2 = createHtmlElement('sup', spanMinus1);
                // spanMinus2.innerText = '-';
                leaflet_1.DomEvent.disableClickPropagation(divMinus);
                var fMinus = this._clickFct = function (ev) {
                    _this.changeFontSize(_this, false);
                    return true;
                };
                divMinus.addEventListener("click", fMinus);
                divMinus.addEventListener("doubleclick", fMinus);
                divMinus.addEventListener("mouseup", fMinus);
                divMinus.addEventListener("pointerup", fMinus);
                this.dom = div;
            }
            return this.dom;
        };
        ChangeFontSizeCtrl.prototype.changeFontSize = function (o, increase) {
            console.info('changefontsize');
            var html = document.querySelector("html");
            if (html) {
                var fs = window.getComputedStyle(html).getPropertyValue('font-size');
                var fontSize = parseInt(fs);
                var i = (increase) ? 1 : -1;
                fontSize += i;
                if (fontSize > 6 && fontSize < 30) {
                    html.style.fontSize = fontSize + 'px';
                    if (fontSize === 7) {
                        this.divMinus.classList.add('disabled');
                    }
                    else {
                        this.divMinus.classList.remove('disabled');
                    }
                    if (fontSize === 29) {
                        this.divPlus.classList.add('disabled');
                    }
                    else {
                        this.divPlus.classList.remove('disabled');
                    }
                }
            }
        };
        ChangeFontSizeCtrl.prototype.onRemove = function (map) {
            this._map = null;
            this.dom.removeEventListener("click", this._clickFct);
        };
        return ChangeFontSizeCtrl;
    }(leaflet_1.Control));
    exports.ChangeFontSizeCtrl = ChangeFontSizeCtrl;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./src/ts/controls/LayerControl.ts":
/*!*****************************************!*\
  !*** ./src/ts/controls/LayerControl.ts ***!
  \*****************************************/
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(/*! leaflet */ "./node_modules/leaflet/dist/leaflet-src.js"), __webpack_require__(/*! ../../../../treecomponent/src/ts/Tree */ "../treecomponent/src/ts/Tree.ts"), __webpack_require__(/*! ../../../../treecomponent/src/ts/TreeNode */ "../treecomponent/src/ts/TreeNode.ts"), __webpack_require__(/*! ./MapControl */ "./src/ts/controls/MapControl.ts")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports, L, Tree_1, TreeNode_1, MapControl_1) {
    "use strict";
    exports.__esModule = true;
    exports.LayerControl = exports.LayerControlOptions = exports.LayerDefinitionOptions = exports.BaseLayerDefinition = void 0;
    var LayerNodeRenderer = /** @class */ (function () {
        function LayerNodeRenderer() {
        }
        // showLegend = true
        LayerNodeRenderer.prototype.render = function (node) {
            var layer = node.data;
            var div = document.createElement("div");
            if (typeof node.data === "string") {
                div.innerHTML = node.data;
                div.dataset.tooltip = node.data;
                div.setAttribute("data-tooltip", node.data);
                div.title = node.data;
            }
            else {
                var txt = node.data.layerDescription["label"];
                if (!txt) {
                    debugger;
                }
                div.innerHTML = txt;
                div.dataset.tooltip = txt;
                div.setAttribute("data-tooltip", txt);
                div.title = txt;
            }
            div.className = "tooltip";
            // if (this.showLegend) {
            //     const legendItem = createLegendLayerItem(layer.layerDescription);
            //     if (legendItem) {
            //         div.appendChild(legendItem);
            //         legendItem.classList.add('legend-item');
            //     }
            // }
            return div;
        };
        return LayerNodeRenderer;
    }());
    var layerRenderer = new LayerNodeRenderer();
    var BaseLayerDefinition = /** @class */ (function () {
        function BaseLayerDefinition() {
        }
        return BaseLayerDefinition;
    }());
    exports.BaseLayerDefinition = BaseLayerDefinition;
    var LayerDefinitionOptions = /** @class */ (function () {
        function LayerDefinitionOptions() {
        }
        return LayerDefinitionOptions;
    }());
    exports.LayerDefinitionOptions = LayerDefinitionOptions;
    var LayerControlOptions = /** @class */ (function () {
        function LayerControlOptions() {
        }
        return LayerControlOptions;
    }());
    exports.LayerControlOptions = LayerControlOptions;
    var LayerControl = /** @class */ (function (_super) {
        __extends(LayerControl, _super);
        function LayerControl(options) {
            var _this = _super.call(this, options) || this;
            _this.categorieLayers = {};
            _this.categorieLayerNodes = {};
            _this.overlays = {};
            if (options.className) {
                _this.className = options.className;
            }
            if (options.baseLayers) {
                _this.baseLayerDefinitions = options.baseLayers;
            }
            if (options.parentNode) {
                _this.parentNode = options.parentNode;
            }
            _this._createTree();
            return _this;
        }
        LayerControl.prototype._layerAdded = function (evt) {
            this.tree.selectNode(evt.layer);
        };
        LayerControl.prototype._layerRemoved = function (evt) {
            this.tree.unselectNode(evt.layer);
        };
        LayerControl.prototype.nodeChanged = function (group, node, sel) {
            console.info("nodeChanged ".concat(group, " ").concat(node.data.name, ", ").concat(TreeNode_1.SelectionStatus[sel]));
        };
        LayerControl.prototype._baseLayerChanged = function (layer) {
            MapControl_1.MapDispatcher.onBaseLayerSelection.dispatch(this, layer);
        };
        LayerControl.prototype.themeLayerChanged = function (node, sel) {
            console.info("themeLayerChanged ".concat(TreeNode_1.SelectionStatus[sel]), node);
            var isSelected = sel === TreeNode_1.SelectionStatus.SELECTED;
            var layer = node.data;
            layer.setSelected(isSelected);
        };
        LayerControl.prototype.baseLayerChanged = function (node, sel) {
            var _this = this;
            console.info("baseLayerChanged ".concat(TreeNode_1.SelectionStatus[sel]), node);
            if (!node.data.layer) {
                this.baseLayerDefOptions.createLayer(node.data).then(function (layer) {
                    node.data.layer = layer;
                    _this._baseLayerChanged(layer);
                });
            }
            else {
                this._baseLayerChanged(node.data.layer);
            }
        };
        LayerControl.prototype.setBaseLayers = function (baseLayers, options) {
            this.baseLayerDefinitions = baseLayers;
            this.baseLayerDefOptions = options;
            if (this.tree) {
                this._addBaseLayersToTree();
            }
            this.selectBaseLayer(this.baseLayerDefinitions[0]);
        };
        LayerControl.prototype.selectBaseLayer = function (baseLayer) {
            console.info("this.setBaseLayer", baseLayer);
            if (typeof baseLayer === "number") {
                this.baseLayerDefinition = this.baseLayerDefinitions[0];
                this.tree.selectNode(baseLayer);
            }
            else {
                this.baseLayerDefinition = baseLayer;
                this.tree.selectNode(baseLayer);
            }
        };
        LayerControl.prototype.selectThemeLayer = function (layerDescr) {
            console.info("selectThemeLayer");
            this.tree.selectNode(layerDescr);
        };
        LayerControl.prototype.addThemes = function (themes) {
            var _this = this;
            this.themes = themes;
            MapControl_1.MapDispatcher.onLayerAdded.subscribe(function (sender, evt) { return _this._layerAdded(evt); });
            MapControl_1.MapDispatcher.onLayerRemoved.subscribe(function (sender, evt) { return _this._layerRemoved(evt); });
            if (this.tree) {
                this._addThemesToTree();
            }
        };
        LayerControl.prototype._createTree = function () {
            this.tree = new Tree_1.Tree(null, { selectMode: TreeNode_1.SelectionMode.MULTI, expandOnlyOneNode: true });
            this._addBaseLayersToTree();
            for (var title in this.overlays) {
                this._addOverlayToTree(title, this.overlays[title]);
            }
            for (var title in this.categorieLayers) {
                this._addCategorieLayerToTree(title, this.categorieLayers[title]);
            }
        };
        LayerControl.prototype._addThemesToTree = function () {
            var _this = this;
            if (this.tree) {
                if (this.themes) {
                    this.themes.forEach(function (theme) {
                        var themeNode = new TreeNode_1.TreeNode(theme.thema);
                        if (theme.layers) {
                            theme.layers.forEach(function (layer) {
                                // const layerNode = new TreeNode(layer, null, {attName2Render:'label'});
                                var layerNode = new TreeNode_1.TreeNode(layer, null, { nodeRenderer: layerRenderer });
                                layerNode.onSelectionChange.subscribe(function (node, sel) { return _this.themeLayerChanged(node, sel); });
                                themeNode.addNode(layerNode);
                            });
                        }
                        if (themeNode.childs && themeNode.childs.length > 0) {
                            _this.tree.addNode(themeNode);
                        }
                    });
                }
            }
        };
        LayerControl.prototype._addBaseLayersToTree = function () {
            var _this = this;
            if (this.tree) {
                var count = this.baseLayerDefinitions ? this.baseLayerDefinitions.length : 0;
                if (count > 0) {
                    var baseLayerNodes = [];
                    var nodeParam = void 0;
                    if (this.baseLayerDefOptions.labelAttribute) {
                        nodeParam = { attName2Render: this.baseLayerDefOptions.labelAttribute };
                    }
                    for (var i = 0; i < count; i++) {
                        var baseLayerNode = new TreeNode_1.TreeNode(this.baseLayerDefinitions[i], null, nodeParam);
                        baseLayerNodes.push(baseLayerNode);
                    }
                    console.info(baseLayerNodes);
                    var baseLNode = new TreeNode_1.RadioGroupTreeNode({ name: "Grundkarte" }, baseLayerNodes);
                    baseLNode.onSelectionChange.subscribe(function (node, sel) { return _this.baseLayerChanged(node, sel); });
                    this.tree.addNode(baseLNode);
                }
                console.info("before setSeled");
                this.tree.selectNode(this.baseLayerDefinition);
                this.tree.onSelectionChange.subscribe(function (node, sel) { return _this.nodeChanged("tree", node, sel); });
            }
        };
        LayerControl.prototype._addCategorieLayerToTree = function (title, categorieLayer) {
            var _this = this;
            if (this.tree) {
                var categories = categorieLayer.getCategories();
                var treeNode_1 = new TreeNode_1.TreeNode(title);
                this.tree.addNode(treeNode_1);
                this.addCategories(treeNode_1, categories);
                this.categorieLayerNodes[title] = treeNode_1;
                treeNode_1.onSelectionChange.subscribe(function (node, status) { return _this._categorieSelected(title, treeNode_1, status); });
            }
        };
        LayerControl.prototype._addOverlayToTree = function (title, overlays) {
            var _this = this;
            console.info("_addCategorieLayerToTree ".concat(this.tree));
            if (this.tree) {
                var treeNode_2 = new TreeNode_1.TreeNode(title, undefined, { selectMode: TreeNode_1.SelectionMode.MULTI });
                this.tree.addNode(treeNode_2);
                overlays.forEach(function (baseLayerDef) {
                    var treeNode = new TreeNode_1.TreeNode(baseLayerDef, null, { selectMode: TreeNode_1.SelectionMode.MULTI, nodeRenderer: layerRenderer });
                    treeNode.addNode(treeNode);
                });
                treeNode_2.onSelectionChange.subscribe(function (node, status) { return _this._themeSelected(title, treeNode_2, status); });
            }
        };
        LayerControl.prototype.addTo = function (map) {
            // console.error('LayerControl.addTo');
            if (this.parentNode) {
                this.remove();
                this._map = map;
                var container = (this._container = this.onAdd(map));
                container.classList.add("layerctrl-dom");
                this.parentNode.appendChild(container);
                this._map.on("unload", this.remove, this);
                return this;
            }
            else {
                return _super.prototype.addTo.call(this, map);
            }
        };
        LayerControl.prototype.onAdd = function (map) {
            console.info("LayerControl.onAdd");
            if (!this.tree) {
                this._createTree();
            }
            // console.info("addbaseLayer", this.baseLayer);
            this._map = map;
            // this.map.addEventListener("movestart", (ev) => { });
            // this.map.addEventListener("moveend", (ev) => { });
            var dom = this.tree._render();
            if (this.className) {
                dom.classList.add(this.className);
            }
            var fnStopPropagation = function (ev) {
                ev.stopPropagation();
                return false;
            };
            // L.DomEvent.disableClickPropagation(dom);
            // L.DomEvent.disableScrollPropagation(dom);
            dom.addEventListener("pointermove", fnStopPropagation);
            dom.addEventListener("mousedown", fnStopPropagation);
            dom.addEventListener("dblclick", fnStopPropagation);
            dom.addEventListener("dragstart", fnStopPropagation);
            dom.addEventListener("drag", fnStopPropagation);
            dom.addEventListener("wheel", fnStopPropagation);
            return dom;
        };
        LayerControl.prototype.onRemove = function (map) {
            console.info("LayerControl.onRemove");
        };
        // remove() {
        //     console.error("LayerControl.remove");
        //     super.remove();
        //     return this;
        // }
        LayerControl.prototype._findBaseLayerDefinition = function (baseLayerId) {
            for (var i = 0; i < this.baseLayerDefinitions.length; i++) {
                if (this.baseLayerDefinitions[i].id === baseLayerId) {
                    return this.baseLayerDefinitions[i];
                }
                if (this.baseLayerDefinitions[i].id.toString().toLowerCase() === baseLayerId.toLowerCase()) {
                    return this.baseLayerDefinitions[i];
                }
            }
            return undefined;
        };
        LayerControl.prototype.findCategorie = function (title, item) {
            console.info("findCategorie", item);
            var node = this.categorieLayerNodes[title];
            if (node) {
                return node.findNode(item.id, "id");
            }
        };
        LayerControl.prototype.findItemsOfCategorie = function (title, item) {
            console.info("findItemsOfCategorie", item);
            var node = this.categorieLayerNodes[title];
            if (node) {
                var nodes = node.findNode(item.id, "id");
                if (nodes) {
                    var path = [];
                    for (var i = nodes.length - 2; i >= 0; i--) {
                        path.push(nodes[i].data.id);
                    }
                    console.info("path", path);
                    var layer = this.categorieLayers[title];
                    if (layer) {
                        return layer.getItems(path);
                    }
                }
            }
        };
        LayerControl.prototype.showCategorie = function (title, item) {
            console.info("showCategorie", item);
            var node = this.categorieLayerNodes[title];
            if (node) {
                node.selectNode(item.id, "id");
            }
        };
        LayerControl.prototype.showMarker = function (title, id, prop) {
            console.info("showmarker(".concat(title, ", ").concat(id, ", ").concat(prop, ")"));
            var layer = this.categorieLayers[title];
            if (layer) {
                var marker = layer.showMarker(id, prop);
            }
        };
        LayerControl.prototype.getItems = function (title, path) {
            console.info("getItems(".concat(title, ", ").concat(path, ")"));
            var layer = this.categorieLayers[title];
            return layer.getItems(path);
        };
        LayerControl.prototype.addCategorieLayer = function (title, categorieLayer, showAll) {
            this.categorieLayers[title] = categorieLayer;
            console.info("addCategorieLayer");
            if (this.tree) {
                this._addCategorieLayerToTree(title, categorieLayer);
                if (showAll) {
                    this.tree.selectNode(title);
                }
            }
        };
        LayerControl.prototype._categorieSelected = function (layerTitle, node, status) {
            console.info("_categorieSelected", node, status);
            var selectedCats = this._findSelected(node.childs);
            var categoryLayer = this.categorieLayers[layerTitle];
            if (categoryLayer) {
                categoryLayer.setKategories(selectedCats);
            }
        };
        LayerControl.prototype._themeSelected = function (theme, node, status) {
            console.info("_themeSelected", theme, node, status);
        };
        LayerControl.prototype._findSelected = function (nodes) {
            var ids = [];
            for (var i = 0; i < nodes.length; i++) {
                if (nodes[i].getSelectionsStatus() === TreeNode_1.SelectionStatus.SELECTED) {
                    ids.push([nodes[i].data.id]);
                }
                else {
                    if (nodes[i].getSelectionsStatus() === TreeNode_1.SelectionStatus.INDETERMINATE) {
                        var chIds = this._findSelected(nodes[i].childs);
                        for (var j = 0; j < chIds.length; j++) {
                            ids.push(__spreadArray([nodes[i].data.id], chIds[j], true));
                        }
                    }
                }
            }
            return ids;
        };
        LayerControl.prototype.addCategories = function (base, categories) {
            for (var i = 0; i < categories.length; i++) {
                var treeNode = new TreeNode_1.TreeNode(categories[i], null, LayerControl.catNodeParam);
                if (categories[i].childs) {
                    this.addCategories(treeNode, categories[i].childs);
                }
                base.addNode(treeNode);
            }
        };
        LayerControl.catNodeParam = {
            attName2Render: "bezeichnung",
            selectMode: TreeNode_1.SelectionMode.MULTI
        };
        return LayerControl;
    }(L.Control));
    exports.LayerControl = LayerControl;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./src/ts/controls/LayerControlVar.ts":
/*!********************************************!*\
  !*** ./src/ts/controls/LayerControlVar.ts ***!
  \********************************************/
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(/*! leaflet */ "./node_modules/leaflet/dist/leaflet-src.js"), __webpack_require__(/*! ../../../../treecomponent/src/ts/Tree */ "../treecomponent/src/ts/Tree.ts"), __webpack_require__(/*! ../../../../treecomponent/src/ts/TreeNode */ "../treecomponent/src/ts/TreeNode.ts"), __webpack_require__(/*! ../Util */ "./src/ts/Util.ts"), __webpack_require__(/*! ../widget/Accordion */ "./src/ts/widget/Accordion.ts"), __webpack_require__(/*! ./LayerControl */ "./src/ts/controls/LayerControl.ts"), __webpack_require__(/*! ./MapControl */ "./src/ts/controls/MapControl.ts"), __webpack_require__(/*! strongly-typed-events */ "./node_modules/strongly-typed-events/dist/index.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports, L, Tree_1, TreeNode_1, Util_1, Accordion_1, LayerControl_1, MapControl_1, strongly_typed_events_1) {
    "use strict";
    exports.__esModule = true;
    exports.LayerControlVar = void 0;
    var ThemeNodeRenderer = /** @class */ (function () {
        function ThemeNodeRenderer() {
        }
        ThemeNodeRenderer.prototype.render = function (node) {
            var theme = node.data;
            var div = document.createElement("div");
            var txt = theme.thema;
            div.innerHTML = txt;
            div.dataset.tooltip = txt;
            div.setAttribute("data-tooltip", txt);
            div.title = txt;
            div.className = "tooltip";
            return div;
        };
        return ThemeNodeRenderer;
    }());
    var ThemeTreeNode = /** @class */ (function (_super) {
        __extends(ThemeTreeNode, _super);
        function ThemeTreeNode() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        ThemeTreeNode.prototype.render = function (inset) {
            var _this = this;
            inset = inset !== null && inset !== void 0 ? inset : 0;
            var dom = this.dom;
            var treerow = this.treerow;
            if (!dom) {
                dom = this.dom = document.createElement("div");
                dom.className = "row-wrapper row-wrapper-" + inset;
                treerow = this.treerow = document.createElement("div");
                treerow.className = "treerow";
                dom.appendChild(treerow);
                var childCount = this.childs ? this.childs.length : 0;
                // const selectMode = this.getSelectMode();
                var theme = this.data;
                if (theme.icon) {
                    var img = document.createElement("img");
                    img.src = theme.icon;
                    img.alt = "Icon " + theme.thema;
                    treerow.appendChild(img);
                }
                var labelDiv = document.createElement("div");
                labelDiv.className = "treelabel";
                // const label = this.nodeRenderer.render(this)
                var label = document.createElement("div");
                var txt = theme.thema;
                label.innerHTML = txt;
                label.dataset.tooltip = txt;
                label.setAttribute("data-tooltip", txt);
                label.title = txt;
                label.className = "tooltip";
                // if (label) {
                labelDiv.appendChild(label);
                treerow.appendChild(labelDiv);
                // }
                if (inset === 0) {
                    var spanOpenClose = (this.spanOpenClose = document.createElement("span"));
                    treerow.addEventListener("click", function (ev) { return _this.onTreeIconClick(ev); });
                    if (this.collapsed) {
                        this.dom.classList.add("closed");
                    }
                    else {
                        this.dom.classList.add("opened");
                    }
                    if (childCount > 0) {
                        if (this.collapsed) {
                            this.spanOpenClose.classList.add("closed");
                        }
                        else {
                            this.spanOpenClose.classList.add("opened");
                        }
                    }
                    this.textNode = spanOpenClose;
                    treerow.appendChild(spanOpenClose);
                }
                else {
                    this.dom.classList.add("opened");
                }
                var nodecontainer = this.childDom;
                if (nodecontainer) {
                    nodecontainer.innerHTML = null;
                }
                if (childCount > 0) {
                    if (!nodecontainer) {
                        nodecontainer = this.childDom = document.createElement("div");
                        nodecontainer.className = "nodecontainer";
                        dom.appendChild(nodecontainer);
                    }
                    // const childInset = this.showOnlyChilds ? inset : (inset + insetSelf);
                    for (var i = 0; i < this.childs.length; i++) {
                        nodecontainer.appendChild(this.childs[i].render(inset + 1));
                    }
                }
                this.dom.style.display = this.hideEmptyNode && childCount === 0 ? "none" : "flex";
            }
            this.insetChilds = this.showOnlyChilds ? inset : inset + 1;
            return dom;
        };
        return ThemeTreeNode;
    }(TreeNode_1.TreeNode));
    var scaleDom = undefined;
    function createZoomScale() {
        if (!scaleDom) {
            /*
            const s1 = `
            <svg width="248" height="80" version="1.1" preserveAspectRatio="none" viewBox="10 0 223 60" xmlns="http://www.w3.org/2000/svg">
            <g font-family="sans-serif" font-size="8px" letter-spacing="0px" stroke-width=".26458" word-spacing="0px">
                <text class="p01" x="20" y="12">1</text>
                <text class="p02" x="40" y="12">2</text>
                <text class="p03" x="60" y="12">3</text>
                <text class="p04" x="80" y="12">4</text>
                <text class="p05" x="100" y="12">5</text>
                <text class="p06" x="120" y="12">6</text>
                <text class="p07" x="140" y="12">7</text>
                <text class="p08" x="160" y="12">8</text>
                <text class="p09" x="180" y="12">9</text>
                <text class="p10" x="200" y="12">10</text>
                <text class="p11" x="220" y="12">11</text>
            </g>
            <path class="p01" d="M 12 35 l 20 1 l 0  -8 l -20 1 l 0  6" stroke="gray" fill="lightgray" />
            <path class="p02" d="M 32 36 l 20 1 l 0 -10 l -20 1 l 0  8" stroke="gray" fill="lightgray" />
            <path class="p03" d="M 52 37 l 20 1 l 0 -12 l -20 1 l 0 10" stroke="gray" fill="lightgray" />
            <path class="p04" d="M 72 38 l 20 1 l 0 -14 l -20 1 l 0 12" stroke="gray" fill="lightgray" />
            <path class="p05" d="M 92 39 l 20 1 l 0 -16 l -20 1 l 0 14" stroke="gray" fill="lightgray" />
            <path class="p06" d="M 112 40 l 20 1 l 0 -18 l -20 1 l 0 16" stroke="gray" fill="lightgray" />
            <path class="p07" d="M 132 41 l 20 1 l 0 -20 l -20 1 l 0 18" stroke="gray" fill="lightgray" />
            <path class="p08" d="M 152 42 l 20 1 l 0 -22 l -20 1 l 0 20" stroke="gray" fill="lightgray" />
            <path class="p09" d="M 172 43 l 20 1 l 0 -24 l -20 1 l 0 22" stroke="gray" fill="lightgray" />
            <path class="p10" d="M 192 44 l 20 1 l 0 -26 l -20 1 l 0 24" stroke="gray" fill="lightgray" />
            <path class="p11" d="M 212 45 l 20 1 l 0 -28 l -20 1 l 0 26" stroke="gray" fill="lightgray" />
    
            <path class="z01" d="M 12 35 l 20 1 l 0  -8 l -20 1 l 0  6" visibility="hidden" />
            <path class="z02" d="M 32 36 l 20 1 l 0 -10 l -20 1 l 0  8" visibility="hidden" />
            <path class="z03" d="M 52 37 l 20 1 l 0 -12 l -20 1 l 0 10" visibility="hidden" />
            <path class="z04" d="M 72 38 l 20 1 l 0 -14 l -20 1 l 0 12" visibility="hidden" />
            <path class="z05" d="M 92 39 l 20 1 l 0 -16 l -20 1 l 0 14" visibility="hidden" />
            <path class="z06" d="M 112 40 l 20 1 l 0 -18 l -20 1 l 0 16" visibility="hidden" />
            <path class="z07" d="M 132 41 l 20 1 l 0 -20 l -20 1 l 0 18" visibility="hidden" />
            <path class="z08" d="M 152 42 l 20 1 l 0 -22 l -20 1 l 0 20" visibility="hidden" />
            <path class="z09" d="M 172 43 l 20 1 l 0 -24 l -20 1 l 0 22" visibility="hidden" />
            <path class="z10" d="M 192 44 l 20 1 l 0 -26 l -20 1 l 0 24" visibility="hidden" />
            <path class="z11" d="M 212 45 l 20 1 l 0 -28 l -20 1 l 0 26" visibility="hidden" />
    
        </svg>
        `;*/
            var s = "\n    <svg width=\"248\" height=\"80\" version=\"1.1\" preserveAspectRatio=\"none\" viewBox=\"10 0 223 60\" xmlns=\"http://www.w3.org/2000/svg\">\n    <g font-family=\"sans-serif\" font-size=\"8px\" letter-spacing=\"0px\" stroke-width=\".26458\" word-spacing=\"0px\">\n        <text class=\"p01\" x=\"20\" y=\"12\">1</text><text class=\"p02\" x=\"40\" y=\"12\">2</text><text class=\"p03\" x=\"60\" y=\"12\">3</text>\n        <text class=\"p04\" x=\"80\" y=\"12\">4</text><text class=\"p05\" x=\"100\" y=\"12\">5</text><text class=\"p06\" x=\"120\" y=\"12\">6</text>\n        <text class=\"p07\" x=\"140\" y=\"12\">7</text><text class=\"p08\" x=\"160\" y=\"12\">8</text><text class=\"p09\" x=\"180\" y=\"12\">9</text>\n        <text class=\"p10\" x=\"200\" y=\"12\">10</text><text class=\"p11\" x=\"220\" y=\"12\">11</text>\n    </g>\n    <path class=\"p01\" d=\"M  12 35 l 20 0 l 0  -6 l -20 0 l 0  6\" stroke=\"gray\" fill=\"lightgray\" />\n    <path class=\"p02\" d=\"M  32 36 l 20 0 l 0  -8 l -20 0 l 0  8\" stroke=\"gray\" fill=\"lightgray\" />\n    <path class=\"p03\" d=\"M  52 37 l 20 0 l 0 -10 l -20 0 l 0 10\" stroke=\"gray\" fill=\"lightgray\" />\n    <path class=\"p04\" d=\"M  72 38 l 20 0 l 0 -12 l -20 0 l 0 12\" stroke=\"gray\" fill=\"lightgray\" />\n    <path class=\"p05\" d=\"M  92 39 l 20 0 l 0 -14 l -20 0 l 0 14\" stroke=\"gray\" fill=\"lightgray\" />\n    <path class=\"p06\" d=\"M 112 40 l 20 0 l 0 -16 l -20 0 l 0 16\" stroke=\"gray\" fill=\"lightgray\" />\n    <path class=\"p07\" d=\"M 132 41 l 20 0 l 0 -18 l -20 0 l 0 18\" stroke=\"gray\" fill=\"lightgray\" />\n    <path class=\"p08\" d=\"M 152 42 l 20 0 l 0 -20 l -20 0 l 0 20\" stroke=\"gray\" fill=\"lightgray\" />\n    <path class=\"p09\" d=\"M 172 43 l 20 0 l 0 -22 l -20 0 l 0 22\" stroke=\"gray\" fill=\"lightgray\" />\n    <path class=\"p10\" d=\"M 192 44 l 20 0 l 0 -24 l -20 0 l 0 24\" stroke=\"gray\" fill=\"lightgray\" />\n    <path class=\"p11\" d=\"M 212 45 l 20 0 l 0 -26 l -20 0 l 0 26\" stroke=\"gray\" fill=\"lightgray\" />\n\n    <path class=\"z01\" d=\"M  12 35 l 20 0 l 0  -6 l -20 0 l 0  6\" visibility=\"hidden\" />\n    <path class=\"z02\" d=\"M  32 36 l 20 0 l 0  -8 l -20 0 l 0  8\" visibility=\"hidden\" />\n    <path class=\"z03\" d=\"M  52 37 l 20 0 l 0 -10 l -20 0 l 0 10\" visibility=\"hidden\" />\n    <path class=\"z04\" d=\"M  72 38 l 20 0 l 0 -12 l -20 0 l 0 12\" visibility=\"hidden\" />\n    <path class=\"z05\" d=\"M  92 39 l 20 0 l 0 -14 l -20 0 l 0 14\" visibility=\"hidden\" />\n    <path class=\"z06\" d=\"M 112 40 l 20 0 l 0 -16 l -20 0 l 0 16\" visibility=\"hidden\" />\n    <path class=\"z07\" d=\"M 132 41 l 20 0 l 0 -18 l -20 0 l 0 18\" visibility=\"hidden\" />\n    <path class=\"z08\" d=\"M 152 42 l 20 0 l 0 -20 l -20 0 l 0 20\" visibility=\"hidden\" />\n    <path class=\"z09\" d=\"M 172 43 l 20 0 l 0 -22 l -20 0 l 0 22\" visibility=\"hidden\" />\n    <path class=\"z10\" d=\"M 192 44 l 20 0 l 0 -24 l -20 0 l 0 24\" visibility=\"hidden\" />\n    <path class=\"z11\" d=\"M 212 45 l 20 0 l 0 -26 l -20 0 l 0 26\" visibility=\"hidden\" />\n\n</svg>\n";
            var parser = new DOMParser();
            var doc = parser.parseFromString(s, "text/html");
            var fragment = doc.querySelector("svg");
            var d = document.createElement("div");
            d.innerHTML = s;
            scaleDom = fragment; //.querySelector("svg");
        }
        return scaleDom.cloneNode(true);
    }
    var SCALES = 
    // [591657550.5, 295828775.3, 147914387.6, 73957193.82, 36978596.91, 18489298.45, 9244649.227, 4622324.614, 2311162.307, 1155581.153, 577790.5767, 288895.2884, 144447.6442, 72223.82209, 36111.91104, 18055.95552, 9027.977761, 4513.98888, 2256.99444, 1128.49722];
    [0, 0, 0, 0, 0, 17471320.7509, 8735660.37545, 4367830.18772, 2183915.09386, 1091957.54693, 545978.773466, 272989.386733, 136494.693366, 68247.3466832, 34123.6733414, 17061.8366707, 8530.91833536, 4265.45916786, 2132.72958393, 1066.36479179];
    var LayerNode = /** @class */ (function (_super) {
        __extends(LayerNode, _super);
        function LayerNode(layer) {
            return _super.call(this, layer) || this;
        }
        LayerNode.prototype.render = function (inset) {
            var _this = this;
            var _a, _b, _c;
            // const col = TreeNode.getTreePath(this).length;
            if (!inset) {
                inset = 0;
            }
            var dom = this.dom;
            var treerow = this.treerow;
            if (!dom) {
                dom = this.dom = document.createElement("div");
                dom.className = "row-wrapper row-wrapper-" + inset;
                treerow = this.treerow = document.createElement("div");
                dom.appendChild(treerow);
                // treerow.id = "treerow" + TreeNode.nodeCounter++
                treerow.className = "treerow";
                // const cb: HTMLInputElement = this._createCeckBox();
                var cb = document.createElement("div");
                cb.className = "cb_layer";
                var chBox = void 0;
                chBox = this.chBox = document.createElement("input");
                chBox.type = "checkbox";
                chBox.id = "cb" + this.data.id;
                // chBox.className = "regular-checkbox";
                // chBox.setAttribute("aria-label", );
                // chBox.checked = this.selectionStatus === SelectionStatus.SELECTED || this.selectionStatus === SelectionStatus.INDETERMINATE;
                // chBox.indeterminate = this.selectionStatus === SelectionStatus.INDETERMINATE;
                chBox.addEventListener("change", function (ev) { return _this.onchBoxChange(ev); });
                cb.appendChild(chBox);
                treerow.appendChild(cb);
                var label = document.createElement("label");
                label.htmlFor = "cb" + this.data.id;
                // treerow.appendChild(label);
                cb.appendChild(label);
                // label.addEventListener("click", function () {
                //     cb.click();
                // });
                var layer_1 = this.data;
                // console.info('LayerControlVar.LayerNodeRenderer.render', layer);
                var layerTitle = (0, Util_1.createHtmlElement)("div", treerow, "layer-title tooltip");
                var txt = layer_1.layerDescription.label;
                if (!txt) {
                    debugger;
                }
                layerTitle.innerHTML = txt;
                layerTitle.dataset.tooltip = txt;
                layerTitle.setAttribute("data-tooltip", txt);
                layerTitle.title = txt;
                if (layer_1.layerDescription.type === "WMS") {
                    var f = function (ev) {
                        // console.info("setOpacity", (<any>layer.layer).options.opacity);
                        var v = 0.01 * parseInt(ev.target.value);
                        if (layer_1.layer) {
                            layer_1.layer.setOpacity(v);
                        }
                        else {
                            layer_1.layerDescription.options["opacity"] = v;
                        }
                    };
                    // const v = layer.layer?.["options"].opacity ?? layer.layerDescription?.options?.["opacity"] || 1;
                    var v = (_c = (_b = (_a = layer_1.layerDescription) === null || _a === void 0 ? void 0 : _a.options) === null || _b === void 0 ? void 0 : _b["opacity"]) !== null && _c !== void 0 ? _c : 1;
                    var dV = 100 * parseFloat(v);
                    var slider = (0, Util_1.createSlider)("0", "100", dV.toString(), f, "opacity-slider");
                    // console.info("slider", layer.layerDescription.label, v, dV);
                    // layerTitle.appendChild(slider);
                    dom.appendChild(slider);
                }
                if (layer_1.layerDescription.minScale || layer_1.layerDescription.maxScale) {
                    // const img = document.createElement("img");
                    // img.src = "images/scale2.svg";
                    // layerTitle.appendChild(img);
                    // console.info("MinMax", layer);
                    for (var i = 8; i <= 19; i++) {
                        // console.error("zoom " + i + "  scale=" + L.CRS["scale"](i));
                        var scale = SCALES[i];
                        if (layer_1.layerDescription.minScale && scale < layer_1.layerDescription.minScale) {
                            dom.classList.add("z" + i + "disabled");
                        }
                        if (layer_1.layerDescription.maxScale && scale > layer_1.layerDescription.maxScale) {
                            dom.classList.add("z" + i + "disabled");
                        }
                    }
                    dom.appendChild(createZoomScale());
                    console.info("zoomScale", layer_1.layerDescription.label, dom);
                }
                var infoIcon = (this.infoIcon = (0, Util_1.createHtmlElement)("span", treerow, "info-icon"));
                infoIcon.addEventListener("click", function (ev) {
                    MapControl_1.MapDispatcher.onShowLayerInfoRequest.dispatch(_this, layer_1);
                });
            }
            return dom;
        };
        LayerNode.prototype.setStatus = function (status) {
            switch (status) {
                case "waiting":
                    this.infoIcon.classList.remove("error");
                    this.infoIcon.classList.add("waiting");
                    break;
                case "error":
                    this.infoIcon.classList.remove("waiting");
                    this.infoIcon.classList.add("error");
                    break;
                default:
                    this.infoIcon.classList.remove("error");
                    this.infoIcon.classList.remove("waiting");
            }
        };
        return LayerNode;
    }(TreeNode_1.TreeNode));
    /**
     *  Nodes for Tree "Meine Kartenauswahl"
     */
    var Tree2Node = /** @class */ (function (_super) {
        __extends(Tree2Node, _super);
        function Tree2Node(data, childs, params) {
            var _this = _super.call(this, data, childs, params) || this;
            _this.onTreeDeleteIconClick = new strongly_typed_events_1.EventDispatcher();
            _this.fChangeNodeOrder = params.fChangeNodeOrder;
            return _this;
        }
        Tree2Node.prototype.render = function (inset) {
            var _this = this;
            console.info("Tree2Node.render selectMode=".concat(this.getSelectMode()));
            var dom = this.dom;
            // let treerow = this.treerow
            if (!dom) {
                dom = this.dom = document.createElement("div");
                dom.className = "row-wrapper";
                var treerow = (this.treerow = document.createElement("div"));
                //  treerow.id = "treerow" + nodeCounter
                treerow.className = "treerow";
                dom.appendChild(treerow);
                // const selectMode = this.getSelectMode();
                var span = document.createElement("div");
                span.className = "treeicon";
                var deleteIcon = document.createElement("i");
                deleteIcon.className = "clear-icon";
                deleteIcon.addEventListener("click", function (ev) { return _this.onTreeDeleteIconClick.dispatch(_this, undefined); });
                var spanOpenClose = (this.spanOpenClose = document.createElement("span"));
                spanOpenClose.addEventListener("click", function (ev) { return _this.onTreeIconClick(ev); });
                // if (selectMode === SelectionMode.SINGLE) {
                //     treerow.addEventListener('click', (ev) => this.itemClicked(ev));
                // }
                treerow.className = "treerow leaf";
                this.textNode = spanOpenClose;
                span.appendChild(deleteIcon);
                span.appendChild(spanOpenClose);
                var cb_1 = this._createCeckBox();
                span.appendChild(cb_1);
                var label = document.createElement("label");
                span.appendChild(label);
                label.addEventListener("click", function () {
                    cb_1.click();
                });
                treerow.appendChild(span);
                var labelDiv = document.createElement("div");
                labelDiv.className = "treelabel";
                // const label = this.nodeRenderer.render(this)
                var txt = this.data.layerDescription["label"];
                var layerTitle = (0, Util_1.createHtmlElement)("span", treerow, "layer-title tooltip");
                layerTitle.innerHTML = txt;
                layerTitle.dataset.tooltip = txt;
                layerTitle.setAttribute("data-tooltip", txt);
                layerTitle.title = txt;
                var infoIcon = (this.infoIcon = (0, Util_1.createHtmlElement)("span", treerow, "info-icon"));
                // infoIcon.innerHTML = '&#xf05a;';
                infoIcon.addEventListener("click", function (ev) {
                    MapControl_1.MapDispatcher.onShowLayerInfoRequest.dispatch(_this, _this.data);
                });
                if (this.fChangeNodeOrder) {
                    var divUpDown = (0, Util_1.createHtmlElement)("div", treerow, "change-layer-order");
                    var up = (0, Util_1.createHtmlElement)("div", divUpDown, "up");
                    var down = (0, Util_1.createHtmlElement)("div", divUpDown, "down");
                    up.addEventListener("click", function (ev) { return _this.nodeUp(); });
                    down.addEventListener("click", function (ev) { return _this.nodeDown(); });
                }
                if (this.actions) {
                    treerow.appendChild(this.renderActions());
                }
                var nodecontainer = this.childDom;
                if (nodecontainer) {
                    nodecontainer.innerHTML = null;
                }
                this.dom.style.display = "flex";
            }
            return dom;
        };
        Tree2Node.prototype.nodeUp = function () {
            console.info("Tree2Node.layerUp", this);
            this.fChangeNodeOrder({ node: this, up: true });
        };
        Tree2Node.prototype.nodeDown = function () {
            console.info("Tree2Node.layerDown", this);
            this.fChangeNodeOrder({ node: this, up: false });
        };
        Tree2Node.prototype.setStatus = function (status) {
            switch (status) {
                case "waiting":
                    this.infoIcon.classList.remove("error");
                    this.infoIcon.classList.add("waiting");
                    break;
                case "error":
                    this.infoIcon.classList.remove("waiting");
                    this.infoIcon.classList.add("error");
                    break;
                default:
                    this.infoIcon.classList.remove("error");
                    this.infoIcon.classList.remove("waiting");
            }
        };
        return Tree2Node;
    }(TreeNode_1.TreeNode));
    var themeNodeRender = new ThemeNodeRenderer();
    var LayerControlVar = /** @class */ (function (_super) {
        __extends(LayerControlVar, _super);
        function LayerControlVar(options) {
            var _this = _super.call(this, options) || this;
            _this.categorieLayers = {};
            _this.categorieLayerNodes = {};
            _this.mapLayerId2OverlayNodes = {};
            _this.mapLayerId2MyLayerNodes = {};
            // console.info("LayerControlVar.construct")
            if (options.className) {
                _this.className = options.className;
            }
            if (options.parentNode) {
                _this.parentNode = options.parentNode;
                // layerRenderer.showLegend = false;
            }
            _this._createTree();
            _this._createTree2();
            _this.fChangeLayerOrder = function (ev) { return _this.changeLayerOrder(ev); };
            _this.fThemeLayerChanged = function (node, sel) { return _this.themeLayerChanged(node, sel); };
            _this.fMyThemesLayerChanged = function (node, sel) { return _this.myThemesLayerChanged(node, sel); };
            _this.fMyThemesDeleteLayer = function (node) { return _this.myThemesDeleteLayer(node); };
            MapControl_1.MapDispatcher.onLayerRequest.subscribe(function (sender, ev) { return _this.onLayerRequested(sender, ev); });
            MapControl_1.MapDispatcher.onLayerReady.subscribe(function (sender, ev) { return _this.onLayerReady(sender, ev); });
            MapControl_1.MapDispatcher.onLayerError.subscribe(function (sender, ev) { return _this.onLayerError(sender, ev); });
            return _this;
        }
        LayerControlVar.prototype.changeLayerOrder = function (ev) {
            console.info("jkdsfhshfk");
            if (ev.up) {
                this.tree2.moveNodeUp(ev.node);
                ev.node.data.layer.bringToBack();
            }
            else {
                this.tree2.moveNodeDown(ev.node);
                ev.node.data.layer.bringToFront();
            }
            // const lwArray:LayerWrapper[] = [];
            // const nodes = this.tree2.nodes;
            // for (let i=0; i<nodes.length; i++) {
            //     (<any>nodes[i].data.layer).setZIndex(i+1);
            // };
            // MapDispatcher.onLayerOrderChanged.dispatch(this, {type:'order-changed', layers:lwArray})
            console.info("changeLayerOrder", ev);
        };
        LayerControlVar.prototype._layerAdded = function (evt) {
            this.tree.selectNode(evt.layer);
        };
        LayerControlVar.prototype._layerRemoved = function (evt) {
            this.tree.unselectNode(evt.layer);
        };
        LayerControlVar.prototype.nodeChanged = function (group, node, sel) {
            console.info("nodeChanged ".concat(group, " ").concat(node.data.name, ", ").concat(TreeNode_1.SelectionStatus[sel]));
        };
        LayerControlVar.prototype._baseLayerChanged = function (layer) {
            MapControl_1.MapDispatcher.onBaseLayerSelection.dispatch(this, layer);
        };
        LayerControlVar.prototype.themeLayerChanged = function (node, sel) {
            console.info("LayerControlVar.themeLayerChanged ".concat(TreeNode_1.SelectionStatus[sel]), node);
            var isSelected = sel === TreeNode_1.SelectionStatus.SELECTED;
            var layer = node.data;
            var tree2node = this.mapLayerId2MyLayerNodes[layer.id];
            if (tree2node) {
                tree2node.setSelected(isSelected);
                // rtr TODO
                // } else {
                //     tree2node = new Tree2Node(layer, null, { fChangeNodeOrder: this.fChangeLayerOrder });
                //     tree2node.onSelectionChange.subscribe(this.fMyThemesLayerChanged);
                //     tree2node.onTreeDeleteIconClick.subscribe(this.fMyThemesDeleteLayer);
                //     this.tree2.addNode(tree2node);
                //     this.mapLayerId2MyLayerNodes[layer.id] = tree2node;
                //     tree2node.setSelected(isSelected);
                //     this.accordion.items[1].setCollapsed(false);
            }
            layer.setSelected(isSelected);
        };
        LayerControlVar.prototype.myThemesLayerChanged = function (node, sel) {
            var isSelected = sel === TreeNode_1.SelectionStatus.SELECTED;
            var layer = node.data;
            layer.setSelected(isSelected);
        };
        LayerControlVar.prototype.clearThemes = function () {
            for (var k in this.mapLayerId2MyLayerNodes) {
                var tree2node = this.mapLayerId2MyLayerNodes[k];
                this.myThemesDeleteLayer(tree2node);
            }
            this.tree.nodes.forEach(function (item) { return item.collapse(); });
        };
        LayerControlVar.prototype.myThemesDeleteLayer = function (node) {
            var layer = node.data;
            var tree2node = this.mapLayerId2MyLayerNodes[layer.id];
            console.info("myThemesDeleteLayer ".concat(tree2node === node));
            if (tree2node) {
                tree2node.setSelected(false);
                this.tree2.removeNode(tree2node);
                delete this.mapLayerId2MyLayerNodes[layer.id];
            }
        };
        LayerControlVar.prototype.baseLayerChanged = function (node, sel) {
            var _this = this;
            // console.info(`baseLayerChanged ${SelectionStatus[sel]}`, node);
            if (!node.data.layer) {
                this.baseLayerDefOptions.createLayer(node.data).then(function (layer) {
                    node.data.layer = layer;
                    _this._baseLayerChanged(layer);
                });
            }
            else {
                this._baseLayerChanged(node.data.layer);
            }
        };
        LayerControlVar.prototype.selectThemeLayer = function (layerDescr) {
            // console.info("selectThemeLayer");
            this.tree.selectNode(layerDescr);
        };
        LayerControlVar.prototype.addThemes = function (themes) {
            var _this = this;
            this.themes = themes;
            MapControl_1.MapDispatcher.onLayerAdded.subscribe(function (sender, evt) { return _this._layerAdded(evt); });
            MapControl_1.MapDispatcher.onLayerRemoved.subscribe(function (sender, evt) { return _this._layerRemoved(evt); });
            if (this.tree) {
                this._addThemesToTree();
            }
        };
        LayerControlVar.prototype._createTree2 = function () {
            this.tree2 = new Tree_1.Tree(null, { selectMode: TreeNode_1.SelectionMode.MULTI, expandOnlyOneNode: true });
        };
        LayerControlVar.prototype._createTree = function () {
            console.info("LayerControlVar._createTree");
            this.tree = new Tree_1.Tree(null, { selectMode: TreeNode_1.SelectionMode.MULTI, expandOnlyOneNode: true });
            // for (const title in this.overlays) {
            //     this._addOverlayToTree(title, this.overlays[title]);
            // }
            // for (const title in this.categorieLayers) {
            //     this._addCategorieLayerToTree(title, this.categorieLayers[title]);
            // }
        };
        LayerControlVar.prototype._createThemNode = function (theme) {
            var _this = this;
            var themeNode = new ThemeTreeNode(theme, null, { nodeRenderer: themeNodeRender });
            if (theme.themes) {
                theme.themes.forEach(function (theme) {
                    var themeNode2 = _this._createThemNode(theme);
                    themeNode.addNode(themeNode2);
                });
            }
            if (theme.layers) {
                theme.layers.forEach(function (layer) {
                    var layerNode = new LayerNode(layer);
                    _this.mapLayerId2OverlayNodes[layer.id] = layerNode;
                    layerNode.onSelectionChange.subscribe(_this.fThemeLayerChanged);
                    themeNode.addNode(layerNode);
                });
            }
            return themeNode;
        };
        LayerControlVar.prototype._addThemesToTree = function () {
            var _this = this;
            console.info("_addThemesToTree ".concat(this.tree));
            if (this.tree) {
                var themeNodes_1 = [];
                if (this.themes) {
                    this.themes.forEach(function (theme) {
                        var themeNode = _this._createThemNode(theme);
                        if (themeNode.childs && themeNode.childs.length > 0) {
                            themeNodes_1.push(themeNode);
                            // this.tree.addNode(themeNode);
                        }
                    });
                    this.tree.addNodes(themeNodes_1);
                }
            }
        };
        LayerControlVar.prototype._addCategorieLayerToTree = function (title, categorieLayer) {
            var _this = this;
            console.info("_addCategorieLayerToTree ".concat(this.tree));
            if (this.tree) {
                var categories = categorieLayer.getCategories();
                var treeNode_1 = new TreeNode_1.TreeNode(title);
                this.tree.addNode(treeNode_1);
                this.addCategories(treeNode_1, categories);
                this.categorieLayerNodes[title] = treeNode_1;
                treeNode_1.onSelectionChange.subscribe(function (node, status) { return _this._categorieSelected(title, treeNode_1, status); });
            }
        };
        LayerControlVar.prototype._addOverlayToTree = function (title, overlays) {
            // console.warn(`_addCategorieLayerToTree ${this.tree}`);
            if (this.tree) {
                var treeNode = new TreeNode_1.TreeNode(title, undefined, { selectMode: TreeNode_1.SelectionMode.MULTI });
                this.tree.addNode(treeNode);
                overlays.forEach(function (baseLayerDef) {
                    var treeNode = new TreeNode_1.TreeNode(baseLayerDef, null, { selectMode: TreeNode_1.SelectionMode.MULTI });
                    treeNode.addNode(treeNode);
                });
                // treeNode.onSelectionChange.subscribe((node, status) => this._themeSelected(title, treeNode, status));
            }
        };
        LayerControlVar.prototype.addTo = function (map) {
            // console.error('LayerControl.addTo');
            if (this.parentNode) {
                this.remove();
                this._map = map;
                var container = (this._container = this.onAdd(map));
                container.classList.add("layerctrl-dom");
                this.parentNode.appendChild(container);
                this._map.on("unload", this.remove, this);
                return this;
            }
            else {
                return _super.prototype.addTo.call(this, map);
            }
        };
        LayerControlVar.prototype.onAdd = function (map) {
            console.info("LayerControl.onAdd");
            this._map = map;
            var dom = this._dom;
            if (!dom) {
                var domTree = this.tree._render();
                if (this.className) {
                    domTree.classList.add(this.className);
                }
                var item1 = new Accordion_1.AccordionItem("Themen", domTree);
                var domTree2 = this.tree2._render();
                if (this.className) {
                    domTree2.classList.add(this.className);
                }
                var accordion = (this.accordion = new Accordion_1.Accordion([new Accordion_1.AccordionItem("Kartenauswahl", domTree), new Accordion_1.AccordionItem("Meine Kartenauswahl", domTree2)]));
                dom = accordion.render();
                // dom.appendChild(domTree);
            }
            // TODO disableEvtPropagation(dom);
            return dom;
        };
        LayerControlVar.prototype.onRemove = function (map) {
            // console.error("LayerControl.onRemove");
        };
        LayerControlVar.prototype.findCategorie = function (title, item) {
            console.info("findCategorie", item);
            var node = this.categorieLayerNodes[title];
            if (node) {
                return node.findNode(item.id, "id");
            }
        };
        LayerControlVar.prototype.findItemsOfCategorie = function (title, item) {
            console.info("findItemsOfCategorie", item);
            var node = this.categorieLayerNodes[title];
            if (node) {
                var nodes = node.findNode(item.id, "id");
                if (nodes) {
                    var path = [];
                    for (var i = nodes.length - 2; i >= 0; i--) {
                        path.push(nodes[i].data.id);
                    }
                    console.info("path", path);
                    var layer = this.categorieLayers[title];
                    if (layer) {
                        return layer.getItems(path);
                    }
                }
            }
        };
        LayerControlVar.prototype.showCategorie = function (title, item) {
            console.info("showCategorie", item);
            var node = this.categorieLayerNodes[title];
            if (node) {
                node.selectNode(item.id, "id");
            }
        };
        LayerControlVar.prototype.showMarker = function (title, id, prop) {
            console.info("showmarker(".concat(title, ", ").concat(id, ", ").concat(prop, ")"));
            var layer = this.categorieLayers[title];
            if (layer) {
                var marker = layer.showMarker(id, prop);
            }
        };
        LayerControlVar.prototype.getItems = function (title, path) {
            console.info("getItems(".concat(title, ", ").concat(path, ")"));
            var layer = this.categorieLayers[title];
            return layer.getItems(path);
        };
        LayerControlVar.prototype.addCategorieLayer = function (title, categorieLayer, showAll) {
            this.categorieLayers[title] = categorieLayer;
            console.info("addCategorieLayer");
            if (this.tree) {
                this._addCategorieLayerToTree(title, categorieLayer);
                if (showAll) {
                    this.tree.selectNode(title);
                }
            }
        };
        LayerControlVar.prototype._categorieSelected = function (layerTitle, node, status) {
            console.info("_categorieSelected", node, status);
            var selectedCats = this._findSelected(node.childs);
            var categoryLayer = this.categorieLayers[layerTitle];
            if (categoryLayer) {
                categoryLayer.setKategories(selectedCats);
            }
        };
        // private _themeSelected(theme: string, node: TreeNode, status: SelectionStatus): void {
        //     console.error("_themeSelected", theme, node, status);
        // }
        LayerControlVar.prototype._findSelected = function (nodes) {
            var ids = [];
            for (var i = 0; i < nodes.length; i++) {
                if (nodes[i].getSelectionsStatus() === TreeNode_1.SelectionStatus.SELECTED) {
                    ids.push([nodes[i].data.id]);
                }
                else {
                    if (nodes[i].getSelectionsStatus() === TreeNode_1.SelectionStatus.INDETERMINATE) {
                        var chIds = this._findSelected(nodes[i].childs);
                        for (var j = 0; j < chIds.length; j++) {
                            ids.push(__spreadArray([nodes[i].data.id], chIds[j], true));
                        }
                    }
                }
            }
            return ids;
        };
        LayerControlVar.prototype.addCategories = function (base, categories) {
            for (var i = 0; i < categories.length; i++) {
                var treeNode = new TreeNode_1.TreeNode(categories[i], null, LayerControl_1.LayerControl.catNodeParam);
                if (categories[i].childs) {
                    this.addCategories(treeNode, categories[i].childs);
                }
                base.addNode(treeNode);
            }
        };
        LayerControlVar.prototype.onLayerReady = function (sender, ev) {
            var _a, _b;
            console.info("onLayerReady", sender, ev);
            (_a = this.mapLayerId2OverlayNodes[ev.layer.id]) === null || _a === void 0 ? void 0 : _a.setStatus("ok");
            if (this.mapLayerId2MyLayerNodes[ev.layer.id]) {
                (_b = this.mapLayerId2MyLayerNodes[ev.layer.id]) === null || _b === void 0 ? void 0 : _b.setStatus("ok");
            }
            else {
                var tree2node = new Tree2Node(ev.layer, null, { fChangeNodeOrder: this.fChangeLayerOrder });
                tree2node.onSelectionChange.subscribe(this.fMyThemesLayerChanged);
                tree2node.onTreeDeleteIconClick.subscribe(this.fMyThemesDeleteLayer);
                this.tree2.addNode(tree2node);
                this.mapLayerId2MyLayerNodes[ev.layer.id] = tree2node;
                tree2node.setSelected(true);
                tree2node.setStatus("ok");
                this.accordion.items[1].setCollapsed(false);
            }
        };
        LayerControlVar.prototype.onLayerRequested = function (sender, ev) {
            var _a, _b;
            console.info("onLayerRequested", sender, ev);
            (_a = this.mapLayerId2OverlayNodes[ev.layer.id]) === null || _a === void 0 ? void 0 : _a.setStatus("waiting");
            (_b = this.mapLayerId2MyLayerNodes[ev.layer.id]) === null || _b === void 0 ? void 0 : _b.setStatus("waiting");
        };
        LayerControlVar.prototype.onLayerError = function (sender, ev) {
            var _a, _b, _c, _d;
            console.info("onLayerRequested", sender, ev);
            (_a = this.mapLayerId2OverlayNodes[ev.layer.id]) === null || _a === void 0 ? void 0 : _a.setStatus("error");
            (_b = this.mapLayerId2MyLayerNodes[ev.layer.id]) === null || _b === void 0 ? void 0 : _b.setStatus("error");
            (_c = this.mapLayerId2OverlayNodes[ev.layer.id]) === null || _c === void 0 ? void 0 : _c.setSelected(false);
            (_d = this.mapLayerId2MyLayerNodes[ev.layer.id]) === null || _d === void 0 ? void 0 : _d.setSelected(false);
        };
        LayerControlVar.catNodeParam = {
            attName2Render: "bezeichnung",
            selectMode: TreeNode_1.SelectionMode.MULTI
        };
        return LayerControlVar;
    }(L.Control));
    exports.LayerControlVar = LayerControlVar;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./src/ts/controls/LegendControl.ts":
/*!******************************************!*\
  !*** ./src/ts/controls/LegendControl.ts ***!
  \******************************************/
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(/*! leaflet */ "./node_modules/leaflet/dist/leaflet-src.js"), __webpack_require__(/*! ../svg/svg */ "./src/ts/svg/svg.ts"), __webpack_require__(/*! ../conf/MapDescription */ "./src/ts/conf/MapDescription.ts"), __webpack_require__(/*! ../Util */ "./src/ts/Util.ts"), __webpack_require__(/*! ./MapControl */ "./src/ts/controls/MapControl.ts")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports, L, svg, MapDescription_1, Util_1, MapControl_1) {
    "use strict";
    exports.__esModule = true;
    exports.createLegendOfPoint = exports.appendLegendLayerEntry = exports.LegendControl = void 0;
    var LegendControl = /** @class */ (function (_super) {
        __extends(LegendControl, _super);
        function LegendControl(options) {
            var _this = _super.call(this, options) || this;
            _this.layers = [];
            var f = function (sender, layerSelectEvt) { return _this._onLayerChanged(sender, layerSelectEvt); };
            MapControl_1.MapDispatcher.onLayerAdded.subscribe(f);
            MapControl_1.MapDispatcher.onLayerRemoved.subscribe(f);
            return _this;
        }
        LegendControl.prototype._onLayerChanged = function (sender, evt) {
            console.info("onLayerAdded", evt);
            if (evt.layer.isSelected) {
                this.layers.push(evt.layer);
            }
            else {
                var idx = this.layers.indexOf(evt.layer);
                if (idx >= 0) {
                    this.layers.splice(idx, 1);
                }
            }
            this._updateLegend();
        };
        LegendControl.prototype.onAdd = function (map) {
            var _this = this;
            this._map = map;
            if (!this.dom) {
                var div = (0, Util_1.createHtmlElement)("div", undefined, "legendctrl ctrl-icon");
                // const icon = createHtmlElement('div', div, "legendctrl-icon");
                var span = (0, Util_1.createHtmlElement)("span", div);
                div.title = "Legende";
                span.innerText = "Legende";
                div.addEventListener("click", function (ev) {
                    ev.cancelBubble = true;
                    ev.stopPropagation();
                    _this.toggleLegend();
                    return true;
                });
                this.dom = div;
                this.fctHideLegend = function (ev) {
                    _this.toggleLegend();
                };
            }
            return this.dom;
        };
        LegendControl.prototype.toggleLegend = function () {
            if (!this.domLegend) {
                this.showLegend();
            }
            else {
                this.domLegend.classList.toggle("closed");
            }
        };
        LegendControl.prototype._createLegendContent = function () {
            var _a;
            console.info("_createLegendContent");
            var div = document.createElement("div");
            div.className = "legendctrl-legend-content";
            var table = (0, Util_1.createHtmlElement)("div", div, "legend-layer-entry");
            if (((_a = this.layers) === null || _a === void 0 ? void 0 : _a.length) > 0) {
                this.layers.forEach(function (layer, idx) {
                    console.info("layer ".concat(idx), layer);
                    appendLegendLayerEntry(layer.layerDescription, table);
                });
            }
            else {
                (0, Util_1.createHtmlElement)("p", div, undefined, {
                    innerHTML: "Es wurden keine Themen gewhlt."
                });
            }
            return div;
        };
        LegendControl.prototype._createLegendDom = function () {
            var _this = this;
            var dom = (0, Util_1.createHtmlElement)("div", undefined, "legendctrl-legend");
            var headArea = (this.navigationArea = (0, Util_1.createHtmlElement)("div", dom, "legendctrl-legend-head"));
            var headSpan = (0, Util_1.createHtmlElement)("span", headArea);
            headSpan.innerText = "Legende";
            var anchorBack = (0, Util_1.createHtmlElement)("a", headArea, "close");
            anchorBack.addEventListener("click", function (ev) { return _this._closeBttnClicked(); });
            var table = (this.innerLegend = this._createLegendContent());
            dom.appendChild(table);
            dom.appendChild((0, Util_1.createCloseButton)(this.fctHideLegend));
            return dom;
        };
        LegendControl.prototype._updateLegend = function () {
            if (this.innerLegend) {
                var table = this._createLegendContent();
                this.innerLegend.replaceWith(table);
                this.innerLegend = table;
            }
        };
        LegendControl.prototype.showLegend = function () {
            console.info("showLegend", this.layers);
            var dom = (this.domLegend = this._createLegendDom());
            dom.classList.remove("closed");
            L.DomEvent.disableClickPropagation(dom);
            L.DomEvent.disableScrollPropagation(dom);
            this._map.getContainer().appendChild(dom);
        };
        LegendControl.prototype._closeBttnClicked = function () {
            console.info("closeLegend");
            if (this.domLegend && this._map) {
                // this._map.getContainer().removeChild(this.domLegend);
                // this.domLegend = undefined;
                this.domLegend.classList.add("closed");
            }
        };
        LegendControl.prototype.onRemove = function (map) {
            this._map = null;
        };
        return LegendControl;
    }(L.Control));
    exports.LegendControl = LegendControl;
    function appendLegendLayerEntry(lDescr, div) {
        var _a;
        console.info("appendLegendLayerEntry", lDescr);
        (0, Util_1.createHtmlElement)("h1", div, undefined, {
            innerHTML: lDescr.label
        });
        try {
            if (lDescr.type === "GeoJSON") {
                if (lDescr.classes) {
                    lDescr.classes.forEach(function (layerClass) {
                        var row = (0, Util_1.createHtmlElement)("div", div, "subelement");
                        var spanClassIcon = (0, Util_1.createHtmlElement)("span", row, "icon");
                        // console.info('layer', layer, layer.geomType);
                        // const legendItem = createLegendCircle(layerClass.style);
                        var legendItem = undefined;
                        if (lDescr.geomType === "Point") {
                            // legendItem = createLegendCircle(layerClass.style);
                            legendItem = createLegendOfPoint(layerClass);
                        }
                        else if (lDescr.geomType === "Polygon") {
                            legendItem = createLegendPolygon(layerClass.style);
                        }
                        else if (lDescr.geomType === "Linestring") {
                            legendItem = createLegendLinestring(layerClass.style);
                        }
                        if (legendItem) {
                            spanClassIcon.appendChild(legendItem);
                        }
                        var spanClassName = (0, Util_1.createHtmlElement)("span", row);
                        spanClassName.innerHTML = layerClass.name;
                    });
                }
                else {
                    var legendItem = void 0;
                    if (lDescr.geomType === "Point") {
                        if ((_a = lDescr.style) === null || _a === void 0 ? void 0 : _a.piechart) {
                            createLegendPiechart(div, lDescr);
                        }
                        else {
                            legendItem = createLegendOfPoint(lDescr);
                        }
                    }
                    else if (lDescr.geomType === "Polygon") {
                        legendItem = createLegendPolygon(lDescr.style);
                    }
                    else if (lDescr.geomType === "Linestring") {
                        legendItem = createLegendLinestring(lDescr.style);
                    }
                    if (legendItem) {
                        var row = (0, Util_1.createHtmlElement)("div", div, "subelement");
                        var spanClassIcon = (0, Util_1.createHtmlElement)("span", row, "icon");
                        spanClassIcon.appendChild(legendItem);
                        // const symbol = createHtmlElement('div', div);
                        // symbol.appendChild(legendItem);
                    }
                }
            }
            else if (lDescr.type === "WMS") {
                var row_1 = (0, Util_1.createHtmlElement)("div", div, "subelement");
                var legendUrl = createLegendUrl(lDescr);
                var img_1 = document.createElement("img");
                img_1.addEventListener("error", function (evt) {
                    var msg = document.createElement("span");
                    msg.innerHTML = "Der Dienst stellt keine Legende zur Verfgung.";
                    img_1.parentElement.removeChild(img_1);
                    row_1.appendChild(msg);
                });
                img_1.src = legendUrl;
                row_1.appendChild(img_1);
            }
        }
        catch (ex) {
            console.error(ex);
            var row = (0, Util_1.createHtmlElement)("div", div, "subelement");
            var msg = (0, Util_1.createHtmlElement)("span", row);
            msg.innerHTML = "Fehler beim Erzeugen der Legende.";
        }
    }
    exports.appendLegendLayerEntry = appendLegendLayerEntry;
    /*
    function appendLegendEntryTable(layer:LayerDescription, table:HTMLTableElement) {
        const row = createHtmlElement("tr", table);
        const td01 = createHtmlElement('td', row);
        td01.innerHTML = layer.label;
        const td02 = createHtmlElement('td', row);
        if (layer.type === 'GeoJSON') {
            if (layer.classes) {
                layer.classes.forEach(layerClass=>{
                    const row = createHtmlElement("tr", table, 'subelement');
                    const td01 = createHtmlElement('td', row);
                    td01.innerHTML = layerClass.name;
                    const td02 = createHtmlElement('td', row);
                    console.info('layer', layer, layer.geomType);
                    // const legendItem = createLegendCircle(layerClass.style);
                    let legendItem = undefined;
                    if (layer.geomType === 'Point') {
                        legendItem = createLegendCircle(layerClass.style);
                    } else if (layer.geomType === 'Polygon') {
                        legendItem = createLegendPolygon(layerClass.style);
                    }
                    if (legendItem) {
                        td02.appendChild(legendItem);
                    }
                });
            }
            else {
                const legendItem = createLegendItem(layer);
                if (legendItem) {
                    td02.appendChild(legendItem);
                }
            }
        } else if (layer.type === 'WMS') {
            const row = createHtmlElement("tr", table, 'subelement');
            const td = createHtmlElement("td", row);
            td.colSpan = 2;
            const legendUrl = createLegendUrl(layer);
            const img = document.createElement('img');
            img.addEventListener('error', evt=>{
                const msg = document.createElement('span');
                msg.innerHTML = 'Der Dienst stellt keine Legende zur Verfgung.';
                img.parentElement.removeChild(img);
                td.appendChild(msg);
            });
            img.src = legendUrl;
            td.appendChild(img);
        }
    }
    */
    // export function createLegendItem(Descr:LayerDescription):Element|undefined {
    //     if (Descr.type ===  'GeoJSON') {
    //         if (Descr.geomType === 'Point') {
    //             return createLegendOfPoint(Descr);
    //         } else if (Descr.geomType === 'Polygon') {
    //             return createLegendOfPolygon(Descr);
    //         } else if (Descr.geomType === 'Linestring') {
    //             return createLegendOfLinestring(Descr);
    //         }
    //     } else if (Descr.type === 'WMS') {
    //         return createWMSLegendItem(Descr);
    //     }
    //     return undefined;
    // }
    function createLegendOfPoint(layer) {
        // if (layer.classes) {
        //     return createLegendClasses(layer);
        // }
        console.info("createLegendOfPoint", layer);
        if (layer.icon && layer.icon.iconUrl) {
            var img = document.createElement("img");
            img.src = layer.icon.iconUrl;
            img.width = layer.icon.iconSize[0];
            img.height = layer.icon.iconSize[1];
            return img;
        }
        var style = layer.style ? layer.style : layer;
        return createLegendCircle(style);
    }
    exports.createLegendOfPoint = createLegendOfPoint;
    // function createLegendClasses(layerDescr:LayerDescription) {
    //     const src = "data:image/svg+xml;base64,PHN2ZyBoZWlnaHQ9JzMwMHB4JyB3aWR0aD0nMzAwcHgnICBmaWxsPSIjMDAwMDAwIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB2ZXJzaW9uPSIxLjEiIHg9IjBweCIgeT0iMHB4IiB2aWV3Qm94PSIwIDAgMTAwIDEwMCIgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAwIDAgMTAwIDEwMCIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+PGc+PHBhdGggZD0iTTM1LjcsMjcuMmg1OC41YzEsMCwxLjgtMC44LDEuOC0xLjhzLTAuOC0xLjgtMS44LTEuOEgzNS43Yy0xLDAtMS44LDAuOC0xLjgsMS44UzM0LjcsMjcuMiwzNS43LDI3LjJ6Ij48L3BhdGg+PHBhdGggZD0iTTk0LjEsNDcuM0gzNS43Yy0xLDAtMS44LDAuOC0xLjgsMS44czAuOCwxLjgsMS44LDEuOGg1OC41YzEsMCwxLjgtMC44LDEuOC0xLjhTOTUuMSw0Ny4zLDk0LjEsNDcuM3oiPjwvcGF0aD48cGF0aCBkPSJNOTQuMSw3MC45SDM1LjdjLTEsMC0xLjgsMC44LTEuOCwxLjhzMC44LDEuOCwxLjgsMS44aDU4LjVjMSwwLDEuOC0wLjgsMS44LTEuOFM5NS4xLDcwLjksOTQuMSw3MC45eiI+PC9wYXRoPjxwYXRoIGQ9Ik0yMi43LDM5LjdINy41Yy0xLDAtMS44LDAuOC0xLjgsMS44djE1LjJjMCwxLDAuOCwxLjgsMS44LDEuOGgxNS4yYzEsMCwxLjgtMC44LDEuOC0xLjhWNDEuNSAgIEMyNC40LDQwLjUsMjMuNiwzOS43LDIyLjcsMzkuN3oiPjwvcGF0aD48cGF0aCBkPSJNNy4xLDM0aDE1LjZjMC42LDAsMS4yLTAuMywxLjUtMC45czAuMy0xLjIsMC0xLjhsLTcuOC0xMy41Yy0wLjMtMC41LTAuOS0wLjktMS41LTAuOXMtMS4yLDAuMy0xLjUsMC45TDUuNiwzMS40ICAgYy0wLjMsMC41LTAuMywxLjIsMCwxLjhTNi41LDM0LDcuMSwzNHoiPjwvcGF0aD48cGF0aCBkPSJNMTUuNCw2Mi42Yy01LjUsMC0xMCw0LjUtMTAsMTBzNC41LDEwLDEwLDEwczEwLTQuNSwxMC0xMFMyMC45LDYyLjYsMTUuNCw2Mi42eiI+PC9wYXRoPjwvZz48L3N2Zz4=";
    //     const img = document.createElement("img");
    //     img.src = src;
    //     img.addEventListener('click', evt=>{
    //         showLegendOfClasses(evt, layerDescr);
    //     });
    //     return img;
    // }
    function createWMSLegendItem(layer) {
        var legendItem = undefined;
        var symbol = (0, MapDescription_1.getMapDescription)().default_wms_legend_icon;
        var legendUrl = createLegendUrl(layer);
        // if (!legendUrl) {
        //     createLegendUrl(layer);
        // }
        if (symbol && legendUrl) {
            // const item = document.createElement('div');
            // const img = createHtmlElement('img', item);
            var img = document.createElement("img");
            img.src = symbol;
            img.addEventListener("click", function (evt) {
                showLegendUrl(evt, legendUrl);
            });
            img.style.position = "relative";
            img.style.width = "20px";
            img.title = "Legende anzeigen.";
            // addTooltip(item, "Legende anzeigen");
            legendItem = img;
        }
        return legendItem;
    }
    function createLegendUrl(layer) {
        var url = undefined;
        if (layer.url_legend) {
            return layer.url_legend;
        }
        if (layer.url) {
            if (layer.url.endsWith("&")) {
                url = layer.url + "SERVICE=WMS&VERSION=1.3.0&REQUEST=GetLegendGraphic&LAYER=" + layer.options["layers"] + "&FORMAT=image/png&SLD_VERSION=1.1.0";
                return url;
            }
            if (layer.url.indexOf("?") > 0) {
                url = layer.url + "&SERVICE=WMS&VERSION=1.3.0&REQUEST=GetLegendGraphic&LAYER=" + layer.options["layers"] + "&FORMAT=image/png&SLD_VERSION=1.1.0";
                return url;
            }
            url = layer.url + "?SERVICE=WMS&VERSION=1.3.0&REQUEST=GetLegendGraphic&LAYER=" + layer.options["layers"] + "&FORMAT=image/png&SLD_VERSION=1.1.0";
            return url;
        }
    }
    // function showLegendOfClasses(evt:MouseEvent, layerDescr:LayerDescription) {
    //     const content = document.createElement('table');
    //     appendLegendLayerEntry(layerDescr, content);
    //     showContent(evt, content);
    // }
    function showLegendUrl(evt, url) {
        var content = document.createElement("div");
        var img = document.createElement("img");
        img.addEventListener("error", function (evt) {
            var msg = document.createElement("span");
            msg.innerHTML = "Der Dienst stellt keine Legende zur Verfgung.";
            img.parentElement.removeChild(img);
            content.appendChild(msg);
        });
        img.src = url;
        content.appendChild(img);
        showContent(evt, content);
    }
    function createSvgStyle(style) {
        console.info("createStyle", style, style.stroke);
        var st = {};
        if (style.stroke) {
            st.stroke = style.color;
            st.strokeOpacity = (style.opacity || 1).toString();
            st.strokeWidth = (style.weight || 3).toString();
            st.strokeLinecap = style.lineCap || "";
            st.strokeLinejoin = style.lineJoin || "";
            st.strokeDasharray = style.dashArray || "";
            st.strokeDashoffset = style.dashOffset || "";
        }
        else {
            st.stroke = "none";
        }
        if (style.fill) {
            st.fill = style.fillColor || style.color;
            if (style.fillOpacity) {
                st.opacity = style.fillOpacity.toString();
            }
            st.fillRule = style.fillRule || "evenodd";
        }
        else {
            st.fill = "none";
        }
        return st;
    }
    // function createLegendOfLinestring(layer:LayerDescription):Element {
    //     console.info('createLegendOfLinestring');
    //     // if (layer.classes) {
    //     //     return createLegendClasses(layer);
    //     // }
    //     const style = {...StandardPathOptions, ...layer.style};
    //     const svgEl = new svg.SVG({x:0, y:0, width:20, height:20});
    //     const st = createSvgStyle(style);
    //     svgEl.addLine(0, 10, 20, 10, st);
    //     return svgEl.svg;
    // }
    function createLegendLinestring(style) {
        console.info("createLegendLinestring", style);
        var svgEl = new svg.SVG({ x: 0, y: 0, width: 20, height: 20 });
        var st = createSvgStyle(__assign(__assign({}, MapDescription_1.StandardPathOptions), style));
        svgEl.addLine(0, 10, 20, 10, st);
        return svgEl.svg;
    }
    // function createLegendOfPolygon(layer:LayerDescription):Element {
    //     // if (layer.classes) {
    //     //     return createLegendClasses(layer);
    //     // }
    //     const style = layer.style;
    //     const svgEl = new svg.SVG({x:0, y:0, width:20, height:20});
    //     const st = {
    //         stroke: style && style.color ? style.color : "#3388ff",
    //         strokeOpacity: "1",
    //         strokeWidth: style && style.weight ? style.weight : "3",
    //         strokeLinecap: "round",
    //         strokeLinejoin: "round",
    //         fill: style && style.color ? style.color : "#3388ff",
    //         fillOpacity: "0.2",
    //         fillRule: "evenodd"
    //     }
    //     svgEl.addPolygGon("1,1 19,1 19,19 1,19", st);
    //     svgEl.svg.style.width = '2rem';
    //     return svgEl.svg;
    // }
    function createLegendPolygon(style) {
        console.info("createLegendPolygon", style);
        var svgEl = new svg.SVG({ x: 0, y: 0, width: 20, height: 20 });
        var st = {
            stroke: style && style.color ? style.color : "#3388ff",
            strokeOpacity: "1",
            strokeWidth: style && style.weight ? style.weight : "3",
            strokeLinecap: "round",
            strokeLinejoin: "round",
            // fill: style && style.fillColor ? style.fillColor : "#3388ff",
            fill: style === null || style === void 0 ? void 0 : style.fillColor,
            fillOpacity: style && style.fillOpacity ? style.fillOpacity : "0.2",
            fillRule: "evenodd"
        };
        svgEl.addPolygGon("1,1 19,1 19,19 1,19", st);
        return svgEl.svg;
    }
    function createLegendPiechart(div, lDescr) {
        var _a, _b;
        /*
        "style": {
            "radius": 15,
            "fillOpacity": 0.6,
            "strokeOpacity": 0.2,
            "strokeWeight": 3,
            "piechart": {
              "casa_ev_qm_kl1": "rgb(162 203 255)",
              "casa_ev_qm_kl2": "rgb(182 247 255)",
              "casa_ev_qm_kl3": "rgb(168 255 188)",
              "casa_ev_qm_kl4": "rgb(240 255 175)",
              "casa_ev_qm_kl5": "rgb(255 215 165)",
              "casa_ev_qm_kl98": "rgb(255 194 186)",
              "casa_ev_qm_kl99": "rgb(255 154 230)"
            }
          },
          */
        for (var k in lDescr.style.piechart) {
            var row = (0, Util_1.createHtmlElement)("div", div, "subelement");
            var spanClassIcon = (0, Util_1.createHtmlElement)("span", row, "icon");
            var legendItem = createLegendPolygon({ fillColor: lDescr.style.piechart[k], color: "#000", weight: 1 });
            spanClassIcon.appendChild(legendItem);
            var spanClassName = (0, Util_1.createHtmlElement)("span", row);
            spanClassName.innerHTML = (_b = (_a = lDescr.layerAttributes) === null || _a === void 0 ? void 0 : _a[k]) !== null && _b !== void 0 ? _b : k;
        }
    }
    function createLegendCircle(style) {
        var svgEl = new svg.SVG({ x: 0, y: 0, width: 24, height: 24 });
        console.info("createLegendCircle", style);
        var st = createSvgStyle(__assign(__assign({}, MapDescription_1.StandardCircleMarkerOptions), style));
        svgEl.addCircle(12, 12, 10, st);
        return svgEl.svg;
    }
    function showContent(evt, content) {
        var dom = (0, Util_1.createHtmlElement)("div", undefined, "legendctrl-legend");
        var headArea = (0, Util_1.createHtmlElement)("div", dom, "legendctrl-legend-head");
        var headSpan = (0, Util_1.createHtmlElement)("span", headArea);
        headSpan.innerText = "Legende";
        var anchorBack = (0, Util_1.createHtmlElement)("a", headArea, "close");
        anchorBack.addEventListener("click", function (ev) {
            if (dom.parentElement) {
                dom.parentElement.removeChild(dom);
            }
        });
        dom.appendChild(content);
        dom.style.position = "absolute";
        dom.style.left = evt.clientX + "px";
        dom.style.top = evt.clientY + "px";
        document.body.appendChild(dom);
    }
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./src/ts/controls/MapControl.ts":
/*!***************************************!*\
  !*** ./src/ts/controls/MapControl.ts ***!
  \***************************************/
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(/*! leaflet */ "./node_modules/leaflet/dist/leaflet-src.js"), __webpack_require__(/*! strongly-typed-events */ "./node_modules/strongly-typed-events/dist/index.js"), __webpack_require__(/*! ../util/Autocompleter */ "./src/ts/util/Autocompleter.ts"), __webpack_require__(/*! ../Util */ "./src/ts/Util.ts"), __webpack_require__(/*! ./LayerControl */ "./src/ts/controls/LayerControl.ts"), __webpack_require__(/*! ./ViewControl */ "./src/ts/controls/ViewControl.ts"), __webpack_require__(/*! ./MarkerListView */ "./src/ts/controls/MarkerListView.ts"), __webpack_require__(/*! ./BaselayerSelectorCtrl */ "./src/ts/controls/BaselayerSelectorCtrl.ts"), __webpack_require__(/*! ./LayerControlVar */ "./src/ts/controls/LayerControlVar.ts"), __webpack_require__(/*! ./SearchCtrl */ "./src/ts/controls/SearchCtrl.ts"), __webpack_require__(/*! ./IconAction */ "./src/ts/controls/IconAction.ts")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports, L, strongly_typed_events_1, Autocompleter_1, Util_1, LayerControl_1, ViewControl_1, MarkerListView_1, BaselayerSelectorCtrl_1, LayerControlVar_1, SearchCtrl_1, IconAction_1) {
    "use strict";
    exports.__esModule = true;
    exports.MapControl = exports.MapDispatcher = exports.LayerWrapper = exports.MenuControlOptions = void 0;
    var MenuControlOptions = /** @class */ (function () {
        function MenuControlOptions() {
        }
        return MenuControlOptions;
    }());
    exports.MenuControlOptions = MenuControlOptions;
    var LayerWrapper = /** @class */ (function () {
        function LayerWrapper(layerDescription) {
            this.isSelected = false;
            /**
             * order 1 ist unten ...
             */
            this.idx = -1;
            this.layerDescription = layerDescription;
            this.id = LayerWrapper.idCounter++;
        }
        LayerWrapper.prototype.setSelected = function (selected) {
            // console.error(`LayerWrapper.setSelected(${selected})`)
            if (this.isSelected !== selected) {
                this.isSelected = selected;
                exports.MapDispatcher.onThemeLayerSelection.dispatch(this, {
                    type: "select",
                    layer: this
                });
            }
        };
        LayerWrapper.idCounter = 0;
        return LayerWrapper;
    }());
    exports.LayerWrapper = LayerWrapper;
    var Dispatcher = /** @class */ (function () {
        function Dispatcher() {
            // map: L.Map;
            this.onListViewItemSelection = new strongly_typed_events_1.EventDispatcher();
            this.onViewRemove = new strongly_typed_events_1.EventDispatcher();
            this.onMapFeatureClick = new strongly_typed_events_1.EventDispatcher();
            this.onBaseLayerSelection = new strongly_typed_events_1.EventDispatcher();
            this.onThemeLayerSelection = new strongly_typed_events_1.EventDispatcher();
            this.onLayerCreationStart = new strongly_typed_events_1.EventDispatcher();
            this.onLayerCreationEnd = new strongly_typed_events_1.EventDispatcher();
            this.onLayerAdded = new strongly_typed_events_1.EventDispatcher();
            this.onLayerRemoved = new strongly_typed_events_1.EventDispatcher();
            this.onLayerOrderChanged = new strongly_typed_events_1.EventDispatcher();
            this.onLayerRequest = new strongly_typed_events_1.EventDispatcher();
            this.onLayerReady = new strongly_typed_events_1.EventDispatcher();
            this.onLayerError = new strongly_typed_events_1.EventDispatcher();
            this.onShowLayerInfoRequest = new strongly_typed_events_1.EventDispatcher();
        }
        return Dispatcher;
    }());
    exports.MapDispatcher = new Dispatcher();
    var LayerInfoAttr = [
        { attrName: "contactPersonName", attrLabel: "Ansprechpartner:" },
        { attrName: "contactEMail", attrLabel: "E-Mail:" },
        { attrName: "contactPhon", attrLabel: "Tel:" },
        { attrName: "actuality", attrLabel: "Aktualitt:" },
        { attrName: "actualityCircle", attrLabel: "Aktualisierungszyklus:" },
    ];
    var MapControl = /** @class */ (function (_super) {
        __extends(MapControl, _super);
        function MapControl(options) {
            var _this = _super.call(this, options) || this;
            _this.closed = true;
            _this.categorieLayers = {};
            _this.layerOnMapList = [];
            if (options.parentNode) {
                _this.parentNode = options.parentNode;
                options.parentNode.classList.add("mapctrl_parent");
                _this.categorieLayerCtrl = new LayerControlVar_1.LayerControlVar({ parentNode: options.parentNode });
                _this.baseLayerCtrl = new BaselayerSelectorCtrl_1.BaseLayerSelectorCtrl({ position: "bottomright" });
                var container = (_this.mapCtrlContentContainer = document.createElement("div"));
                container.className = "mapctrl_content";
            }
            else {
                _this.categorieLayerCtrl = new LayerControl_1.LayerControl({ position: "topleft" });
                _this.baseLayerCtrl = new LayerControl_1.LayerControl({
                    position: "topleft",
                    className: "flex-no-shrink"
                });
            }
            _this.searchFct = options.searchFct;
            _this.resetMap = options.resetMap;
            _this._subscribe();
            return _this;
        }
        MapControl.prototype._subscribe = function () {
            var _this = this;
            exports.MapDispatcher.onMapFeatureClick.subscribe(function (sender, evt) { return _this.onMapFeatureClick(sender, evt); });
            exports.MapDispatcher.onBaseLayerSelection.subscribe(function (sender, layer) { return _this.onBaseLayerSelection(sender, layer); });
            exports.MapDispatcher.onThemeLayerSelection.subscribe(function (sender, layerSelectEvt) { return _this.onThemeLayerSelection(sender, layerSelectEvt); });
            exports.MapDispatcher.onLayerReady.subscribe(function (sender, evt) { return _this.onLayerReady(sender, evt); });
            exports.MapDispatcher.onViewRemove.subscribe(function (sender, evt) { return _this.onViewRemove(sender, evt); });
            exports.MapDispatcher.onShowLayerInfoRequest.subscribe(function (sender, layerDescr) { return _this.onShowLayerInfoRequest(sender, layerDescr); });
        };
        MapControl.prototype.addCategorieLayer = function (categorieLayer, showAll) {
            var _this = this;
            categorieLayer.once("CategoriesLoaded", function (evt) {
                _this.categorieLayerCtrl.addCategorieLayer("Kategories", categorieLayer, showAll);
                _this.map.addLayer(categorieLayer);
            });
            categorieLayer.loadCategories();
            this.categorieLayers["Kategories"] = categorieLayer;
        };
        MapControl.prototype.itemSelected = function (ev) {
            var layer = ev.target;
            var marker = ev.marker;
            this.showData(layer, marker);
        };
        MapControl.prototype.itemUnselected = function (ev) {
            this.viewCtrl.goBack();
        };
        MapControl.prototype.setContentView = function (v, replace) {
            this.viewCtrl.setContentView(v, replace);
        };
        MapControl.prototype.onShowLayerInfoRequest = function (sender, layer) {
            console.info("onShowLayerInfoRequest", sender, layer);
            var self = this;
            var v = {
                getDom: function () {
                    console.info("getDom", this);
                    if (!this.dom) {
                        var d = (this.dom = document.createElement("div"));
                        d.className = "layerinfo";
                        if (layer.layerDescription.label) {
                            (0, Util_1.createHtmlElement)("span", d, "layerinfo-title", {
                                innerText: layer.layerDescription.label
                            });
                        }
                        if (layer.loadError) {
                            var txt_1 = layer.layerDescription.type === "WMS" ? "Beim Zugriff auf den externen Dienst ist ein Fehler aufgetreten. Versuchen Sie es spter erneut." : "Beim Laden des Themas ist ein Fehler aufgetreten. Versuchen Sie es spter erneut.";
                            (0, Util_1.createHtmlElement)("span", d, "layerinfo-error", {
                                innerText: txt_1
                            });
                        }
                        var layerDescr = layer.layerDescription;
                        if (layerDescr.abstract) {
                            (0, Util_1.createHtmlElement)("span", d, "layerinfo-subtitle", {
                                innerText: "Beschreibung:"
                            });
                            (0, Util_1.createHtmlElement)("span", d, "layerinfo-text", {
                                innerText: layerDescr.abstract
                            });
                        }
                        if (layerDescr.contactOrganisation) {
                            (0, Util_1.createHtmlElement)("span", d, "layerinfo-subtitle", {
                                innerText: "Quelle:"
                            });
                            (0, Util_1.createHtmlElement)("span", d, "layerinfo-text", {
                                innerText: layerDescr.contactOrganisation
                            });
                        }
                        for (var i = 0, count = LayerInfoAttr.length; i < count; i++) {
                            var layerInfoAttr = LayerInfoAttr[i];
                            if (layerDescr[layerInfoAttr.attrName]) {
                                var p = (0, Util_1.createHtmlElement)("p", d, "layerinfo-row");
                                (0, Util_1.createHtmlElement)("span", p, "layerinfo-row-head", {
                                    innerText: layerInfoAttr.attrLabel
                                });
                                (0, Util_1.createHtmlElement)("span", p, "layerinfo-row-content", {
                                    innerText: layerDescr[layerInfoAttr.attrName]
                                });
                            }
                        }
                        var txt = void 0;
                        var f = void 0;
                        var vc = this.viewCtc;
                        if (layer.isSelected) {
                            txt = "ausblenden";
                            f = function (evt) {
                                layer.setSelected(false);
                                //  MapDispatcher.onThemeLayerSelection.dispatch(layer, {type:'removed-from-map', layer:layer})
                                self.viewCtrl.goBack();
                            };
                        }
                        else {
                            txt = "einblenden";
                            f = function (evt) {
                                layer.setSelected(true);
                                self.viewCtrl.goBack();
                                // MapDispatcher.onThemeLayerSelection.dispatch(layer, {type:'select', layer:layer})
                            };
                        }
                        var bttnDiv = (0, Util_1.createHtmlElement)("div", d);
                        var bttn = (0, Util_1.createHtmlElement)("button", bttnDiv);
                        bttn.addEventListener("click", f);
                        bttn.innerText = txt;
                    }
                    return this.dom;
                }
            };
            this.showView(v);
        };
        MapControl.prototype.onViewRemove = function (sender, view) {
            var _a;
            console.info("onViewRemove", sender, view);
            if (view && view instanceof MarkerListView_1.MarkerView) {
                if ((_a = view.layer) === null || _a === void 0 ? void 0 : _a.highlightMarker) {
                    view.layer.highlightMarker(view.marker, false);
                    if (this.selectedItem && this.selectedItem.feature === view.marker) {
                        this.selectedItem = undefined;
                    }
                }
            }
            if (this.parentNode) {
                this.map.removeControl(this.viewCtrl);
                this.map.addControl(this.categorieLayerCtrl);
            }
            if (this._sidebarClosed) {
                document.getElementById("main").classList.add("sidebar-collapsed");
            }
        };
        MapControl.prototype.onMapFeatureClick = function (sender, evt) {
            console.info("onMapFeatureClick", evt);
            var layer = evt.propagatedFrom;
            var geoJsonL = evt.target;
            var isOtherItem = true;
            if (this.selectedItem) {
                isOtherItem = this.selectedItem.feature !== layer;
                if (geoJsonL.fctPopup) {
                    this.selectedItem.featureLayer.highlightMarker(this.selectedItem.feature, false);
                }
                else {
                    this.viewCtrl.goBack();
                }
            }
            if (isOtherItem) {
                geoJsonL.highlightMarker(layer, true);
                if (geoJsonL.fctPopup) {
                    var s = geoJsonL.fctPopup(layer.feature.properties);
                    var popup = L.popup().setContent(s).setLatLng(evt.latlng).openOn(geoJsonL._map);
                    popup.once("remove", function (evt) {
                        geoJsonL.highlightMarker(layer, false);
                    });
                }
                else {
                    this.showData(geoJsonL, layer);
                }
                this.selectedItem = { featureLayer: geoJsonL, feature: layer };
            }
        };
        MapControl.prototype.onBaseLayerSelection = function (sender, nBaseLayer) {
            console.info("onBaseLayerSelection", sender, nBaseLayer);
            if (this.baseLayer) {
                if (this.baseLayer === nBaseLayer) {
                    return;
                }
                this.baseLayer.remove();
            }
            if (this.map) {
                console.info("baseLayerChanged new", nBaseLayer);
                console.info("before addLayer", nBaseLayer);
                nBaseLayer.setZIndex(0);
                this.map.addLayer(nBaseLayer);
                console.info("layer added", nBaseLayer);
                this.baseLayer = nBaseLayer;
            }
            else {
                console.info("baseLayerChanged map==null");
            }
        };
        MapControl.prototype.addOverlayToMap = function (lw) {
            console.info("MapControl.addOverlayToMap");
            this.map.addLayer(lw.layer);
            lw.idx = this.layerOnMapList.length;
            this.layerOnMapList.push(lw);
            exports.MapDispatcher.onLayerAdded.dispatch(this, {
                type: "added-to-map",
                layer: lw
            });
            // this.printLayerInfo();
        };
        MapControl.prototype.onLayerReady = function (sender, evt) {
            console.info("MapControl.onLayerReady");
            if (evt.layer.isSelected) {
                this.addOverlayToMap(evt.layer);
            }
        };
        MapControl.prototype.removeLayerFromMap = function (lw) {
            this.map.removeLayer(lw.layer);
            exports.MapDispatcher.onLayerRemoved.dispatch(this, {
                type: "removed-from-map",
                layer: lw
            });
            var arr = [];
            for (var i = 0; i < this.layerOnMapList.length; i++) {
                if (lw !== this.layerOnMapList[i]) {
                    this.layerOnMapList[i].idx = arr.length;
                    arr.push(this.layerOnMapList[i]);
                }
            }
            lw.idx = -1;
            this.layerOnMapList = arr;
            // this.printLayerInfo();
        };
        // printLayerInfo() {
        //     console.error('printLayerInfo');
        //     this.map.eachLayer(item => {
        //         console.warn(item);
        //     })
        //     console.error('printLayerInfo2');
        //     this.layerOnMapList.forEach(item => {
        //         console.warn(item);
        //     })
        // }
        MapControl.prototype.onThemeLayerSelection = function (sender, evt) {
            // console.error("onThemeLayerSelection", evt);
            if (this.map) {
                if (evt.layer.isSelected) {
                    try {
                        if (evt.layer && evt.layer.layer) {
                            this.addOverlayToMap(evt.layer);
                        }
                        else {
                            exports.MapDispatcher.onLayerRequest.dispatch(this, {
                                type: "request-layer",
                                layer: evt.layer
                            });
                        }
                    }
                    catch (ex) {
                        console.info("error adding layer \"".concat(evt.layer.layerDescription.label, "\""), ex);
                    }
                }
                else {
                    if (evt.layer.layer) {
                        this.removeLayerFromMap(evt.layer);
                    }
                }
            }
        };
        MapControl.prototype.showView = function (view) {
            var _a;
            if (this.parentNode) {
                console.info("MapCtrl.showData");
                this.categorieLayerCtrl.remove();
                this.map.addControl(this.viewCtrl);
            }
            else {
                this.closeMenu();
            }
            this.viewCtrl.setContentView(view, true);
            if ((_a = document.getElementById("main")) === null || _a === void 0 ? void 0 : _a.classList.contains("sidebar-collapsed")) {
                document.getElementById("main").classList.remove("sidebar-collapsed");
                this._sidebarClosed = true;
            }
            else {
                this._sidebarClosed = false;
            }
        };
        MapControl.prototype.showData = function (layer, marker) {
            if (layer === null || layer === void 0 ? void 0 : layer.renderData) {
                this.showView(layer.renderData(marker));
            }
            else {
                if (marker === null || marker === void 0 ? void 0 : marker.feature) {
                    this.showView(new MarkerListView_1.MarkerView(layer, marker));
                }
                else {
                    console.info(layer, marker);
                }
            }
        };
        MapControl.prototype.addTo = function (map) {
            // console.error("MapControl.addTo", this.parentNode);
            if (this.parentNode) {
                this.remove();
                this.map = map;
                var container = (this._container = this.onAdd(map));
                this.parentNode.appendChild(container);
                this.map.on("unload", this.remove, this);
                this.map.addControl(this.baseLayerCtrl);
                this.map.addControl(this.categorieLayerCtrl);
                // this.map.addControl(this.baseLayerCtrl2);
                this.parentNode.appendChild(this.mapCtrlContentContainer);
                // this.parentNode.appendChild(this.layCtrlContainer);
                // this.parentNode.appendChild(this.viewCtrlContainer);
                // this.viewCtrlContainer.style.display = 'none';
                return this;
            }
            else {
                // return super.addTo(map);
                _super.prototype.addTo.call(this, map);
                this.searchBox.focus();
                map.addControl(this.viewCtrl);
                return this;
            }
        };
        MapControl.prototype.onAdd = function (map) {
            var _this = this;
            console.info("MenuControl.onAdd");
            // MapDispatcher.map = map;
            this.map = map;
            if (!this.dom) {
                var div = (0, Util_1.createHtmlElement)("div", undefined, "mapctrl");
                var divTop = (this.topDiv = (0, Util_1.createHtmlElement)("div", div, "mapctrl-top closed"));
                var searchTop = document.getElementById("searchwrapper");
                if (!this.parentNode) {
                    var anchor = (0, Util_1.createHtmlElement)("a", divTop, "menu-button");
                    anchor.addEventListener("pointerup", function (p) { return _this._menuClicked(p); });
                    (0, Util_1.createHtmlElement)("div", anchor);
                    var searchWrapper = document.createElement("div");
                    L.DomEvent.disableClickPropagation(searchWrapper);
                    L.DomEvent.disableScrollPropagation(searchWrapper);
                    searchWrapper.className = "search-wrapper";
                    if (searchTop) {
                        searchTop.appendChild(searchWrapper);
                    }
                    else {
                        divTop.appendChild(searchWrapper);
                    }
                    var searchBox_1 = (this.searchBox = document.createElement("input"));
                    searchWrapper.appendChild(searchBox_1);
                    searchBox_1.type = "text";
                    // searchBox.addEventListener('keyup', (ev)=>this._searchInput(ev));
                    searchBox_1.addEventListener("focusin", function (ev) { return _this._searchFocusIn(ev); });
                    searchBox_1.placeholder = "Suche";
                    var searchBoxClear = document.createElement("i");
                    searchBoxClear.className = "search-input-clear";
                    searchWrapper.appendChild(searchBoxClear);
                    searchBoxClear.addEventListener("click", function (ev) {
                        searchBox_1.value = "";
                        _this.viewCtrl.clear();
                    });
                    (0, Autocompleter_1["default"])(searchBox_1, {
                        onSelect: function (item, input) { return _this._found(item, input); },
                        onSearchStart: function (input) { return _this._searchStart(input); },
                        fetch: this.searchFct,
                        minLength: 3,
                        showOnFocus: true,
                        labelAttr: "name"
                    });
                }
                else {
                    var searchCtrl = (this.searchCtrl = new SearchCtrl_1.SearchControl({
                        onSelect: function (item, input) { return _this._found(item, input); },
                        onSearchStart: function (input) { return _this._searchStart(input); },
                        fetch: this.searchFct,
                        minLength: 3,
                        showOnFocus: true,
                        labelAttr: "name"
                    }));
                    map.addControl(searchCtrl);
                    map.addControl(new IconAction_1.IconActionCtrl({
                        position: "topright",
                        className: "home-icon",
                        action: function (ctrl) {
                            _this.showHome(ctrl);
                        }
                    }));
                    map.addControl(new IconAction_1.ChangeFontSizeCtrl({
                        position: "topright"
                    }));
                }
                L.DomEvent.disableClickPropagation(div);
                L.DomEvent.disableScrollPropagation(div);
                this.dom = div;
                if (this.parentNode) {
                    this.viewCtrl = new ViewControl_1.ViewControl({ parentNode: this.mapCtrlContentContainer });
                }
                else {
                    this.viewCtrl = new ViewControl_1.ViewControl({ position: "topleft" });
                }
            }
            var currZoomClass = (this.currZoomClass = "zoom" + map.getZoom());
            this.parentNode.classList.add(currZoomClass);
            map.addEventListener("zoomend", function (ev) {
                _this.parentNode.classList.remove(_this.currZoomClass);
                var currZoomClass = (_this.currZoomClass = "zoom" + map.getZoom());
                _this.parentNode.classList.add(currZoomClass);
            });
            return this.dom;
        };
        MapControl.prototype.showHome = function (ctrl) {
            console.info("showHome", this);
            document.getElementById("home-overlay").style.display = "";
            if (this.categorieLayerCtrl instanceof LayerControlVar_1.LayerControlVar) {
                this.categorieLayerCtrl.clearThemes();
            }
            this.searchCtrl.clearClicked();
            this.viewCtrl.clear();
            if (this.resetMap) {
                this.resetMap();
            }
            this.baseLayerCtrl.selectBaseLayer(0);
        };
        MapControl.prototype._searchStart = function (input) {
            console.info("_searchStart");
            this.clearResults();
        };
        MapControl.prototype.clearResults = function () {
            console.info("clearResults");
            this.viewCtrl.clear();
            if (this.categorieLayerCtrl.categorieLayers["Kategories"]) {
                this.categorieLayerCtrl.categorieLayers["Kategories"].removeSearchResults();
            }
            if (this.foundArea) {
                this.foundArea.remove();
                this.foundArea = undefined;
            }
        };
        /* TODO */
        MapControl.prototype._found = function (item, input) {
            // console.error("_found");
            this.clearResults();
            this.closeMenu();
            if ((item === null || item === void 0 ? void 0 : item.group) === "Thema") {
                exports.MapDispatcher.onShowLayerInfoRequest.dispatch(this, item.layer);
            }
            else if (item) {
                var geoJ = this.showGeojson(item);
                console.info("found", item);
            }
            // if (item.group==='Kategorie') {
            // } else if (item.group==='Ort') {
            // } else if (item.group==='Einrichtung') {
            //     console.info('_foundEinrichtung', item);
            //     const layer = this.categorieLayerCtrl.categorieLayers["Kategories"];
            //     if (layer) {
            //         const marker = layer.findMarker(item.id, "id");
            //         if (marker) {
            //             this.showData(layer, marker);
            //         }
            //     }
            // } else {
            //     const geoJ = this.showOrtschaft(item);
            //     console.info('found', item);
            //     const catL = this.categorieLayerCtrl.categorieLayers["Kategories"];
            //     catL.findMarkers(item.table, item.id).then(
            //         markers=>{
            //             const view = new MarkerListView(geoJ, catL, markers);
            //             this.setContentView(view);
            //         }
            //     );
            // }
        };
        MapControl.prototype.showGeojson = function (item) {
            console.info("showGeojson");
            var geoJ = (this.foundArea = L.geoJSON(item.feature.geometry, {
                style: function (feature) {
                    return { color: "#000", dashArray: "10 8", fillColor: "#555" };
                }
            }));
            this.map.addLayer(geoJ);
            this.map.fitBounds(geoJ.getBounds());
            return geoJ;
        };
        MapControl.prototype._searchFocusIn = function (ev) {
            console.info("_searchFocusIn", ev);
        };
        MapControl.prototype._menuClicked = function (p) {
            console.info("_menuClicked");
            if (this.closed) {
                this.openMenu();
            }
            else {
                this.closeMenu();
            }
        };
        MapControl.prototype.closeMenu = function () {
            if (this.isMenuOpen) {
                this.closed = true;
                this.topDiv.classList.replace("opened", "closed");
                this.map.removeControl(this.baseLayerCtrl);
                this.map.removeControl(this.categorieLayerCtrl);
                // this.contentArea.style.display = '';
                this.map.addControl(this.viewCtrl);
                this.isMenuOpen = false;
            }
        };
        MapControl.prototype.openMenu = function () {
            if (!this.isMenuOpen) {
                this.closed = false;
                this.topDiv.classList.replace("closed", "opened");
                this.map.addControl(this.baseLayerCtrl);
                this.map.addControl(this.categorieLayerCtrl);
                // this.contentArea.style.display = 'none';
                this.map.removeControl(this.viewCtrl);
                this.isMenuOpen = true;
            }
        };
        MapControl.prototype.onRemove = function (map) {
            console.info("MenuControl.onRemove");
            this.map = null;
        };
        MapControl.prototype.setBaseLayers = function (baseLayers, options) {
            this.baseLayerCtrl.setBaseLayers(baseLayers, options);
        };
        return MapControl;
    }(L.Control));
    exports.MapControl = MapControl;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./src/ts/controls/MarkerListView.ts":
/*!*******************************************!*\
  !*** ./src/ts/controls/MarkerListView.ts ***!
  \*******************************************/
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(/*! ./MapControl */ "./src/ts/controls/MapControl.ts"), __webpack_require__(/*! ../Util */ "./src/ts/Util.ts")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports, MapControl_1, Util_1) {
    "use strict";
    exports.__esModule = true;
    exports.MarkerListView = exports.MarkerView = void 0;
    function prepareLinks(s) {
        var result = "";
        if (s) {
            if (s.split(/[>]/).length > 1 && s.split(/[>]/).length > 1) {
                // vielleicht HTML keine nderung
                // console.log(`/[><]+/g.exec(s).length='${/[><]+/g.exec(s)?.length}'`);
                // console.log(`s.split(/[><]/).length='${s.split(/[><]/).length}'`);
                // console.log(s.split(/[><]/));
                result = s;
            }
            else {
                var sA = s.split(/[\s]+/);
                for (var i = 0, count = sA.length; i < count; i++) {
                    var part = sA[i];
                    if (i > 0) {
                        result += " ";
                    }
                    if (part.indexOf("http") === 0) {
                        result += '<a href="';
                        result += part;
                        result += '">';
                        result += part;
                        result += "</a>";
                    }
                    else {
                        result += part;
                    }
                }
            }
        }
        return result;
    }
    var MarkerView = /** @class */ (function () {
        function MarkerView(layer, marker) {
            console.info("Markerview create");
            this.layer = layer;
            this.marker = marker;
        }
        MarkerView.prototype.getTitle = function () {
            var _a;
            return (_a = this.layer["LayerDescription"]) === null || _a === void 0 ? void 0 : _a.label;
        };
        MarkerView.prototype.getDom = function () {
            var _a;
            if (!this.dom) {
                if ((_a = this.layer) === null || _a === void 0 ? void 0 : _a.popupFactory) {
                    this.dom = this.layer.popupFactory.renderDataView(this.layer, this.marker);
                }
                else {
                    this.dom = this.renderDataView();
                }
            }
            return this.dom;
        };
        MarkerView.prototype.renderDataView = function () {
            var _a, _b, _c, _d;
            console.info("renderdataView", this);
            var dom = (0, Util_1.createHtmlElement)("div", undefined, "data-view");
            (0, Util_1.createHtmlElement)("h1", dom, "datainfo-title", {
                innerHTML: (_a = this.layer["LayerDescription"]) === null || _a === void 0 ? void 0 : _a.label
            });
            console.info((_b = this.layer["LayerDescription"]) === null || _b === void 0 ? void 0 : _b.label);
            // const table = createHtmlElement('table', dom);
            var data = this.marker.data ? this.marker.data : (_d = (_c = this.marker) === null || _c === void 0 ? void 0 : _c.feature) === null || _d === void 0 ? void 0 : _d.properties;
            var layerDes = this.layer["LayerDescription"];
            if (layerDes === null || layerDes === void 0 ? void 0 : layerDes.layerAttributes) {
                var i = 0;
                for (var k in layerDes.layerAttributes) {
                    var v = data[k];
                    if (v || !layerDes.hideEmptyLayerAttributes) {
                        var p = (0, Util_1.createHtmlElement)("p", dom, "datainfo-row");
                        (0, Util_1.createHtmlElement)("span", p, "datainfo-row-head", {
                            innerHTML: layerDes.layerAttributes[k]
                        });
                        if (typeof v === "string" && v.indexOf("http") >= 0) {
                            v = prepareLinks(v);
                        }
                        (0, Util_1.createHtmlElement)("span", p, "datainfo-row-content", {
                            innerHTML: v
                        });
                        i++;
                        // createRow(layerDes.layerAttributes[k], v, table);
                    }
                }
                if (i === 0) {
                    (0, Util_1.createHtmlElement)("p", dom, "datainfo-row-head", {
                        innerHTML: "Es liegen keine weiteren Daten vor."
                    });
                }
                // if (layerDes?.geomType === "Chart") {
                //     const m = <PiechartMarker<any>>this.marker;
                //     const div = createHtmlElement("div", dom);
                //     div.appendChild(m.getPiechart());
                // }
            }
            else {
                // createRow(k, data[k], table);
                (0, Util_1.createHtmlElement)("p", dom, "datainfo-row-head", {
                    innerHTML: "Es liegen keine weiteren Daten vor."
                });
            }
            return dom;
        };
        return MarkerView;
    }());
    exports.MarkerView = MarkerView;
    var MarkerListView = /** @class */ (function () {
        function MarkerListView(geoJ, layer, markers) {
            console.info("MarkerListiew");
            this.layer = layer;
            this.markers = markers;
            this.geoJson = geoJ;
        }
        MarkerListView.prototype.getDom = function () {
            var _this = this;
            if (!this.dom) {
                var divList_1 = document.createElement("div");
                divList_1.className = "list-item-view";
                var markers = this.markers;
                var pop_1 = this.layer.popupFactory;
                if (markers && markers.length > 0) {
                    markers.forEach(function (marker) {
                        var itemDom = pop_1.renderListItem(_this.layer, marker);
                        divList_1.appendChild(itemDom);
                        itemDom.className = "list-item";
                        itemDom.addEventListener("click", function (ev) { return _this.listEntryClicked({ dom: ev.target, item: marker }); });
                    });
                }
                else {
                    (0, Util_1.createHtmlElement)("p", divList_1).innerHTML = "Es wurde nichts gefunden";
                }
                this.dom = divList_1;
            }
            return this.dom;
        };
        MarkerListView.prototype.listEntryClicked = function (entry) {
            if (this.selectedListEntry) {
                this.selectedListEntry.dom.classList.remove("selected");
                if (this.selectedListEntry === entry) {
                    this.selectedListEntry = undefined;
                    MapControl_1.MapDispatcher.onListViewItemSelection.dispatch(this, undefined);
                }
            }
            this.selectedListEntry = entry;
            MapControl_1.MapDispatcher.onListViewItemSelection.dispatch(this, entry.item);
            console.info("listEntryClicked", entry);
        };
        MarkerListView.prototype.onAdd = function (parent) {
            console.info("MarkerListView.onAdd");
        };
        MarkerListView.prototype.onRemove = function () {
            if (this.geoJson) {
                this.geoJson.remove();
            }
            console.info("MarkerListView.onRemove");
        };
        return MarkerListView;
    }());
    exports.MarkerListView = MarkerListView;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./src/ts/controls/SearchCtrl.ts":
/*!***************************************!*\
  !*** ./src/ts/controls/SearchCtrl.ts ***!
  \***************************************/
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(/*! leaflet */ "./node_modules/leaflet/dist/leaflet-src.js"), __webpack_require__(/*! ste-events */ "./node_modules/ste-events/dist/index.js"), __webpack_require__(/*! ../Util */ "./src/ts/Util.ts"), __webpack_require__(/*! ../util/Autocompleter */ "./src/ts/util/Autocompleter.ts")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports, leaflet_1, ste_events_1, Util_1, Autocompleter_1) {
    "use strict";
    exports.__esModule = true;
    exports.SearchControl = void 0;
    var SearchControl = /** @class */ (function (_super) {
        __extends(SearchControl, _super);
        function SearchControl(params) {
            var _this = _super.call(this, params) || this;
            _this.onShowSearchField = new ste_events_1.EventDispatcher();
            _this.params = params;
            params.onSearchFinished = function (ev) { return _this.isSearching(false); };
            params.onSearchStartRunning = function (ev) { return _this.isSearching(true); };
            return _this;
        }
        SearchControl.prototype.isSearching = function (searching) {
            if (this.searchDom) {
                if (searching) {
                    this.searchDom.classList.add("searching");
                }
                else {
                    this.searchDom.classList.remove("searching");
                }
            }
        };
        SearchControl.prototype.onAdd = function (map) {
            var _this = this;
            console.info("SearchControl.onAdd");
            this._container = (0, Util_1.createHtmlElement)("div", undefined, "control-search");
            var bttn = (this._Bttn = (0, Util_1.createHtmlElement)("button", this._container, "search-button ctrl-icon"));
            bttn.ariaLabel = "Suchfeld ffnen";
            (0, Util_1.createHtmlElement)("i", bttn);
            this._clickFct = function (evt) {
                // this.onShowSearchField.dispatch(this, !closed);
                _this.showSearchField();
            };
            bttn.addEventListener("click", this._clickFct);
            leaflet_1.DomEvent.disableClickPropagation(this._container);
            this.createSearchField();
            this._container.appendChild(this.searchDom);
            // this._container.addEventListener('mouseenter', ()=>{
            //   console.info("element._container:",this._container);
            //   console.info("element.offsetTop:"+this._container.offsetTop);
            //   console.info("element.offsetLeft:"+this._container.offsetLeft);
            //   console.info("element.offsetWidth:"+this._container.offsetWidth);
            //   console.info("element.offsetHeight:"+this._container.offsetHeight);
            //   console.info("element.offsetParent:",this._container.offsetParent);
            //   console.info("element.offsetParent.offsetParent:", (<any>this._container.offsetParent).offsetParent);
            // })
            document.addEventListener("keydown", function (evt) {
                if (evt.ctrlKey && evt.key === "f") {
                    console.info(evt);
                    _this.showSearchField();
                    _this.inputField.focus();
                    evt.preventDefault();
                }
            });
            return this._container;
        };
        SearchControl.prototype.onRemove = function (map) {
            this._Bttn.removeEventListener("click", this._clickFct);
        };
        SearchControl.prototype.createSearchField = function () {
            var _this = this;
            var searchDom = (this.searchDom = (0, Util_1.createHtmlElement)("div", undefined, "search"));
            (0, Util_1.createHtmlElement)("div", searchDom, "search-animation");
            var searchWrapper = (0, Util_1.createHtmlElement)("div", searchDom, "search-wrapper");
            var closeBttn = (this.closeBttn = (0, Util_1.createHtmlElement)("div", searchDom, "angels-up"));
            closeBttn.addEventListener("click", function (ev) { return _this.closeBttnClicked(ev); });
            var searchBox = (this.inputField = this.searchBox = document.createElement("input"));
            searchWrapper.appendChild(searchBox);
            searchBox.type = "text";
            searchBox.placeholder = "Ort, Adresse, Thema..";
            var searchBoxClear = document.createElement("i");
            searchBoxClear.className = "search-input-clear";
            searchWrapper.appendChild(searchBoxClear);
            searchBoxClear.addEventListener("click", function (ev) {
                searchBox.value = "";
                _this.clearClicked();
            });
            (0, Autocompleter_1["default"])(searchBox, this.params);
        };
        SearchControl.prototype.showSearchField = function () {
            this._container.classList.toggle("opened");
            this.searchBox.focus();
        };
        SearchControl.prototype.closeBttnClicked = function (ev) {
            this._container.classList.toggle("opened");
        };
        SearchControl.prototype.clearClicked = function () {
            this.inputField.value = "";
            this.params.onSelect(undefined, this.inputField);
        };
        return SearchControl;
    }(leaflet_1.Control));
    exports.SearchControl = SearchControl;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./src/ts/controls/ViewControl.ts":
/*!****************************************!*\
  !*** ./src/ts/controls/ViewControl.ts ***!
  \****************************************/
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(/*! leaflet */ "./node_modules/leaflet/dist/leaflet-src.js"), __webpack_require__(/*! ../Util */ "./src/ts/Util.ts"), __webpack_require__(/*! ./MapControl */ "./src/ts/controls/MapControl.ts")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports, L, Util_1, MapControl_1) {
    "use strict";
    exports.__esModule = true;
    exports.ViewControl = void 0;
    var ViewControl = /** @class */ (function (_super) {
        __extends(ViewControl, _super);
        function ViewControl(options) {
            var _this = _super.call(this, options) || this;
            _this.contentHistory = [];
            _this.counter = 0;
            _this.parentNode = options.parentNode;
            var div = _this.dom = document.createElement('div');
            div.className = 'viewctrl';
            var navArea = _this.navigationArea = document.createElement('div');
            navArea.className = 'viewctrl-nav';
            _this.navTitle = (0, Util_1.createHtmlElement)('span', navArea);
            var navSpan = _this.navBttn = document.createElement('span');
            navArea.appendChild(navSpan);
            var anchorBack = _this.anchorBack = document.createElement('a');
            anchorBack.className = 'close';
            navSpan.appendChild(anchorBack);
            // const anchorClose = document.createElement('a') ;
            // anchorClose.className = 'back';
            // navSpan.appendChild(anchorClose);
            // navBttn.innerHTML = '&laquo; zurck';
            navSpan.addEventListener('click', function (ev) { return _this._backBttnClicked(); });
            // div.appendChild(this.navigationArea);
            _this.contentArea = document.createElement('div');
            _this.contentArea.className = 'viewctrl-content';
            div.appendChild(_this.contentArea);
            var fnStopPropagation = function (ev) {
                ev.stopPropagation();
                return false;
            };
            L.DomEvent.disableClickPropagation(div);
            L.DomEvent.disableScrollPropagation(div);
            return _this;
            // div.addEventListener("pointermove", fnStopPropagation); 
            // div.addEventListener("click", fnStopPropagation);
            // div.addEventListener("mouseup", fnStopPropagation);
            // div.addEventListener("pointerup", fnStopPropagation);
            // div.addEventListener("wheel", fnStopPropagation);
        }
        ViewControl.prototype._backBttnClicked = function () {
            this.goBack();
        };
        ViewControl.prototype.addTo = function (map) {
            // console.error('ViewControl.addTo');
            if (this.parentNode) {
                this.remove();
                this._map = map;
                var container = this._container = this.onAdd(map);
                this.parentNode.appendChild(container);
                this._map.on('unload', this.remove, this);
                return this;
            }
            else {
                return _super.prototype.addTo.call(this, map);
            }
        };
        ViewControl.prototype.onAdd = function (map) {
            return this.dom;
        };
        // onRemove(map:L.Map) {
        //     // console.error("ViewControl.onRemove");
        // }
        ViewControl.prototype.clear = function () {
            console.info("clear");
            var view;
            while (view = this.contentHistory.pop()) {
                if (view.onRemove) {
                    view.onRemove();
                }
                MapControl_1.MapDispatcher.onViewRemove.dispatch(this, view);
            }
            this.contentHistory = [];
            if (this.contentArea.firstChild) {
                this.contentArea.removeChild(this.contentArea.firstChild);
            }
            if (this.dom.contains(this.navigationArea)) {
                this.dom.removeChild(this.navigationArea);
            }
        };
        ViewControl.prototype.setContentView = function (v, replace) {
            console.info("setView", v);
            if (replace) {
                this._replaceContent(v);
            }
            else {
                this._setContent(v);
            }
            if (v.onAdd) {
                v.onAdd(this);
            }
        };
        ViewControl.prototype._replaceContent = function (view) {
            console.info("_replaceContent");
            var oldView;
            while (oldView = this.contentHistory.pop()) {
                if (oldView.onRemove) {
                    oldView.onRemove();
                }
            }
            var dom = view.getDom();
            if (this.contentArea.firstChild) {
                console.info("_replaceContent01", this.contentArea.firstChild);
                this.contentArea.replaceChild(dom, this.contentArea.firstChild);
            }
            else {
                console.info("_replaceContent02");
                this.dom.insertBefore(this.navigationArea, this.contentArea);
                this.contentArea.appendChild(dom);
            }
            this.contentHistory = [view];
        };
        ViewControl.prototype._setContent = function (view) {
            var dom = view.getDom();
            console.info('ViewControl._setContent01', dom);
            dom.id = 'view_' + this.counter;
            this.counter++;
            if (this.contentArea.firstChild) {
                console.info("setContent ".concat(this.contentArea.firstChild['id'], " => ").concat(dom.id));
                this.contentArea.replaceChild(dom, this.contentArea.firstChild);
                this.contentHistory.push(view);
            }
            else {
                console.info("setContent none => ".concat(dom.id, " (addNavArea)"));
                this.dom.insertBefore(this.navigationArea, this.contentArea);
                this.contentArea.appendChild(dom);
                this.contentHistory.push(view);
            }
            var viewText = view.getTitle ? view.getTitle() : undefined;
            this.navTitle.innerText = (viewText) ? viewText : '';
            console.info("setContent done ".concat(this.contentHistory.length), this.contentHistory);
            if (this.contentHistory.length === 1) {
                this.anchorBack.classList.replace('back', 'close');
                this.anchorBack.title = "schlieen";
            }
            else {
                this.anchorBack.classList.replace('close', 'back');
                this.anchorBack.title = "zurck";
            }
        };
        ViewControl.prototype.goBack = function () {
            console.info("goBack ".concat(this.contentHistory.length), this.contentHistory);
            if (this.contentArea.firstChild) {
                var currentContent = this.contentHistory.pop();
                console.info("goBack ".concat(this.contentHistory.length), this.contentHistory);
                if (currentContent) {
                    if (this.contentHistory.length > 0) {
                        var lastContent = this.contentHistory[this.contentHistory.length - 1];
                        console.info("goBack ".concat(currentContent.getDom()['id'], " => ").concat(lastContent.getDom()['id']), currentContent, lastContent);
                        this.contentArea.replaceChild(lastContent.getDom(), this.contentArea.firstChild);
                    }
                    else {
                        console.info("goBack ".concat(currentContent['id'], " => none removeNavArea"));
                        this.contentArea.removeChild(currentContent.getDom());
                        this.dom.removeChild(this.navigationArea);
                    }
                    if (currentContent.onRemove) {
                        currentContent.onRemove();
                    }
                    MapControl_1.MapDispatcher.onViewRemove.dispatch(this, currentContent);
                }
            }
            console.info('goBack this.anchorBack.classList', this.anchorBack.className);
            if (this.contentHistory.length <= 1) {
                this.anchorBack.classList.replace('back', 'close');
            }
            else {
                this.anchorBack.classList.replace('close', 'back');
            }
        };
        return ViewControl;
    }(L.Control));
    exports.ViewControl = ViewControl;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./src/ts/svg/piechart.ts":
/*!********************************!*\
  !*** ./src/ts/svg/piechart.ts ***!
  \********************************/
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports) {
    "use strict";
    exports.__esModule = true;
    exports.createPiechart = void 0;
    function createPiechart(param) {
        var _a, _b, _c;
        var svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        var d = 2 * param.radius;
        if (svg.viewBox.baseVal) {
            svg.viewBox.baseVal.x = 0;
            svg.viewBox.baseVal.y = 0;
            svg.viewBox.baseVal.width = d;
            svg.viewBox.baseVal.height = d;
        }
        else {
            var viewboxString = "0 0 " + d.toString() + " " + d.toString();
            svg.setAttribute("viewBox", viewboxString);
        }
        svg.setAttribute("width", d.toString());
        svg.setAttribute("height", d.toString());
        // calculate sum of values
        var sum = 0;
        var radius = param.radius;
        for (var e = 0; e < param.segments.length; e++) {
            sum += param.segments[e].value;
        }
        // generate proportional pie for all segments
        var startAngle = 0, endAngle = 0;
        for (var i = 0; i < param.segments.length; i++) {
            var element = param.segments[i];
            var angle = (element.value * 2 * Math.PI) / sum;
            endAngle += angle;
            var svgLine = makeSVG("line", {
                x1: radius,
                y1: radius,
                x2: Math.cos(endAngle) * radius + radius,
                y2: Math.sin(endAngle) * radius + radius,
                stroke: param.color,
                strokeOpacity: param.strokeOpacity,
                strokeWidth: param.strokeWeight
            });
            svg.append(svgLine);
            var pathStr = "M " + radius + "," + radius + " " + "L " + (Math.cos(startAngle) * radius + radius) + "," + (Math.sin(startAngle) * radius + radius) + " " + "A " + radius + "," + radius + " 0 " + (angle < Math.PI ? "0" : "1") + " 1 " + (Math.cos(endAngle) * radius + radius) + "," + (Math.sin(endAngle) * radius + radius) + " " + "Z";
            var svgPath = makeSVG("path", {
                d: pathStr,
                fill: element.style.fill,
                opacity: element.style.opacity,
                stroke: (_a = param.color) !== null && _a !== void 0 ? _a : "#bbb",
                strokeOpacity: (_b = param.strokeOpacity) !== null && _b !== void 0 ? _b : "0.6",
                strokeWidth: (_c = param.strokeWeight) !== null && _c !== void 0 ? _c : "1"
            });
            svg.append(svgPath);
            startAngle += angle;
        }
        return svg;
    }
    exports.createPiechart = createPiechart;
    // SVG Maker - to draw SVG by script
    function makeSVG(tag, attrs) {
        var el = document.createElementNS("http://www.w3.org/2000/svg", tag);
        for (var k in attrs) {
            el.setAttribute(k, attrs[k]);
        }
        return el;
    }
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./src/ts/svg/svg.ts":
/*!***************************!*\
  !*** ./src/ts/svg/svg.ts ***!
  \***************************/
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports) {
    "use strict";
    exports.__esModule = true;
    exports.SVG = exports.Polygon = exports.PolyLine = exports.Line = exports.Circle = exports.SvgBaseElement = void 0;
    function applyStyle(el, style) {
        for (var k in style) {
            el.style[k] = style[k];
        }
    }
    var SvgBaseElement = /** @class */ (function () {
        function SvgBaseElement(el, style) {
            this.svg = el;
            if (style) {
                applyStyle(el, style);
            }
        }
        SvgBaseElement.prototype.updateStyle = function (style) {
            applyStyle(this.svg, style);
        };
        SvgBaseElement.prototype.getSVG = function () {
            return this.svg;
        };
        SvgBaseElement.prototype.getPathLength = function () {
            return this.svg.pathLength;
        };
        SvgBaseElement.prototype.isPointInFill = function (point) {
            return this.svg.isPointInFill(point);
        };
        SvgBaseElement.prototype.isPointInStroke = function (point) {
            return this.svg.isPointInStroke(point);
        };
        SvgBaseElement.prototype.getTotalLength = function () {
            return this.svg.getTotalLength();
        };
        SvgBaseElement.prototype.getPointAtLength = function (distance) {
            return this.svg.getPointAtLength(distance);
        };
        return SvgBaseElement;
    }());
    exports.SvgBaseElement = SvgBaseElement;
    var Circle = /** @class */ (function (_super) {
        __extends(Circle, _super);
        function Circle(cx, cy, radius, style) {
            var _this = _super.call(this, document.createElementNS("http://www.w3.org/2000/svg", "circle"), style) || this;
            _this.update(cx, cy, radius);
            return _this;
        }
        Circle.prototype.update = function (cx, cy, radius) {
            this.svg.setAttribute("r", String(radius));
            this.svg.setAttribute("cx", String(cx));
            this.svg.setAttribute("cy", String(cy));
        };
        return Circle;
    }(SvgBaseElement));
    exports.Circle = Circle;
    var Line = /** @class */ (function (_super) {
        __extends(Line, _super);
        function Line(x1, y1, x2, y2, style) {
            var _this = _super.call(this, document.createElementNS("http://www.w3.org/2000/svg", "line"), style) || this;
            _this.update(x1, y1, x2, y2);
            return _this;
        }
        Line.prototype.update = function (x1, y1, x2, y2) {
            this.svg.setAttribute("x1", String(x1));
            this.svg.setAttribute("y1", String(y1));
            this.svg.setAttribute("x2", String(x2));
            this.svg.setAttribute("y2", String(y2));
            this.svg.style["x1"] = String(x1);
            this.svg.style["y1"] = String(y1);
            this.svg.style["x2"] = String(x2);
            this.svg.style["y2"] = String(y2);
        };
        return Line;
    }(SvgBaseElement));
    exports.Line = Line;
    var PolyLine = /** @class */ (function (_super) {
        __extends(PolyLine, _super);
        function PolyLine(points, style) {
            var _this = _super.call(this, document.createElementNS("http://www.w3.org/2000/svg", "polyline"), style) || this;
            _this.update(points);
            return _this;
        }
        PolyLine.prototype.update = function (points) {
            // points="100,10 40,198 190,78 10,78 160,198"
            if (points) {
                if (typeof points === "string") {
                    this.svg.setAttribute("points", points);
                }
                else {
                    if (points.length > 0) {
                        var s = points[0][0] + "," + points[0][1];
                        for (var i = 1, count = points.length; i < count; i++) {
                            s += " " + points[i][0] + "," + points[i][1];
                        }
                        this.svg.setAttribute("points", s);
                    }
                }
            }
        };
        return PolyLine;
    }(SvgBaseElement));
    exports.PolyLine = PolyLine;
    var Polygon = /** @class */ (function (_super) {
        __extends(Polygon, _super);
        function Polygon(points, style) {
            var _this = _super.call(this, document.createElementNS("http://www.w3.org/2000/svg", "polygon"), style) || this;
            _this.update(points);
            return _this;
        }
        Polygon.prototype.update = function (points) {
            // points="100,10 40,198 190,78 10,78 160,198"
            if (points) {
                if (typeof points === "string") {
                    this.svg.setAttribute("points", points);
                }
                else {
                    if (points.length > 0) {
                        var s = points[0][0] + "," + points[0][1];
                        for (var i = 1, count = points.length; i < count; i++) {
                            s += " " + points[i][0] + "," + points[i][1];
                        }
                        this.svg.setAttribute("points", s);
                    }
                }
            }
        };
        return Polygon;
    }(SvgBaseElement));
    exports.Polygon = Polygon;
    var SVG = /** @class */ (function () {
        function SVG(viewbox) {
            var svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            if (viewbox) {
                if (svg.viewBox.baseVal) {
                    svg.viewBox.baseVal.x = viewbox.x;
                    svg.viewBox.baseVal.y = viewbox.y;
                    svg.viewBox.baseVal.width = viewbox.width;
                    svg.viewBox.baseVal.height = viewbox.height;
                }
                else {
                    // svg.setAttribute("viewBox", "x:viewbox.x, y:viewbox.y, width:viewbox.width, height:viewbox.height");
                    var viewboxString = "" + viewbox.x.toString() + " " + viewbox.y.toString() + " " + viewbox.width.toString() + " " + viewbox.height.toString();
                    svg.setAttribute("viewBox", viewboxString);
                    console.debug("svg.viewBox", svg.viewBox);
                }
            }
            this.svg = svg;
        }
        SVG.prototype.getGElement = function () {
            if (!this.g) {
                this.g = document.createElementNS("http://www.w3.org/2000/svg", "g");
                this.svg.appendChild(this.g);
            }
            return this.g;
        };
        SVG.prototype.addCircle = function (cx, cy, radius, style) {
            var circle = new Circle(cx, cy, radius, style);
            this.getGElement().appendChild(circle.svg);
            return circle;
        };
        SVG.prototype.addLine = function (x1, y1, x2, y2, style) {
            var line = new Line(x1, y1, x2, y2, style);
            this.getGElement().appendChild(line.svg);
            return line;
        };
        SVG.prototype.addPolyLine = function (points, style) {
            var polygon = new PolyLine(points, style);
            this.getGElement().appendChild(polygon.svg);
            return polygon;
        };
        SVG.prototype.addPolygGon = function (points, style) {
            var polygon = new Polygon(points, style);
            this.getGElement().appendChild(polygon.svg);
            return polygon;
        };
        return SVG;
    }());
    exports.SVG = SVG;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./src/ts/util/Autocompleter.ts":
/*!**************************************!*\
  !*** ./src/ts/util/Autocompleter.ts ***!
  \**************************************/
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 * https://github.com/kraaden/autocomplete
 * Copyright (c) 2016 Denys Krasnoshchok
 * MIT License
 */
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports) {
    "use strict";
    exports.__esModule = true;
    function autocomplete(input, settings) {
        // just an alias to minimize JS file size
        var doc = document;
        var container = doc.createElement("div");
        var containerStyle = container.style;
        var userAgent = navigator.userAgent;
        var mobileFirefox = userAgent.indexOf("Firefox") !== -1 && userAgent.indexOf("Mobile") !== -1;
        var debounceWaitMs = settings.debounceWaitMs || 0;
        var preventSubmit = settings.preventSubmit || false;
        var labelAttr = settings.labelAttr || 'name';
        var initialItems = settings.initialItems;
        // 'keyup' event will not be fired on Mobile Firefox, so we have to use 'input' event instead
        var keyUpEventName = mobileFirefox ? "input" : "keyup";
        var isBeforeStart = true;
        var items = [];
        var inputValue = "";
        var minLen = settings.minLength || 2;
        var showOnFocus = settings.showOnFocus;
        var selected = settings.value;
        if (selected) {
            input.value = selected[labelAttr];
        }
        var keypressCounter = 0;
        var debounceTimer;
        var searchCounter = 0;
        var lastSearch;
        if (!input) {
            throw new Error("input undefined");
        }
        var promises = [];
        container.className = "autocomplete " + (settings.className || "");
        // IOS implementation for fixed positioning has many bugs, so we will use absolute positioning
        containerStyle.position = "absolute";
        /**
         * Detach the container from DOM
         */
        function detach() {
            var parent = container.parentNode;
            if (parent) {
                parent.removeChild(container);
            }
        }
        /**
         * Clear debouncing timer if assigned
         */
        function clearDebounceTimer() {
            if (debounceTimer) {
                window.clearTimeout(debounceTimer);
            }
        }
        /**
         * Attach the container to DOM
         */
        function attach() {
            if (!container.parentNode) {
                doc.body.appendChild(container);
            }
        }
        /**
         * Check if container for autocomplete is displayed
         */
        function containerDisplayed() {
            return !!container.parentNode;
        }
        /**
         * Clear autocomplete state and hide container
         */
        function clear() {
            // prevent the update call if there are pending AJAX requests
            keypressCounter++;
            items = [];
            inputValue = "";
            selected = undefined;
            detach();
            lastSearch = undefined;
            for (var i = 0; i < promises.length; i++) {
                promises[i]["cancel"]();
            }
        }
        /**
         * Update autocomplete position
         */
        function updatePosition() {
            // console.warn("updatePosition");
            if (!containerDisplayed()) {
                return;
            }
            containerStyle.height = "auto";
            var width = input.offsetWidth + "px";
            // try {
            //     console.info('updatePosition', input.parentElement.parentElement);
            // } catch (ex) {
            //     console.error(ex)
            // }
            containerStyle.width = width;
            var maxHeight = 0;
            var maxWidth = input.offsetWidth;
            var inputRect;
            function calc() {
                var docEl = doc.documentElement;
                var clientTop = docEl.clientTop || doc.body.clientTop || 0;
                var clientLeft = docEl.clientLeft || doc.body.clientLeft || 0;
                var scrollTop = window.pageYOffset || docEl.scrollTop;
                var scrollLeft = window.pageXOffset || docEl.scrollLeft;
                inputRect = input.parentElement.getBoundingClientRect();
                var top = inputRect.top + input.offsetHeight + scrollTop - clientTop + 6;
                var left = inputRect.left + scrollLeft - clientLeft;
                containerStyle.top = top + "px";
                containerStyle.left = left + "px";
                maxHeight = window.innerHeight - (inputRect.top + input.offsetHeight + 8);
                if (maxHeight < 0) {
                    maxHeight = 0;
                }
                maxWidth = window.innerWidth - (inputRect.left);
                containerStyle.top = top + "px";
                containerStyle.bottom = "";
                containerStyle.left = left + "px";
                containerStyle.maxHeight = maxHeight + "px";
                containerStyle.minWidth = input.parentElement.offsetWidth + "px";
                if (maxWidth > 100) {
                    containerStyle.width = 'unset';
                    containerStyle.maxWidth = maxWidth + "px";
                }
            }
            // the calc method must be called twice, otherwise the calculation may be wrong on resize event (chrome browser)
            calc();
            calc();
            if (settings.customize && inputRect) {
                settings.customize(input, inputRect, container, maxHeight);
            }
        }
        /**
         * Redraw the autocomplete div element with suggestions
         */
        function update() {
            // delete all children from autocomplete DOM container
            while (container.firstChild) {
                container.removeChild(container.firstChild);
            }
            // function for rendering autocomplete suggestions
            var render = settings.render || function (item, currentValue) {
                var itemElement = doc.createElement("div");
                var textArea = doc.createElement("label");
                textArea.innerText = item[labelAttr] || "";
                itemElement.appendChild(textArea);
                if (item['group'] === 'Thema') {
                    itemElement.title = item['layer'].layerDescription.abstract;
                }
                return itemElement;
            };
            // if (settings.render) {
            //     render = settings.render;
            // }
            // function to render autocomplete groups
            var renderGroup = settings.renderGroup || function (groupName, currentValue) {
                var groupDiv = doc.createElement("div");
                groupDiv.textContent = groupName;
                return groupDiv;
            };
            // if () {
            //     renderGroup = settings.renderGroup;
            // }
            var fragment = doc.createDocumentFragment();
            var prevGroup = "#9?$";
            items.forEach(function (item) {
                if (item["group"] && item["group"] !== prevGroup) {
                    prevGroup = item["group"];
                    var groupDiv = renderGroup(item["group"], inputValue);
                    if (groupDiv) {
                        groupDiv.className += " group";
                        fragment.appendChild(groupDiv);
                    }
                }
                var div = render(item, inputValue);
                if (div) {
                    div.addEventListener("click", function (ev) {
                        input.value = item[labelAttr];
                        settings.onSelect(item, input);
                        console.info("isBeforeStart267 true");
                        isBeforeStart = true;
                        clear();
                        ev.preventDefault();
                        ev.stopPropagation();
                    });
                    if (item === selected) {
                        div.className += " selected";
                    }
                    fragment.appendChild(div);
                }
            });
            container.appendChild(fragment);
            if (items.length < 1) {
                if (settings.emptyMsg) {
                    var empty = doc.createElement("div");
                    empty.className = "empty";
                    empty.textContent = settings.emptyMsg;
                    container.appendChild(empty);
                }
                else {
                    clear();
                    return;
                }
            }
            attach();
            updatePosition();
            updateScroll();
        }
        function updateIfDisplayed() {
            if (containerDisplayed()) {
                update();
            }
        }
        function resizeEventHandler() {
            updateIfDisplayed();
        }
        function scrollEventHandler(e) {
            if (e.target !== container) {
                updateIfDisplayed();
            }
            else {
                e.preventDefault();
            }
        }
        function keyupEventHandler(ev) {
            var keyCode = ev.which || ev.keyCode || 0;
            var ignore = [38 /* Up */, 27 /* Esc */, 39 /* Right */, 37 /* Left */, 16 /* Shift */, 17 /* Ctrl */, 18 /* Alt */, 20 /* CapsLock */, 91 /* WindowsKey */, 9 /* Tab */];
            for (var _i = 0, ignore_1 = ignore; _i < ignore_1.length; _i++) {
                var key = ignore_1[_i];
                if (keyCode === key) {
                    return;
                }
            }
            if (keyCode >= 112 /* F1 */ && keyCode <= 123 /* F12 */) {
                return;
            }
            // the down key is used to open autocomplete
            if (keyCode === 40 /* Down */ && containerDisplayed()) {
                return;
            }
            startFetch(0 /* Keyboard */);
        }
        /**
         * Automatically move scroll bar if selected item is not visible
         */
        function updateScroll() {
            var elements = container.getElementsByClassName("selected");
            if (elements.length > 0) {
                var element = elements[0];
                // make group visible
                var previous = element.previousElementSibling;
                if (previous && previous.className.indexOf("group") !== -1 && !previous.previousElementSibling) {
                    element = previous;
                }
                if (element.offsetTop < container.scrollTop) {
                    container.scrollTop = element.offsetTop;
                }
                else {
                    var selectBottom = element.offsetTop + element.offsetHeight;
                    var containerBottom = container.scrollTop + container.offsetHeight;
                    if (selectBottom > containerBottom) {
                        container.scrollTop += selectBottom - containerBottom;
                    }
                }
            }
        }
        /**
         * Select the previous item in suggestions
         */
        function selectPrev() {
            if (items.length < 1) {
                selected = undefined;
            }
            else {
                if (selected === items[0]) {
                    selected = items[items.length - 1];
                }
                else {
                    for (var i = items.length - 1; i > 0; i--) {
                        if (selected === items[i] || i === 1) {
                            selected = items[i - 1];
                            break;
                        }
                    }
                }
            }
        }
        /**
         * Select the next item in suggestions
         */
        function selectNext() {
            if (items.length < 1) {
                selected = undefined;
            }
            if (!selected || selected === items[items.length - 1]) {
                selected = items[0];
                return;
            }
            for (var i = 0; i < (items.length - 1); i++) {
                if (selected === items[i]) {
                    selected = items[i + 1];
                    break;
                }
            }
        }
        function keydownEventHandler(ev) {
            var keyCode = ev.which || ev.keyCode || 0;
            if (isBeforeStart) {
                if (settings.onSearchStart) {
                    console.info("keydownEventHandler", ev);
                    settings.onSearchStart(input);
                }
                isBeforeStart = false;
            }
            if (ev.keyCode == 65 && ev.ctrlKey) {
                ev.target.select();
            }
            if (keyCode === 38 /* Up */ || keyCode === 40 /* Down */ || keyCode === 27 /* Esc */) {
                var containerIsDisplayed = containerDisplayed();
                if (keyCode === 27 /* Esc */) {
                    clear();
                    // cancel();
                }
                else {
                    if (!containerDisplayed || items.length < 1) {
                        return;
                    }
                    keyCode === 38 /* Up */
                        ? selectPrev()
                        : selectNext();
                    update();
                }
                ev.preventDefault();
                if (containerIsDisplayed) {
                    ev.stopPropagation();
                }
                return;
            }
            if (keyCode === 13 /* Enter */) {
                if (selected) {
                    input.value = selected[labelAttr];
                    settings.onSelect(selected, input);
                    console.info("isBeforeStart444 true");
                    isBeforeStart = true;
                    clear();
                }
                if (preventSubmit) {
                    ev.preventDefault();
                }
            }
        }
        function focusEventHandler() {
            if (showOnFocus) {
                startFetch(1 /* Focus */);
            }
            if (initialItems) {
                items = initialItems;
                update();
            }
            if (input) {
                input.select();
            }
        }
        // function startFetch(trigger: EventTrigger) {
        //     // if multiple keys were pressed, before we get update from server,
        //     // this may cause redrawing our autocomplete multiple times after the last key press.
        //     // to avoid this, the number of times keyboard was pressed will be
        //     // saved and checked before redraw our autocomplete box.
        //     const savedKeypressCounter = ++keypressCounter;
        //     const val = input.value;
        //     if (val.length >= minLen || trigger === EventTrigger.Focus) {
        //         clearDebounceTimer();
        //         debounceTimer = window.setTimeout(function(): void {
        //             settings.fetch(val, function(elements: T[] | false): void {
        //                 if (keypressCounter === savedKeypressCounter && elements) {
        //                     items = elements;
        //                     inputValue = val;
        //                     selected = items.length > 0 ? items[0] : undefined;
        //                     update();
        //                 }
        //             }, EventTrigger.Keyboard);
        //         }, trigger === EventTrigger.Keyboard ? debounceWaitMs : 0);
        //     } else {
        //         clear();
        //     }
        // }
        function addToSearchCounter(i) {
            searchCounter = searchCounter + i;
            console.info("addToSearchCounter(".concat(i, ")=>").concat(searchCounter));
            if (searchCounter < 0) {
                searchCounter = 0;
            }
            if (searchCounter === 0) {
                // console.warn("allSsearchFetchDone");
                if (settings.onSearchFinished) {
                    settings.onSearchFinished(input);
                }
                ;
            }
            else {
                // console.warn("searching");
                if (settings.onSearchStartRunning) {
                    settings.onSearchStartRunning(input);
                }
                ;
            }
        }
        function removePromise(p) {
            promises = promises.filter(function (f) {
                return f !== p;
            });
        }
        function startFetch(trigger) {
            // if multiple keys were pressed, before we get update from server,
            // this may cause redrawing our autocomplete multiple times after the last key press.
            // to avoid this, the number of times keyboard was pressed will be
            // saved and checked before redraw our autocomplete box.
            var savedKeypressCounter = ++keypressCounter;
            // console.info(`startFetch "${input.value}" ${trigger}`, trigger);
            var val = input.value;
            // if (val.length >= minLen || trigger === EventTrigger.Focus) {
            if (val.length >= minLen && val !== lastSearch) {
                if (val === lastSearch) {
                    console.info("equ ".concat(val, " ").concat(lastSearch));
                }
                lastSearch = val;
                clearDebounceTimer();
                debounceTimer = window.setTimeout(function () {
                    addToSearchCounter(1);
                    var promise = settings.fetch(val);
                    promises.push(promise);
                    promise.then(function (elements) {
                        console.info("Autocomnplete.update", elements);
                        // console.info(`autocompleter keypressCounter=${keypressCounter} savedKeypressCounter=${savedKeypressCounter}`, elements);
                        if (keypressCounter === savedKeypressCounter && elements) {
                            items = elements;
                            inputValue = val;
                            selected = items.length > 0 ? items[0] : undefined;
                            update();
                        }
                        addToSearchCounter(-1);
                        removePromise(promise);
                    })["catch"](function (reason) {
                        console.info("fetch not succedded", reason);
                        addToSearchCounter(-1);
                        removePromise(promise);
                    });
                }, trigger === 0 /* Keyboard */ ? debounceWaitMs : 0);
            }
            else {
                console.info("startFetch=>clear");
                clear();
            }
        }
        function blurEventHandler() {
            // we need to delay clear, because when we click on an item, blur will be called before click and remove items from DOM
            setTimeout(function () {
                if (doc.activeElement !== input) {
                    clear();
                }
            }, 200);
        }
        /**
         * Fixes #26: on long clicks focus will be lost and onSelect method will not be called
         */
        container.addEventListener("mousedown", function (evt) {
            evt.stopPropagation();
            evt.preventDefault();
        });
        /**
         * Fixes #30: autocomplete closes when scrollbar is clicked in IE
         * See: https://stackoverflow.com/a/9210267/13172349
         */
        container.addEventListener("focus", function () { return input.focus(); });
        /**
         * This function will remove DOM elements and clear event handlers
         */
        function destroy() {
            input.removeEventListener("focus", focusEventHandler);
            input.removeEventListener("keydown", keydownEventHandler);
            input.removeEventListener(keyUpEventName, keyupEventHandler);
            input.removeEventListener("blur", blurEventHandler);
            window.removeEventListener("resize", resizeEventHandler);
            doc.removeEventListener("scroll", scrollEventHandler, true);
            clearDebounceTimer();
            clear();
        }
        // setup event handlers
        input.addEventListener("keydown", keydownEventHandler);
        input.addEventListener(keyUpEventName, keyupEventHandler);
        input.addEventListener("blur", blurEventHandler);
        input.addEventListener("focus", focusEventHandler);
        window.addEventListener("resize", resizeEventHandler);
        doc.addEventListener("scroll", scrollEventHandler, true);
        return {
            destroy: destroy
        };
    }
    exports["default"] = autocomplete;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./src/ts/util/FormatExpression.ts":
/*!*****************************************!*\
  !*** ./src/ts/util/FormatExpression.ts ***!
  \*****************************************/
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports) {
    "use strict";
    exports.__esModule = true;
    exports.createExpressionFct = void 0;
    function createFormatExpression(s) {
        var tokens = [];
        var token = '';
        for (var i = 0; i < s.length; i++) {
            if (s[i] === '$' && token.length > 0) {
                tokens.push(token);
                token = '$';
            }
            else {
                token += s[i];
                if (s[i] === '}') {
                    tokens.push(token);
                    token = '';
                }
            }
        }
        tokens.push(token);
        return tokens;
    }
    function createExpressionFct(s) {
        var tokens = createFormatExpression(s);
        console.info("createf");
        return function (obj) {
            console.info("kshdkdhjaskkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkk");
            console.info("popup", obj);
            if (tokens.length === 1) {
                return obj[tokens[0]];
            }
            s = '';
            for (var i = 0; i < tokens.length; i++) {
                var token = tokens[i];
                if (token.startsWith('$')) {
                    var attN = token.substring(2, token.length - 1);
                    var v = obj[attN];
                    s += v;
                }
                else {
                    s += token;
                }
            }
            return s;
        };
    }
    exports.createExpressionFct = createExpressionFct;
    ;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./src/ts/util/L.GeocoderMV.ts":
/*!*************************************!*\
  !*** ./src/ts/util/L.GeocoderMV.ts ***!
  \*************************************/
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(/*! leaflet */ "./node_modules/leaflet/dist/leaflet-src.js"), __webpack_require__(/*! ../Util */ "./src/ts/Util.ts")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports, L, Util) {
    "use strict";
    exports.__esModule = true;
    exports.Geocoder = void 0;
    var Geocoder = /** @class */ (function () {
        function Geocoder(key, options) {
            this.options = {
                serviceUrl: undefined,
                nameProperties: ['_title_'],
                geocodingQueryParams: undefined,
                reverseQueryParams: undefined
            };
            this.options = __assign(__assign({}, this.options), options);
            this._key = key;
        }
        Geocoder.prototype.geocode = function (query) {
            var _this = this;
            if (this._activeRequest) {
                console.info("cancel last");
                this._activeRequest.abort();
            }
            var params = __assign({ type: 'search', key: this._key, query: query.toLowerCase() }, this.options.geocodingQueryParams);
            var url = this.options.serviceUrl + Util.getParamString(params);
            var xhr = this._activeRequest = new XMLHttpRequest();
            var promise = new Promise(function (resolve, reject) {
                xhr.onloadend = function () {
                    if (xhr.status === 200) {
                        var json = JSON.parse(xhr.responseText);
                        var data = _this._decodeFeatures(json, params);
                        console.info("resolved");
                        resolve(data);
                    }
                    else {
                        reject({
                            status: xhr.status,
                            statusText: xhr.statusText
                        });
                    }
                };
                xhr.onerror = function (ev) {
                    reject({
                        status: this.status,
                        statusText: xhr.statusText,
                        event: ev
                    });
                };
                xhr.open('GET', url);
                console.info("run request \"".concat(url, "\""));
                xhr.send();
            });
            promise["cancel"] = function () {
                xhr.abort();
                console.info("xhr.canceled");
            };
            return promise;
        };
        /*
        async geocode2(query:string):Promise<any> {
            if (this._activeRequest) {
                console.info("cancel last");
                this._activeRequest.cancel();
            }
            return new Promise<any>( (resolve, reject) => {
                const params = {
                    type: 'search',
                    key: this._key,
                    query: query.toLowerCase(),
                    ...this.options.geocodingQueryParams
                }
                console.info("create Request");
                const promise = this._activeRequest = Util.loadJson(this.options.serviceUrl, params);
                promise.then(
                    data => {
                        console.info("loadJson=>then");
                        this._activeRequest = undefined;
                        resolve(this._decodeFeatures(data, params));
                    }
                ).catch(reason => {
                    this._activeRequest = undefined;
                    reject(reason);
                });
            });
    
            // getJSON(
            //     this.options.serviceUrl,
            //     params,
            //     (data) => { cb.call(context, this._decodeFeatures(data, params.query)) }
            // )
        }
    */
        Geocoder.prototype.suggest = function (query) {
            return this.geocode(query);
        };
        Geocoder.prototype.reverse = function (latLng, scale, cb, context) {
            var _this = this;
            var bb = latLng.toBounds(200);
            var params = {
                type: 'reverse',
                key: this._key,
                query: latLng.lng + ',' + latLng.lat,
                bbox: bb.getWest() + ',' + bb.getNorth() + ',' + bb.getEast() + ',' + bb.getSouth(),
                bbox_epsg: '4326'
            };
            params = __assign(__assign({}, this.options.reverseQueryParams), params);
            Util.loadJson(this.options.serviceUrl, params).then(function (data) {
                cb.call(context, _this._decodeReverseFeatures(data));
            });
            // getJSON(
            //     this.options.serviceUrl,
            //     params,
            //     (data: any) => { cb.call(context, this._decodeReverseFeatures(data)) }
            // );
        };
        Geocoder.prototype._decodeFeatures = function (data, query) {
            // console.info(`decodeFeatures ${query.class}`, query, data);
            var results = [];
            var group = query["class"];
            // console.info(query, data);
            if (data && data.features) {
                for (var i = 0; i < data.features.length; i++) {
                    var f = data.features[i];
                    if (f.properties.objektgruppe === "Adresse") {
                        results.push({
                            name: this._deocodeFeatureNameAdresse(f),
                            group: f.properties.objektgruppe,
                            // html: this.options.htmlTemplate ? this.options.htmlTemplate(f) : undefined,
                            feature: f
                        });
                    }
                    else if (f.properties.objektgruppe === "Strae") {
                        results.push({
                            name: this._deocodeFeatureNameStrasse(f),
                            group: f.properties.objektgruppe,
                            // html: this.options.htmlTemplate ? this.options.htmlTemplate(f) : undefined,
                            feature: f
                        });
                    }
                    else if (f.properties.objektgruppe === "Gemeindeteil") {
                        results.push({
                            name: this._deocodeFeatureNameGemeindeteil(f),
                            group: f.properties.objektgruppe,
                            // html: this.options.htmlTemplate ? this.options.htmlTemplate(f) : undefined,
                            feature: f
                        });
                    }
                    else if (f.properties.objektgruppe === "Gemeinde") {
                        results.push({
                            name: this._deocodeFeatureNameGemeinde(f),
                            group: f.properties.objektgruppe,
                            // html: this.options.htmlTemplate ? this.options.htmlTemplate(f) : undefined,
                            feature: f
                        });
                    }
                    else {
                        results.push({
                            name: this._deocodeFeatureName(f),
                            group: f.properties.objektgruppe,
                            // html: this.options.htmlTemplate ? this.options.htmlTemplate(f) : undefined,
                            feature: f
                        });
                    }
                }
            }
            return results;
        };
        Geocoder.prototype._decodeReverseFeatures = function (data) {
            var results = [];
            if (data && data.features) {
                for (var i = 0; i < data.features.length; i++) {
                    var f = data.features[i];
                    if (f.properties.objektgruppe === "Adresse") {
                        results.push({
                            name: this._deocodeFeatureNameAdresse(f),
                            html: this.options.htmlTemplate ? this.options.htmlTemplate(f) : undefined,
                            feature: f,
                            properties: f.properties,
                            center: new L.LatLng(f.geometry.coordinates[1], f.geometry.coordinates[0])
                        });
                    }
                }
            }
            return results;
        };
        Geocoder.prototype._deocodeFeatureNameGemeinde = function (f) {
            var name = f.properties['gemeinde_name'];
            var idx = name.indexOf(',');
            return (idx > 0) ? name.substring(0, idx) : name;
        };
        Geocoder.prototype._deocodeFeatureNameGemeindeteil = function (f) {
            var gemeinde_name = f.properties['gemeinde_name'];
            var gemeindeteil_name = f.properties['gemeindeteil_name'];
            var idx = gemeinde_name.indexOf(',');
            var name = (idx > 0) ? gemeinde_name.substring(0, idx) : gemeinde_name;
            if (gemeindeteil_name && name !== gemeindeteil_name) {
                name += ", " + gemeindeteil_name;
            }
            return name;
        };
        Geocoder.prototype._deocodeFeatureNameStrasse = function (f) {
            var gemeinde_name = f.properties['gemeinde_name'];
            var gemeindeteil_name = f.properties['gemeindeteil_name'];
            var strasse_name = f.properties['strasse_name'];
            var idx = gemeinde_name.indexOf(',');
            // console.info(gemeinde_name + " " + idx);
            var name = (idx > 0) ? gemeinde_name.substring(0, idx) : gemeinde_name;
            if (gemeindeteil_name && name !== gemeindeteil_name) {
                name += ", " + gemeindeteil_name;
            }
            name += ", " + strasse_name;
            return name;
        };
        Geocoder.prototype._deocodeFeatureNameAdresse = function (f) {
            var gemeinde_name = f.properties['gemeinde_name'];
            var gemeindeteil_name = f.properties['gemeindeteil_name'];
            var strasse_name = f.properties['strasse_name'];
            var idx = gemeinde_name.indexOf(',');
            var name = (idx > 0) ? gemeinde_name.substring(0, idx) : gemeinde_name;
            if (gemeindeteil_name && name !== gemeindeteil_name) {
                name += ", " + gemeindeteil_name;
            }
            name += ", " + strasse_name;
            var hausnummer = f.properties['hausnummer'];
            var hausnummer_zusatz = f.properties['hausnummer_zusatz'];
            if (hausnummer) {
                name += " " + hausnummer;
            }
            if (hausnummer_zusatz) {
                name += hausnummer_zusatz;
            }
            return name;
        };
        Geocoder.prototype._deocodeFeatureName = function (f) {
            var name;
            for (var j = 0; !name && j < this.options.nameProperties.length; j++) {
                name = f.properties[this.options.nameProperties[j]];
            }
            if (f.properties.objektgruppe === "Gemeindeteil" || f.properties.objektgruppe === "Gemeinde") {
                var idx = f.properties['_title_'].indexOf(',');
                name = (idx > 0) ? f.properties['_title_'].substring(0, idx) : f.properties['_title_'];
            }
            return name;
        };
        return Geocoder;
    }());
    exports.Geocoder = Geocoder;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./src/ts/widget/Accordion.ts":
/*!************************************!*\
  !*** ./src/ts/widget/Accordion.ts ***!
  \************************************/
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(/*! ../Util */ "./src/ts/Util.ts")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports, Util_1) {
    "use strict";
    exports.__esModule = true;
    exports.Accordion = exports.AccordionItem = void 0;
    var AccordionItem = /** @class */ (function () {
        function AccordionItem(title, content) {
            this.title = title;
            this.content = content;
        }
        AccordionItem.prototype.render = function () {
            var dom = this.dom = document.createElement('div');
            dom.className = 'accordion-item';
            var titleDiv = (0, Util_1.createHtmlElement)('div', dom);
            var span = (0, Util_1.createHtmlElement)('span', titleDiv);
            var i = (0, Util_1.createHtmlElement)('span', titleDiv, 'icon');
            span.innerHTML = this.title;
            titleDiv.addEventListener('click', function (evt) { dom.classList.toggle('opened'); });
            if (this.content) {
                dom.appendChild(this.content);
            }
            return dom;
        };
        AccordionItem.prototype.setCollapsed = function (collapse) {
            if (collapse) {
                this.dom.classList.remove('opened');
            }
            else {
                this.dom.classList.add('opened');
            }
        };
        return AccordionItem;
    }());
    exports.AccordionItem = AccordionItem;
    var Accordion = /** @class */ (function () {
        function Accordion(items) {
            this.items = items;
        }
        Accordion.prototype.render = function () {
            var dom = document.createElement('div');
            dom.className = 'accordion';
            var items = this.items;
            for (var i = 0; i < items.length; i++) {
                var itemDom = items[i].render();
                if (i === 0) {
                    itemDom.classList.add('opened');
                }
                dom.appendChild(itemDom);
            }
            return dom;
        };
        return Accordion;
    }());
    exports.Accordion = Accordion;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "../treecomponent/src/ts/Tree.ts":
/*!***************************************!*\
  !*** ../treecomponent/src/ts/Tree.ts ***!
  \***************************************/
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(/*! strongly-typed-events */ "../treecomponent/node_modules/strongly-typed-events/dist/index.js"), __webpack_require__(/*! ./TreeNode */ "../treecomponent/src/ts/TreeNode.ts")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports, strongly_typed_events_1, TreeNode_1) {
    "use strict";
    exports.__esModule = true;
    exports.Tree = void 0;
    var Tree = /** @class */ (function () {
        function Tree(nodes, param) {
            var _this = this;
            this.selectMode = TreeNode_1.SelectionMode.SINGLE;
            this.onSelectionChange = new strongly_typed_events_1.EventDispatcher();
            this.pane = null;
            this.nodes = [];
            if (param) {
                for (var k in param) {
                    this[k] = param[k];
                }
                if (param.expandOnlyOneNode) {
                    this.childExpandChangeHandler = function (node, expanded) { return _this.childExpandChanged(node, expanded); };
                }
            }
            this.nodeSelectionChangeHandler = function (node, status) { return _this.nodeSelected(node, status); };
            if (nodes) {
                this.nodes = nodes;
                for (var i = 0, count = nodes.length; i < count; i++) {
                    nodes[i].setTree(this);
                    nodes[i].onSelectionChange.subscribe(this.nodeSelectionChangeHandler);
                    if (this.expandOnlyOneNode) {
                        nodes[i].onExpandChange.subscribe(this.childExpandChangeHandler);
                    }
                }
            }
            else {
                this.nodes = [];
            }
        }
        Tree.prototype._render = function () {
            var pane = document.createElement("div");
            pane.className = "treecontainer";
            for (var i = 0, count = this.nodes.length; i < count; i++) {
                pane.appendChild(this.nodes[i].render());
            }
            return this.pane = pane;
        };
        Tree.prototype._mutation = function (mutations, observer) {
            var _this = this;
            this.resize();
            var f = function () { return _this.resize(); };
            window.setTimeout(f, 520);
        };
        Tree.prototype._update = function () {
            var pane = this.pane;
            var newChilds = [];
            for (var i = 0, count = this.nodes.length; i < count; i++) {
                newChilds.push(this.nodes[i].render());
            }
            pane.replaceChildren.apply(pane, newChilds);
            console.info("replacc");
            return this.pane = pane;
        };
        Tree.prototype.moveNodeUp = function (n) {
            console.info('moveNodeUp');
            var idx = this.nodes.indexOf(n);
            if (idx > 0) {
                var otherNode = this.nodes[idx - 1];
                this.nodes[idx - 1] = n;
                this.nodes[idx] = otherNode;
            }
            this._update();
        };
        Tree.prototype.moveNodeDown = function (n) {
            console.info('moveNodeDown');
            var idx = this.nodes.indexOf(n);
            if (idx < this.nodes.length - 1) {
                var otherNode = this.nodes[idx + 1];
                this.nodes[idx + 1] = n;
                this.nodes[idx] = otherNode;
            }
            this._update();
        };
        Tree.prototype.resize = function () {
            // console.info("Tree "+ this.nodes.length, this.pane.getBoundingClientRect());        
            for (var i = 0, count = this.nodes.length; i < count; i++) {
                this.nodes[i].resize();
            }
        };
        Tree.prototype.addNode = function (node) {
            // console.info("addNode", node);
            node.setTree(this);
            node.onSelectionChange.subscribe(this.nodeSelectionChangeHandler);
            if (this.expandOnlyOneNode) {
                node.onExpandChange.subscribe(this.childExpandChangeHandler);
            }
            this.nodes.push(node);
            if (this.pane) {
                var el = node.render();
                this.pane.appendChild(el);
            }
        };
        Tree.prototype.addNodes = function (nodes) {
            // console.info("addNode", node);
            var newNodes = [];
            var d = document.createDocumentFragment();
            for (var i = 0; i < nodes.length; i++) {
                var node = nodes[i];
                node.setTree(this);
                node.onSelectionChange.subscribe(this.nodeSelectionChangeHandler);
                if (this.expandOnlyOneNode) {
                    node.onExpandChange.subscribe(this.childExpandChangeHandler);
                }
                this.nodes.push(node);
                newNodes.push(node);
                d.appendChild(node.render());
            }
            if (this.pane) {
                // let el = node.render()
                this.pane.appendChild(d);
            }
        };
        Tree.prototype.insertNode = function (node, pos) {
            node.setTree(this);
            node.onSelectionChange.subscribe(this.nodeSelectionChangeHandler);
            if (this.expandOnlyOneNode) {
                node.onExpandChange.subscribe(this.childExpandChangeHandler);
            }
            var nodes = [];
            for (var i = 0, count = this.nodes.length; i < count; i++) {
                if (i === pos) {
                    nodes.push(node);
                }
                nodes.push(this.nodes[i]);
            }
            if (pos < this.nodes.length) {
                this.pane.insertBefore(node.render(), this.nodes[pos].dom);
            }
            else {
                this.pane.appendChild(node.render());
            }
            this.nodes = nodes;
        };
        Tree.prototype.findNode = function (data, node) {
            var nodes = node ? node.childs : this.nodes;
            if (nodes) {
                for (var i = 0, count = nodes.length; i < count; i++) {
                    if (data === nodes[i].data) {
                        return nodes[i];
                    }
                    else {
                        var node_1 = this.findNode(data, nodes[i]);
                        if (node_1) {
                            return node_1;
                        }
                    }
                }
            }
            return null;
        };
        Tree.prototype.selectNode = function (data, prop) {
            for (var i = 0, count = this.nodes.length; i < count; i++) {
                var selNodes = this.nodes[i].selectNode(data, prop);
                if (selNodes) {
                    return selNodes;
                }
            }
        };
        Tree.prototype.unselectNode = function (data, prop) {
            for (var i = 0, count = this.nodes.length; i < count; i++) {
                var selNodes = this.nodes[i].unselectNode(data, prop);
            }
        };
        Tree.prototype.selectAndExpandNode = function (data, prop) {
            for (var i = 0, count = this.nodes.length; i < count; i++) {
                var selNodes = this.nodes[i].selectNode(data, prop);
                // console.info('selectNode', selNodes);
                if (selNodes) {
                    return selNodes;
                }
            }
        };
        Tree.prototype.expandAll = function () {
            for (var i = 0, count = this.nodes.length; i < count; i++) {
                this.nodes[i].expand();
            }
        };
        Tree.prototype.removeNode = function (node) {
            // console.info("removeNode", node);
            node.setTree(null);
            node.onSelectionChange.unsubscribe(this.nodeSelectionChangeHandler);
            if (this.expandOnlyOneNode) {
                node.onExpandChange.unsubscribe(this.childExpandChangeHandler);
            }
            // node.off("change", this.selectionChanged, this);
            if (node.parent) {
                node.parent._removeChild(node);
            }
            else {
                var nodes = [];
                for (var i = 0, count = this.nodes.length; i < count; i++) {
                    if (this.nodes[i] !== node) {
                        nodes.push(this.nodes[i]);
                    }
                    else {
                        console.info("removeNode " + i, this.nodes[i]);
                    }
                }
                node.remove();
                this.nodes = nodes;
            }
        };
        Tree.prototype.onResize = function (ev) {
            this.resize();
        };
        Tree.prototype.addTo = function (elem) {
            var _this = this;
            if (!this.pane) {
                this._render();
                window.addEventListener("resize", function (ev) { return _this.onResize(ev); });
            }
            var pane = this.getDom();
            pane.addEventListener("resize", function (ev) { return _this.onResize(ev); });
            elem.addEventListener("resize", function (ev) { return _this.onResize(ev); });
            elem.appendChild(this.getDom());
        };
        Tree.prototype.getWidh = function () {
            return (this.pane && this.pane.parentElement) ? this.pane.parentElement.clientWidth : -1;
        };
        Tree.prototype.getBoundingClientRect = function () {
            return (this.pane && this.pane.parentElement) ? this.pane.getBoundingClientRect() : null;
        };
        Tree.prototype.getDom = function () {
            return this.pane;
        };
        /**
         * return the Data of the selected nodes
         */
        Tree.prototype.getSelected = function () {
            var result = [];
            for (var i = 0, count = this.nodes.length; i < count; i++) {
                result = result.concat(this.nodes[i].getSelected());
            }
            return result;
        };
        Tree.prototype.childExpandChanged = function (node, expanded) {
            console.info("childExpandChanged");
            if (expanded && this.expandOnlyOneNode) {
                var count = this.nodes ? this.nodes.length : 0;
                for (var i = 0; i < count; i++) {
                    if (node !== this.nodes[i]) {
                        this.nodes[i].collapse();
                    }
                }
            }
        };
        // nodeSelected(evt:L.LeafletEvent) {
        Tree.prototype.nodeSelected = function (node, status) {
            // console.info(`Tree nodeSelected(${node.data.name} status=${SelectionStatus[status]}) selectedNode=${this.selectedNode ? this.selectedNode.data.name : "undefined"}`);
            if (this.selectMode === TreeNode_1.SelectionMode.SINGLE) {
                if (this.selectedNode) {
                    // console.info(`oldSelectedNode=${this.selectedNode.data.name}  `+this.selectedNode.data.name);
                    if (this.selectedNode !== node) {
                        this.selectedNode.setSelected(false);
                    }
                }
                if (node && node.selectionStatus === TreeNode_1.SelectionStatus.SELECTED) {
                    this.selectedNode = node;
                    // console.info("dispatch02");
                    this.onSelectionChange.dispatch(this.selectedNode, status);
                }
                else {
                    // console.info("dispatch03");
                    this.onSelectionChange.dispatch(node, status);
                }
            }
            else {
                this.onSelectionChange.dispatch(node, status);
            }
        };
        Tree.NODE_SELECTION_CHANGE_EVENT = "nodeSelectionChange";
        Tree.NODE_SELECTED_EVENT = "node_selected";
        Tree.NODE_UNSELECTED_EVENT = "node_unselected";
        return Tree;
    }());
    exports.Tree = Tree;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "../treecomponent/src/ts/TreeNode.ts":
/*!*******************************************!*\
  !*** ../treecomponent/src/ts/TreeNode.ts ***!
  \*******************************************/
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(/*! strongly-typed-events */ "../treecomponent/node_modules/strongly-typed-events/dist/index.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports, strongly_typed_events_1) {
    "use strict";
    exports.__esModule = true;
    exports.RadioGroupTreeNode = exports.TreeNode = exports.SelectionStatus = exports.SelectionMode = void 0;
    var SelectionMode;
    (function (SelectionMode) {
        SelectionMode[SelectionMode["MULTI"] = 0] = "MULTI";
        SelectionMode[SelectionMode["SINGLE"] = 1] = "SINGLE";
        SelectionMode[SelectionMode["RADIO"] = 2] = "RADIO";
        // Node with childs where one can be choosen
        SelectionMode[SelectionMode["RADIO_GROUP"] = 3] = "RADIO_GROUP";
    })(SelectionMode = exports.SelectionMode || (exports.SelectionMode = {}));
    // let nodeCounter = 1;
    var standardRender = {
        render: function (node) {
            var div = document.createElement("div");
            if (typeof node.data === 'string') {
                div.innerHTML = node.data;
                div.dataset.tooltip = node.data;
                div.setAttribute("data-tooltip", node.data);
                div.title = node.data;
            }
            else {
                var txt = (node.attName2Render) ? node.data[node.attName2Render] : node.data.name;
                if (!txt) {
                    debugger;
                }
                div.innerHTML = txt;
                div.dataset.tooltip = txt;
                div.setAttribute("data-tooltip", txt);
                div.title = txt;
            }
            div.className = 'tooltip';
            return div;
        }
    };
    var SelectionStatus;
    (function (SelectionStatus) {
        SelectionStatus[SelectionStatus["SELECTED"] = 0] = "SELECTED";
        SelectionStatus[SelectionStatus["UNSELECTED"] = 1] = "UNSELECTED";
        SelectionStatus[SelectionStatus["INDETERMINATE"] = 2] = "INDETERMINATE";
    })(SelectionStatus = exports.SelectionStatus || (exports.SelectionStatus = {}));
    var TreeNode = /** @class */ (function () {
        function TreeNode(data, childs, params) {
            var _this = this;
            this.onSelectionChange = new strongly_typed_events_1.EventDispatcher();
            this.onExpandChange = new strongly_typed_events_1.EventDispatcher();
            this.nodeRenderer = standardRender;
            // selected: boolean = false;
            this.selectionStatus = SelectionStatus.UNSELECTED;
            this.showOnlyChilds = false;
            this.hideEmptyNode = false;
            this.css_prop = TreeNode._css_prop;
            this.collapsed = true;
            this.data = data;
            this.childs = childs;
            this.nodeSelectionChangeHandler = function (node, selectionStatus) { return _this.childSelected(node, selectionStatus); };
            if (params) {
                for (var k in params) {
                    this[k] = params[k];
                }
                if (params.expandOnlyOneNode) {
                    this.childExpandChangeHandler = function (node, expanded) { return _this.childExpandChanged(node, expanded); };
                }
            }
            if (childs && childs.length > 0) {
                for (var i = 0, count = childs.length; i < count; i++) {
                    childs[i].onSelectionChange.subscribe(this.nodeSelectionChangeHandler);
                    childs[i].parent = this;
                    if (params === null || params === void 0 ? void 0 : params.expandOnlyOneNode) {
                        childs[i].onExpandChange.subscribe(this.childExpandChangeHandler);
                    }
                }
            }
            if (this.actions) {
                var actions = this.actions;
                var f = function (evt) { return _this.actionChanged(evt); };
                for (var i = 0; i < actions.length; i++) {
                    actions[i].addListener(f);
                }
            }
        }
        TreeNode.prototype.actionChanged = function (evt) {
            this.render();
        };
        TreeNode.prototype.getWidh = function () {
            if (this.tree) {
                return this.tree.getWidh();
            }
            return -1;
        };
        TreeNode.prototype.setTree = function (tree) {
            this.tree = tree;
            var childs = this.childs;
            if (childs && childs.length > 0) {
                for (var i = 0, count = childs.length; i < count; i++) {
                    childs[i].setTree(tree);
                }
            }
        };
        TreeNode.prototype.setChilds = function (childs) {
            this._removeChilds();
            if (childs && childs.length > 0) {
                for (var i = 0, count = childs.length; i < count; i++) {
                    childs[i].onSelectionChange.subscribe(this.nodeSelectionChangeHandler);
                    // childs[i].on("change", this.childChanged, this);
                    // childs[i].on("selected", this.childSelected, this);
                    childs[i].parent = this;
                    if (this.tree) {
                        childs[i].setTree(this.tree);
                    }
                }
            }
            this.childs = childs;
            this.render();
        };
        TreeNode.prototype.findNode = function (data, prop) {
            // console.info(data+" "+prop, this.data, this.data[prop])
            if ((prop && this.data[prop] === data) || this.data === data) {
                return [this];
            }
            else if (this.childs) {
                for (var i = 0, count = this.childs.length; i < count; i++) {
                    var selNodes = this.childs[i].findNode(data, prop);
                    if (selNodes) {
                        selNodes.push(this);
                        return selNodes;
                    }
                }
            }
        };
        TreeNode.prototype.selectNode = function (data, prop) {
            // console.info(data+" "+prop, this.data, this.data[prop])
            if ((prop && this.data[prop] === data) || this.data === data) {
                // console.error("TreeNode.selectNode");
                this.setSelected(true);
                return [this];
            }
            else if (this.childs) {
                for (var i = 0, count = this.childs.length; i < count; i++) {
                    var selNodes = this.childs[i].selectNode(data, prop);
                    if (selNodes) {
                        selNodes.push(this);
                        return selNodes;
                    }
                }
            }
        };
        TreeNode.prototype.unselectNode = function (data, prop) {
            if ((prop && this.data[prop] === data) || this.data === data) {
                this.setSelected(false);
                return [this];
            }
            else if (this.childs) {
                for (var i = 0, count = this.childs.length; i < count; i++) {
                    var selNodes = this.childs[i].unselectNode(data, prop);
                    if (selNodes) {
                        selNodes.push(this);
                        return selNodes;
                    }
                }
            }
        };
        TreeNode.prototype.addNode = function (child) {
            // child.on("selected", this.childSelected, this);
            // console.info(`addNode childInset=${this.insetChilds}`, this.data, child.data);
            child.onSelectionChange.subscribe(this.nodeSelectionChangeHandler);
            if (this.onExpandChange) {
                child.onExpandChange.subscribe(this.childExpandChangeHandler);
            }
            if (!this.childs) {
                this.childs = [];
            }
            child.parent = this;
            child.setTree(this.tree);
            this.childs.push(child);
            if (this.dom) {
                if (!this.childDom) {
                    var nodecontainer = this.childDom = document.createElement('div');
                    nodecontainer.className = "nodecontainer";
                    this.dom.appendChild(nodecontainer);
                    // rtr nodecontainer.style.display = 'none'
                }
                this.childDom.appendChild(child.render(this.insetChilds));
                var childCount = this.childs ? this.childs.length : 0;
                // const col = TreeNode.getTreePath(this).length;
                // this.treerow.style.paddingLeft = ((col - 1) * 1.9 + 0.3) + "rem"
                var col = TreeNode.getTreePath(this).length;
                var inset = col;
                if (childCount > 0) {
                    // this.treerow.style.paddingLeft = ((col - 1) * 1.18 + 0.3) + "rem";
                    // let s = `calc(${col - 1} * (${this.css_prop.iconWidth} + ${this.css_prop.iconDistance}) + ${this.css_prop.treePadding})`;
                    // this.treerow.style.paddingLeft = `calc(${col - 1} * (${this.css_prop.iconWidth} + ${this.css_prop.iconDistance}) + ${this.css_prop.treePadding})`;
                    if (this.isCollapsed()) {
                        // this.spanOpenClose.innerText = String.fromCharCode(9660);
                        this.childDom.classList.replace('opened', 'closed');
                        this.spanOpenClose.classList.add('closed');
                        this.spanOpenClose.classList.remove('opened');
                    }
                    else {
                        // this.spanOpenClose.innerText = String.fromCharCode(9654);                    
                        this.childDom.classList.replace('closed', 'opened');
                        this.spanOpenClose.classList.add('opened');
                        this.spanOpenClose.classList.remove('closed');
                    }
                    this.treerow.classList.remove('leaf');
                }
                else {
                    // this.treerow.style.paddingLeft = ((col - 2) * 1.18 + 0.3) + "rem";
                    // this.treerow.style.paddingLeft = `calc(${col - 1} * (${this.css_prop.iconWidth} + ${this.css_prop.iconDistance}) + ${this.css_prop.treePadding})`;
                }
            }
        };
        TreeNode.prototype.remove = function () {
            this.dom.remove();
        };
        TreeNode.prototype._removeChilds = function () {
            var childs = this.childs;
            if (childs && childs.length > 0) {
                for (var i = 0, count = childs.length; i < count; i++) {
                    childs[i].onSelectionChange.unsubscribe(this.nodeSelectionChangeHandler);
                }
            }
            this.childs = null;
        };
        TreeNode.prototype._removeChild = function (node) {
            var nodes = [];
            for (var i = 0, count = this.childs.length; i < count; i++) {
                if (this.childs[i] !== node) {
                    nodes.push(this.childs[i]);
                }
                else {
                    console.info("removeNode " + i, this.childs[i]);
                }
            }
            node.onSelectionChange.unsubscribe(this.nodeSelectionChangeHandler);
            node.remove();
            this.childs = nodes;
            this.render();
        };
        TreeNode.prototype.isCollapsed = function () {
            return this.collapsed;
            // return this.childDom && this.childDom.style.display == 'flex'
        };
        /**
         * expands this node and childs if onlyCurrentNode is not true
         */
        TreeNode.prototype.expand = function (onlyCurrentNode) {
            if (this.collapsed) {
                this.collapsed = false;
                if (this.dom) {
                    this.dom.classList.replace('closed', 'opened');
                    this.spanOpenClose.classList.replace('closed', 'opened');
                }
            }
            if (!onlyCurrentNode && this.childs) {
                for (var i = 0, count = this.childs.length; i < count; i++) {
                    this.childs[i].expand();
                }
            }
        };
        TreeNode.prototype.collapse = function () {
            if (!this.collapsed) {
                this.collapsed = true;
                if (this.dom) {
                    this.dom.classList.replace('opened', 'closed');
                    this.spanOpenClose.classList.replace('opened', 'closed');
                }
            }
        };
        TreeNode.prototype.getSelectMode = function () {
            if (this.selectMode !== undefined) {
                return this.selectMode;
            }
            else {
                if (this.parent) {
                    return this.parent.getSelectMode();
                }
                else {
                    if (this.tree) {
                        return this.tree.selectMode;
                    }
                }
            }
            return SelectionMode.SINGLE;
        };
        /*
            render20210521(inset?:number): HTMLElement {
                // console.info(`render inset=${inset}`, this.data, this.collapsed);
                const col = TreeNode.getTreePath(this).length;
                if (!inset) {
                    inset = 0;
                }
                let insetSelf = 0;
                // let inset = col-1;
        
                let dom = this.dom;
                let treerow = this.treerow
                if (!dom) {
                    dom = this.dom = document.createElement("div");
                    dom.className = 'row-wrapper',
                    treerow = this.treerow = document.createElement('div');
                    treerow.id = "treerow" + nodeCounter
                    treerow.className = "treerow";
                    // if (!this.showOnlyChilds) {
                    //     dom.appendChild(treerow);
                    // }
        
                    const childCount = this.childs ? this.childs.length : 0
                    const selectMode = this.getSelectMode();
                    const span = document.createElement('div');
                    span.className = "treeicon";
        
                    const spanOpenClose = this.spanOpenClose = document.createElement('span');
                    spanOpenClose.addEventListener('click', (ev) => this.onTreeIconClick(ev));
                    insetSelf++;
        
                    if (this.collapsed) {
                        this.dom.classList.add('closed');
                    }
                    else {
                        this.dom.classList.add('opened');
                    }
        
                    if (childCount > 0) {
                        // treerow.style.paddingLeft = `calc(${col - 1} * (${this.css_prop.iconWidth} + ${this.css_prop.iconDistance}) + ${this.css_prop.treePadding})`;
                        if (this.collapsed) {
                            this.spanOpenClose.classList.add('closed');
                        }
                        else {
                            this.spanOpenClose.classList.add('opened');
                        }
                    }
                    else {
                        if (selectMode === SelectionMode.SINGLE) {
                            treerow.addEventListener('click', (ev) => this.itemClicked(ev));
                        }
                        // treerow.style.paddingLeft = (col - 2) * 2.8 + 0.3) + "rem"
                        if (selectMode === SelectionMode.RADIO) {
                            // this.treerow.style.paddingLeft = `calc(${col - 1} * (${this.css_prop.iconWidth} + ${this.css_prop.iconDistance}) + ${this.css_prop.treePadding})`;
                            //treerow.style.paddingLeft = ((col-1)*1.18 + 0.3) + "rem"
                        } else {
                            // treerow.style.paddingLeft = ((col)*1.18 + 0.3) + "rem";
                            // this.treerow.style.paddingLeft = `calc(${col} * (${this.css_prop.iconWidth} + ${this.css_prop.iconDistance}) + ${this.css_prop.treePadding})`;
                        }
                        if (col > 1) {
                            treerow.className = 'treerow leaf'
                        }
                        // spanOpenClose.innerHTML = "&nbsp;"
                    }
                    this.textNode = spanOpenClose
                    span.appendChild(spanOpenClose);
                    if (selectMode === SelectionMode.MULTI) {
                        const cb: HTMLInputElement = this._createCeckBox()
                        span.appendChild(cb);
                        const label = document.createElement("label");
                        span.appendChild(label);
                        label.addEventListener('click', function () { cb.click() });
                        insetSelf++;
                    } else if (selectMode === SelectionMode.RADIO) {
                        const cb: HTMLInputElement = this._createRadioBttn()
                        span.appendChild(cb);
                        const label = document.createElement("label");
                        span.appendChild(label)
                        label.addEventListener('click', function () {
                            cb.click();
                        });
                        insetSelf++;
                    }
                    // let inseg = 0;
                    for (let i=0; i<inset ; i++) {
                        const insetBlock = document.createElement("span");
                        insetBlock.className = "inset-block";
                        treerow.appendChild(insetBlock);
                        // inseg++;
                    }
                    // console.info(`inseg=${inseg}`)
                    treerow.appendChild(span);
                    const labelDiv = document.createElement("div")
                    labelDiv.className = 'treelabel'
                    const label = this.nodeRenderer.render(this)
                    if (label) {
                        labelDiv.appendChild(label)
                        treerow.appendChild(labelDiv);
                    }
        
                    if (this.actions) {
                        treerow.appendChild(this.renderActions())
                    }
        
                    let nodecontainer = this.childDom;
                    if (nodecontainer) {
                        nodecontainer.innerHTML = null
                    }
        
                    if (childCount > 0) {
                        if (!nodecontainer) {
                            nodecontainer = this.childDom = document.createElement('div');
                            nodecontainer.className = "nodecontainer"
                            dom.appendChild(nodecontainer);
                            // nodecontainer.style.display = 'none'
                        }
                        for (let i = 0; i < this.childs.length; i++) {
                            nodecontainer.appendChild(this.childs[i].render(inset+insetSelf));
                        }
        
                    }
                    this.dom.style.display = (this.hideEmptyNode && childCount === 0) ? 'none' : 'flex';
                }
                this.insetChilds = inset+insetSelf;
                return dom
            }
        */
        TreeNode.prototype.render = function (inset) {
            var _this = this;
            // console.info(`render inset=${inset}`, this.data, this.collapsed, this.showOnlyChilds);
            var col = TreeNode.getTreePath(this).length;
            if (!inset) {
                inset = 0;
            }
            var insetSelf = 0;
            // let inset = col-1;
            var dom = this.dom;
            var treerow = this.treerow;
            if (!dom) {
                dom = this.dom = document.createElement("div");
                dom.className = 'row-wrapper',
                    treerow = this.treerow = document.createElement('div');
                treerow.id = "treerow" + TreeNode.nodeCounter++;
                treerow.className = "treerow";
                // console.info(`showOnlyChilds=${this.showOnlyChilds}`);
                if (!this.showOnlyChilds) {
                    dom.appendChild(treerow);
                }
                var childCount = this.childs ? this.childs.length : 0;
                var selectMode = this.getSelectMode();
                var span = document.createElement('div');
                span.className = "treeicon";
                var spanOpenClose = this.spanOpenClose = document.createElement('span');
                spanOpenClose.addEventListener('click', function (ev) { return _this.onTreeIconClick(ev); });
                insetSelf++;
                if (this.collapsed) {
                    this.dom.classList.add('closed');
                }
                else {
                    this.dom.classList.add('opened');
                }
                if (childCount > 0) {
                    // treerow.style.paddingLeft = `calc(${col - 1} * (${this.css_prop.iconWidth} + ${this.css_prop.iconDistance}) + ${this.css_prop.treePadding})`;
                    if (this.collapsed) {
                        this.spanOpenClose.classList.add('closed');
                    }
                    else {
                        this.spanOpenClose.classList.add('opened');
                    }
                }
                else {
                    if (selectMode === SelectionMode.SINGLE) {
                        treerow.addEventListener('click', function (ev) { return _this.itemClicked(ev); });
                    }
                    // treerow.style.paddingLeft = (col - 2) * 2.8 + 0.3) + "rem"
                    if (selectMode === SelectionMode.RADIO) {
                        // this.treerow.style.paddingLeft = `calc(${col - 1} * (${this.css_prop.iconWidth} + ${this.css_prop.iconDistance}) + ${this.css_prop.treePadding})`;
                        //treerow.style.paddingLeft = ((col-1)*1.18 + 0.3) + "rem"
                    }
                    else {
                        // treerow.style.paddingLeft = ((col)*1.18 + 0.3) + "rem";
                        // this.treerow.style.paddingLeft = `calc(${col} * (${this.css_prop.iconWidth} + ${this.css_prop.iconDistance}) + ${this.css_prop.treePadding})`;
                    }
                    if (col > 1) {
                        treerow.className = 'treerow leaf';
                    }
                    // spanOpenClose.innerHTML = "&nbsp;"
                }
                this.textNode = spanOpenClose;
                span.appendChild(spanOpenClose);
                if (selectMode === SelectionMode.MULTI) {
                    var cb_1 = this._createCeckBox();
                    span.appendChild(cb_1);
                    var label_1 = document.createElement("label");
                    span.appendChild(label_1);
                    label_1.addEventListener('click', function () { cb_1.click(); });
                    insetSelf++;
                }
                else if (selectMode === SelectionMode.RADIO) {
                    var cb_2 = this._createRadioBttn();
                    span.appendChild(cb_2);
                    var label_2 = document.createElement("label");
                    span.appendChild(label_2);
                    label_2.addEventListener('click', function () {
                        cb_2.click();
                    });
                    insetSelf++;
                }
                // let inseg = 0;
                for (var i = 0; i < inset; i++) {
                    var insetBlock = document.createElement("span");
                    insetBlock.className = "inset-block";
                    treerow.appendChild(insetBlock);
                    // inseg++;
                }
                // console.info(`inseg=${inseg}`)
                treerow.appendChild(span);
                var labelDiv = document.createElement("div");
                labelDiv.className = 'treelabel';
                var label = this.nodeRenderer.render(this);
                if (label) {
                    labelDiv.appendChild(label);
                    treerow.appendChild(labelDiv);
                }
                if (this.actions) {
                    treerow.appendChild(this.renderActions());
                }
                var nodecontainer = this.childDom;
                if (nodecontainer) {
                    nodecontainer.innerHTML = null;
                }
                if (childCount > 0) {
                    if (!nodecontainer) {
                        nodecontainer = this.childDom = document.createElement('div');
                        nodecontainer.className = "nodecontainer";
                        dom.appendChild(nodecontainer);
                        // nodecontainer.style.display = 'none'
                    }
                    var childInset = this.showOnlyChilds ? inset : (inset + insetSelf);
                    // console.info(`insets ${inset} - ${inset+insetSelf}`)
                    for (var i = 0; i < this.childs.length; i++) {
                        nodecontainer.appendChild(this.childs[i].render(childInset));
                    }
                }
                this.dom.style.display = (this.hideEmptyNode && childCount === 0) ? 'none' : 'flex';
            }
            this.insetChilds = this.showOnlyChilds ? inset : (inset + insetSelf);
            return dom;
        };
        // renderOrg(inset?:number): HTMLElement {
        //     // console.info(`render inset=${inset}`, this.data, this.collapsed);
        //     const col = TreeNode.getTreePath(this).length;
        //     if (!inset) {
        //         inset = 0;
        //     }        
        //     let insetSelf = 0;
        //     // let inset = col-1;
        //     let dom = this.dom;
        //     let treerow = this.treerow
        //     if (!dom) {
        //         dom = this.dom = document.createElement("div");
        //         dom.className = 'row-wrapper',
        //         treerow = this.treerow = document.createElement('div');
        //         treerow.id = "treerow" + TreeNode.nodeCounter++            
        //         treerow.className = "treerow";
        //         dom.appendChild(treerow);
        //         const childCount = this.childs ? this.childs.length : 0
        //         const selectMode = this.getSelectMode();
        //         const span = document.createElement('div');
        //         span.className = "treeicon";
        //         const spanOpenClose = this.spanOpenClose = document.createElement('span');
        //         spanOpenClose.addEventListener('click', (ev) => this.onTreeIconClick(ev));
        //         insetSelf++;
        //         if (this.collapsed) {
        //             this.dom.classList.add('closed');
        //         }
        //         else {                    
        //             this.dom.classList.add('opened');
        //         }    
        //         if (childCount > 0) {
        //             // treerow.style.paddingLeft = `calc(${col - 1} * (${this.css_prop.iconWidth} + ${this.css_prop.iconDistance}) + ${this.css_prop.treePadding})`;
        //             if (this.collapsed) {                    
        //                 this.spanOpenClose.classList.add('closed');
        //             }
        //             else {                    
        //                 this.spanOpenClose.classList.add('opened');
        //             }                
        //         }
        //         else {
        //             if (selectMode === SelectionMode.SINGLE) {
        //                 treerow.addEventListener('click', (ev) => this.itemClicked(ev));
        //             }
        //             // treerow.style.paddingLeft = (col - 2) * 2.8 + 0.3) + "rem"
        //             if (selectMode === SelectionMode.RADIO) {
        //                 // this.treerow.style.paddingLeft = `calc(${col - 1} * (${this.css_prop.iconWidth} + ${this.css_prop.iconDistance}) + ${this.css_prop.treePadding})`;
        //                 //treerow.style.paddingLeft = ((col-1)*1.18 + 0.3) + "rem"
        //             } else {
        //                 // treerow.style.paddingLeft = ((col)*1.18 + 0.3) + "rem";
        //                 // this.treerow.style.paddingLeft = `calc(${col} * (${this.css_prop.iconWidth} + ${this.css_prop.iconDistance}) + ${this.css_prop.treePadding})`;
        //             }
        //             if (col > 1) {
        //                 treerow.className = 'treerow leaf'
        //             }
        //             // spanOpenClose.innerHTML = "&nbsp;"
        //         }
        //         this.textNode = spanOpenClose
        //         span.appendChild(spanOpenClose);
        //         if (selectMode === SelectionMode.MULTI) {
        //             const cb: HTMLInputElement = this._createCeckBox()
        //             span.appendChild(cb);
        //             const label = document.createElement("label");
        //             span.appendChild(label);
        //             label.addEventListener('click', function () { cb.click() });   
        //             insetSelf++;             
        //         } else if (selectMode === SelectionMode.RADIO) {
        //             const cb: HTMLInputElement = this._createRadioBttn()
        //             span.appendChild(cb);
        //             const label = document.createElement("label");
        //             span.appendChild(label)
        //             label.addEventListener('click', function () { 
        //                 cb.click();
        //             });
        //             insetSelf++;
        //         }
        //         for (let i=0; i<inset; i++) {
        //             const insetBlock = document.createElement("span");
        //             insetBlock.className = "inset-block";
        //             treerow.appendChild(insetBlock);
        //         }
        //         treerow.appendChild(span);
        //         const labelDiv = document.createElement("div")
        //         labelDiv.className = 'treelabel'
        //         const label = this.nodeRenderer.render(this)
        //         if (label) {
        //             labelDiv.appendChild(label)
        //             treerow.appendChild(labelDiv);
        //         }
        //         if (this.actions) {
        //             treerow.appendChild(this.renderActions())
        //         }
        //         let nodecontainer = this.childDom;
        //         if (nodecontainer) {
        //             nodecontainer.innerHTML = null
        //         }
        //         if (childCount > 0) {
        //             if (!nodecontainer) {
        //                 nodecontainer = this.childDom = document.createElement('div');
        //                 nodecontainer.className = "nodecontainer"
        //                 dom.appendChild(nodecontainer);
        //                 // nodecontainer.style.display = 'none'
        //             }
        //             for (let i = 0; i < this.childs.length; i++) {
        //                 nodecontainer.appendChild(this.childs[i].renderOrg(inset+insetSelf));
        //             }
        //         }      
        //         this.dom.style.display = (this.hideEmptyNode && childCount === 0) ? 'none' : 'flex';
        //     }
        //     this.insetChilds = inset+insetSelf;
        //     return dom
        // }
        TreeNode.prototype.renderActions = function () {
            var _this = this;
            var actDiv = document.createElement("div");
            actDiv.className = "tree_action_icons";
            var _loop_1 = function (i) {
                var a = this_1.actions[i];
                if (a.authorized) {
                    actDiv.appendChild(this_1.renderIcon(a.icon, function () { return a.callback(_this.data); }));
                }
            };
            var this_1 = this;
            for (var i = 0; i < this.actions.length; i++) {
                _loop_1(i);
            }
            return actDiv;
        };
        TreeNode.prototype.renderIcon = function (icon, cb) {
            var el = document.createElement("i");
            el.style.cssFloat = "right";
            el.style.marginLeft = "12px";
            el.className = "fas fa-" + icon;
            el.onclick = cb;
            return el;
        };
        /**
         * return the checkbox for item selection, if not exist create
         */
        TreeNode.prototype._createCeckBox = function () {
            var _this = this;
            var chBox;
            if (!this.chBox) {
                chBox = this.chBox = document.createElement('input');
                chBox.type = 'checkbox';
                chBox.className = 'regular-checkbox';
                chBox.setAttribute('aria-label', this.data.id);
                chBox.checked = this.selectionStatus === SelectionStatus.SELECTED || this.selectionStatus === SelectionStatus.INDETERMINATE;
                chBox.indeterminate = this.selectionStatus === SelectionStatus.INDETERMINATE;
                chBox.addEventListener('change', function (ev) { return _this.onchBoxChange(ev); });
            }
            return this.chBox;
        };
        TreeNode.prototype._createRadioBttn = function () {
            var _this = this;
            if (!this.chBox) {
                var chBox = this.chBox = document.createElement('input');
                chBox.type = 'radio';
                chBox.className = 'regular-checkbox';
                chBox.setAttribute('aria-label', this.data.id);
                chBox.checked = this.selectionStatus === SelectionStatus.SELECTED;
                chBox.addEventListener('change', function (ev) { return _this.onchBoxChange(ev); });
                this.chBox = chBox;
            }
            return this.chBox;
        };
        TreeNode.prototype.onchBoxChange = function (evt) {
            // console.warn(`onchBoxChange ${this.data.name} ${this.chBox.checked} childCount=${this.childs ? this.childs.length : 0}`);
            // console.warn(this);
            if (this.childs) {
                var isSelected = this.chBox.checked;
                for (var i = 0; i < this.childs.length; i++) {
                    this.childs[i].setSelected(isSelected);
                }
            }
            else {
                this.setSelected(this.chBox.checked);
            }
            evt.preventDefault();
        };
        TreeNode.prototype.itemClicked = function (evt) {
            console.info("TreeNode.itemClicked");
            this.setSelected(this.selectionStatus === SelectionStatus.UNSELECTED);
        };
        TreeNode.prototype.onTreeIconClick = function (evt) {
            // console.info(`onTreeIconClick ${this.collapsed}`);
            if (this.childs && this.childs.length > 0) {
                if (this.collapsed) {
                    this.dom.classList.replace('closed', 'opened');
                    // this.childDom.classList.replace('closed', 'opened');
                    this.spanOpenClose.classList.replace('closed', 'opened');
                }
                else {
                    this.dom.classList.replace('opened', 'closed');
                    // this.childDom.classList.replace('opened', 'closed');
                    this.spanOpenClose.classList.replace('opened', 'closed');
                }
                this.collapsed = !this.collapsed;
                this.onExpandChange.dispatch(this, !this.collapsed);
            }
            evt.stopImmediatePropagation();
        };
        // isSelected(): boolean {
        //     if (this.chBox) {
        //         return this.chBox.checked;
        //     }
        //     return this.selected;
        // }
        TreeNode.prototype.getSelectionsStatus = function () {
            // if (this.chBox) {
            //     if (this.chBox.checked) {
            //         return this.chBox.indeterminate ? SelectionStatus.INDETERMINATE : SelectionStatus.SELECTED;
            //     }
            //     return SelectionStatus.UNSELECTED;
            // }
            // return this.selected ? SelectionStatus.SELECTED : SelectionStatus.UNSELECTED;
            return this.selectionStatus;
        };
        /*
        childSelected(evt:TreeSelectionChangeEvent) {
            this.fire(Tree.NODE_SELECTION_CHANGE_EVENT, {changedNode:evt.changedNode});
        }
        */
        TreeNode.prototype._getStatusOfChilds = function () {
            var count = 0;
            for (var i = 0; i < this.childs.length; i++) {
                // console.info(`\t ${i} ${SelectionStatus[this.childs[i].getSelectionsStatus()]}`);
                var sStatus = this.childs[i].getSelectionsStatus();
                if (sStatus === SelectionStatus.SELECTED) {
                    count++;
                }
                else {
                    if (sStatus === SelectionStatus.INDETERMINATE) {
                        return SelectionStatus.INDETERMINATE;
                    }
                }
            }
            if (count === 0)
                return SelectionStatus.UNSELECTED;
            return (this.childs.length > count) ? SelectionStatus.INDETERMINATE : SelectionStatus.SELECTED;
        };
        TreeNode.prototype.childExpandChanged = function (node, expanded) {
            console.info("childExpandChanged");
            if (expanded && this.expandOnlyOneNode) {
                var count = this.childs ? this.childs.length : 0;
                for (var i = 0; i < count; i++) {
                    if (node !== this.childs[i]) {
                        this.childs[i].collapse();
                    }
                }
            }
        };
        TreeNode.prototype.childSelected = function (n, selectionStatus) {
            // console.info(`childSelected this=${this.data.bezeichnung} child=${n.data.bezeichnung} ${SelectionStatus[selectionStatus]}`);
            var selStatus = this._getStatusOfChilds();
            if (this.chBox) {
                if (selStatus === SelectionStatus.UNSELECTED) {
                    this.chBox.checked = false;
                    this.chBox.indeterminate = false;
                }
                else {
                    this.chBox.checked = true;
                    this.chBox.indeterminate = selStatus === SelectionStatus.INDETERMINATE;
                }
            }
            // console.info(`childSelected this=${this.data.bezeichnung} child=${n.data.bezeichnung} ${SelectionStatus[selectionStatus]} 
            // => ${selStatus}`);
            this.selectionStatus = selStatus;
            this.onSelectionChange.dispatch(this, selStatus);
        };
        TreeNode.prototype.getSelected = function () {
            var ids = [];
            if (this.selectionStatus === SelectionStatus.SELECTED || this.selectionStatus === SelectionStatus.INDETERMINATE) {
                if (this.selectionStatus === SelectionStatus.SELECTED) {
                    ids.push(this.data);
                }
                if (this.childs) {
                    for (var i = 0; i < this.childs.length; i++) {
                        ids = ids.concat(this.childs[i].getSelected());
                    }
                }
            }
            return ids;
        };
        TreeNode.prototype.setSelected = function (selected) {
            console.info("setSelected ".concat(this.data.name ? this.data.name : this.data.label ? this.data.label : this.data, " SelectionMode=").concat(SelectionMode[this.getSelectMode()]));
            console.info('TreeNode.setSelected', this.data);
            var selectionsStatus = selected ? SelectionStatus.SELECTED : SelectionStatus.UNSELECTED;
            if (selectionsStatus === this.selectionStatus) {
                return;
            }
            if (this.getSelectMode() === SelectionMode.SINGLE) {
                if (this.treerow) {
                    if (this.selectionStatus === SelectionStatus.UNSELECTED) {
                        this.treerow.classList.add('selected');
                    }
                    else {
                        this.treerow.classList.remove('selected');
                    }
                }
            }
            else {
                if (this.chBox) {
                    this.chBox.checked = selected;
                }
                if (this.childs) {
                    for (var i = 0; i < this.childs.length; i++) {
                        this.childs[i].setSelected(selected);
                    }
                }
            }
            this.selectionStatus = selected ? SelectionStatus.SELECTED : SelectionStatus.UNSELECTED;
            this.onSelectionChange.dispatch(this, this.selectionStatus);
        };
        // _setSelected(selected: boolean) {
        //     console.error(`_setSelected ${this.data.name} this.selected=${this.selected} => ${selected}`);
        //     if (selected === this.selected) {
        //         return;
        //     }
        //     if (this.treerow) {
        //         if (this.selected) {
        //             this.treerow.classList.remove('selected');
        //         }
        //         else {
        //             this.treerow.classList.add('selected');
        //         }
        //     }
        //     this.selected = !this.selected;
        // }
        TreeNode.prototype.resize = function () {
            var treeWidth = this.tree.getWidh();
            // return;
            // console.info(this.data.name + "  !!!!!!!!!");
            // console.info("tree", this.tree.getBoundingClientRect())        
            var childs = this.childs;
            if (childs && childs.length > 0) {
                for (var i = 0, count = childs.length; i < count; i++) {
                    childs[i].resize();
                }
            }
            else {
                var treeRow = this.treerow;
                var recRow = treeRow.getBoundingClientRect();
                // console.log("treeRow", recRow);
                var wA = [];
                for (var i = 0; i < treeRow.childNodes.length; i++) {
                    var child_1 = treeRow.children[i];
                    var recChild = child_1.getBoundingClientRect();
                    // console.log("elem" + i + "  ", recChild);
                    wA.push(recChild.width);
                }
                // console.log("span"+1+"  ", recRow, recSpa);
                var child = treeRow.children[1];
                // child.style.width = (treeWidth - 130) + "px"
                // let w:number = ( treeWidth - wA[0] - wA[2] - 92 )
                var w = (treeWidth + recRow.left - child.getBoundingClientRect().left - wA[2]);
                // console.log("res   "+ w + " = " + treeWidth +" - "+ wA[0]+" - "+ wA[2]);
                // console.log("res   "+ w + " = " + treeWidth +" + "+ recRow.left+ " - "+ child.getBoundingClientRect().left + " - " + wA[2]);
                child.style.width = w + "px";
            }
        };
        TreeNode.getTreePath = function (node) {
            var result = [node];
            var parent = node.parent;
            while (parent) {
                result.push(parent);
                parent = parent.parent;
            }
            return result.reverse();
        };
        TreeNode.nodeCounter = 0;
        TreeNode._css_prop = {
            iconWidth: '0.950rem',
            iconDistance: '0.18rem',
            treePadding: '0.3rem'
        };
        return TreeNode;
    }());
    exports.TreeNode = TreeNode;
    var RadioGroupTreeNode = /** @class */ (function (_super) {
        __extends(RadioGroupTreeNode, _super);
        function RadioGroupTreeNode(data, childs, params) {
            var _this = _super.call(this, data, childs, params) || this;
            _this.selectMode = SelectionMode.RADIO_GROUP;
            for (var i = 0, count = childs.length; i < count; i++) {
                childs[i].selectMode = SelectionMode.RADIO;
            }
            return _this;
        }
        // childSelected(n: TreeNode, selectionStatus: SelectionStatus) {
        //     console.info(`radioTreeNode.childSelected this=${this.data.bezeichnung} child=${n.data.bezeichnung} ${SelectionStatus[selectionStatus]}`);     
        //     this.onSelectionChange.dispatch(n, selectionStatus);        
        // }
        RadioGroupTreeNode.prototype.childSelected = function (node, status) {
            // console.error(`RadioGroupTreeNode.childSelected ${node.data.name} ${SelectionStatus[status]}`);        
            // console.info(`radioTreeNode.childSelected this=${this.data.bezeichnung} child=${node.data.bezeichnung} ${SelectionStatus[status]}`);     
            if (node.getSelectionsStatus() === SelectionStatus.SELECTED) {
                for (var i = 0, count = this.childs.length; i < count; i++) {
                    if (this.childs[i] !== node) {
                        this.childs[i].setSelected(false);
                    }
                }
                // console.info(`RadioGroupTreeNode.childSelected dispatch ${node.data.name}`);
                this.onSelectionChange.dispatch(node, SelectionStatus.SELECTED);
            }
        };
        return RadioGroupTreeNode;
    }(TreeNode));
    exports.RadioGroupTreeNode = RadioGroupTreeNode;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "../treecomponent/node_modules/ste-core/dist/dispatching.js":
/*!******************************************************************!*\
  !*** ../treecomponent/node_modules/ste-core/dist/dispatching.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DispatcherWrapper = exports.EventListBase = exports.DispatcherBase = void 0;
var management_1 = __webpack_require__(/*! ./management */ "../treecomponent/node_modules/ste-core/dist/management.js");
var subscription_1 = __webpack_require__(/*! ./subscription */ "../treecomponent/node_modules/ste-core/dist/subscription.js");
/**
 * Base class for implementation of the dispatcher. It facilitates the subscribe
 * and unsubscribe methods based on generic handlers. The TEventType specifies
 * the type of event that should be exposed. Use the asEvent to expose the
 * dispatcher as event.
 */
var DispatcherBase = /** @class */ (function () {
    function DispatcherBase() {
        this._wrap = new DispatcherWrapper(this);
        this._subscriptions = new Array();
    }
    Object.defineProperty(DispatcherBase.prototype, "count", {
        /**
         * Returns the number of subscriptions.
         *
         * @readonly
         *
         * @memberOf DispatcherBase
         */
        get: function () {
            return this._subscriptions.length;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Subscribe to the event dispatcher.
     * @param fn The event handler that is called when the event is dispatched.
     * @returns A function that unsubscribes the event handler from the event.
     */
    DispatcherBase.prototype.subscribe = function (fn) {
        var _this = this;
        if (fn) {
            this._subscriptions.push(new subscription_1.Subscription(fn, false));
        }
        return function () {
            _this.unsubscribe(fn);
        };
    };
    /**
     * Subscribe to the event dispatcher.
     * @param fn The event handler that is called when the event is dispatched.
     * @returns A function that unsubscribes the event handler from the event.
     */
    DispatcherBase.prototype.sub = function (fn) {
        return this.subscribe(fn);
    };
    /**
     * Subscribe once to the event with the specified name.
     * @param fn The event handler that is called when the event is dispatched.
     * @returns A function that unsubscribes the event handler from the event.
     */
    DispatcherBase.prototype.one = function (fn) {
        var _this = this;
        if (fn) {
            this._subscriptions.push(new subscription_1.Subscription(fn, true));
        }
        return function () {
            _this.unsubscribe(fn);
        };
    };
    /**
     * Checks it the event has a subscription for the specified handler.
     * @param fn The event handler.
     */
    DispatcherBase.prototype.has = function (fn) {
        if (!fn)
            return false;
        return this._subscriptions.some(function (sub) { return sub.handler == fn; });
    };
    /**
     * Unsubscribes the handler from the dispatcher.
     * @param fn The event handler.
     */
    DispatcherBase.prototype.unsubscribe = function (fn) {
        if (!fn)
            return;
        for (var i = 0; i < this._subscriptions.length; i++) {
            if (this._subscriptions[i].handler == fn) {
                this._subscriptions.splice(i, 1);
                break;
            }
        }
    };
    /**
     * Unsubscribes the handler from the dispatcher.
     * @param fn The event handler.
     */
    DispatcherBase.prototype.unsub = function (fn) {
        this.unsubscribe(fn);
    };
    /**
     * Generic dispatch will dispatch the handlers with the given arguments.
     *
     * @protected
     * @param {boolean} executeAsync True if the even should be executed async.
     * @param {*} The scope the scope of the event. The scope becomes the "this" for handler.
     * @param {IArguments} args The arguments for the event.
     */
    DispatcherBase.prototype._dispatch = function (executeAsync, scope, args) {
        var _this = this;
        var _loop_1 = function (sub) {
            var ev = new management_1.EventManagement(function () { return _this.unsub(sub.handler); });
            var nargs = Array.prototype.slice.call(args);
            nargs.push(ev);
            sub.execute(executeAsync, scope, nargs);
            //cleanup subs that are no longer needed
            this_1.cleanup(sub);
            if (!executeAsync && ev.propagationStopped) {
                return "break";
            }
        };
        var this_1 = this;
        //execute on a copy because of bug #9
        for (var _i = 0, _a = __spreadArrays(this._subscriptions); _i < _a.length; _i++) {
            var sub = _a[_i];
            var state_1 = _loop_1(sub);
            if (state_1 === "break")
                break;
        }
    };
    /**
     * Cleans up subs that ran and should run only once.
     */
    DispatcherBase.prototype.cleanup = function (sub) {
        if (sub.isOnce && sub.isExecuted) {
            var i = this._subscriptions.indexOf(sub);
            if (i > -1) {
                this._subscriptions.splice(i, 1);
            }
        }
    };
    /**
     * Creates an event from the dispatcher. Will return the dispatcher
     * in a wrapper. This will prevent exposure of any dispatcher methods.
     */
    DispatcherBase.prototype.asEvent = function () {
        return this._wrap;
    };
    /**
     * Clears all the subscriptions.
     */
    DispatcherBase.prototype.clear = function () {
        this._subscriptions.splice(0, this._subscriptions.length);
    };
    return DispatcherBase;
}());
exports.DispatcherBase = DispatcherBase;
/**
 * Base class for event lists classes. Implements the get and remove.
 */
var EventListBase = /** @class */ (function () {
    function EventListBase() {
        this._events = {};
    }
    /**
     * Gets the dispatcher associated with the name.
     * @param name The name of the event.
     */
    EventListBase.prototype.get = function (name) {
        var event = this._events[name];
        if (event) {
            return event;
        }
        event = this.createDispatcher();
        this._events[name] = event;
        return event;
    };
    /**
     * Removes the dispatcher associated with the name.
     * @param name The name of the event.
     */
    EventListBase.prototype.remove = function (name) {
        delete this._events[name];
    };
    return EventListBase;
}());
exports.EventListBase = EventListBase;
/**
 * Hides the implementation of the event dispatcher. Will expose methods that
 * are relevent to the event.
 */
var DispatcherWrapper = /** @class */ (function () {
    /**
     * Creates a new EventDispatcherWrapper instance.
     * @param dispatcher The dispatcher.
     */
    function DispatcherWrapper(dispatcher) {
        this._subscribe = function (fn) { return dispatcher.subscribe(fn); };
        this._unsubscribe = function (fn) { return dispatcher.unsubscribe(fn); };
        this._one = function (fn) { return dispatcher.one(fn); };
        this._has = function (fn) { return dispatcher.has(fn); };
        this._clear = function () { return dispatcher.clear(); };
        this._count = function () { return dispatcher.count; };
    }
    Object.defineProperty(DispatcherWrapper.prototype, "count", {
        /**
         * Returns the number of subscriptions.
         *
         * @readonly
         * @type {number}
         * @memberOf DispatcherWrapper
         */
        get: function () {
            return this._count();
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Subscribe to the event dispatcher.
     * @param fn The event handler that is called when the event is dispatched.
     * @returns A function that unsubscribes the event handler from the event.
     */
    DispatcherWrapper.prototype.subscribe = function (fn) {
        return this._subscribe(fn);
    };
    /**
     * Subscribe to the event dispatcher.
     * @param fn The event handler that is called when the event is dispatched.
     * @returns A function that unsubscribes the event handler from the event.
     */
    DispatcherWrapper.prototype.sub = function (fn) {
        return this.subscribe(fn);
    };
    /**
     * Unsubscribe from the event dispatcher.
     * @param fn The event handler that is called when the event is dispatched.
     */
    DispatcherWrapper.prototype.unsubscribe = function (fn) {
        this._unsubscribe(fn);
    };
    /**
     * Unsubscribe from the event dispatcher.
     * @param fn The event handler that is called when the event is dispatched.
     */
    DispatcherWrapper.prototype.unsub = function (fn) {
        this.unsubscribe(fn);
    };
    /**
     * Subscribe once to the event with the specified name.
     * @param fn The event handler that is called when the event is dispatched.
     */
    DispatcherWrapper.prototype.one = function (fn) {
        return this._one(fn);
    };
    /**
     * Checks it the event has a subscription for the specified handler.
     * @param fn The event handler.
     */
    DispatcherWrapper.prototype.has = function (fn) {
        return this._has(fn);
    };
    /**
     * Clears all the subscriptions.
     */
    DispatcherWrapper.prototype.clear = function () {
        this._clear();
    };
    return DispatcherWrapper;
}());
exports.DispatcherWrapper = DispatcherWrapper;


/***/ }),

/***/ "../treecomponent/node_modules/ste-core/dist/index.js":
/*!************************************************************!*\
  !*** ../treecomponent/node_modules/ste-core/dist/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*!
 * Strongly Typed Events for TypeScript - Core
 * https://github.com/KeesCBakker/StronlyTypedEvents/
 * http://keestalkstech.com
 *
 * Copyright Kees C. Bakker / KeesTalksTech
 * Released under the MIT license
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Subscription = exports.EventListBase = exports.DispatcherWrapper = exports.DispatcherBase = void 0;
var dispatching_1 = __webpack_require__(/*! ./dispatching */ "../treecomponent/node_modules/ste-core/dist/dispatching.js");
Object.defineProperty(exports, "DispatcherBase", ({ enumerable: true, get: function () { return dispatching_1.DispatcherBase; } }));
Object.defineProperty(exports, "DispatcherWrapper", ({ enumerable: true, get: function () { return dispatching_1.DispatcherWrapper; } }));
Object.defineProperty(exports, "EventListBase", ({ enumerable: true, get: function () { return dispatching_1.EventListBase; } }));
var subscription_1 = __webpack_require__(/*! ./subscription */ "../treecomponent/node_modules/ste-core/dist/subscription.js");
Object.defineProperty(exports, "Subscription", ({ enumerable: true, get: function () { return subscription_1.Subscription; } }));


/***/ }),

/***/ "../treecomponent/node_modules/ste-core/dist/management.js":
/*!*****************************************************************!*\
  !*** ../treecomponent/node_modules/ste-core/dist/management.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EventManagement = void 0;
/**
 * Allows the user to interact with the event.
 *
 * @class EventManagement
 * @implements {IEventManagement}
 */
var EventManagement = /** @class */ (function () {
    function EventManagement(unsub) {
        this.unsub = unsub;
        this.propagationStopped = false;
    }
    EventManagement.prototype.stopPropagation = function () {
        this.propagationStopped = true;
    };
    return EventManagement;
}());
exports.EventManagement = EventManagement;


/***/ }),

/***/ "../treecomponent/node_modules/ste-core/dist/subscription.js":
/*!*******************************************************************!*\
  !*** ../treecomponent/node_modules/ste-core/dist/subscription.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Subscription = void 0;
/**
 * Stores a handler. Manages execution meta data.
 * @class Subscription
 * @template TEventHandler
 */
var Subscription = /** @class */ (function () {
    /**
     * Creates an instance of Subscription.
     *
     * @param {TEventHandler} handler The handler for the subscription.
     * @param {boolean} isOnce Indicates if the handler should only be executed once.
     */
    function Subscription(handler, isOnce) {
        this.handler = handler;
        this.isOnce = isOnce;
        /**
         * Indicates if the subscription has been executed before.
         */
        this.isExecuted = false;
    }
    /**
     * Executes the handler.
     *
     * @param {boolean} executeAsync True if the even should be executed async.
     * @param {*} scope The scope the scope of the event.
     * @param {IArguments} args The arguments for the event.
     */
    Subscription.prototype.execute = function (executeAsync, scope, args) {
        if (!this.isOnce || !this.isExecuted) {
            this.isExecuted = true;
            var fn = this.handler;
            if (executeAsync) {
                setTimeout(function () {
                    fn.apply(scope, args);
                }, 1);
            }
            else {
                fn.apply(scope, args);
            }
        }
    };
    return Subscription;
}());
exports.Subscription = Subscription;


/***/ }),

/***/ "../treecomponent/node_modules/ste-events/dist/events.js":
/*!***************************************************************!*\
  !*** ../treecomponent/node_modules/ste-events/dist/events.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EventHandlingBase = exports.EventList = exports.NonUniformEventList = exports.EventDispatcher = void 0;
var ste_core_1 = __webpack_require__(/*! ste-core */ "../treecomponent/node_modules/ste-core/dist/index.js");
/**
 * Dispatcher implementation for events. Can be used to subscribe, unsubscribe
 * or dispatch events. Use the ToEvent() method to expose the event.
 */
var EventDispatcher = /** @class */ (function (_super) {
    __extends(EventDispatcher, _super);
    /**
     * Creates a new EventDispatcher instance.
     */
    function EventDispatcher() {
        return _super.call(this) || this;
    }
    /**
     * Dispatches the event.
     * @param sender The sender.
     * @param args The arguments object.
     */
    EventDispatcher.prototype.dispatch = function (sender, args) {
        this._dispatch(false, this, arguments);
    };
    /**
     * Dispatches the events thread.
     * @param sender The sender.
     * @param args The arguments object.
     */
    EventDispatcher.prototype.dispatchAsync = function (sender, args) {
        this._dispatch(true, this, arguments);
    };
    /**
     * Creates an event from the dispatcher. Will return the dispatcher
     * in a wrapper. This will prevent exposure of any dispatcher methods.
     */
    EventDispatcher.prototype.asEvent = function () {
        return _super.prototype.asEvent.call(this);
    };
    return EventDispatcher;
}(ste_core_1.DispatcherBase));
exports.EventDispatcher = EventDispatcher;
/**
 * Similar to EventList, but instead of TArgs, a map of event names ang argument types is provided with TArgsMap.
 */
var NonUniformEventList = /** @class */ (function () {
    function NonUniformEventList() {
        this._events = {};
    }
    /**
     * Gets the dispatcher associated with the name.
     * @param name The name of the event.
     */
    NonUniformEventList.prototype.get = function (name) {
        if (this._events[name]) {
            // @TODO avoid typecasting. Not sure why TS thinks this._events[name] could still be undefined.
            return this._events[name];
        }
        var event = this.createDispatcher();
        this._events[name] = event;
        return event;
    };
    /**
     * Removes the dispatcher associated with the name.
     * @param name The name of the event.
     */
    NonUniformEventList.prototype.remove = function (name) {
        delete this._events[name];
    };
    /**
     * Creates a new dispatcher instance.
     */
    NonUniformEventList.prototype.createDispatcher = function () {
        return new EventDispatcher();
    };
    return NonUniformEventList;
}());
exports.NonUniformEventList = NonUniformEventList;
/**
 * Storage class for multiple events that are accessible by name.
 * Events dispatchers are automatically created.
 */
var EventList = /** @class */ (function (_super) {
    __extends(EventList, _super);
    /**
     * Creates a new EventList instance.
     */
    function EventList() {
        return _super.call(this) || this;
    }
    /**
     * Creates a new dispatcher instance.
     */
    EventList.prototype.createDispatcher = function () {
        return new EventDispatcher();
    };
    return EventList;
}(ste_core_1.EventListBase));
exports.EventList = EventList;
/**
 * Extends objects with event handling capabilities.
 */
var EventHandlingBase = /** @class */ (function () {
    function EventHandlingBase() {
        this._events = new EventList();
    }
    Object.defineProperty(EventHandlingBase.prototype, "events", {
        /**
         * Gets the list with all the event dispatchers.
         */
        get: function () {
            return this._events;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Subscribes to the event with the specified name.
     * @param name The name of the event.
     * @param fn The event handler.
     */
    EventHandlingBase.prototype.subscribe = function (name, fn) {
        this._events.get(name).subscribe(fn);
    };
    /**
     * Subscribes to the event with the specified name.
     * @param name The name of the event.
     * @param fn The event handler.
     */
    EventHandlingBase.prototype.sub = function (name, fn) {
        this.subscribe(name, fn);
    };
    /**
     * Unsubscribes from the event with the specified name.
     * @param name The name of the event.
     * @param fn The event handler.
     */
    EventHandlingBase.prototype.unsubscribe = function (name, fn) {
        this._events.get(name).unsubscribe(fn);
    };
    /**
     * Unsubscribes from the event with the specified name.
     * @param name The name of the event.
     * @param fn The event handler.
     */
    EventHandlingBase.prototype.unsub = function (name, fn) {
        this.unsubscribe(name, fn);
    };
    /**
     * Subscribes to once the event with the specified name.
     * @param name The name of the event.
     * @param fn The event handler.
     */
    EventHandlingBase.prototype.one = function (name, fn) {
        this._events.get(name).one(fn);
    };
    /**
     * Subscribes to once the event with the specified name.
     * @param name The name of the event.
     * @param fn The event handler.
     */
    EventHandlingBase.prototype.has = function (name, fn) {
        return this._events.get(name).has(fn);
    };
    return EventHandlingBase;
}());
exports.EventHandlingBase = EventHandlingBase;


/***/ }),

/***/ "../treecomponent/node_modules/ste-events/dist/index.js":
/*!**************************************************************!*\
  !*** ../treecomponent/node_modules/ste-events/dist/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NonUniformEventList = exports.EventList = exports.EventHandlingBase = exports.EventDispatcher = void 0;
var events_1 = __webpack_require__(/*! ./events */ "../treecomponent/node_modules/ste-events/dist/events.js");
Object.defineProperty(exports, "EventDispatcher", ({ enumerable: true, get: function () { return events_1.EventDispatcher; } }));
Object.defineProperty(exports, "EventHandlingBase", ({ enumerable: true, get: function () { return events_1.EventHandlingBase; } }));
Object.defineProperty(exports, "EventList", ({ enumerable: true, get: function () { return events_1.EventList; } }));
Object.defineProperty(exports, "NonUniformEventList", ({ enumerable: true, get: function () { return events_1.NonUniformEventList; } }));


/***/ }),

/***/ "../treecomponent/node_modules/ste-signals/dist/index.js":
/*!***************************************************************!*\
  !*** ../treecomponent/node_modules/ste-signals/dist/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SignalList = exports.SignalHandlingBase = exports.SignalDispatcher = void 0;
var signals_1 = __webpack_require__(/*! ./signals */ "../treecomponent/node_modules/ste-signals/dist/signals.js");
Object.defineProperty(exports, "SignalDispatcher", ({ enumerable: true, get: function () { return signals_1.SignalDispatcher; } }));
Object.defineProperty(exports, "SignalHandlingBase", ({ enumerable: true, get: function () { return signals_1.SignalHandlingBase; } }));
Object.defineProperty(exports, "SignalList", ({ enumerable: true, get: function () { return signals_1.SignalList; } }));


/***/ }),

/***/ "../treecomponent/node_modules/ste-signals/dist/signals.js":
/*!*****************************************************************!*\
  !*** ../treecomponent/node_modules/ste-signals/dist/signals.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SignalHandlingBase = exports.SignalList = exports.SignalDispatcher = void 0;
var ste_core_1 = __webpack_require__(/*! ste-core */ "../treecomponent/node_modules/ste-core/dist/index.js");
/**
 * The dispatcher handles the storage of subsciptions and facilitates
 * subscription, unsubscription and dispatching of a signal event.
 */
var SignalDispatcher = /** @class */ (function (_super) {
    __extends(SignalDispatcher, _super);
    /**
     * Creates a new SignalDispatcher instance.
     */
    function SignalDispatcher() {
        return _super.call(this) || this;
    }
    /**
     * Dispatches the signal.
     */
    SignalDispatcher.prototype.dispatch = function () {
        this._dispatch(false, this, arguments);
    };
    /**
     * Dispatches the signal threaded.
     */
    SignalDispatcher.prototype.dispatchAsync = function () {
        this._dispatch(true, this, arguments);
    };
    /**
     * Creates an event from the dispatcher. Will return the dispatcher
     * in a wrapper. This will prevent exposure of any dispatcher methods.
     */
    SignalDispatcher.prototype.asEvent = function () {
        return _super.prototype.asEvent.call(this);
    };
    return SignalDispatcher;
}(ste_core_1.DispatcherBase));
exports.SignalDispatcher = SignalDispatcher;
/**
 * Storage class for multiple signal events that are accessible by name.
 * Events dispatchers are automatically created.
 */
var SignalList = /** @class */ (function (_super) {
    __extends(SignalList, _super);
    /**
     * Creates a new SignalList instance.
     */
    function SignalList() {
        return _super.call(this) || this;
    }
    /**
     * Creates a new dispatcher instance.
     */
    SignalList.prototype.createDispatcher = function () {
        return new SignalDispatcher();
    };
    return SignalList;
}(ste_core_1.EventListBase));
exports.SignalList = SignalList;
/**
 * Extends objects with signal event handling capabilities.
 */
var SignalHandlingBase = /** @class */ (function () {
    function SignalHandlingBase() {
        this._events = new SignalList();
    }
    Object.defineProperty(SignalHandlingBase.prototype, "events", {
        get: function () {
            return this._events;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Subscribes once to the event with the specified name.
     * @param name The name of the event.
     * @param fn The event handler.
     */
    SignalHandlingBase.prototype.one = function (name, fn) {
        this._events.get(name).one(fn);
    };
    /**
     * Checks it the event has a subscription for the specified handler.
     * @param name The name of the event.
     * @param fn The event handler.
     */
    SignalHandlingBase.prototype.has = function (name, fn) {
        return this._events.get(name).has(fn);
    };
    /**
     * Subscribes to the event with the specified name.
     * @param name The name of the event.
     * @param fn The event handler.
     */
    SignalHandlingBase.prototype.subscribe = function (name, fn) {
        this._events.get(name).subscribe(fn);
    };
    /**
     * Subscribes to the event with the specified name.
     * @param name The name of the event.
     * @param fn The event handler.
     */
    SignalHandlingBase.prototype.sub = function (name, fn) {
        this.subscribe(name, fn);
    };
    /**
     * Unsubscribes from the event with the specified name.
     * @param name The name of the event.
     * @param fn The event handler.
     */
    SignalHandlingBase.prototype.unsubscribe = function (name, fn) {
        this._events.get(name).unsubscribe(fn);
    };
    /**
     * Unsubscribes from the event with the specified name.
     * @param name The name of the event.
     * @param fn The event handler.
     */
    SignalHandlingBase.prototype.unsub = function (name, fn) {
        this.unsubscribe(name, fn);
    };
    return SignalHandlingBase;
}());
exports.SignalHandlingBase = SignalHandlingBase;


/***/ }),

/***/ "../treecomponent/node_modules/ste-simple-events/dist/index.js":
/*!*********************************************************************!*\
  !*** ../treecomponent/node_modules/ste-simple-events/dist/index.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NonUniformSimpleEventList = exports.SimpleEventList = exports.SimpleEventHandlingBase = exports.SimpleEventDispatcher = void 0;
var simple_events_1 = __webpack_require__(/*! ./simple-events */ "../treecomponent/node_modules/ste-simple-events/dist/simple-events.js");
Object.defineProperty(exports, "SimpleEventDispatcher", ({ enumerable: true, get: function () { return simple_events_1.SimpleEventDispatcher; } }));
Object.defineProperty(exports, "SimpleEventHandlingBase", ({ enumerable: true, get: function () { return simple_events_1.SimpleEventHandlingBase; } }));
Object.defineProperty(exports, "SimpleEventList", ({ enumerable: true, get: function () { return simple_events_1.SimpleEventList; } }));
Object.defineProperty(exports, "NonUniformSimpleEventList", ({ enumerable: true, get: function () { return simple_events_1.NonUniformSimpleEventList; } }));


/***/ }),

/***/ "../treecomponent/node_modules/ste-simple-events/dist/simple-events.js":
/*!*****************************************************************************!*\
  !*** ../treecomponent/node_modules/ste-simple-events/dist/simple-events.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SimpleEventHandlingBase = exports.SimpleEventList = exports.NonUniformSimpleEventList = exports.SimpleEventDispatcher = void 0;
var ste_core_1 = __webpack_require__(/*! ste-core */ "../treecomponent/node_modules/ste-core/dist/index.js");
/**
 * The dispatcher handles the storage of subsciptions and facilitates
 * subscription, unsubscription and dispatching of a simple event
 */
var SimpleEventDispatcher = /** @class */ (function (_super) {
    __extends(SimpleEventDispatcher, _super);
    /**
     * Creates a new SimpleEventDispatcher instance.
     */
    function SimpleEventDispatcher() {
        return _super.call(this) || this;
    }
    /**
     * Dispatches the event.
     * @param args The arguments object.
     */
    SimpleEventDispatcher.prototype.dispatch = function (args) {
        this._dispatch(false, this, arguments);
    };
    /**
     * Dispatches the events thread.
     * @param args The arguments object.
     */
    SimpleEventDispatcher.prototype.dispatchAsync = function (args) {
        this._dispatch(true, this, arguments);
    };
    /**
     * Creates an event from the dispatcher. Will return the dispatcher
     * in a wrapper. This will prevent exposure of any dispatcher methods.
     */
    SimpleEventDispatcher.prototype.asEvent = function () {
        return _super.prototype.asEvent.call(this);
    };
    return SimpleEventDispatcher;
}(ste_core_1.DispatcherBase));
exports.SimpleEventDispatcher = SimpleEventDispatcher;
/**
 * Similar to EventList, but instead of TArgs, a map of event names ang argument types is provided with TArgsMap.
 */
var NonUniformSimpleEventList = /** @class */ (function () {
    function NonUniformSimpleEventList() {
        this._events = {};
    }
    /**
     * Gets the dispatcher associated with the name.
     * @param name The name of the event.
     */
    NonUniformSimpleEventList.prototype.get = function (name) {
        if (this._events[name]) {
            // @TODO avoid typecasting. Not sure why TS thinks this._events[name] could still be undefined.
            return this._events[name];
        }
        var event = this.createDispatcher();
        this._events[name] = event;
        return event;
    };
    /**
     * Removes the dispatcher associated with the name.
     * @param name The name of the event.
     */
    NonUniformSimpleEventList.prototype.remove = function (name) {
        delete this._events[name];
    };
    /**
     * Creates a new dispatcher instance.
     */
    NonUniformSimpleEventList.prototype.createDispatcher = function () {
        return new SimpleEventDispatcher();
    };
    return NonUniformSimpleEventList;
}());
exports.NonUniformSimpleEventList = NonUniformSimpleEventList;
/**
 * Storage class for multiple simple events that are accessible by name.
 * Events dispatchers are automatically created.
 */
var SimpleEventList = /** @class */ (function (_super) {
    __extends(SimpleEventList, _super);
    /**
     * Creates a new SimpleEventList instance.
     */
    function SimpleEventList() {
        return _super.call(this) || this;
    }
    /**
     * Creates a new dispatcher instance.
     */
    SimpleEventList.prototype.createDispatcher = function () {
        return new SimpleEventDispatcher();
    };
    return SimpleEventList;
}(ste_core_1.EventListBase));
exports.SimpleEventList = SimpleEventList;
/**
 * Extends objects with simple event handling capabilities.
 */
var SimpleEventHandlingBase = /** @class */ (function () {
    function SimpleEventHandlingBase() {
        this._events = new SimpleEventList();
    }
    Object.defineProperty(SimpleEventHandlingBase.prototype, "events", {
        get: function () {
            return this._events;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Subscribes to the event with the specified name.
     * @param name The name of the event.
     * @param fn The event handler.
     */
    SimpleEventHandlingBase.prototype.subscribe = function (name, fn) {
        this._events.get(name).subscribe(fn);
    };
    /**
     * Subscribes to the event with the specified name.
     * @param name The name of the event.
     * @param fn The event handler.
     */
    SimpleEventHandlingBase.prototype.sub = function (name, fn) {
        this.subscribe(name, fn);
    };
    /**
     * Subscribes once to the event with the specified name.
     * @param name The name of the event.
     * @param fn The event handler.
     */
    SimpleEventHandlingBase.prototype.one = function (name, fn) {
        this._events.get(name).one(fn);
    };
    /**
     * Checks it the event has a subscription for the specified handler.
     * @param name The name of the event.
     * @param fn The event handler.
     */
    SimpleEventHandlingBase.prototype.has = function (name, fn) {
        return this._events.get(name).has(fn);
    };
    /**
     * Unsubscribes from the event with the specified name.
     * @param name The name of the event.
     * @param fn The event handler.
     */
    SimpleEventHandlingBase.prototype.unsubscribe = function (name, fn) {
        this._events.get(name).unsubscribe(fn);
    };
    /**
     * Unsubscribes from the event with the specified name.
     * @param name The name of the event.
     * @param fn The event handler.
     */
    SimpleEventHandlingBase.prototype.unsub = function (name, fn) {
        this.unsubscribe(name, fn);
    };
    return SimpleEventHandlingBase;
}());
exports.SimpleEventHandlingBase = SimpleEventHandlingBase;


/***/ }),

/***/ "../treecomponent/node_modules/strongly-typed-events/dist/index.js":
/*!*************************************************************************!*\
  !*** ../treecomponent/node_modules/strongly-typed-events/dist/index.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*!
 * Strongly Typed Events for TypeScript
 * https://github.com/KeesCBakker/StronlyTypedEvents/
 * http://keestalkstech.com
 *
 * Copyright Kees C. Bakker / KeesTalksTech
 * Released under the MIT license
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SignalList = exports.SignalHandlingBase = exports.SignalDispatcher = exports.NonUniformSimpleEventList = exports.SimpleEventList = exports.SimpleEventHandlingBase = exports.SimpleEventDispatcher = exports.NonUniformEventList = exports.EventList = exports.EventHandlingBase = exports.EventDispatcher = exports.Subscription = exports.EventListBase = exports.DispatcherWrapper = exports.DispatcherBase = void 0;
var ste_core_1 = __webpack_require__(/*! ste-core */ "../treecomponent/node_modules/ste-core/dist/index.js");
Object.defineProperty(exports, "DispatcherBase", ({ enumerable: true, get: function () { return ste_core_1.DispatcherBase; } }));
Object.defineProperty(exports, "DispatcherWrapper", ({ enumerable: true, get: function () { return ste_core_1.DispatcherWrapper; } }));
Object.defineProperty(exports, "EventListBase", ({ enumerable: true, get: function () { return ste_core_1.EventListBase; } }));
Object.defineProperty(exports, "Subscription", ({ enumerable: true, get: function () { return ste_core_1.Subscription; } }));
var ste_events_1 = __webpack_require__(/*! ste-events */ "../treecomponent/node_modules/ste-events/dist/index.js");
Object.defineProperty(exports, "EventDispatcher", ({ enumerable: true, get: function () { return ste_events_1.EventDispatcher; } }));
Object.defineProperty(exports, "EventHandlingBase", ({ enumerable: true, get: function () { return ste_events_1.EventHandlingBase; } }));
Object.defineProperty(exports, "EventList", ({ enumerable: true, get: function () { return ste_events_1.EventList; } }));
Object.defineProperty(exports, "NonUniformEventList", ({ enumerable: true, get: function () { return ste_events_1.NonUniformEventList; } }));
var ste_simple_events_1 = __webpack_require__(/*! ste-simple-events */ "../treecomponent/node_modules/ste-simple-events/dist/index.js");
Object.defineProperty(exports, "SimpleEventDispatcher", ({ enumerable: true, get: function () { return ste_simple_events_1.SimpleEventDispatcher; } }));
Object.defineProperty(exports, "SimpleEventHandlingBase", ({ enumerable: true, get: function () { return ste_simple_events_1.SimpleEventHandlingBase; } }));
Object.defineProperty(exports, "SimpleEventList", ({ enumerable: true, get: function () { return ste_simple_events_1.SimpleEventList; } }));
Object.defineProperty(exports, "NonUniformSimpleEventList", ({ enumerable: true, get: function () { return ste_simple_events_1.NonUniformSimpleEventList; } }));
var ste_signals_1 = __webpack_require__(/*! ste-signals */ "../treecomponent/node_modules/ste-signals/dist/index.js");
Object.defineProperty(exports, "SignalDispatcher", ({ enumerable: true, get: function () { return ste_signals_1.SignalDispatcher; } }));
Object.defineProperty(exports, "SignalHandlingBase", ({ enumerable: true, get: function () { return ste_signals_1.SignalHandlingBase; } }));
Object.defineProperty(exports, "SignalList", ({ enumerable: true, get: function () { return ste_signals_1.SignalList; } }));


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module used 'module' so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/EnergieAtlas.ts");
/******/ 	
/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFjO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sK0RBQStEO0FBQ3JFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSwwQkFBMEIsb0hBQW9IO0FBQzlJLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FB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QTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwwRUFBMEU7QUFDMUU7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0NBQWtDLFFBQVE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQSxLQUFLO0FBQ0wsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVDQUF1Qzs7QUFFdkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTzs7QUFFUCxPQUFPLE9BQU87QUFDZDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsZUFBZSw2Q0FBNkM7O0FBRTVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFF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QUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSw0Q0FBNEMsU0FBUztBQUNyRDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsdUJBQXVCLElBQUk7QUFDM0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUNBQXlDLFNBQVM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7O0FBRW5CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUJBQXlCLDJCQUEyQjs7QUFFcEQ7QUFDQSxrQkFBa0Isd0JBQXdCOztBQUUxQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1DQUFtQyx1QkFBdUIsSUFBSTtBQUM5RCxrQ0FBa0MsT0FBTztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUE0Qix1QkFBdUIsSUFBSTtBQUN2RCxVQUFVLGdCQUFnQjtBQUMxQixrQ0FBa0MsT0FBTztBQUN6QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQ0FBbUMsU0FBUztBQUM1QztBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLGtCQUFrQixnQkFBZ0I7QUFDbEMsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEseUJBQXlCLFlBQVk7QUFDckM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsd0NBQXdDLFNBQVM7QUFDakQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxrQ0FBa0M7O0FBRTlDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBOztBQUVBLDJCQUEyQiwrQkFBK0I7QUFDMUQsY0FBYywwQkFBMEI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdDQUF3QyxTQUFTO0FBQ2pEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsU0FBUztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixxQkFBcUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELHVDQUF1QztBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxTQUFTO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSx5Q0FBeUMsU0FBUztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHFCQUFxQjtBQUM1QztBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsU0FBUztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxTQUFTO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsU0FBUztBQUNsRDtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsU0FBUztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHFCQUFxQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsU0FBUztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsU0FBUztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQyxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyx5QkFBeUIsT0FBTyxzQ0FBc0M7QUFDakg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1QjtBQUN2Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osR0FBRztBQUNIO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0EsR0FBRzs7QUFFSCxxQkFBcUI7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1DQUFtQyxTQUFTO0FBQzVDOztBQUVBLHNDQUFzQyxVQUFVO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUM7QUFDckM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GO0FBQ25GLHNDQUFzQztBQUN0QztBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDs7QUFFQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHNDQUFzQyxVQUFVO0FBQ2hELE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLGdCQUFnQjtBQUNwRixnRUFBZ0UsZ0JBQWdCO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxnQkFBZ0I7QUFDckYsaUVBQWlFLGdCQUFnQjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFNBQVM7QUFDbkQ7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyx1Q0FBdUM7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSx3Q0FBd0MsU0FBUztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCx1Q0FBdUM7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSx3Q0FBd0MsU0FBUztBQUNqRDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsOEVBQThFLGdCQUFnQjtBQUM5RjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyw2QkFBNkI7QUFDbEM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7O0FBRTdCO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELFlBQVk7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHlCQUF5QjtBQUN0RCw0QkFBNEIscURBQXFEO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGNBQWM7QUFDL0QsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGNBQWM7QUFDeEQsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkMsNkNBQTZDLGFBQWE7QUFDMUQsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsdUJBQXVCO0FBQ3ZCLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsWUFBWTtBQUNwQjtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLHNCQUFzQixlQUFlO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxtRUFBbUUsWUFBWTtBQUMvRTtBQUNBLFFBQVEsY0FBYztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixxQkFBcUIsc0JBQXNCLElBQUk7QUFDekUsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFJO0FBQ0o7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseUJBQXlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseUJBQXlCO0FBQzdDO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxvQkFBb0IseUJBQXlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHlCQUF5QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsUUFBUTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMEJBQTBCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHdCQUF3QjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFFBQVE7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qjs7QUFFekI7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWU7O0FBRWY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBLG9HQUFvRztBQUNwRyxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQyxpRkFBaUY7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGVBQWU7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxTQUFTO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLEtBQUsscUJBQXFCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLEtBQUsscUJBQXFCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLEtBQUsscUJBQXFCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0EsS0FBSywrQkFBK0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0EsS0FBSywrQkFBK0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxTQUFTO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxTQUFTO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsaUNBQWlDO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3QjtBQUN4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBLCtCQUErQjs7QUFFL0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQixZQUFZO0FBQ3RDO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsd0JBQXdCO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEI7QUFDNUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2QkFBNkI7O0FBRTdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSwrQkFBK0IsYUFBYTtBQUM1QztBQUNBOztBQUVBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQSx5Q0FBeUMsU0FBUztBQUNsRDtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxTQUFTO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsNkNBQTZDO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsYUFBYTtBQUMvQyxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGFBQWE7QUFDbEQsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxnQ0FBZ0MsYUFBYTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBLGtDQUFrQztBQUNsQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDs7QUFFaEQ7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDBCQUEwQixlQUFlOztBQUV6QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QiwyQ0FBMkM7QUFDekUsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7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QUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsU0FBUztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxTQUFTO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsU0FBUztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxTQUFTO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGtCQUFrQixzQkFBc0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDJCQUEyQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QjtBQUM5QixrQ0FBa0M7O0FBRWxDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFlBQVk7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFlBQVk7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsWUFBWTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsWUFBWTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakMsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0U7QUFDbEU7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixjQUFjOztBQUUzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGNBQWM7QUFDckQ7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsY0FBYzs7QUFFNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxjQUFjO0FBQ3REO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7O0FBRUosZ0NBQWdDOztBQUVoQyw2QkFBNkI7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qix5QkFBeUI7QUFDdEQ7QUFDQTtBQUNBLGdDQUFnQyxhQUFhO0FBQzdDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQSxvREFBb0Q7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSw0QkFBNEI7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxzQ0FBc0MsT0FBTztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUEsa0JBQWtCOztBQUVsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUEsa0JBQWtCOztBQUVsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVK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O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOztBQUVK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QUFVO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsK0JBQStCOzs7Ozs7Ozs7Ozs7QUM5S2xCO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QVUsRUFBRSxVQUFVLEVBQUUsQ0FBQyxFQUFFLGFBQWEsRUFBRSxNQUFNLEVBQUM7UUFDL0UsRUFBRSxPQUFPLEVBQUUsQ0FBQyxJQUFJLEVBQUUsR0FBRyxDQUFDLEVBQUUsR0FBRyxFQUFFLFVBQVUsRUFBRSxVQUFVLEVBQUUsQ0FBQyxFQUFFLGFBQWEsRUFBRSxNQUFNLEVBQUM7UUFDOUUsRUFBRSxPQUFPLEVBQUUsQ0FBQyxJQUFJLEVBQUUsR0FBRyxDQUFDLEVBQUUsR0FBRyxFQUFFLFVBQVUsRUFBRSxVQUFVLEVBQUUsQ0FBQyxFQUFFLGFBQWEsRUFBRSxNQUFNLEVBQUM7UUFDOUUsRUFBRSxPQUFPLEVBQUUsQ0FBQyxJQUFJLEVBQUUsR0FBRyxDQUFDLEVBQUUsR0FBRyxFQUFFLFVBQVUsRUFBRSxVQUFVLEVBQUUsQ0FBQyxFQUFFLGFBQWEsRUFBRSxNQUFNLEVBQUM7UUFDOUUsRUFBRSxPQUFPLEVBQUUsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLEVBQUUsR0FBRyxFQUFFLFVBQVUsRUFBRSxVQUFVLEVBQUUsQ0FBQyxFQUFFLGFBQWEsRUFBRSxNQUFNLEVBQUM7UUFDL0UsRUFBRSxPQUFPLEVBQUUsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLEVBQUUsR0FBRyxFQUFFLFVBQVUsRUFBRSxVQUFVLEVBQUUsQ0FBQyxFQUFFLGFBQWEsRUFBRSxNQUFNLEVBQUM7UUFDL0UsRUFBRSxPQUFPLEVBQUUsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLEVBQUUsR0FBRyxFQUFFLFVBQVUsRUFBRSxVQUFVLEVBQUUsQ0FBQyxFQUFFLGFBQWEsRUFBRSxNQUFNLEVBQUM7S0FDbEYsQ0FBQztJQUVGLFNBQVMsY0FBYyxDQUFDLFNBQVM7UUFDN0IsSUFBTSxHQUFHLEdBQWMsRUFBRSxDQUFDO1FBQzFCLFNBQVMsQ0FBQyxPQUFPLENBQUMsaUJBQU87WUFDckIsT0FBTyxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsVUFBQyxNQUFhO2dCQUNsQyxHQUFHLENBQUMsSUFBSSxDQUFDO29CQUNMLE1BQU0sRUFBRSxNQUFNO29CQUNkLEdBQUcsRUFBRSxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQztvQkFDdkIsR0FBRyxFQUFFLE9BQU8sQ0FBQyxHQUFHO29CQUNoQixVQUFVLEVBQUUsT0FBTyxDQUFDLEdBQUc7b0JBQ3ZCLGFBQWEsRUFBRSxPQUFPLENBQUMsYUFBYTtpQkFDdkMsQ0FBQztZQUNOLENBQUMsQ0FBQyxDQUFDO1FBQ1AsQ0FBQyxDQUFDLENBQUM7UUFDSCxPQUFPLEdBQUcsQ0FBQztJQUNmLENBQUM7SUFFRCxJQUFNLFFBQVEsR0FBRyxjQUFjLENBQUMsU0FBUyxDQUFDLENBQUM7SUFLM0M7UUFBQTtRQUVBLENBQUM7UUFBRCxZQUFDO0lBQUQsQ0FBQztJQUVEO1FBS0ksb0JBQVksR0FBVSxFQUFFLEdBQTBCLEVBQUUsS0FBMkI7WUFDM0UsSUFBSSxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUM7WUFDZixJQUFJLENBQUMsTUFBTSxHQUFHLEtBQUssQ0FBQztZQUNwQixJQUFJLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQztRQUNuQixDQUFDO1FBRU8sb0NBQWUsR0FBdkIsVUFBd0IsVUFBcUIsRUFBRSxNQUFVO1lBQ3JELE9BQU8sVUFBVSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUM7UUFDbEMsQ0FBQztRQUVPLCtCQUFVLEdBQWxCLFVBQW1CLEdBQU8sRUFBRSxNQUFVO1lBQ2xDLDJDQUEyQztZQUMzQyxJQUFJLE1BQVUsQ0FBQztZQUNmLElBQUksT0FBTyxHQUFHLEtBQUssUUFBUSxFQUFFO2dCQUN6QixJQUFJLEdBQUcsQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLEVBQUU7b0JBQ3JCLElBQU0sR0FBRyxHQUFHLEdBQUcsQ0FBQyxTQUFTLENBQUMsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxNQUFNLEdBQUMsQ0FBQyxDQUFDLENBQUM7b0JBQzNDLGtDQUFrQztvQkFDbEMsTUFBTSxHQUFHLE1BQU0sQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLENBQUMsRUFBRSxHQUFHLENBQUMsTUFBTSxHQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7aUJBQ25EO3FCQUFNO29CQUNILElBQUksR0FBRyxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsRUFBRTt3QkFDckIsTUFBTSxHQUFHLEdBQUcsQ0FBQyxTQUFTLENBQUMsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxNQUFNLEdBQUMsQ0FBQyxDQUFDLENBQUM7cUJBQzNDO3lCQUFNO3dCQUNILE1BQU0sR0FBRyxHQUFHLENBQUM7cUJBQ2hCO2lCQUNKO2FBQ0o7aUJBQU07Z0JBQ0gsTUFBTSxHQUFHLEdBQUcsQ0FBQzthQUNoQjtZQUNELE9BQU8sTUFBTSxDQUFDO1FBQ2xCLENBQUM7UUFFRCx5QkFBSSxHQUFKLFVBQUssTUFBVTtZQUFmLGlCQVdDO1lBVkcsSUFBTSxNQUFNLEdBQUcsRUFBRSxDQUFDO1lBQ2xCLElBQUksQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFFLGlCQUFPO2dCQUN4QixJQUFJLE9BQU8sWUFBWSxVQUFVLEVBQUU7b0JBQy9CLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSSxDQUFDLGVBQWUsQ0FBQyxPQUFPLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQztpQkFDdEQ7cUJBQU07b0JBQ0gsTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFJLENBQUMsVUFBVSxDQUFDLE9BQU8sQ0FBQyxLQUFHLEdBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQztpQkFDckQ7WUFDTCxDQUFDLENBQUMsQ0FBQztZQUVILE9BQU8sSUFBSSxDQUFDLEdBQUcsT0FBUixJQUFJLEVBQVEsTUFBTSxFQUFFO1FBQy9CLENBQUM7UUFDTCxpQkFBQztJQUFELENBQUM7SUFoRFksZ0NBQVU7SUF3RHZCLElBQU0sY0FBYyxHQUFHLENBQUMsQ0FBQztJQUl6Qjs7Ozs7Ozs7OztPQVVHO0lBQ0gsU0FBUyxXQUFXLENBQUMsR0FBVSxFQUFFLE1BQWE7UUFDMUMsT0FBTyxHQUFHLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQztJQUMzQyxDQUFDO0lBRUQ7Ozs7Ozs7OztPQVNHO0lBQ0gsU0FBUyxhQUFhLENBQUMsR0FBVyxFQUFFLFlBQXVCO1FBQ3ZELElBQU0sQ0FBQyxHQUFHLEdBQUcsQ0FBQyxXQUFXLEVBQUUsQ0FBQztRQUM1QixPQUFPLFlBQVksQ0FBQyxNQUFNLENBQUMsVUFBQyxLQUFjLEVBQUUsUUFBaUI7WUFDekQsT0FBTyxLQUFLO2dCQUNSLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUM7UUFDL0QsQ0FBQyxFQUFFLFNBQVMsQ0FBQyxDQUFDO0lBQ2xCLENBQUM7SUFHRDs7Ozs7Ozs7Ozs7T0FXRztJQUNIO1FBSUk7Ozs7V0FJRztRQUNILHdCQUFZLFdBQW1CLEVBQUUsT0FBWSxFQUFFLFFBQWE7WUFBaEQsaURBQW1CO1lBQUUsc0NBQVk7WUFBRSx3Q0FBYTtZQUN4RCxJQUFNLGVBQWUsR0FBRyxVQUFDLENBQUMsRUFBRSxDQUFDLElBQUssUUFBQyxDQUFDLE1BQU0sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxNQUFNLEVBQWpDLENBQWlDLENBQUM7WUFDcEUsSUFBSSxDQUFDLFdBQVcsR0FBRyxXQUFXO2dCQUMxQixJQUFJLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQyxLQUFLLEVBQUUsQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDO2dCQUNwRCxJQUFJLENBQUMsUUFBUSxHQUFHLFFBQVEsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDO1FBRTlELENBQUM7UUFFRDs7Ozs7Ozs7Ozs7V0FXRztRQUNLLCtDQUFzQixHQUE5QixVQUErQixhQUFvQixFQUFFLGlCQUF3QixFQUFFLGVBQWdDO1lBQzNHLElBQU0sTUFBTSxHQUFHLGFBQWEsQ0FBQyxhQUFhLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1lBQzNELElBQUksQ0FBQyxNQUFNLElBQUksTUFBTSxDQUFDLFVBQVUsR0FBRyxpQkFBaUIsRUFBRTtnQkFDbEQsT0FBTyxJQUFJLENBQUM7YUFDZjtZQUNELElBQU0sY0FBYyxHQUFJLENBQUMsTUFBTSxDQUFDLGFBQWEsS0FBSyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLFVBQVUsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUM7WUFDdEcsSUFBTSxrQkFBa0IsR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDLFdBQVcsQ0FBQyxhQUFhLEVBQUUsTUFBTSxDQUFDLE1BQU0sQ0FBQyxFQUFFLGNBQWMsQ0FBQyxDQUFDO1lBRXpHLE9BQU87Z0JBQ0gsc0VBQXNFO2dCQUN0RSxPQUFPLEVBQUUsSUFBSSxVQUFVLENBQUUsTUFBTSxDQUFDLEdBQUcsRUFBRSxNQUFNLENBQUMsR0FBRyxFQUFFLENBQUMsZUFBZSxFQUFFLGtCQUFrQixDQUFDLE9BQU8sQ0FBQyxDQUFDO2dCQUMvRixTQUFTLEVBQUUsa0JBQWtCLENBQUMsU0FBUzthQUMxQyxDQUFDO1FBQ04sQ0FBQztRQUdEOzs7Ozs7O1dBT0c7UUFDSyw4Q0FBcUIsR0FBN0IsVUFBOEIsYUFBb0I7WUFDOUMsSUFBTSxLQUFLLEdBQUcsYUFBYSxDQUFDLGFBQWEsRUFBRSxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7WUFDekQsSUFBSSxDQUFDLEtBQUssRUFBRTtnQkFDUixPQUFPLElBQUksQ0FBQzthQUNmO1lBRUQsSUFBTSxnQkFBZ0IsR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDLFdBQVcsQ0FBQyxhQUFhLEVBQUUsS0FBSyxDQUFDLE1BQU0sQ0FBQyxFQUFFLEtBQUssQ0FBQyxVQUFVLENBQUMsQ0FBQztZQUV4RyxPQUFPO2dCQUNILGFBQWE7Z0JBQ2IsT0FBTyxFQUFFLElBQUksVUFBVSxDQUFDLEtBQUssQ0FBQyxHQUFHLEVBQUUsU0FBUyxFQUFFLENBQUMsZ0JBQWdCLENBQUMsT0FBTyxDQUFDLENBQUM7Z0JBQ3pFLFNBQVMsRUFBRSxnQkFBZ0IsQ0FBQyxTQUFTO2FBQ3hDLENBQUM7UUFDTixDQUFDO1FBQ0Q7Ozs7Ozs7Ozs7V0FVRztRQUNILHNDQUFhLEdBQWIsVUFBYyxhQUFxQixFQUFFLGlCQUF5QixFQUFFLFdBQWlCO1lBQzdFLHVEQUF1RDtZQUN2RCxJQUFJLENBQUMsYUFBYSxDQUFDLE1BQU0sSUFBSSxDQUFDLFdBQVcsRUFBRTtnQkFDdkMsTUFBTSxJQUFJLFdBQVcsQ0FBQywyQ0FBMkMsQ0FBQyxDQUFDO2FBQ3RFO1lBRUQsd0NBQXdDO1lBQ3hDLHFGQUFxRjtZQUNyRixJQUFNLFVBQVUsR0FDWixXQUFXLENBQUMsQ0FBQyxDQUFDLEVBQUUsT0FBTyxFQUFFLFdBQVcsRUFBRSxTQUFTLEVBQUUsYUFBYSxFQUFFLENBQUMsQ0FBQztnQkFDOUQsSUFBSSxDQUFDLHFCQUFxQixDQUFDLGFBQWEsQ0FBQztvQkFDekMsSUFBSSxDQUFDLDZCQUE2QixDQUFDLGFBQWEsQ0FBQztvQkFDakQsSUFBSSxDQUFDLGNBQWMsQ0FBQyxhQUFhLENBQUM7b0JBQ2xDLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxhQUFhLENBQUMsQ0FBQztZQUVoRCxJQUFJLENBQUMsVUFBVSxFQUFFO2dCQUNiLE1BQU0sSUFBSSxXQUFXLENBQUMsd0RBQXdELENBQUMsQ0FBQzthQUNuRjtZQUVELGlHQUFpRztZQUNqRyxJQUFNLFlBQVksR0FBRyxJQUFJLENBQUMsc0JBQXNCLENBQUMsVUFBVSxDQUFDLFNBQVMsRUFBRSxpQkFBaUIsRUFBRSxVQUFVLENBQUMsT0FBTyxDQUFDLENBQUM7WUFDOUcsSUFBSSxDQUFDLFlBQVksRUFBRTtnQkFDZiw4QkFBOEI7Z0JBQzlCLE9BQU8sVUFBVSxDQUFDO2FBQ3JCO1lBRUQsK0ZBQStGO1lBQy9GLE9BQU8sSUFBSSxDQUFDLGFBQWEsQ0FBQyxZQUFZLENBQUMsU0FBUyxFQUFFLGlCQUFpQixFQUFFLFlBQVksQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUMvRixDQUFDO1FBRUQ7Ozs7Ozs7V0FPRztRQUNLLHVDQUFjLEdBQXRCLFVBQXVCLGFBQXFCO1lBQ3hDLElBQU0sUUFBUSxHQUFHLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxZQUFZLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUM5RCxJQUFJLENBQUMsUUFBUSxFQUFFO2dCQUNYLE9BQU8sSUFBSSxDQUFDO2FBQ2Y7WUFFRCxPQUFPO2dCQUNILE9BQU8sRUFBRSxFQUFFLEtBQUcsRUFBRSxRQUFRLEVBQUU7Z0JBQzFCLFNBQVMsRUFBRSxXQUFXLENBQUMsYUFBYSxFQUFFLFFBQVEsQ0FBQzthQUNsRCxDQUFDO1FBQ04sQ0FBQztRQUNPLDRDQUFtQixHQUEzQixVQUE0QixhQUFxQjtZQUM3QyxJQUFJLGFBQWEsQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLEVBQUU7Z0JBQy9CLElBQUksUUFBUSxHQUFHLEdBQUcsQ0FBQztnQkFDbkIsS0FBSyxJQUFJLENBQUMsR0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFDLGFBQWEsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7b0JBQ3ZDLElBQUksYUFBYSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsSUFBRSxHQUFHLEVBQUU7d0JBQzlCLFFBQVEsSUFBSSxhQUFhLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDO3FCQUN2Qzt5QkFDSTt3QkFDRCxRQUFRLElBQUksR0FBRyxDQUFDO3dCQUNoQixPQUFPOzRCQUNILE9BQU8sRUFBRSxFQUFFLEtBQUcsRUFBRSxRQUFRLEVBQUU7NEJBQzFCLFNBQVMsRUFBRSxXQUFXLENBQUMsYUFBYSxFQUFFLFFBQVEsQ0FBQzt5QkFDbEQsQ0FBQztxQkFDTDtpQkFDSjthQUVKO1lBQ0QsT0FBTyxJQUFJLENBQUM7UUFDaEIsQ0FBQztRQUNEOzs7Ozs7O1dBT0c7UUFDSyxzREFBNkIsR0FBckMsVUFBc0MsYUFBcUI7WUFDdkQsSUFBSSxhQUFhLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxLQUFLLEdBQUcsRUFBRTtnQkFDakMsT0FBTyxJQUFJLENBQUM7YUFDZjtZQUVELElBQU0sZ0JBQWdCLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQyxXQUFXLENBQUMsYUFBYSxFQUFFLEdBQUcsQ0FBQyxFQUFFLGNBQWMsQ0FBQyxDQUFDO1lBQzdGLElBQUksZ0JBQWdCLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsS0FBSyxHQUFHLEVBQUU7Z0JBQzlDLE1BQU0sSUFBSSxXQUFXLENBQUMsK0NBQStDLENBQUMsQ0FBQzthQUMxRTtZQUVELE9BQU87Z0JBQ0gsT0FBTyxFQUFFLGdCQUFnQixDQUFDLE9BQU87Z0JBQ2pDLFNBQVMsRUFBRSxXQUFXLENBQUMsZ0JBQWdCLENBQUMsU0FBUyxFQUFFLEdBQUcsQ0FBQzthQUMxRCxDQUFDO1FBQ04sQ0FBQztRQUNEOzs7Ozs7V0FNRztRQUNILDhCQUFLLEdBQUwsVUFBTSxLQUFhO1lBRWYsSUFBSSxPQUFPLEtBQUssS0FBSyxRQUFRLEVBQUU7Z0JBQzNCLE1BQU0sSUFBSSxXQUFXLENBQUMsMENBQTBDLENBQUMsQ0FBQzthQUNyRTtZQUVELElBQU0sYUFBYSxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRSxFQUFFLGNBQWMsQ0FBQyxDQUFDO1lBQ3ZFLElBQUksYUFBYSxDQUFDLFNBQVMsQ0FBQyxNQUFNLEVBQUU7Z0JBQ2hDLE1BQU0sSUFBSSxXQUFXLENBQUMsb0RBQW9ELENBQUMsQ0FBQzthQUMvRTtZQUVELE9BQU8sYUFBYSxDQUFDLE9BQU8sQ0FBQztRQUNqQyxDQUFDO1FBQ0wscUJBQUM7SUFBRCxDQUFDO0lBN0xZLHdDQUFjO0lBK0wzQixJQUFNLGNBQWMsR0FBRyxJQUFJLGNBQWMsQ0FBQyxLQUFLLEVBQUUsRUFBRSxFQUFFLFFBQVEsQ0FBQyxDQUFDO0lBRS9ELFNBQWdCLGVBQWUsQ0FBQyxDQUFRO1FBQ3BDLElBQUk7WUFDQSxPQUFPLGNBQWMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDbEM7UUFBQyxPQUFPLEtBQUssRUFBRTtZQUNaLE9BQU8sQ0FBQyxLQUFLLENBQUMsZ0NBQWdDLENBQUM7U0FDbEQ7SUFFTCxDQUFDO0lBUEQsMENBT0M7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUN2WUQ7UUFBa0MsZ0NBQTJCO1FBR3pELHNCQUFvQixJQUFTLEVBQUUsT0FBOEI7WUFBN0QsWUFDSSxrQkFBTSxPQUFPLENBQUMsU0FHakI7WUFKbUIsVUFBSSxHQUFKLElBQUksQ0FBSztZQUV6QixPQUFPLENBQUMsSUFBSSxDQUFDLGNBQWMsRUFBRSxPQUFPLEVBQUUsSUFBSSxDQUFDLENBQUM7O1lBQzVDLG9CQUFvQjtRQUN4QixDQUFDO1FBRUQsaUNBQVUsR0FBVjtZQUNJLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFO2dCQUNoQixJQUFNLEtBQUssR0FBa0IsYUFBVSxJQUFJLENBQUMsT0FBTyxDQUFFLENBQUM7Z0JBQ3RELEtBQUssQ0FBQyxRQUFRLEdBQUcsRUFBRSxDQUFDO2dCQUNwQixpQ0FBaUM7Z0JBQ2pDLHVEQUF1RDtnQkFDdkQsNkNBQTZDO2dCQUM3QyxvQkFBb0I7Z0JBQ3BCLEtBQUs7Z0JBQ0wsT0FBTyxDQUFDLElBQUksQ0FBQywrQkFBK0IsRUFBRSxLQUFLLENBQUMsQ0FBQztnQkFDckQsT0FBTyxDQUFDLElBQUksQ0FBQyxpQ0FBaUMsRUFBRSxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7Z0JBQzlELDBFQUEwRTtnQkFDMUUsS0FBSyxJQUFJLENBQUMsSUFBSSxJQUFJLENBQUMsT0FBTyxDQUFDLFFBQVEsRUFBRTtvQkFDakMsc0NBQXNDO29CQUN0QyxxRUFBcUU7b0JBQ3JFLEtBQUssQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEVBQUUsS0FBSyxFQUFFLFVBQVUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsS0FBSyxFQUFFLElBQUksQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQztpQkFDN0Y7Z0JBQ0QsSUFBSSxDQUFDLFFBQVEsR0FBRyw2QkFBYyxFQUFDLEtBQUssQ0FBQyxDQUFDO2FBQ3pDO1lBQ0QsT0FBWSxJQUFJLENBQUMsUUFBUSxDQUFDO1FBQzlCLENBQUM7UUFDTCxtQkFBQztJQUFELENBQUMsQ0E5QmlDLGNBQUksR0E4QnJDO0lBOUJZLG9DQUFZO0lBZ0N6QjtRQUFrRSxrQ0FBTTtRQVFwRSxlQUFlO1FBRWYsd0JBQVksV0FBMEIsRUFBRSxLQUF5QixFQUFFLElBQVMsRUFBRSxPQUErQjtZQUE3RyxZQUNJLGtCQUFNLEtBQUssRUFBRSxPQUFPLENBQUMsU0FNeEI7WUFoQkQsYUFBTyxHQUFZLEtBQUssQ0FBQztZQUt6QixjQUFRLEdBQUcsS0FBSyxDQUFDO1lBTWIsaURBQWlEO1lBQ2pELEtBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxHQUFHLElBQUksWUFBWSxDQUFDLElBQUksRUFBRSxXQUFXLENBQUMsd0JBQXdCLEVBQUUsQ0FBQyxDQUFDO1lBQ25GLEtBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDO1lBQ2pCLEtBQUksQ0FBQyxXQUFXLEdBQUcsV0FBVyxDQUFDOztZQUMvQiwwQkFBMEI7UUFDOUIsQ0FBQztRQUVELG1DQUFVLEdBQVYsVUFBVyxPQUFnQjtZQUN2QixJQUFJLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQztRQUMzQixDQUFDO1FBRUQsa0NBQVMsR0FBVDtZQUNJLE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQztRQUN4QixDQUFDO1FBRUQsa0NBQVMsR0FBVCxVQUFVLFNBQWtCO1lBQ3hCLE9BQU8sQ0FBQyxJQUFJLENBQUMsMEJBQTBCLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxTQUFTLENBQUMsQ0FBQztZQUNyRSxJQUFJLENBQUMsUUFBUSxHQUFHLFNBQVMsQ0FBQztZQUMxQixJQUFJLElBQUksQ0FBQyxLQUFLLEVBQUU7Z0JBQ1osSUFBSSxTQUFTLEVBQUU7b0JBQ1gsSUFBSSxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLGtCQUFrQixDQUFDLENBQUM7aUJBQ2hEO3FCQUFNO29CQUNILElBQUksQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO2lCQUNuRDthQUNKO1lBQ0QsT0FBTyxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFDL0IsQ0FBQztRQUVELG9DQUFXLEdBQVg7WUFDSSxPQUFzQixJQUFJLENBQUMsT0FBTyxDQUFDLElBQUssQ0FBQyxRQUFRLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3RFLENBQUM7UUFLTCxxQkFBQztJQUFELENBQUMsQ0EvQ2lFLGdCQUFNLEdBK0N2RTtJQS9DWSx3Q0FBYztJQW1EM0I7UUFBbUMsaUNBQVk7UUFJM0MsdUJBQVksTUFBZ0IsRUFBRSxPQUFtQztZQUFqRSxZQUNJLGtCQUFNLE1BQU0sRUFBRSxPQUFPLENBQUMsU0FFekI7WUFERyxLQUFJLENBQUMsZ0JBQWdCLEdBQUcsT0FBTyxDQUFDLGdCQUFnQixDQUFDOztRQUNyRCxDQUFDO1FBRUQsdUNBQWUsR0FBZixVQUFnQixNQUE4QixFQUFFLFNBQWtCO1lBQzlELE1BQU0sQ0FBQyxTQUFTLENBQUMsU0FBUyxDQUFDLENBQUM7UUFDaEMsQ0FBQztRQUVELHNDQUFjLEdBQWQsVUFBZSxNQUE4QixFQUFFLEVBQXVCO1lBQ2xFLHlGQUF5RjtZQUN6RiwwQkFBYSxDQUFDLGlCQUFpQixDQUFDLFFBQVEsQ0FBQyxNQUFNLEVBQUUsRUFBRSxDQUFDLENBQUM7UUFDekQsQ0FBQztRQUVELGtDQUFVLEdBQVYsVUFBVyxNQUE4QjtZQUNyQyxPQUFPLElBQUksMkJBQVUsQ0FBQyxJQUFJLEVBQUUsTUFBTSxDQUFDLENBQUM7UUFDeEMsQ0FBQztRQUVELGdEQUF3QixHQUF4Qjs7WUFDSSxJQUFJLENBQUMsSUFBSSxDQUFDLHFCQUFxQixFQUFFO2dCQUM3QixJQUFNLE9BQU8sR0FBRyxDQUFDLElBQUksQ0FBQyxxQkFBcUIsR0FBRztvQkFDMUMsTUFBTSxFQUFFLFVBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLE1BQU0sbUNBQUksRUFBRTtvQkFDM0QsS0FBSyxFQUFFLFVBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLEtBQUssbUNBQUksVUFBVTtvQkFDakUsYUFBYSxFQUFFLFVBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLGFBQWEsbUNBQUksQ0FBQztvQkFDeEUsWUFBWSxFQUFFLFVBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLFlBQVksbUNBQUksQ0FBQztvQkFDdEUsUUFBUSxFQUFFLEVBQUU7aUJBQ2YsQ0FBQyxDQUFDO2dCQUNILElBQU0sYUFBYSxHQUFHLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxPQUFPLENBQUM7Z0JBQ3BELEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEtBQUssR0FBRyxhQUFhLENBQUMsTUFBTSxFQUFFLENBQUMsR0FBRyxLQUFLLEVBQUUsQ0FBQyxFQUFFLEVBQUU7b0JBQzFELElBQU0sS0FBSyxHQUFHLGFBQWEsQ0FBQyxDQUFDLENBQUMsQ0FBQztvQkFDL0IsT0FBTyxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxHQUFHO3dCQUNqQyxJQUFJLEVBQUUsS0FBSyxDQUFDLEtBQUssQ0FBQyxTQUFTO3dCQUMzQixPQUFPLEVBQUUsS0FBSyxDQUFDLEtBQUssQ0FBQyxXQUFXO3dCQUNoQyxNQUFNLEVBQUUsV0FBSyxDQUFDLEtBQUssQ0FBQyxLQUFLLG1DQUFJLE1BQU07d0JBQ25DLGFBQWEsRUFBRSxXQUFLLENBQUMsS0FBSyxDQUFDLGFBQWEsbUNBQUksS0FBSzt3QkFDakQsV0FBVyxFQUFFLFdBQUssQ0FBQyxLQUFLLENBQUMsWUFBWSxtQ0FBSSxHQUFHO3FCQUMvQyxDQUFDO2lCQUNMO2FBQ0o7WUFDRCxPQUFPLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDO1lBQ3pDLE9BQU8sSUFBSSxDQUFDLHFCQUFxQixDQUFDO1FBQ3RDLENBQUM7UUFDTCxvQkFBQztJQUFELENBQUMsQ0E5Q2tDLHNCQUFZLEdBOEM5QztJQTlDWSxzQ0FBYTs7Ozs7Ozs7Ozs7Ozs7Ozs7SUMvRjFCLFNBQWdCLHdCQUF3QixDQUFDLFFBQW9HO1FBQ3pJLElBQU0sQ0FBQyxHQUF1QixJQUFJLE9BQU8sQ0FBQyxRQUFRLENBQXVCLENBQUM7UUFDMUUsQ0FBQyxDQUFDLFFBQVEsR0FBRyxVQUFDLEVBQWM7WUFDbEIsQ0FBRSxDQUFDLFlBQVksR0FBRyxFQUFFLENBQUM7WUFDM0IsT0FBTyxDQUFDLENBQUM7UUFDYixDQUFDLENBQUM7UUFDRixDQUFDLENBQUMsTUFBTSxHQUFHO1lBQ1AsT0FBTyxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsQ0FBQztZQUM5QixJQUFVLENBQUUsQ0FBQyxZQUFZLEVBQUU7Z0JBQ2pCLENBQUUsQ0FBQyxZQUFZLEVBQUUsQ0FBQzthQUMzQjtRQUNMLENBQUMsQ0FBQztRQUNGLE9BQU8sQ0FBQyxDQUFDO0lBQ2IsQ0FBQztJQWJELDREQWFDO0lBRUQsU0FBZ0IsUUFBUSxDQUFDLEdBQVcsRUFBRSxNQUFZO1FBQzlDLElBQUksT0FBMEIsQ0FBQztRQUMvQixPQUFPLHdCQUF3QixDQUFDLFVBQVUsT0FBTyxFQUFFLE1BQU07WUFDckQsSUFBTSxJQUFJLEdBQUcsR0FBRyxHQUFHLGNBQWMsQ0FBQyxNQUFNLENBQUMsQ0FBQztZQUMxQyxPQUFPLEdBQUcsV0FBVyxDQUFDLElBQUksQ0FBQyxDQUFDO1lBQzVCLE9BQU87aUJBQ0YsSUFBSSxDQUFDLFVBQUMsS0FBSztnQkFDUixJQUFJO29CQUNBLElBQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUM7b0JBQ2pDLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQztpQkFDbkI7Z0JBQUMsT0FBTyxFQUFFLEVBQUU7b0JBQ1QsTUFBTSxDQUFDLHdDQUFnQyxJQUFJLHlCQUFhLEVBQUUsT0FBRyxDQUFDLENBQUM7aUJBQ2xFO1lBQ0wsQ0FBQyxDQUFDLENBQ0QsT0FBSyxFQUFDLFVBQUMsTUFBTTtnQkFDVixNQUFNLENBQUMsTUFBTSxDQUFDLENBQUM7WUFDbkIsQ0FBQyxDQUFDLENBQUM7UUFDWCxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUM7WUFDUixPQUFPLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1lBQ3ZCLElBQUksT0FBTyxFQUFFO2dCQUNULE9BQU8sQ0FBQyxNQUFNLEVBQUUsQ0FBQzthQUNwQjtRQUNMLENBQUMsQ0FBQyxDQUFDO1FBQ0gsK0RBQStEO1FBQy9ELDRCQUE0QjtJQUNoQyxDQUFDO0lBekJELDRCQXlCQztJQUVELFNBQWdCLFdBQVcsQ0FBQyxHQUFXLEVBQUUsSUFBYTtRQUNsRCxJQUFNLEdBQUcsR0FBRyxJQUFJLGNBQWMsRUFBRSxDQUFDO1FBQ2pDLE9BQU8sd0JBQXdCLENBQUMsVUFBVSxPQUFPLEVBQUUsTUFBTTtZQUNyRCxHQUFHLENBQUMsU0FBUyxHQUFHO2dCQUNaLElBQUksSUFBSSxDQUFDLE1BQU0sS0FBSyxHQUFHLEVBQUU7b0JBQ3JCLE9BQU8sQ0FBQyxHQUFHLENBQUMsWUFBWSxDQUFDLENBQUM7aUJBQzdCO3FCQUFNO29CQUNILE1BQU0sQ0FBQzt3QkFDSCxNQUFNLEVBQUUsSUFBSSxDQUFDLE1BQU07d0JBQ25CLFVBQVUsRUFBRSxHQUFHLENBQUMsVUFBVTtxQkFDN0IsQ0FBQyxDQUFDO2lCQUNOO1lBQ0wsQ0FBQyxDQUFDO1lBQ0YsR0FBRyxDQUFDLE9BQU8sR0FBRyxVQUFVLEVBQUU7Z0JBQ3RCLE1BQU0sQ0FBQztvQkFDSCxNQUFNLEVBQUUsSUFBSSxDQUFDLE1BQU07b0JBQ25CLFVBQVUsRUFBRSxHQUFHLENBQUMsVUFBVTtvQkFDMUIsS0FBSyxFQUFFLEVBQUU7aUJBQ1osQ0FBQyxDQUFDO1lBQ1AsQ0FBQyxDQUFDO1lBQ0YsR0FBRyxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsR0FBRyxDQUFDLENBQUM7WUFDckIsSUFBSSxJQUFJLEVBQUU7Z0JBQ04sR0FBRyxDQUFDLGdCQUFnQixDQUFDLGVBQWUsRUFBRSxJQUFJLENBQUMsQ0FBQzthQUMvQztZQUNELE9BQU8sQ0FBQyxJQUFJLENBQUMsd0JBQWdCLEdBQUcsT0FBRyxDQUFDLENBQUM7WUFDckMsR0FBRyxDQUFDLElBQUksRUFBRSxDQUFDO1FBQ2YsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDO1lBQ1IsT0FBTyxDQUFDLEtBQUssQ0FBQyxXQUFXLEVBQUUsR0FBRyxDQUFDLENBQUM7WUFDaEMsR0FBRyxDQUFDLEtBQUssRUFBRSxDQUFDO1FBQ2hCLENBQUMsQ0FBQyxDQUFDO0lBQ1AsQ0FBQztJQTlCRCxrQ0E4QkM7SUFFRCxTQUFnQixjQUFjLENBQUMsR0FBUSxFQUFFLFdBQW9CLEVBQUUsU0FBbUI7UUFDOUUsSUFBSSxDQUFDLEdBQUcsRUFBRTtZQUNOLE9BQU8sRUFBRSxDQUFDO1NBQ2I7UUFDRCxJQUFNLE1BQU0sR0FBRyxFQUFFLENBQUM7UUFDbEIsS0FBSyxJQUFJLENBQUMsSUFBSSxHQUFHLEVBQUU7WUFDZixJQUFNLEdBQUcsR0FBRyxrQkFBa0IsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDaEUsSUFBTSxLQUFLLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ3JCLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxFQUFFO2dCQUN2QixNQUFNLENBQUMsSUFBSSxDQUFDLEdBQUcsR0FBRyxHQUFHLEdBQUcsa0JBQWtCLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQzthQUN0RDtpQkFBTTtnQkFDSCxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsS0FBSyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtvQkFDbkMsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLGtCQUFrQixDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7aUJBQ3pEO2FBQ0o7U0FDSjtRQUNELE9BQU8sQ0FBQyxDQUFDLFdBQVcsSUFBSSxXQUFXLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDNUYsQ0FBQztJQWpCRCx3Q0FpQkM7SUFFRCxTQUFnQixZQUFZLENBQUMsR0FBVyxFQUFFLEdBQVcsRUFBRSxLQUFhLEVBQUUsUUFBOEIsRUFBRSxTQUFrQjtRQUNwSCxnRkFBZ0Y7UUFDaEYsSUFBTSxLQUFLLEdBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUM5QyxLQUFLLENBQUMsSUFBSSxHQUFHLE9BQU8sQ0FBQztRQUNyQixLQUFLLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQztRQUNoQixLQUFLLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQztRQUNoQixLQUFLLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztRQUNwQixJQUFJLFFBQVEsRUFBRTtZQUNWLEtBQUssQ0FBQyxnQkFBZ0IsQ0FBQyxPQUFPLEVBQUUsUUFBUSxDQUFDLENBQUM7U0FDN0M7UUFDRCxJQUFJLFNBQVMsRUFBRTtZQUNYLEtBQUssQ0FBQyxTQUFTLEdBQUcsU0FBUyxDQUFDO1NBQy9CO1FBQ0QsT0FBTyxLQUFLLENBQUM7SUFDakIsQ0FBQztJQWRELG9DQWNDO0lBRUQsU0FBZ0IsaUJBQWlCLENBQXdDLEdBQU0sRUFBRSxNQUFvQixFQUFFLFNBQWtCLEVBQUUsS0FBVztRQUNsSSxJQUFNLEVBQUUsR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ3ZDLElBQUksTUFBTSxFQUFFO1lBQ1IsTUFBTSxDQUFDLFdBQVcsQ0FBQyxFQUFFLENBQUMsQ0FBQztTQUMxQjtRQUNELElBQUksU0FBUyxFQUFFO1lBQ1gsRUFBRSxDQUFDLFNBQVMsR0FBRyxTQUFTLENBQUM7U0FDNUI7UUFDRCxJQUFJLEtBQUssRUFBRTtZQUNQLEtBQUssSUFBTSxDQUFDLElBQUksS0FBSyxFQUFFO2dCQUNuQixFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO2FBQ3BCO1NBQ0o7UUFDRCxPQUFPLEVBQUUsQ0FBQztJQUNkLENBQUM7SUFkRCw4Q0FjQztJQUVELFNBQWdCLGlCQUFpQixDQUFDLEVBQTRCO1FBQzFELElBQU0sU0FBUyxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDakQsU0FBUyxDQUFDLFNBQVMsR0FBRyxjQUFjLENBQUM7UUFDckMsdUNBQXVDO1FBQ3ZDLFNBQVMsQ0FBQyxnQkFBZ0IsQ0FBQyxPQUFPLEVBQUUsRUFBRSxDQUFDLENBQUM7UUFDeEMsT0FBTyxTQUFTLENBQUM7SUFDckIsQ0FBQztJQU5ELDhDQU1DO0lBRUQsU0FBZ0IsU0FBUyxDQUFDLE9BQWUsRUFBRSxLQUFVLEVBQUUsTUFBbUI7UUFDdEUsSUFBTSxHQUFHLEdBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUN6QyxJQUFNLEVBQUUsR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3hDLEVBQUUsQ0FBQyxTQUFTLEdBQUcsT0FBTyxDQUFDO1FBQ3ZCLElBQU0sRUFBRSxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDeEMsRUFBRSxDQUFDLFNBQVMsR0FBRyxLQUFLLENBQUM7UUFDckIsR0FBRyxDQUFDLFdBQVcsQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUNwQixHQUFHLENBQUMsV0FBVyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQ3BCLE1BQU0sQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDeEIsT0FBTyxHQUFHLENBQUM7SUFDZixDQUFDO0lBVkQsOEJBVUM7SUFFRCxJQUFNLGlCQUFpQixHQUFHLFVBQUMsRUFBUztRQUNoQyxJQUFJLEVBQUUsQ0FBQyxlQUFlLEVBQUU7WUFDcEIsRUFBRSxDQUFDLGVBQWUsRUFBRSxDQUFDO1NBQ3hCO2FBQU07WUFDSCxFQUFFLENBQUMsWUFBWSxHQUFHLElBQUksQ0FBQztTQUMxQjtRQUNELEVBQUUsQ0FBQyxlQUFlLEVBQUUsQ0FBQztRQUNyQixJQUFJLEVBQUUsQ0FBQyxjQUFjLEVBQUU7WUFDbkIsRUFBRSxDQUFDLGNBQWMsRUFBRSxDQUFDO1NBQ3ZCO2FBQU07WUFDSCxFQUFFLENBQUMsV0FBVyxHQUFHLEtBQUssQ0FBQztTQUMxQjtRQUNELE9BQU8sS0FBSyxDQUFDO0lBQ2pCLENBQUMsQ0FBQztJQUNGLHFHQUFxRztJQUNyRyxTQUFnQixxQkFBcUIsQ0FBQyxHQUFnQjtRQUNsRCxJQUFNLGFBQWEsR0FBUyxpQkFBUSxDQUFDLGFBQWEsQ0FBQztRQUNuRCxHQUFHLENBQUMsZ0JBQWdCLENBQUMsYUFBYSxFQUFFLGlCQUFpQixDQUFDLENBQUM7UUFDdkQsR0FBRyxDQUFDLGdCQUFnQixDQUFDLFdBQVcsRUFBRSxpQkFBaUIsQ0FBQyxDQUFDO1FBQ3JELEdBQUcsQ0FBQyxnQkFBZ0IsQ0FBQyxVQUFVLEVBQUUsaUJBQWlCLENBQUMsQ0FBQztRQUNwRCxHQUFHLENBQUMsZ0JBQWdCLENBQUMsV0FBVyxFQUFFLGlCQUFpQixDQUFDLENBQUM7UUFDckQsR0FBRyxDQUFDLGdCQUFnQixDQUFDLE1BQU0sRUFBRSxpQkFBaUIsQ0FBQyxDQUFDO1FBQ2hELEdBQUcsQ0FBQyxnQkFBZ0IsQ0FBQyxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsYUFBYSxDQUFDLENBQUMsQ0FBQyxFQUFFLE9BQU8sRUFBRSxLQUFLLEVBQUUsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDakcsQ0FBQztJQVJELHNEQVFDO0lBRUQsSUFBSTtJQUNKLFNBQWdCLGlCQUFpQixDQUFDLFFBQVEsRUFBRSxLQUFLO1FBQzdDLE9BQU8sQ0FBQyxJQUFJLENBQUMsNEJBQXFCLFFBQVEsZUFBSyxLQUFLLE1BQUcsQ0FBQyxDQUFDO1FBQ3pELElBQUksQ0FBQyxRQUFRLENBQUMsV0FBVztZQUFFLE9BQU87UUFDbEMsSUFBSSxRQUFRLENBQUMsb0JBQW9CLENBQUMsTUFBTSxDQUFDLENBQUMsTUFBTSxJQUFJLENBQUM7WUFBRSxPQUFPO1FBRTlELElBQUksVUFBeUIsQ0FBQztRQUM5QixpQkFBaUI7UUFFakIsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsS0FBSyxHQUFHLFFBQVEsQ0FBQyxXQUFXLENBQUMsTUFBTSxFQUFFLENBQUMsR0FBRyxLQUFLLElBQUksVUFBVSxFQUFFLENBQUMsRUFBRSxFQUFFO1lBQy9FLElBQUksQ0FBQyxRQUFRLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsRUFBRTtnQkFDbkMsSUFBTSxLQUFLLEdBQUcsUUFBUSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUM7Z0JBRTVDLElBQUksT0FBTyxLQUFLLElBQUksUUFBUSxFQUFFO29CQUMxQixJQUFJLEtBQUssQ0FBQyxTQUFTLEtBQUssRUFBRSxJQUFJLEtBQUssQ0FBQyxTQUFTLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFO3dCQUNwRSxVQUFVLEdBQUcsUUFBUSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQztxQkFDeEM7aUJBQ0o7YUFDSjtTQUNKO1FBRUQsSUFBSSxDQUFDLFVBQVUsRUFBRTtZQUNiLElBQU0saUJBQWlCLEdBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBQyxPQUFPLENBQUMsQ0FBQztZQUMxRCxpQkFBaUIsQ0FBQyxJQUFJLEdBQUcsVUFBVSxDQUFDO1lBQ3BDLFFBQVEsQ0FBQyxvQkFBb0IsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsaUJBQWlCLENBQUMsQ0FBQztZQUV4RSxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsUUFBUSxDQUFDLFdBQVcsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7Z0JBQ2xELElBQUksUUFBUSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLEVBQUU7b0JBQ2xDLFNBQVM7aUJBQ1o7Z0JBQ0QsVUFBVSxHQUFHLFFBQVEsQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUM7YUFDeEM7U0FDSjtRQUVELElBQU0sZ0JBQWdCLEdBQUcsVUFBVSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUM5RSxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsZ0JBQWdCLEVBQUUsQ0FBQyxFQUFFLEVBQUU7WUFDdkMsSUFBTSxJQUFJLEdBQUcsVUFBVSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNwQyxJQUFJLElBQUksWUFBWSxZQUFZLEVBQUU7Z0JBQzlCLElBQUksSUFBSSxDQUFDLFlBQVksSUFBSSxJQUFJLENBQUMsWUFBWSxDQUFDLFdBQVcsRUFBRSxJQUFJLFFBQVEsQ0FBQyxXQUFXLEVBQUUsRUFBRTtvQkFDaEYsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLEdBQUcsS0FBSyxDQUFDO29CQUMzQixPQUFPO2lCQUNWO2FBQ0o7U0FDSjtRQUNELFVBQVUsQ0FBQyxVQUFVLENBQUMsUUFBUSxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxFQUFFLGdCQUFnQixDQUFDLENBQUM7SUFDMUUsQ0FBQztJQTVDRCw4Q0E0Q0M7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lDMU5ELElBQUksUUFBd0IsQ0FBQztJQUU3QixTQUFzQixPQUFPLENBQUMsR0FBVzs7Ozs7OzZCQUNqQyxDQUFDLFFBQVEsRUFBVCx3QkFBUzt3QkFDSSxxQkFBTSxtQkFBUSxFQUFDLEdBQUcsQ0FBQzs7d0JBQTFCLElBQUksR0FBRyxTQUFtQjt3QkFFaEMsUUFBUSxHQUFHOzRCQUNQLHVCQUF1QixFQUFFLElBQUksQ0FBQyx1QkFBdUI7NEJBQ3JELFVBQVUsRUFBRSxJQUFJLENBQUMsVUFBVTs0QkFDM0IsVUFBVSxFQUFFLElBQUksQ0FBQyxVQUFVOzRCQUMzQixNQUFNLEVBQUUsRUFBRTt5QkFDYixDQUFDO3dCQUNJLGNBQXFDLEVBQUUsQ0FBQzt3QkFDeEMsVUFBUSxVQUFVLE1BQWU7NEJBQ25DLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxNQUFNLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO2dDQUNwQyxJQUFNLEtBQUssR0FBRyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0NBQ3hCLEtBQUssQ0FBQyxNQUFNLEdBQUcsRUFBRSxDQUFDO2dDQUNsQixJQUFJLEtBQUssQ0FBQyxNQUFNLEVBQUU7b0NBQ2QsT0FBSyxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQztpQ0FDdkI7Z0NBQ0QsV0FBUyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsR0FBRyxLQUFLLENBQUM7Z0NBQy9CLElBQU0sU0FBUyxHQUFHLEtBQUssQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO2dDQUN6QyxLQUFLLENBQUMsS0FBSyxHQUFHLFNBQVMsQ0FBQyxTQUFTLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDOzZCQUNqRDt3QkFDTCxDQUFDLENBQUM7d0JBQ0YsT0FBSyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQzt3QkFDbkIsUUFBUSxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDO3dCQUU5QixLQUFTLENBQUMsR0FBRyxDQUFDLEVBQUUsS0FBSyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxFQUFFLENBQUMsR0FBRyxLQUFLLEVBQUUsQ0FBQyxFQUFFLEVBQUU7NEJBQ3BELE9BQU8sR0FBcUIsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQzs0QkFFL0MsS0FBSyxHQUFHLFdBQVMsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUM7NEJBRXJDLElBQUksS0FBSyxFQUFFO2dDQUNQLElBQUksT0FBTyxDQUFDLElBQUksS0FBSyxLQUFLLEVBQUU7b0NBQ3hCLE9BQU8sQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLEdBQUcsYUFBRyxDQUFTLE9BQU8sQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztpQ0FDaEU7Z0NBQ0QsS0FBSyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSx5QkFBWSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUM7Z0NBQzdDLE9BQU8sQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDOzZCQUN6QjtpQ0FBTTtnQ0FDSCxPQUFPLENBQUMsS0FBSyxDQUFDLG1CQUFtQixFQUFFLE9BQU8sQ0FBQyxDQUFDOzZCQUMvQzt5QkFDSjs7NEJBRUwsc0JBQU8sUUFBUSxFQUFDOzs7O0tBQ25CO0lBM0NELDBCQTJDQztJQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FzREc7SUFFSCxTQUFnQixpQkFBaUI7UUFDN0IsSUFBSSxDQUFDLFFBQVEsRUFBRTtZQUNYLE1BQU0sSUFBSSxLQUFLLENBQUMsaUNBQWlDLENBQUMsQ0FBQztTQUN0RDtRQUNELE9BQU8sUUFBUSxDQUFDO0lBQ3BCLENBQUM7SUFMRCw4Q0FLQztJQTJIRDtRQUFBO1lBQ0k7O2VBRUc7WUFDSCxXQUFNLEdBQUcsSUFBSSxDQUFDO1lBRWQ7O2VBRUc7WUFDSCxVQUFLLEdBQVcsU0FBUyxDQUFDO1lBRTFCOztlQUVHO1lBQ0gsV0FBTSxHQUFHLENBQUMsQ0FBQztZQUVYOztlQUVHO1lBQ0gsWUFBTyxHQUFHLENBQUMsQ0FBQztZQUVaOztlQUVHO1lBQ0gsWUFBTyxHQUFXLE9BQU8sQ0FBQztZQU8xQjs7ZUFFRztZQUNILGNBQVMsR0FBVyxJQUFJLENBQUM7WUFFekI7O2VBRUc7WUFDSCxlQUFVLEdBQVcsSUFBSSxDQUFDO1lBRTFCOztlQUVHO1lBQ0gsU0FBSSxHQUFZLEtBQUssQ0FBQztZQUV0Qjs7ZUFFRztZQUNILGNBQVMsR0FBVyxJQUFJLENBQUM7WUFFekI7O2VBRUc7WUFDSCxnQkFBVyxHQUFXLEdBQUcsQ0FBQztZQUUxQjs7ZUFFRztZQUNILGFBQVEsR0FBRyxTQUFTLENBQUM7WUFFckI7OztlQUdHO1lBQ0gsd0JBQW1CLEdBQUcsSUFBSSxDQUFDO1FBQy9CLENBQUM7UUFBRCxrQkFBQztJQUFELENBQUM7SUFsRVksa0NBQVc7SUFvRXhCO1FBQWtDLHVDQUFXO1FBQTdDO1lBQUEscUVBT0M7WUFORyxVQUFJLEdBQUcsSUFBSSxDQUFDOztRQU1oQixDQUFDO1FBQUQsMEJBQUM7SUFBRCxDQUFDLENBUGlDLFdBQVcsR0FPNUM7SUFFWSwyQkFBbUIsR0FBRyxJQUFJLFdBQVcsRUFBRSxDQUFDO0lBQ3hDLG1DQUEyQixHQUFHLElBQUksbUJBQW1CLEVBQUUsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7SUN4VHJFLHdDQUF3QztJQUN4QywrQ0FBK0M7SUFDL0MsNkNBQTZDO0lBRTdDOzs7Ozs7T0FNRztJQUVVLHVCQUFlLEdBQUcsaUJBQU8sQ0FBQyxNQUFNLENBQUM7UUFDN0MsV0FBVztRQUNYLG1DQUFtQztRQUNuQyxPQUFPLEVBQUU7WUFDUixRQUFRLEVBQUUsYUFBYTtZQUN2QixxQ0FBcUM7WUFDckMsd0VBQXdFO1lBQ3hFLE1BQU0sRUFBRSx1RkFBdUY7U0FDL0Y7UUFFRCxVQUFVLEVBQUUsVUFBVSxPQUFPO1lBQzVCLGNBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxFQUFFLE9BQU8sQ0FBQyxDQUFDO1lBQ3pCLElBQUksQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDO1lBQ3pCLElBQUksQ0FBQyxhQUFhLEdBQUcsRUFBRSxDQUFDO1FBQ3pCLENBQUM7UUFFRCxLQUFLLEVBQUUsVUFBVSxHQUFHO1lBQ25CLEdBQUcsQ0FBQyxrQkFBa0IsR0FBRyxJQUFJLENBQUM7WUFDOUIsSUFBSSxDQUFDLFVBQVUsR0FBRyxpQkFBTyxDQUFDLE1BQU0sQ0FBQyxLQUFLLEVBQUUscUJBQXFCLENBQUMsQ0FBQztZQUN6RCxJQUFJLENBQUMsZUFBZSxHQUFHLGlCQUFPLENBQUMsTUFBTSxDQUFDLEtBQUssRUFBRSxpQkFBaUIsRUFBRSxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7WUFDakYsSUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDLEtBQUssR0FBRyxpQkFBTyxDQUFDLE1BQU0sQ0FBQyxRQUFRLEVBQUUsV0FBVyxFQUFFLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQztZQUNqRixJQUFJLENBQUMsU0FBUyxHQUFHLFFBQVE7WUFDekIsSUFBSSxDQUFDLFFBQVEsR0FBRyxVQUFDLEdBQWM7Z0JBQzNCLElBQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQztnQkFDN0QsNENBQTRDO2dCQUM1QyxJQUFJLENBQUMsU0FBUyxHQUFHLFFBQVEsRUFBQyxDQUFDLHFCQUFxQixDQUFDLENBQUMsQ0FBQyxxQkFBcUI7WUFFNUUsQ0FBQztZQUNELElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1lBQ3BELGtCQUFRLENBQUMsdUJBQXVCLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1lBRWxELHNCQUFzQjtZQUN0QixLQUFLLElBQUksQ0FBQyxJQUFJLEdBQUcsQ0FBQyxPQUFPLEVBQUU7Z0JBQzFCLElBQUksR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxjQUFjLEVBQUU7b0JBQ2xDLElBQUksQ0FBQyxjQUFjLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxjQUFjLEVBQUUsQ0FBQyxDQUFDO2lCQUNyRDthQUNEO1lBRUQsSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDO1lBRWYsT0FBTyxJQUFJLENBQUMsVUFBVSxDQUFDO1FBQ3hCLENBQUM7UUFFRCwwQ0FBMEM7UUFDMUMseUNBQXlDO1FBQ3pDLFNBQVMsRUFBRSxVQUFVLE1BQU07WUFDMUIsSUFBSSxDQUFDLE9BQU8sQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDO1lBQzdCLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQztZQUNmLE9BQU8sSUFBSSxDQUFDO1FBQ2IsQ0FBQztRQUVELDZDQUE2QztRQUM3QyxpRUFBaUU7UUFDakUsY0FBYyxFQUFFLFVBQVUsSUFBSTtZQUN2QiwwQ0FBMEM7WUFDaEQsSUFBSSxDQUFDLElBQUksRUFBRTtnQkFBRSxPQUFPLElBQUksQ0FBQzthQUFFO1lBRTNCLElBQUksQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxFQUFFO2dCQUM5QixJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQzthQUM3QjtZQUNELElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQztZQUUzQixJQUFJLENBQUMsT0FBTyxFQUFFLENBQUM7WUFFZixPQUFPLElBQUksQ0FBQztRQUNiLENBQUM7UUFFRCxnREFBZ0Q7UUFDaEQsK0JBQStCO1FBQy9CLGlCQUFpQixFQUFFLFVBQVUsSUFBSTtZQUMxQiw2Q0FBNkM7WUFDbkQsSUFBSSxDQUFDLElBQUksRUFBRTtnQkFBRSxPQUFPLElBQUksQ0FBQzthQUFFO1lBRTNCLElBQUksSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsRUFBRTtnQkFDN0IsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDO2dCQUMzQixJQUFJLENBQUMsT0FBTyxFQUFFLENBQUM7YUFDZjtZQUVELE9BQU8sSUFBSSxDQUFDO1FBQ2IsQ0FBQztRQUVELE9BQU8sRUFBRTtZQUNSLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFO2dCQUFFLE9BQU87YUFBRTtZQUUzQixJQUFNLE9BQU8sR0FBRyxFQUFFLENBQUM7WUFFbkIsS0FBSyxJQUFJLENBQUMsSUFBSSxJQUFJLENBQUMsYUFBYSxFQUFFO2dCQUNqQyxJQUFJLElBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDLEVBQUU7b0JBQzFCLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7aUJBQ2hCO2FBQ0Q7WUFFRCxJQUFNLGdCQUFnQixHQUFHLEVBQUUsQ0FBQztZQUU1QixJQUFJLElBQUksQ0FBQyxPQUFPLENBQUMsTUFBTSxFQUFFO2dCQUN4QixnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQzthQUMzQztZQUNELElBQUksT0FBTyxDQUFDLE1BQU0sRUFBRTtnQkFDbkIsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQzthQUMxQztZQUVELGlFQUFpRTtZQUMzRCxJQUFJLENBQUMsZUFBZSxDQUFDLFNBQVMsR0FBRyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDdEUsQ0FBQztLQUNELENBQUMsQ0FBQztJQUVILGlCQUFpQjtJQUNqQiwyQkFBMkI7SUFDM0IsNkNBQTZDO0lBQzdDLHdGQUF3RjtJQUN4RixhQUFHLENBQUMsWUFBWSxDQUFDO1FBQ2hCLGtCQUFrQixFQUFFLElBQUk7S0FDeEIsQ0FBQyxDQUFDO0lBRUgsYUFBRyxDQUFDLFdBQVcsQ0FBQztRQUNmLElBQUksSUFBSSxDQUFDLE9BQU8sQ0FBQyxrQkFBa0IsRUFBRTtZQUNwQyxJQUFJLHVCQUFlLEVBQUUsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDbEM7SUFDRixDQUFDLENBQUMsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUM5SEg7UUFBMkMseUNBQVM7UUFrQmhELCtCQUFZLE9BQTRCO1lBQXhDLFlBQ0ksa0JBQU0sT0FBTyxDQUFDLFNBQ2pCO1lBVEQsb0JBQWMsR0FBa0MsRUFBRSxDQUFDO1lBSW5ELFlBQU0sR0FBRyxLQUFLLENBQUM7O1FBS2YsQ0FBQztRQUVELDJDQUFXLEdBQVg7WUFBQSxpQkFvQ0M7WUFuQ0csSUFBSSxDQUFDLElBQUksQ0FBQyxhQUFhLEVBQUU7Z0JBQ3JCLElBQU0sQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLGFBQWEsR0FBRyw0QkFBaUIsRUFBQyxLQUFLLEVBQUUsU0FBUyxFQUFFLDZCQUE2QixDQUFDLENBQUMsQ0FBQzt3Q0FFM0YsQ0FBQztvQkFDTixJQUFNLElBQUksR0FBRyxPQUFLLG9CQUFvQixDQUFDLENBQUMsQ0FBQyxDQUFDO29CQUMxQyxJQUFNLENBQUMsR0FBRyw0QkFBaUIsRUFBQyxLQUFLLEVBQUUsQ0FBQyxFQUFFLG9CQUFvQixDQUFDLENBQUM7b0JBQzVELElBQU0sSUFBSSxHQUFHLDRCQUFpQixFQUFDLEtBQUssRUFBRSxDQUFDLEVBQUUsb0JBQW9CLENBQUMsQ0FBQztvQkFDL0QsSUFBTSxJQUFJLEdBQUcsNEJBQWlCLEVBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQyxDQUFDO29CQUMxQyxJQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUM7b0JBQ2pDLElBQUksQ0FBQyxTQUFTLEdBQUcsS0FBSyxDQUFDO29CQUN2QixDQUFDLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztvQkFDaEIseURBQXlEO29CQUN6RCxJQUFJLENBQUMsS0FBSyxDQUFDLGVBQWUsR0FBRyxPQUFPLEdBQUcsSUFBSSxDQUFDLEdBQUcsR0FBRyxJQUFJLENBQUM7b0JBQ3ZELENBQUMsQ0FBQyxnQkFBZ0IsQ0FBQyxPQUFPLEVBQUUsVUFBQyxHQUFHO3dCQUM1QixxQkFBcUI7d0JBQ3JCLEtBQUksQ0FBQyxvQkFBb0IsQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLENBQUM7d0JBQ3JDLFdBQVc7d0JBQ1gseUNBQXlDO3dCQUN6QywwQkFBMEI7d0JBQzFCLElBQUk7b0JBQ1IsQ0FBQyxDQUFDLENBQUM7b0JBQ0gsSUFBSSxPQUFLLG1CQUFtQixLQUFLLElBQUksRUFBRTt3QkFDbkMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLENBQUM7cUJBQzlCO29CQUNELElBQUksT0FBSywwQkFBMEIsS0FBSyxJQUFJLEVBQUU7d0JBQzFDLENBQUMsQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxDQUFDO3FCQUMvQjtvQkFDRCxPQUFLLGNBQWMsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7OztnQkF6Qm5DLGdEQUFnRDtnQkFDaEQsS0FBSyxJQUFJLENBQUMsR0FBRyxJQUFJLENBQUMsb0JBQW9CLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsRUFBRTs0QkFBckQsQ0FBQztpQkF5QlQ7Z0JBQ0QsSUFBTSxTQUFTLEdBQUcsNEJBQWlCLEVBQUMsS0FBSyxFQUFFLENBQUMsRUFBRSwwQkFBMEIsQ0FBQyxDQUFDO2dCQUMxRSxTQUFTLENBQUMsZ0JBQWdCLENBQUMsT0FBTyxFQUFFO29CQUNoQyxLQUFJLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUM7Z0JBQ3RDLENBQUMsQ0FBQyxDQUFDO2dCQUNILE9BQU8sQ0FBQyxDQUFDO2FBQ1o7UUFDTCxDQUFDO1FBRUQscUNBQUssR0FBTCxVQUFNLEdBQVU7WUFDWixJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRTtnQkFDWCxJQUFNLEdBQUcsR0FBRyw0QkFBaUIsRUFBQyxLQUFLLEVBQUUsU0FBUyxFQUFFLGVBQWUsQ0FBQyxDQUFDO2dCQUNqRSxJQUFJLElBQUksQ0FBQyxvQkFBb0IsRUFBRTtvQkFDM0IsSUFBSSxDQUFDLEdBQUcsQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLFdBQVcsRUFBRSxFQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLENBQUM7aUJBQ2xFO2dCQUNELElBQUksQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDO2FBQ2xCO1lBQ0QsT0FBTyxJQUFJLENBQUMsR0FBRyxDQUFDO1FBQ3BCLENBQUM7UUFFRCw2Q0FBYSxHQUFiLFVBQWMsVUFBaUMsRUFBRSxPQUFnQztZQUFqRixpQkFhQztZQVpHLElBQUksQ0FBQyxvQkFBb0IsR0FBRyxVQUFVLENBQUM7WUFDdkMsSUFBSSxDQUFDLG1CQUFtQixHQUFHLE9BQU8sQ0FBQztZQUNuQyw0REFBNEQ7WUFFNUQsSUFBSSxJQUFJLENBQUMsR0FBRyxFQUFFO2dCQUNWLElBQUksQ0FBQyxHQUFHLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUUsRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxDQUFDO2dCQUMvRCxJQUFNLFFBQVEsR0FBRyw0QkFBaUIsRUFBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLEdBQUcsRUFBRSx5QkFBeUIsQ0FBQyxDQUFDO2dCQUMvRSxRQUFRLENBQUMsZ0JBQWdCLENBQUMsT0FBTyxFQUFFO29CQUMvQixLQUFJLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUM7Z0JBQ3RDLENBQUMsQ0FBQyxDQUFDO2FBQ047WUFDRCxJQUFJLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3ZELENBQUM7UUFFRCwrQ0FBZSxHQUFmLFVBQWdCLFNBQThCO1lBQzFDLDRLQUE0SztZQUM1SyxJQUFJLENBQUMsU0FBUyxFQUFFO2dCQUNaLE9BQU87YUFDVjtZQUNELElBQUksSUFBSSxDQUFDLG1CQUFtQixFQUFFO2dCQUMxQixJQUFNLE1BQUksR0FBRyxJQUFJLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDO2dCQUN6RSxNQUFJLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsQ0FBQzthQUNwQztZQUNELElBQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsU0FBUyxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUM7WUFDMUQsSUFBSSxJQUFJLEVBQUU7Z0JBQ04sSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLENBQUM7YUFDakM7WUFDRCxJQUFJLFdBQXdCLENBQUM7WUFDN0IsSUFBSSxJQUFJLENBQUMsMEJBQTBCLEVBQUU7Z0JBQ2pDLE9BQU8sQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7Z0JBQ3JCLElBQU0sTUFBSSxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLDBCQUEwQixDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUM7Z0JBQ2hGLE1BQUksQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDO2dCQUNsQyxJQUFJLFNBQVMsS0FBSyxJQUFJLENBQUMsb0JBQW9CLENBQUMsQ0FBQyxDQUFDLEVBQUU7b0JBQzVDLFdBQVcsR0FBRyxJQUFJLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDLENBQUMsQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDO29CQUM5RSxrQ0FBa0M7b0JBQ2xDLHdCQUF3QjtvQkFDeEIsSUFBSSxDQUFDLDBCQUEwQixHQUFHLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDLENBQUMsQ0FBQztvQkFDL0QsT0FBTyxDQUFDLElBQUksQ0FBQyw0QkFBNEIsQ0FBQyxDQUFDO2lCQUM5QztxQkFBTTtvQkFDSCxXQUFXLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsb0JBQW9CLENBQUMsQ0FBQyxDQUFDLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQztvQkFDOUUsa0NBQWtDO29CQUNsQyxJQUFJLENBQUMsMEJBQTBCLEdBQUcsSUFBSSxDQUFDLG9CQUFvQixDQUFDLENBQUMsQ0FBQyxDQUFDO2lCQUNsRTthQUNKO2lCQUFNO2dCQUNILFdBQVcsR0FBRyxJQUFJLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDLENBQUMsQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDO2dCQUM5RSxJQUFJLENBQUMsMEJBQTBCLEdBQUcsSUFBSSxDQUFDLG9CQUFvQixDQUFDLENBQUMsQ0FBQyxDQUFDO2FBQ2xFO1lBQ0QsV0FBVyxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLENBQUM7WUFDdEMsV0FBVyxDQUFDLGFBQWEsQ0FBQyxXQUFXLENBQUMsV0FBVyxDQUFDLENBQUM7UUFDdkQsQ0FBQztRQUVELCtDQUFlLEdBQWYsVUFBZ0IsWUFBMEM7WUFDdEQsT0FBTyxDQUFDLElBQUksQ0FBQyxpQkFBaUIsRUFBRSxJQUFJLENBQUMsb0JBQW9CLEVBQUUsWUFBWSxDQUFDLENBQUM7WUFDekUsa0hBQWtIO1lBRWxILHlEQUF5RDtZQUN6RCxJQUFJLFNBQThCLENBQUM7WUFDbkMsSUFBSSxPQUFPLFlBQVksS0FBSyxRQUFRLEVBQUU7Z0JBQ2xDLFNBQVMsR0FBRyxJQUFJLENBQUMsb0JBQW9CLENBQUMsQ0FBQyxDQUFDLENBQUM7YUFDNUM7aUJBQU07Z0JBQ0gsU0FBUyxHQUFHLFlBQVksQ0FBQzthQUM1QjtZQUVELElBQUksQ0FBQyxlQUFlLENBQUMsU0FBUyxDQUFDLENBQUM7WUFDaEMsSUFBSSxDQUFDLG1CQUFtQixHQUFHLFNBQVMsQ0FBQztZQUNyQywwQkFBYSxDQUFDLG9CQUFvQixDQUFDLFFBQVEsQ0FBTSxJQUFJLEVBQUUsU0FBUyxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQ3hFLDBCQUFhLENBQUMsb0JBQW9CLENBQUMsUUFBUSxDQUFNLElBQUksRUFBRSxTQUFTLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDNUUsQ0FBQztRQUVELG9EQUFvQixHQUFwQixVQUFxQixHQUFlLEVBQUUsUUFBNkI7WUFDL0QsSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLEVBQUU7Z0JBQ2pCLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxXQUFXLENBQUMsUUFBUSxDQUFDLENBQUMsSUFBSSxDQUFDLFVBQUMsS0FBSztvQkFDdEQsUUFBUSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7Z0JBQzNCLENBQUMsQ0FBQyxDQUFDO2FBQ047WUFDRCxJQUFJLENBQUMsZUFBZSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1lBQy9CLHFDQUFxQztRQUN6QyxDQUFDO1FBQ0wsNEJBQUM7SUFBRCxDQUFDLENBdEowQyxDQUFDLENBQUMsT0FBTyxHQXNKbkQ7SUF0Slksc0RBQXFCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQ0xsQyxtQkFBTyxDQUFDLDJEQUFTLENBQUMsQ0FBQztJQUNuQixtQkFBTyxDQUFDLHVIQUFnQyxDQUFDLENBQUM7SUFTMUMscUVBQXFFO0lBRXJFLFNBQVMsVUFBVSxDQUFDLElBQVk7UUFDNUIsT0FBZSxDQUFDLENBQUMsT0FBTyxDQUFDLEVBQUUsSUFBSSxFQUFFLGtCQUFrQixHQUFHLE1BQU0sQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLEdBQUcsTUFBTSxFQUFFLFFBQVEsRUFBRSxJQUFJLENBQUMsQ0FBQyxLQUFLLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLFVBQVUsRUFBRSxJQUFJLENBQUMsQ0FBQyxLQUFLLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLFNBQVMsRUFBRSxZQUFZLEVBQUUsQ0FBQyxDQUFDO0lBQ3pMLENBQUM7SUFDRCxTQUFTLGtCQUFrQixDQUFDLElBQVk7UUFDcEMsT0FBZSxDQUFDLENBQUMsT0FBTyxDQUFDLEVBQUUsSUFBSSxFQUFFLGtCQUFrQixHQUFHLE1BQU0sQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLEdBQUcsTUFBTSxFQUFFLFFBQVEsRUFBRSxJQUFJLENBQUMsQ0FBQyxLQUFLLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLFVBQVUsRUFBRSxJQUFJLENBQUMsQ0FBQyxLQUFLLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLFNBQVMsRUFBRSxzQkFBc0IsRUFBRSxDQUFDLENBQUM7SUFDbk0sQ0FBQztJQXdERDtRQUF3RSx3Q0FBYztRQU9sRiw4QkFBWSxXQUFzRCxFQUFFLEtBQXlCLEVBQUUsSUFBUyxFQUFFLE9BQStCO1lBQXpJLFlBQ0ksa0JBQU0sS0FBSyxFQUFFLE9BQU8sQ0FBQyxTQUV4QjtZQVRELGFBQU8sR0FBWSxLQUFLLENBQUM7WUFJekIsY0FBUSxHQUFHLEtBQUssQ0FBQztZQUliLEtBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDOztRQUNyQixDQUFDO1FBRUQseUNBQVUsR0FBVixVQUFXLE9BQWdCO1lBQ3ZCLElBQUksQ0FBQyxPQUFPLEdBQUcsT0FBTyxDQUFDO1FBQzNCLENBQUM7UUFFRCx3Q0FBUyxHQUFUO1lBQ0ksT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDO1FBQ3hCLENBQUM7UUFFRCx3Q0FBUyxHQUFULFVBQVUsU0FBa0I7WUFDeEIsT0FBTyxDQUFDLElBQUksQ0FBQyx5Q0FBa0MsU0FBUyxjQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUUsQ0FBQyxDQUFDO1lBRS9FLElBQUksU0FBUyxFQUFFO2dCQUNYLElBQUksQ0FBQyxXQUFXLENBQUMsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLFNBQVMsSUFBSSxJQUFJLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQztnQkFDakUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQUUsQ0FBQyxDQUFDO2FBQ3ZDO2lCQUFNO2dCQUNILElBQU0sU0FBUyxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQztnQkFDcEMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQUUsQ0FBQyxDQUFDO2FBQzNDO1FBQ0wsQ0FBQztRQUNMLDJCQUFDO0lBQUQsQ0FBQyxDQS9CdUUsQ0FBQyxDQUFDLFlBQVksR0ErQnJGO0lBL0JZLG9EQUFvQjtJQWlDakM7UUFBa0Usa0NBQVE7UUFXdEUsZUFBZTtRQUVmLHdCQUFZLFdBQXNELEVBQUUsS0FBeUIsRUFBRSxJQUFTLEVBQUUsT0FBK0I7WUFBekksWUFDSSxrQkFBTSxLQUFLLEVBQUUsT0FBTyxDQUFDLFNBY3hCO1lBM0JELGFBQU8sR0FBWSxLQUFLLENBQUM7WUFPekIsNENBQTRDO1lBQzVDLGNBQVEsR0FBRyxLQUFLLENBQUM7WUFNYiwyQkFBMkI7WUFDM0IsZ0JBQWdCO1lBQ2hCLElBQUk7WUFDSixLQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQztZQUNqQixLQUFJLENBQUMsV0FBVyxHQUFHLFdBQVcsQ0FBQztZQUUvQixJQUFJLENBQUMsT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksRUFBRTtnQkFDM0IsS0FBSSxDQUFDLE9BQU8sQ0FBQyxjQUFjLENBQUMsR0FBRyxjQUFjLENBQUMsSUFBSSxDQUFDO2dCQUNuRCxLQUFJLENBQUMsT0FBTyxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsQ0FBQzthQUNyQztZQUNELElBQUksQ0FBQyxPQUFPLElBQUksQ0FBQyxPQUFPLENBQUMsVUFBVSxFQUFFO2dCQUNqQyxLQUFJLENBQUMsT0FBTyxDQUFDLFlBQVksQ0FBQyxHQUFHLGNBQWMsQ0FBQyxZQUFZLENBQUM7YUFDNUQ7O1FBQ0wsQ0FBQztRQUVELG1DQUFVLEdBQVYsVUFBVyxPQUFnQjtZQUN2QixJQUFJLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQztRQUMzQixDQUFDO1FBRUQsa0NBQVMsR0FBVDtZQUNJLE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQztRQUN4QixDQUFDO1FBRUQsa0NBQWtDO1FBQ2xDLDRFQUE0RTtRQUM1RSxpQ0FBaUM7UUFDakMsWUFBWTtRQUNaLDJCQUEyQjtRQUMzQiwyRUFBMkU7UUFDM0UsWUFBWTtRQUNaLGlCQUFpQjtRQUNqQiw4RUFBOEU7UUFDOUUsWUFBWTtRQUNaLHFCQUFxQjtRQUNyQixnQ0FBZ0M7UUFDaEMsUUFBUTtRQUNSLElBQUk7UUFDSixrQ0FBUyxHQUFULFVBQVUsU0FBa0I7WUFDeEIsT0FBTyxDQUFDLElBQUksQ0FBQywwQkFBMEIsRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLFNBQVMsQ0FBQyxDQUFDO1lBQ3JFLElBQUksQ0FBQyxRQUFRLEdBQUcsU0FBUyxDQUFDO1lBQzFCLElBQUksSUFBSSxDQUFDLEtBQUssRUFBRTtnQkFDWixJQUFJLFNBQVMsRUFBRTtvQkFDWCxJQUFJLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsa0JBQWtCLENBQUMsQ0FBQztpQkFDaEQ7cUJBQU07b0JBQ0gsSUFBSSxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLGtCQUFrQixDQUFDLENBQUM7aUJBQ25EO2FBQ0o7WUFDRCxPQUFPLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsQ0FBQztZQUMzQixtQkFBbUI7WUFDbkIsc0VBQXNFO1lBQ3RFLFdBQVc7WUFDWCx3RUFBd0U7WUFDeEUsSUFBSTtRQUNSLENBQUM7UUFqRU0sbUJBQUksR0FBRyxVQUFVLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDMUIsMkJBQVksR0FBRyxrQkFBa0IsQ0FBQyxNQUFNLENBQUMsQ0FBQztRQWlFckQscUJBQUM7S0FBQSxDQXJFaUUsQ0FBQyxDQUFDLE1BQU0sR0FxRXpFO0lBckVZLHdDQUFjO0lBNkYzQixJQUFJLGFBQWEsR0FBRyxDQUFDLENBQUM7SUFDdEI7UUFBa0MsZ0NBQW9CO1FBTWxELHNCQUFZLE9BQTZCO1lBQXpDLFlBQ0ksa0JBQU0sT0FBTyxDQUFDLFNBRWpCO1lBREcsS0FBSSxDQUFDLGdCQUFnQixHQUFHLE9BQU8sQ0FBQyxnQkFBZ0IsQ0FBQzs7UUFDckQsQ0FBQztRQUVELHNDQUFlLEdBQWYsVUFBZ0IsTUFBOEIsRUFBRSxTQUFrQjtZQUM5RCxNQUFNLENBQUMsU0FBUyxDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBQ2hDLENBQUM7UUFFRCxxQ0FBYyxHQUFkLFVBQWUsTUFBOEIsRUFBRSxFQUF1QjtZQUNsRSx5RkFBeUY7WUFDekYsMEJBQWEsQ0FBQyxpQkFBaUIsQ0FBQyxRQUFRLENBQUMsTUFBTSxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBQ3pELENBQUM7UUFFRCxpQ0FBVSxHQUFWLFVBQVcsTUFBOEI7WUFDckMsT0FBTyxJQUFJLDJCQUFVLENBQUMsSUFBSSxFQUFFLE1BQU0sQ0FBQyxDQUFDO1FBQ3hDLENBQUM7UUFFRCxpREFBMEIsR0FBMUIsVUFBMkIsT0FBWTs7WUFDbkMsSUFBTSxVQUFVLEdBQUcsT0FBTyxDQUFDLGFBQWEsRUFBRSxDQUFDO1lBRTNDLDhCQUE4QjtZQUM5Qix5QkFBeUI7WUFDekIsb0JBQW9CO1lBQ3BCLGlDQUFpQztZQUNqQyxxQkFBcUI7WUFDckIsV0FBVztZQUNYLG9CQUFvQjtZQUNwQixJQUFJO1lBRUosSUFBSSxDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUU7Z0JBQ25CLElBQUksQ0FBQyxTQUFRLENBQUM7Z0JBRWQsSUFBSSxVQUFJLENBQUMsZ0JBQWdCLENBQUMsSUFBSSwwQ0FBRSxPQUFPLEVBQUU7b0JBQ3JDLHNFQUFzRTtvQkFDdEUsQ0FBQyxHQUFHLFVBQVUsR0FBRyxhQUFhLEVBQUUsQ0FBQztvQkFDakMsNEJBQWlCLEVBQUMsR0FBRyxHQUFHLENBQUMsRUFBRSxrQ0FBMEIsSUFBSSxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxPQUFPLFNBQUssQ0FBQyxDQUFDO2lCQUNqRztxQkFBTSxJQUFJLFVBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxLQUFLLDBDQUFFLElBQUksRUFBRTtvQkFDMUMsdUVBQXVFO29CQUN2RSxDQUFDLEdBQUcsVUFBVSxHQUFHLGFBQWEsRUFBRSxDQUFDO29CQUNqQyw0QkFBaUIsRUFBQyxHQUFHLEdBQUcsQ0FBQyxFQUFFLGtDQUEwQixJQUFJLENBQUMsZ0JBQWdCLENBQUMsS0FBSyxDQUFDLElBQUksU0FBSyxDQUFDLENBQUM7aUJBQy9GO3FCQUFNLElBQUksSUFBSSxDQUFDLGdCQUFnQixDQUFDLE9BQU8sRUFBRTtvQkFDdEMsSUFBSSxVQUFJLENBQUMsZ0JBQWdCLENBQUMsS0FBSywwQ0FBRSxJQUFJLEVBQUU7d0JBQ25DLENBQUMsR0FBRyxVQUFVLEdBQUcsYUFBYSxFQUFFLENBQUM7d0JBQ2pDLHVFQUF1RTt3QkFDdkUsNEJBQWlCLEVBQUMsR0FBRyxHQUFHLENBQUMsRUFBRSxrQ0FBMEIsSUFBSSxDQUFDLGdCQUFnQixDQUFDLEtBQUssQ0FBQyxJQUFJLFNBQUssQ0FBQyxDQUFDO3FCQUMvRjtpQkFDSjtnQkFDRCxJQUFJLENBQUMsRUFBRTtvQkFDSCxJQUFJLENBQUMsV0FBVyxHQUFHLDBEQUEwRCxHQUFHLENBQUMsQ0FBQztpQkFDckY7cUJBQU07b0JBQ0gsSUFBSSxDQUFDLFdBQVcsR0FBRyxxQ0FBcUMsQ0FBQztpQkFDNUQ7YUFDSjtZQUNELE9BQU8sSUFBSSxDQUFDLENBQUMsT0FBTyxDQUFDLEVBQUUsSUFBSSxFQUFFLGFBQWEsR0FBRyxVQUFVLEdBQUcsZUFBZSxFQUFFLFNBQVMsRUFBRSxJQUFJLENBQUMsV0FBVyxFQUFFLFFBQVEsRUFBRSxJQUFJLENBQUMsQ0FBQyxLQUFLLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQztZQUN6SSxzS0FBc0s7WUFDdEssa0pBQWtKO1FBQ3RKLENBQUM7UUFLTCxtQkFBQztJQUFELENBQUMsQ0FwRWlDLENBQUMsQ0FBQyxrQkFBa0IsR0FvRXJEO0lBcEVZLG9DQUFZO0lBc0V6QixtRkFBbUY7SUFDbkY7UUFBcUUsa0NBQW9CO1FBc0JyRix3QkFBWSxPQUFxQztZQUFqRCxZQUNJLGtCQUFNLE9BQU8sQ0FBQyxTQUtqQjtZQWhCRCxlQUFTLEdBQTJDLEVBQUUsQ0FBQztZQUN2RCxhQUFPLEdBQTJCLEVBQUUsQ0FBQztZQVdqQyxLQUFJLENBQUMsWUFBWSxHQUFHLE9BQU8sQ0FBQyxZQUFZLENBQUM7WUFDekMsS0FBSSxDQUFDLEdBQUcsR0FBRyxPQUFPLENBQUMsR0FBRyxDQUFDO1lBQ3ZCLEtBQUksQ0FBQyxRQUFRLEdBQUcsT0FBTyxDQUFDLFFBQVEsQ0FBQztZQUNqQyxLQUFJLENBQUMsWUFBWSxHQUFHLE9BQU8sQ0FBQyxZQUFZLENBQUM7O1FBQzdDLENBQUM7UUFFRCx1Q0FBYyxHQUFkO1lBQUEsaUJBUUM7WUFQRyxNQUFNLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQyxJQUFJLENBQUMsVUFBQyxRQUFRO2dCQUMxQyxRQUFRLENBQUMsSUFBSSxFQUFFLENBQUMsSUFBSSxDQUFDLFVBQUMsSUFBSTtvQkFDdEIsS0FBSSxDQUFDLFVBQVUsR0FBRyxJQUFJLENBQUM7b0JBQ3ZCLEtBQUksQ0FBQyxJQUFJLENBQUMsa0JBQWtCLENBQUMsQ0FBQztvQkFDOUIsS0FBSSxDQUFDLFNBQVMsRUFBRSxDQUFDO2dCQUNyQixDQUFDLENBQUMsQ0FBQztZQUNQLENBQUMsQ0FBQyxDQUFDO1FBQ1AsQ0FBQztRQUNPLGtDQUFTLEdBQWpCO1lBQUEsaUJBWUM7WUFYRyxNQUFNLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsVUFBQyxRQUFRO2dCQUNqQyxRQUFRLENBQUMsSUFBSSxFQUFFLENBQUMsSUFBSSxDQUFDLFVBQUMsSUFBSTtvQkFDdEIsS0FBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUM7b0JBQ2pCLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO3dCQUNsQyxJQUFNLE1BQU0sR0FBRyxJQUFJLGNBQWMsQ0FBQyxLQUFJLEVBQUUsRUFBRSxHQUFHLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO3dCQUN6RixLQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQzt3QkFDMUIsS0FBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsTUFBTSxDQUFDO3FCQUN2QztvQkFDRCxLQUFJLENBQUMsT0FBTyxFQUFFLENBQUM7Z0JBQ25CLENBQUMsQ0FBQyxDQUFDO1lBQ1AsQ0FBQyxDQUFDLENBQUM7UUFDUCxDQUFDO1FBRUQsOEJBQUssR0FBTCxVQUFNLEdBQVU7WUFBaEIsaUJBUUM7WUFQRyxPQUFPLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxJQUFJLENBQUMsQ0FBQztZQUM3QixpQkFBTSxLQUFLLFlBQUMsR0FBRyxDQUFDLENBQUM7WUFDakIsSUFBSSxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUM7WUFDZixHQUFHLENBQUMsRUFBRSxDQUFDLFNBQVMsRUFBRSxVQUFDLEdBQUc7Z0JBQ2xCLEtBQUksQ0FBQyxlQUFlLEdBQUcsSUFBSSxDQUFDO1lBQ2hDLENBQUMsQ0FBQyxDQUFDO1lBQ0gsT0FBTyxJQUFJLENBQUM7UUFDaEIsQ0FBQztRQUNELGlDQUFRLEdBQVIsVUFBUyxHQUFVO1lBQ2YsaUJBQU0sUUFBUSxZQUFDLEdBQUcsQ0FBQyxDQUFDO1lBQ3BCLElBQUksQ0FBQyxHQUFHLEdBQUcsU0FBUyxDQUFDO1lBQ3JCLE9BQU8sSUFBSSxDQUFDO1FBQ2hCLENBQUM7UUFFTyxvQ0FBVyxHQUFuQixVQUFvQixLQUFVLEVBQUUsSUFBWTtZQUN4QyxJQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDO1lBQzdCLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEtBQUssR0FBRyxPQUFPLENBQUMsTUFBTSxFQUFFLENBQUMsR0FBRyxLQUFLLEVBQUUsQ0FBQyxFQUFFLEVBQUU7Z0JBQ3BELElBQU0sTUFBTSxHQUFHLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDMUIsSUFBSSxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLEtBQUssRUFBRTtvQkFDN0IsT0FBTyxNQUFNLENBQUM7aUJBQ2pCO2FBQ0o7UUFDTCxDQUFDO1FBRUssb0NBQVcsR0FBakIsVUFBa0IsR0FBVyxFQUFFLEtBQVU7Ozs7O2dDQUNwQixxQkFBTSxNQUFNLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxHQUFHLEdBQUcsVUFBVSxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsS0FBSyxDQUFDOzs0QkFBeEUsUUFBUSxHQUFHLFNBQTZEOzRCQUN2RCxxQkFBTSxRQUFRLENBQUMsSUFBSSxFQUFFOzs0QkFBdEMsSUFBSSxHQUFhLFNBQXFCOzRCQUN0QyxNQUFNLEdBQTJCLEVBQUUsQ0FBQzs0QkFDMUMsS0FBUyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO2dDQUM1QixNQUFNLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztnQ0FDdkMsSUFBSSxNQUFNLEVBQUU7b0NBQ1IsTUFBTSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztvQ0FDcEIsSUFBSSxDQUFDLE1BQU0sQ0FBQyxTQUFTLEVBQUUsRUFBRTt3Q0FDckIsSUFBSSxDQUFDLElBQUksQ0FBQyxZQUFZLEVBQUU7NENBQ3BCLElBQUksQ0FBQyxZQUFZLEdBQUcsRUFBRSxDQUFDO3lDQUMxQjt3Q0FDRCxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQzt3Q0FDL0IsSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQztxQ0FDekI7aUNBQ0o7NkJBQ0o7NEJBQ0Qsc0JBQU8sTUFBTSxFQUFDOzs7O1NBQ2pCO1FBRUQsNENBQW1CLEdBQW5CO1lBQUEsaUJBUUM7WUFQRyxPQUFPLENBQUMsSUFBSSxDQUFDLHFCQUFxQixDQUFDLENBQUM7WUFDcEMsSUFBSSxJQUFJLENBQUMsWUFBWSxFQUFFO2dCQUNuQixJQUFJLENBQUMsWUFBWSxDQUFDLE9BQU8sQ0FBQyxVQUFDLElBQUk7b0JBQzNCLEtBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUM7Z0JBQzNCLENBQUMsQ0FBQyxDQUFDO2dCQUNILElBQUksQ0FBQyxZQUFZLEdBQUcsU0FBUyxDQUFDO2FBQ2pDO1FBQ0wsQ0FBQztRQUVELG1GQUFtRjtRQUNuRiw2REFBNkQ7UUFDN0QsNERBQTREO1FBQzVELElBQUk7UUFFSix1Q0FBYyxHQUFkLFVBQWUsTUFBNEIsRUFBRSxFQUF1QjtZQUFwRSxpQkE0QkM7WUEzQkcsT0FBTyxDQUFDLEtBQUssQ0FBQyxnQkFBZ0IsRUFBRSxNQUFNLEVBQUUsRUFBRSxDQUFDLENBQUM7WUFFNUMsSUFBSSxNQUFNLENBQUMsUUFBUSxFQUFFO2dCQUNqQixJQUFJLElBQUksQ0FBQyxHQUFHLENBQUMsT0FBTyxFQUFFLEVBQUU7b0JBQ3BCLElBQU0sR0FBRyxHQUFTLE1BQU0sQ0FBQyxJQUFLLENBQUMsR0FBRyxDQUFDO29CQUNuQyxJQUFNLEdBQUcsR0FBUyxNQUFNLENBQUMsSUFBSyxDQUFDLEdBQUcsQ0FBQztvQkFDbkMsSUFBTSxHQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsTUFBTSxDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FBQztvQkFFakMsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDO29CQUV6QixJQUFJLENBQUMsSUFBSSxDQUFDLGNBQWMsRUFBRSxVQUFDLEdBQUc7d0JBQzFCLE9BQU8sQ0FBQyxJQUFJLENBQUMsb0NBQTZCLEdBQUMsTUFBRyxDQUFDLENBQUM7d0JBQ2hELE1BQU0sQ0FBQyxVQUFVLENBQUM7NEJBQ2QsS0FBSSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsR0FBQyxDQUFDLENBQUM7d0JBQ3hCLENBQUMsQ0FBQyxDQUFDO29CQUNQLENBQUMsQ0FBQyxDQUFDO2lCQUNOO3FCQUFNO29CQUNILHlGQUF5RjtvQkFDekYsK0RBQStEO29CQUMvRCwwQkFBYSxDQUFDLGlCQUFpQixDQUFDLFFBQVEsQ0FBQyxNQUFNLEVBQUUsRUFBRSxDQUFDLENBQUM7aUJBQ3hEO2FBQ0o7aUJBQU07Z0JBQ0gsNkRBQTZEO2dCQUM3RCx5RkFBeUY7Z0JBQ3pGLDBCQUFhLENBQUMsaUJBQWlCLENBQUMsUUFBUSxDQUFDLE1BQU0sRUFBRSxFQUFFLENBQUMsQ0FBQztnQkFDckQsSUFBSSxDQUFDLGNBQWMsR0FBRyxNQUFNLENBQUM7YUFDaEM7UUFDTCxDQUFDO1FBRUQsd0NBQWUsR0FBZixVQUFnQixNQUF5QixFQUFFLFNBQWtCO1lBQ3pELE9BQU8sQ0FBQyxJQUFJLENBQUMseUNBQWtDLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLGNBQUksU0FBUyxDQUFFLENBQUMsQ0FBQztZQUVqRixJQUFJLFNBQVMsRUFBRTtnQkFDWCxJQUFJLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxDQUFDO2dCQUN6QixPQUFPLENBQUMsSUFBSSxDQUFDLHNCQUFzQixHQUFHLE1BQU0sQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7Z0JBQzNELE1BQU0sQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLEdBQUcsTUFBTSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUM7Z0JBQ2hELE1BQU0sQ0FBQyxPQUFPLENBQUMsSUFBSSxHQUFHLGVBQWUsQ0FBQztnQkFDdEMsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLENBQUM7Z0JBQzNCLE1BQU0sQ0FBQyxTQUFTLENBQUMsU0FBUyxDQUFDLENBQUM7YUFDL0I7aUJBQU07Z0JBQ0gsSUFBSSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLENBQUM7Z0JBQzlCLElBQU0sT0FBTyxHQUFHLE1BQU0sQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLENBQUM7Z0JBQzFDLElBQUksT0FBTyxFQUFFO29CQUNULE1BQU0sQ0FBQyxPQUFPLENBQUMsSUFBSSxHQUFHLE9BQU8sQ0FBQztpQkFDakM7Z0JBQ0QsSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQztnQkFDdEIsTUFBTSxDQUFDLFNBQVMsQ0FBQyxTQUFTLENBQUMsQ0FBQzthQUMvQjtRQUNMLENBQUM7UUFFRCxtQ0FBVSxHQUFWLFVBQVcsS0FBVSxFQUFFLElBQVk7WUFDL0IsT0FBTyxJQUFJLENBQUMsV0FBVyxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsQ0FBQztRQUN6QyxDQUFDO1FBRUQsbUNBQVUsR0FBVixVQUFXLEtBQVUsRUFBRSxJQUFZO1lBQy9CLE9BQU8sQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUM7WUFDM0IsSUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLENBQUM7WUFDN0MsSUFBSSxNQUFNLEVBQUU7Z0JBQ1IsSUFBSSxDQUFDLE1BQU0sQ0FBQyxTQUFTLEVBQUUsRUFBRTtvQkFDckIsSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQztpQkFDekI7Z0JBQ0QsSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxHQUFHLEVBQUUsRUFBRTtvQkFDMUIsSUFBSSxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsTUFBTSxDQUFDLFNBQVMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDO2lCQUNuRDtxQkFBTTtvQkFDSCxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsU0FBUyxFQUFFLENBQUMsQ0FBQztpQkFDdkM7YUFDSjtZQUNELE9BQU8sTUFBTSxDQUFDO1FBQ2xCLENBQUM7UUFFRCxtQ0FBVSxHQUFWLFVBQVcsTUFBNEI7WUFDbkMsT0FBTyxJQUFJLDJCQUFVLENBQUMsSUFBSSxFQUFFLE1BQU0sQ0FBQyxDQUFDO1FBQ3hDLENBQUM7UUFFRCxpQ0FBUSxHQUFSLFVBQVMsSUFBZTtZQUNwQixPQUFPLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1lBQ3hCLElBQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUM7WUFDL0IsSUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQztZQUU3QixJQUFNLE9BQU8sR0FBMkIsRUFBRSxDQUFDO1lBQzNDLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEtBQUssR0FBRyxPQUFPLENBQUMsTUFBTSxFQUFFLENBQUMsR0FBRyxLQUFLLEVBQUUsQ0FBQyxFQUFFLEVBQUU7Z0JBQ3BELElBQU0sTUFBTSxHQUFHLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFFMUIsSUFBSSxRQUFRLENBQUMsWUFBWSxDQUFDLE1BQU0sQ0FBQyxJQUFJLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFO29CQUM1QyxPQUFPLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO2lCQUN4QjthQUNKO1lBQ0QsT0FBTyxPQUFPLENBQUM7UUFDbkIsQ0FBQztRQUVELGdDQUFPLEdBQVA7WUFDSSxPQUFPLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1lBQ3hCLElBQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUM7WUFDL0IsSUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQztZQUU3QixJQUFJLElBQUksQ0FBQyxrQkFBa0IsRUFBRTtnQkFDekIsSUFBTSxZQUFZLEdBQUcsSUFBSSxDQUFDLGtCQUFrQixDQUFDO2dCQUM3QyxnQkFBZ0I7Z0JBQ2hCLDhDQUE4QztnQkFDOUMsbURBQW1EO2dCQUNuRCxJQUFJO2dCQUNKLDJFQUEyRTtnQkFFM0UsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsS0FBSyxHQUFHLE9BQU8sQ0FBQyxNQUFNLEVBQUUsQ0FBQyxHQUFHLEtBQUssRUFBRSxDQUFDLEVBQUUsRUFBRTtvQkFDcEQsSUFBTSxNQUFNLEdBQUcsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDO29CQUUxQixJQUFJLFFBQVEsQ0FBQyxZQUFZLENBQUMsTUFBTSxDQUFDLElBQUksRUFBRSxZQUFZLENBQUMsRUFBRTt3QkFDbEQsSUFBSSxDQUFDLE1BQU0sQ0FBQyxTQUFTLEVBQUUsRUFBRTs0QkFDckIsZ0dBQWdHOzRCQUNoRyxJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDOzRCQUN0QixNQUFNLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDO3lCQUMzQjtxQkFDSjt5QkFBTTt3QkFDSCxJQUFJLE1BQU0sQ0FBQyxTQUFTLEVBQUUsRUFBRTs0QkFDcEIsZ0dBQWdHOzRCQUNoRyxJQUFJLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxDQUFDOzRCQUN6QixNQUFNLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxDQUFDO3lCQUM1QjtxQkFDSjtpQkFDSjthQUNKO2lCQUFNO2dCQUNILEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEtBQUssR0FBRyxPQUFPLENBQUMsTUFBTSxFQUFFLENBQUMsR0FBRyxLQUFLLEVBQUUsQ0FBQyxFQUFFLEVBQUU7b0JBQ3BELElBQU0sTUFBTSxHQUFHLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQztvQkFDMUIsSUFBSSxNQUFNLENBQUMsU0FBUyxFQUFFLEVBQUU7d0JBQ3BCLElBQUksQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLENBQUM7d0JBQ3pCLE1BQU0sQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLENBQUM7cUJBQzVCO2lCQUNKO2FBQ0o7UUFDTCxDQUFDO1FBRUQsc0NBQWEsR0FBYixVQUFjLEdBQWM7WUFDeEIsSUFBSSxDQUFDLGtCQUFrQixHQUFHLEdBQUcsQ0FBQztZQUM5QixJQUFJLENBQUMsT0FBTyxFQUFFLENBQUM7UUFDbkIsQ0FBQztRQUVELHNDQUFhLEdBQWI7WUFDSSxPQUFPLElBQUksQ0FBQyxVQUFVLENBQUM7UUFDM0IsQ0FBQztRQUNMLHFCQUFDO0lBQUQsQ0FBQyxDQTdQb0UsQ0FBQyxDQUFDLGtCQUFrQixHQTZQeEY7SUE3UFksd0NBQWM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lDbFEzQjtRQUFvQyxrQ0FBTztRQVF2Qyx3QkFBWSxPQUE4QjtZQUExQyxZQUNJLGtCQUFNLE9BQU8sQ0FBQyxTQUVqQjtZQURHLEtBQUksQ0FBQyxPQUFPLEdBQUcsT0FBTyxDQUFDOztRQUMzQixDQUFDO1FBRUQsOEJBQUssR0FBTCxVQUFNLEdBQVE7WUFBZCxpQkFlQztZQWRMLDJDQUEyQztZQUNuQyxJQUFJLENBQUMsSUFBSSxHQUFHLEdBQUcsQ0FBQztZQUNoQixJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRTtnQkFDWCxJQUFNLEdBQUcsR0FBRyw0QkFBaUIsRUFBQyxLQUFLLEVBQUUsU0FBUyxFQUFFLElBQUksQ0FBQyxPQUFPLENBQUMsU0FBUyxHQUFDLFlBQVksQ0FBQyxDQUFDO2dCQUNyRixJQUFNLENBQUMsR0FBRyxJQUFJLENBQUMsU0FBUyxHQUFHLFVBQUMsRUFBYTtvQkFDckMsRUFBRSxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUM7b0JBQ3ZCLEVBQUUsQ0FBQyxlQUFlLEVBQUUsQ0FBQztvQkFDckIsS0FBSSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsS0FBSSxDQUFDLENBQUM7b0JBQzFCLE9BQU8sSUFBSSxDQUFDO2dCQUNoQixDQUFDLENBQUM7Z0JBQ0YsR0FBRyxDQUFDLGdCQUFnQixDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUMsQ0FBQztnQkFDakMsSUFBSSxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUM7YUFDbEI7WUFDRCxPQUFPLElBQUksQ0FBQyxHQUFHLENBQUM7UUFDcEIsQ0FBQztRQUVELGlDQUFRLEdBQVIsVUFBUyxHQUFVO1lBQ2YsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUM7WUFDakIsSUFBSSxDQUFDLEdBQUcsQ0FBQyxtQkFBbUIsQ0FBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBQzFELENBQUM7UUFDTCxxQkFBQztJQUFELENBQUMsQ0FsQ21DLGlCQUFPLEdBa0MxQztJQWxDWSx3Q0FBYztJQW9DM0I7UUFBd0Msc0NBQU87UUFVM0MsNEJBQVksT0FBdUI7WUFBbkMsWUFDSSxrQkFBTSxPQUFPLENBQUMsU0FFakI7WUFERyxLQUFJLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQzs7UUFDM0IsQ0FBQztRQUVELGtDQUFLLEdBQUwsVUFBTSxHQUFRO1lBQWQsaUJBeUNDO1lBeENHLG1DQUFtQztZQUNuQyxJQUFJLENBQUMsSUFBSSxHQUFHLEdBQUcsQ0FBQztZQUVoQixJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRTtnQkFDWCxJQUFNLEdBQUcsR0FBRyw0QkFBaUIsRUFBQyxLQUFLLEVBQUUsU0FBUyxFQUFFLGVBQWUsQ0FBQyxDQUFDO2dCQUNqRSxJQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsT0FBTyxHQUFHLDRCQUFpQixFQUFDLEtBQUssRUFBRSxHQUFHLEVBQUUscUJBQXFCLENBQUMsQ0FBQztnQkFDcEYsb0RBQW9EO2dCQUNwRCxPQUFPLENBQUMsU0FBUyxHQUFHLEdBQUcsQ0FBQztnQkFDeEIsNkRBQTZEO2dCQUM3RCx5QkFBeUI7Z0JBQ3pCLGtCQUFRLENBQUMsdUJBQXVCLENBQUMsT0FBTyxDQUFDLENBQUM7Z0JBQzFDLElBQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxTQUFTLEdBQUcsVUFBQyxFQUFhO29CQUN6QyxLQUFJLENBQUMsY0FBYyxDQUFDLEtBQUksRUFBRSxJQUFJLENBQUMsQ0FBQztvQkFDaEMsT0FBTyxJQUFJLENBQUM7Z0JBQ2hCLENBQUMsQ0FBQztnQkFDRixPQUFPLENBQUMsZ0JBQWdCLENBQUMsT0FBTyxFQUFFLEtBQUssQ0FBQyxDQUFDO2dCQUN6QyxPQUFPLENBQUMsZ0JBQWdCLENBQUMsYUFBYSxFQUFFLEtBQUssQ0FBQyxDQUFDO2dCQUMvQyxPQUFPLENBQUMsZ0JBQWdCLENBQUMsU0FBUyxFQUFFLEtBQUssQ0FBQyxDQUFDO2dCQUMzQyxPQUFPLENBQUMsZ0JBQWdCLENBQUMsV0FBVyxFQUFFLEtBQUssQ0FBQyxDQUFDO2dCQUc3QyxJQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsUUFBUSxHQUFHLDRCQUFpQixFQUFDLEtBQUssRUFBRSxHQUFHLEVBQUUsc0JBQXNCLENBQUMsQ0FBQztnQkFDdkYsMERBQTBEO2dCQUMxRCxRQUFRLENBQUMsU0FBUyxHQUFHLEdBQUcsQ0FBQztnQkFDekIsMkRBQTJEO2dCQUMzRCw4QkFBOEI7Z0JBQzlCLGtCQUFRLENBQUMsdUJBQXVCLENBQUMsUUFBUSxDQUFDLENBQUM7Z0JBQzNDLElBQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxTQUFTLEdBQUcsVUFBQyxFQUFhO29CQUMxQyxLQUFJLENBQUMsY0FBYyxDQUFDLEtBQUksRUFBRSxLQUFLLENBQUMsQ0FBQztvQkFDakMsT0FBTyxJQUFJLENBQUM7Z0JBQ2hCLENBQUMsQ0FBQztnQkFDRixRQUFRLENBQUMsZ0JBQWdCLENBQUMsT0FBTyxFQUFFLE1BQU0sQ0FBQyxDQUFDO2dCQUMzQyxRQUFRLENBQUMsZ0JBQWdCLENBQUMsYUFBYSxFQUFFLE1BQU0sQ0FBQyxDQUFDO2dCQUNqRCxRQUFRLENBQUMsZ0JBQWdCLENBQUMsU0FBUyxFQUFFLE1BQU0sQ0FBQyxDQUFDO2dCQUM3QyxRQUFRLENBQUMsZ0JBQWdCLENBQUMsV0FBVyxFQUFFLE1BQU0sQ0FBQyxDQUFDO2dCQUcvQyxJQUFJLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQzthQUNsQjtZQUNELE9BQU8sSUFBSSxDQUFDLEdBQUcsQ0FBQztRQUNwQixDQUFDO1FBRUQsMkNBQWMsR0FBZCxVQUFlLENBQW9CLEVBQUUsUUFBZ0I7WUFDakQsT0FBTyxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQztZQUM5QixJQUFNLElBQUksR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBQzVDLElBQUksSUFBSSxFQUFFO2dCQUNOLElBQU0sRUFBRSxHQUFHLE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsQ0FBQyxnQkFBZ0IsQ0FBQyxXQUFXLENBQUMsQ0FBQztnQkFDdkUsSUFBSSxRQUFRLEdBQUcsUUFBUSxDQUFDLEVBQUUsQ0FBQyxDQUFDO2dCQUM1QixJQUFNLENBQUMsR0FBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUMvQixRQUFRLElBQUksQ0FBQyxDQUFDO2dCQUVkLElBQUksUUFBUSxHQUFDLENBQUMsSUFBSSxRQUFRLEdBQUMsRUFBRSxFQUFFO29CQUMzQixJQUFJLENBQUMsS0FBSyxDQUFDLFFBQVEsR0FBRyxRQUFRLEdBQUMsSUFBSSxDQUFDO29CQUVwQyxJQUFJLFFBQVEsS0FBRyxDQUFDLEVBQUU7d0JBQ2QsSUFBSSxDQUFDLFFBQVEsQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxDQUFDO3FCQUMzQzt5QkFBTTt3QkFDSCxJQUFJLENBQUMsUUFBUSxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLENBQUM7cUJBQzlDO29CQUNELElBQUksUUFBUSxLQUFHLEVBQUUsRUFBRTt3QkFDZixJQUFJLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLENBQUM7cUJBQzFDO3lCQUFNO3dCQUNILElBQUksQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsQ0FBQztxQkFDN0M7aUJBQ0o7YUFDSjtRQUVMLENBQUM7UUFFRCxxQ0FBUSxHQUFSLFVBQVMsR0FBVTtZQUNmLElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDO1lBQ2pCLElBQUksQ0FBQyxHQUFHLENBQUMsbUJBQW1CLENBQUMsT0FBTyxFQUFFLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUMxRCxDQUFDO1FBRUwseUJBQUM7SUFBRCxDQUFDLENBMUZ1QyxpQkFBTyxHQTBGOUM7SUExRlksZ0RBQWtCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQ3hDL0I7UUFBQTtRQWlDQSxDQUFDO1FBaENHLG9CQUFvQjtRQUVwQixrQ0FBTSxHQUFOLFVBQU8sSUFBYztZQUNqQixJQUFNLEtBQUssR0FBaUIsSUFBSSxDQUFDLElBQUksQ0FBQztZQUN0QyxJQUFNLEdBQUcsR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQzFDLElBQUksT0FBTyxJQUFJLENBQUMsSUFBSSxLQUFLLFFBQVEsRUFBRTtnQkFDL0IsR0FBRyxDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDO2dCQUMxQixHQUFHLENBQUMsT0FBTyxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDO2dCQUNoQyxHQUFHLENBQUMsWUFBWSxDQUFDLGNBQWMsRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7Z0JBQzVDLEdBQUcsQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQzthQUN6QjtpQkFBTTtnQkFDSCxJQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLE9BQU8sQ0FBQyxDQUFDO2dCQUNoRCxJQUFJLENBQUMsR0FBRyxFQUFFO29CQUNOLFFBQVEsQ0FBQztpQkFDWjtnQkFDRCxHQUFHLENBQUMsU0FBUyxHQUFHLEdBQUcsQ0FBQztnQkFDcEIsR0FBRyxDQUFDLE9BQU8sQ0FBQyxPQUFPLEdBQUcsR0FBRyxDQUFDO2dCQUMxQixHQUFHLENBQUMsWUFBWSxDQUFDLGNBQWMsRUFBRSxHQUFHLENBQUMsQ0FBQztnQkFDdEMsR0FBRyxDQUFDLEtBQUssR0FBRyxHQUFHLENBQUM7YUFDbkI7WUFDRCxHQUFHLENBQUMsU0FBUyxHQUFHLFNBQVMsQ0FBQztZQUUxQix5QkFBeUI7WUFDekIsd0VBQXdFO1lBQ3hFLHdCQUF3QjtZQUN4Qix1Q0FBdUM7WUFDdkMsbURBQW1EO1lBQ25ELFFBQVE7WUFDUixJQUFJO1lBRUosT0FBTyxHQUFHLENBQUM7UUFDZixDQUFDO1FBQ0wsd0JBQUM7SUFBRCxDQUFDO0lBRUQsSUFBTSxhQUFhLEdBQUcsSUFBSSxpQkFBaUIsRUFBRSxDQUFDO0lBRTlDO1FBQUE7UUFLQSxDQUFDO1FBQUQsMEJBQUM7SUFBRCxDQUFDO0lBTFksa0RBQW1CO0lBT2hDO1FBQUE7UUFHQSxDQUFDO1FBQUQsNkJBQUM7SUFBRCxDQUFDO0lBSFksd0RBQXNCO0lBS25DO1FBQUE7UUFPQSxDQUFDO1FBQUQsMEJBQUM7SUFBRCxDQUFDO0lBUFksa0RBQW1CO0lBY2hDO1FBQWtDLGdDQUFTO1FBcUJ2QyxzQkFBWSxPQUE2QjtZQUF6QyxZQUNJLGtCQUFNLE9BQU8sQ0FBQyxTQVdqQjtZQXBCRCxxQkFBZSxHQUErQyxFQUFFLENBQUM7WUFDakUseUJBQW1CLEdBQStCLEVBQUUsQ0FBQztZQUVyRCxjQUFRLEdBQTRDLEVBQUUsQ0FBQztZQU9uRCxJQUFJLE9BQU8sQ0FBQyxTQUFTLEVBQUU7Z0JBQ25CLEtBQUksQ0FBQyxTQUFTLEdBQUcsT0FBTyxDQUFDLFNBQVMsQ0FBQzthQUN0QztZQUNELElBQUksT0FBTyxDQUFDLFVBQVUsRUFBRTtnQkFDcEIsS0FBSSxDQUFDLG9CQUFvQixHQUFHLE9BQU8sQ0FBQyxVQUFVLENBQUM7YUFDbEQ7WUFDRCxJQUFJLE9BQU8sQ0FBQyxVQUFVLEVBQUU7Z0JBQ3BCLEtBQUksQ0FBQyxVQUFVLEdBQUcsT0FBTyxDQUFDLFVBQVUsQ0FBQzthQUN4QztZQUNELEtBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQzs7UUFDdkIsQ0FBQztRQUVPLGtDQUFXLEdBQW5CLFVBQW9CLEdBQWU7WUFDL0IsSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQ3BDLENBQUM7UUFDTyxvQ0FBYSxHQUFyQixVQUFzQixHQUFlO1lBQ2pDLElBQUksQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUN0QyxDQUFDO1FBRUQsa0NBQVcsR0FBWCxVQUFZLEtBQWEsRUFBRSxJQUFjLEVBQUUsR0FBb0I7WUFDM0QsT0FBTyxDQUFDLElBQUksQ0FBQyxzQkFBZSxLQUFLLGNBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLGVBQUssMEJBQWUsQ0FBQyxHQUFHLENBQUMsQ0FBRSxDQUFDLENBQUM7UUFDcEYsQ0FBQztRQUVELHdDQUFpQixHQUFqQixVQUFrQixLQUFjO1lBQzVCLDBCQUFhLENBQUMsb0JBQW9CLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRSxLQUFLLENBQUMsQ0FBQztRQUM3RCxDQUFDO1FBRUQsd0NBQWlCLEdBQWpCLFVBQWtCLElBQWMsRUFBRSxHQUFvQjtZQUNsRCxPQUFPLENBQUMsSUFBSSxDQUFDLDRCQUFxQiwwQkFBZSxDQUFDLEdBQUcsQ0FBQyxDQUFFLEVBQUUsSUFBSSxDQUFDLENBQUM7WUFDaEUsSUFBTSxVQUFVLEdBQUcsR0FBRyxLQUFLLDBCQUFlLENBQUMsUUFBUSxDQUFDO1lBQ3BELElBQU0sS0FBSyxHQUFpQixJQUFJLENBQUMsSUFBSSxDQUFDO1lBQ3RDLEtBQUssQ0FBQyxXQUFXLENBQUMsVUFBVSxDQUFDLENBQUM7UUFDbEMsQ0FBQztRQUVELHVDQUFnQixHQUFoQixVQUFpQixJQUFjLEVBQUUsR0FBb0I7WUFBckQsaUJBVUM7WUFURyxPQUFPLENBQUMsSUFBSSxDQUFDLDJCQUFvQiwwQkFBZSxDQUFDLEdBQUcsQ0FBQyxDQUFFLEVBQUUsSUFBSSxDQUFDLENBQUM7WUFDL0QsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFO2dCQUNsQixJQUFJLENBQUMsbUJBQW1CLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsVUFBQyxLQUFLO29CQUN2RCxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7b0JBQ3hCLEtBQUksQ0FBQyxpQkFBaUIsQ0FBQyxLQUFLLENBQUMsQ0FBQztnQkFDbEMsQ0FBQyxDQUFDLENBQUM7YUFDTjtpQkFBTTtnQkFDSCxJQUFJLENBQUMsaUJBQWlCLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQzthQUMzQztRQUNMLENBQUM7UUFFRCxvQ0FBYSxHQUFiLFVBQWMsVUFBaUMsRUFBRSxPQUFnQztZQUM3RSxJQUFJLENBQUMsb0JBQW9CLEdBQUcsVUFBVSxDQUFDO1lBQ3ZDLElBQUksQ0FBQyxtQkFBbUIsR0FBRyxPQUFPLENBQUM7WUFDbkMsSUFBSSxJQUFJLENBQUMsSUFBSSxFQUFFO2dCQUNYLElBQUksQ0FBQyxvQkFBb0IsRUFBRSxDQUFDO2FBQy9CO1lBQ0QsSUFBSSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsb0JBQW9CLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUN2RCxDQUFDO1FBRUQsc0NBQWUsR0FBZixVQUFnQixTQUF1QztZQUNuRCxPQUFPLENBQUMsSUFBSSxDQUFDLG1CQUFtQixFQUFFLFNBQVMsQ0FBQyxDQUFDO1lBQzdDLElBQUksT0FBTyxTQUFTLEtBQUssUUFBUSxFQUFFO2dCQUMvQixJQUFJLENBQUMsbUJBQW1CLEdBQUcsSUFBSSxDQUFDLG9CQUFvQixDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUN4RCxJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxTQUFTLENBQUMsQ0FBQzthQUNuQztpQkFBTTtnQkFDSCxJQUFJLENBQUMsbUJBQW1CLEdBQUcsU0FBUyxDQUFDO2dCQUNyQyxJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxTQUFTLENBQUMsQ0FBQzthQUNuQztRQUNMLENBQUM7UUFFRCx1Q0FBZ0IsR0FBaEIsVUFBaUIsVUFBNEI7WUFDekMsT0FBTyxDQUFDLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO1lBQ2pDLElBQUksQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBQ3JDLENBQUM7UUFFRCxnQ0FBUyxHQUFULFVBQVUsTUFBZTtZQUF6QixpQkFPQztZQU5HLElBQUksQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDO1lBQ3JCLDBCQUFhLENBQUMsWUFBWSxDQUFDLFNBQVMsQ0FBQyxVQUFDLE1BQU0sRUFBRSxHQUFHLElBQUssWUFBSSxDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUMsRUFBckIsQ0FBcUIsQ0FBQyxDQUFDO1lBQzdFLDBCQUFhLENBQUMsY0FBYyxDQUFDLFNBQVMsQ0FBQyxVQUFDLE1BQU0sRUFBRSxHQUFHLElBQUssWUFBSSxDQUFDLGFBQWEsQ0FBQyxHQUFHLENBQUMsRUFBdkIsQ0FBdUIsQ0FBQyxDQUFDO1lBQ2pGLElBQUksSUFBSSxDQUFDLElBQUksRUFBRTtnQkFDWCxJQUFJLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQzthQUMzQjtRQUNMLENBQUM7UUFFTyxrQ0FBVyxHQUFuQjtZQUNJLElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxXQUFJLENBQUMsSUFBSSxFQUFFLEVBQUUsVUFBVSxFQUFFLHdCQUFhLENBQUMsS0FBSyxFQUFFLGlCQUFpQixFQUFFLElBQUksRUFBRSxDQUFDLENBQUM7WUFDekYsSUFBSSxDQUFDLG9CQUFvQixFQUFFLENBQUM7WUFDNUIsS0FBSyxJQUFNLEtBQUssSUFBSSxJQUFJLENBQUMsUUFBUSxFQUFFO2dCQUMvQixJQUFJLENBQUMsaUJBQWlCLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQzthQUN2RDtZQUVELEtBQUssSUFBTSxLQUFLLElBQUksSUFBSSxDQUFDLGVBQWUsRUFBRTtnQkFDdEMsSUFBSSxDQUFDLHdCQUF3QixDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsZUFBZSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7YUFDckU7UUFDTCxDQUFDO1FBRU8sdUNBQWdCLEdBQXhCO1lBQUEsaUJBbUJDO1lBbEJHLElBQUksSUFBSSxDQUFDLElBQUksRUFBRTtnQkFDWCxJQUFJLElBQUksQ0FBQyxNQUFNLEVBQUU7b0JBQ2IsSUFBSSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsVUFBQyxLQUFLO3dCQUN0QixJQUFNLFNBQVMsR0FBRyxJQUFJLG1CQUFRLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDO3dCQUM1QyxJQUFJLEtBQUssQ0FBQyxNQUFNLEVBQUU7NEJBQ2QsS0FBSyxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsVUFBQyxLQUFLO2dDQUN2Qix5RUFBeUU7Z0NBQ3pFLElBQU0sU0FBUyxHQUFHLElBQUksbUJBQVEsQ0FBQyxLQUFLLEVBQUUsSUFBSSxFQUFFLEVBQUUsWUFBWSxFQUFFLGFBQWEsRUFBRSxDQUFDLENBQUM7Z0NBQzdFLFNBQVMsQ0FBQyxpQkFBaUIsQ0FBQyxTQUFTLENBQUMsVUFBQyxJQUFJLEVBQUUsR0FBRyxJQUFLLFlBQUksQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLEVBQUUsR0FBRyxDQUFDLEVBQWpDLENBQWlDLENBQUMsQ0FBQztnQ0FDeEYsU0FBUyxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsQ0FBQzs0QkFDakMsQ0FBQyxDQUFDLENBQUM7eUJBQ047d0JBQ0QsSUFBSSxTQUFTLENBQUMsTUFBTSxJQUFJLFNBQVMsQ0FBQyxNQUFNLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTs0QkFDakQsS0FBSSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLENBQUM7eUJBQ2hDO29CQUNMLENBQUMsQ0FBQyxDQUFDO2lCQUNOO2FBQ0o7UUFDTCxDQUFDO1FBQ08sMkNBQW9CLEdBQTVCO1lBQUEsaUJBc0JDO1lBckJHLElBQUksSUFBSSxDQUFDLElBQUksRUFBRTtnQkFDWCxJQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsb0JBQW9CLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDL0UsSUFBSSxLQUFLLEdBQUcsQ0FBQyxFQUFFO29CQUNYLElBQU0sY0FBYyxHQUFlLEVBQUUsQ0FBQztvQkFDdEMsSUFBSSxTQUFTLFNBQWUsQ0FBQztvQkFDN0IsSUFBSSxJQUFJLENBQUMsbUJBQW1CLENBQUMsY0FBYyxFQUFFO3dCQUN6QyxTQUFTLEdBQUcsRUFBRSxjQUFjLEVBQUUsSUFBSSxDQUFDLG1CQUFtQixDQUFDLGNBQWMsRUFBRSxDQUFDO3FCQUMzRTtvQkFDRCxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsS0FBSyxFQUFFLENBQUMsRUFBRSxFQUFFO3dCQUM1QixJQUFNLGFBQWEsR0FBRyxJQUFJLG1CQUFRLENBQUMsSUFBSSxDQUFDLG9CQUFvQixDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksRUFBRSxTQUFTLENBQUMsQ0FBQzt3QkFDbEYsY0FBYyxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQztxQkFDdEM7b0JBQ0QsT0FBTyxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQztvQkFDN0IsSUFBTSxTQUFTLEdBQUcsSUFBSSw2QkFBa0IsQ0FBQyxFQUFFLElBQUksRUFBRSxZQUFZLEVBQUUsRUFBRSxjQUFjLENBQUMsQ0FBQztvQkFDakYsU0FBUyxDQUFDLGlCQUFpQixDQUFDLFNBQVMsQ0FBQyxVQUFDLElBQUksRUFBRSxHQUFHLElBQUssWUFBSSxDQUFDLGdCQUFnQixDQUFDLElBQUksRUFBRSxHQUFHLENBQUMsRUFBaEMsQ0FBZ0MsQ0FBQyxDQUFDO29CQUN2RixJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsQ0FBQztpQkFDaEM7Z0JBQ0QsT0FBTyxDQUFDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO2dCQUNoQyxJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsbUJBQW1CLENBQUMsQ0FBQztnQkFDL0MsSUFBSSxDQUFDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxTQUFTLENBQUMsVUFBQyxJQUFJLEVBQUUsR0FBRyxJQUFLLFlBQUksQ0FBQyxXQUFXLENBQUMsTUFBTSxFQUFFLElBQUksRUFBRSxHQUFHLENBQUMsRUFBbkMsQ0FBbUMsQ0FBQyxDQUFDO2FBQzdGO1FBQ0wsQ0FBQztRQUVELCtDQUF3QixHQUF4QixVQUF5QixLQUFhLEVBQUUsY0FBd0M7WUFBaEYsaUJBU0M7WUFSRyxJQUFJLElBQUksQ0FBQyxJQUFJLEVBQUU7Z0JBQ1gsSUFBTSxVQUFVLEdBQUcsY0FBYyxDQUFDLGFBQWEsRUFBRSxDQUFDO2dCQUNsRCxJQUFNLFVBQVEsR0FBRyxJQUFJLG1CQUFRLENBQUMsS0FBSyxDQUFDLENBQUM7Z0JBQ3JDLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLFVBQVEsQ0FBQyxDQUFDO2dCQUM1QixJQUFJLENBQUMsYUFBYSxDQUFDLFVBQVEsRUFBRSxVQUFVLENBQUMsQ0FBQztnQkFDekMsSUFBSSxDQUFDLG1CQUFtQixDQUFDLEtBQUssQ0FBQyxHQUFHLFVBQVEsQ0FBQztnQkFDM0MsVUFBUSxDQUFDLGlCQUFpQixDQUFDLFNBQVMsQ0FBQyxVQUFDLElBQUksRUFBRSxNQUFNLElBQUssWUFBSSxDQUFDLGtCQUFrQixDQUFDLEtBQUssRUFBRSxVQUFRLEVBQUUsTUFBTSxDQUFDLEVBQWhELENBQWdELENBQUMsQ0FBQzthQUM1RztRQUNMLENBQUM7UUFFRCx3Q0FBaUIsR0FBakIsVUFBa0IsS0FBYSxFQUFFLFFBQStCO1lBQWhFLGlCQVdDO1lBVkcsT0FBTyxDQUFDLElBQUksQ0FBQyxtQ0FBNEIsSUFBSSxDQUFDLElBQUksQ0FBRSxDQUFDLENBQUM7WUFDdEQsSUFBSSxJQUFJLENBQUMsSUFBSSxFQUFFO2dCQUNYLElBQU0sVUFBUSxHQUFHLElBQUksbUJBQVEsQ0FBQyxLQUFLLEVBQUUsU0FBUyxFQUFFLEVBQUUsVUFBVSxFQUFFLHdCQUFhLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQztnQkFDckYsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsVUFBUSxDQUFDLENBQUM7Z0JBQzVCLFFBQVEsQ0FBQyxPQUFPLENBQUMsVUFBQyxZQUFZO29CQUMxQixJQUFNLFFBQVEsR0FBRyxJQUFJLG1CQUFRLENBQUMsWUFBWSxFQUFFLElBQUksRUFBRSxFQUFFLFVBQVUsRUFBRSx3QkFBYSxDQUFDLEtBQUssRUFBRSxZQUFZLEVBQUUsYUFBYSxFQUFFLENBQUMsQ0FBQztvQkFDcEgsUUFBUSxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQztnQkFDL0IsQ0FBQyxDQUFDLENBQUM7Z0JBQ0gsVUFBUSxDQUFDLGlCQUFpQixDQUFDLFNBQVMsQ0FBQyxVQUFDLElBQUksRUFBRSxNQUFNLElBQUssWUFBSSxDQUFDLGNBQWMsQ0FBQyxLQUFLLEVBQUUsVUFBUSxFQUFFLE1BQU0sQ0FBQyxFQUE1QyxDQUE0QyxDQUFDLENBQUM7YUFDeEc7UUFDTCxDQUFDO1FBRUQsNEJBQUssR0FBTCxVQUFNLEdBQVU7WUFDWix1Q0FBdUM7WUFDdkMsSUFBSSxJQUFJLENBQUMsVUFBVSxFQUFFO2dCQUNqQixJQUFJLENBQUMsTUFBTSxFQUFFLENBQUM7Z0JBQ2QsSUFBSSxDQUFDLElBQUksR0FBRyxHQUFHLENBQUM7Z0JBQ2hCLElBQU0sU0FBUyxHQUFHLENBQU8sSUFBSyxDQUFDLFVBQVUsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7Z0JBQzdELFNBQVMsQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLGVBQWUsQ0FBQyxDQUFDO2dCQUN6QyxJQUFJLENBQUMsVUFBVSxDQUFDLFdBQVcsQ0FBQyxTQUFTLENBQUMsQ0FBQztnQkFDdkMsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsUUFBUSxFQUFFLElBQUksQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLENBQUM7Z0JBQzFDLE9BQU8sSUFBSSxDQUFDO2FBQ2Y7aUJBQU07Z0JBQ0gsT0FBTyxpQkFBTSxLQUFLLFlBQUMsR0FBRyxDQUFDLENBQUM7YUFDM0I7UUFDTCxDQUFDO1FBRUQsNEJBQUssR0FBTCxVQUFNLEdBQVU7WUFDWixPQUFPLENBQUMsSUFBSSxDQUFDLG9CQUFvQixDQUFDLENBQUM7WUFDbkMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUU7Z0JBQ1osSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFDO2FBQ3RCO1lBRUQsZ0RBQWdEO1lBRWhELElBQUksQ0FBQyxJQUFJLEdBQUcsR0FBRyxDQUFDO1lBQ2hCLHVEQUF1RDtZQUN2RCxxREFBcUQ7WUFDckQsSUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQztZQUVoQyxJQUFJLElBQUksQ0FBQyxTQUFTLEVBQUU7Z0JBQ2hCLEdBQUcsQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQzthQUNyQztZQUNELElBQU0saUJBQWlCLEdBQUcsVUFBQyxFQUFTO2dCQUNoQyxFQUFFLENBQUMsZUFBZSxFQUFFLENBQUM7Z0JBQ3JCLE9BQU8sS0FBSyxDQUFDO1lBQ2pCLENBQUMsQ0FBQztZQUNGLDJDQUEyQztZQUMzQyw0Q0FBNEM7WUFDNUMsR0FBRyxDQUFDLGdCQUFnQixDQUFDLGFBQWEsRUFBRSxpQkFBaUIsQ0FBQyxDQUFDO1lBQ3ZELEdBQUcsQ0FBQyxnQkFBZ0IsQ0FBQyxXQUFXLEVBQUUsaUJBQWlCLENBQUMsQ0FBQztZQUNyRCxHQUFHLENBQUMsZ0JBQWdCLENBQUMsVUFBVSxFQUFFLGlCQUFpQixDQUFDLENBQUM7WUFDcEQsR0FBRyxDQUFDLGdCQUFnQixDQUFDLFdBQVcsRUFBRSxpQkFBaUIsQ0FBQyxDQUFDO1lBQ3JELEdBQUcsQ0FBQyxnQkFBZ0IsQ0FBQyxNQUFNLEVBQUUsaUJBQWlCLENBQUMsQ0FBQztZQUNoRCxHQUFHLENBQUMsZ0JBQWdCLENBQUMsT0FBTyxFQUFFLGlCQUFpQixDQUFDLENBQUM7WUFDakQsT0FBTyxHQUFHLENBQUM7UUFDZixDQUFDO1FBQ0QsK0JBQVEsR0FBUixVQUFTLEdBQVU7WUFDZixPQUFPLENBQUMsSUFBSSxDQUFDLHVCQUF1QixDQUFDLENBQUM7UUFDMUMsQ0FBQztRQUVELGFBQWE7UUFDYiw0Q0FBNEM7UUFDNUMsc0JBQXNCO1FBQ3RCLG1CQUFtQjtRQUNuQixJQUFJO1FBRUosK0NBQXdCLEdBQXhCLFVBQXlCLFdBQW1CO1lBQ3hDLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsb0JBQW9CLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO2dCQUN2RCxJQUFJLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLEtBQUssV0FBVyxFQUFFO29CQUNqRCxPQUFPLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDLENBQUMsQ0FBQztpQkFDdkM7Z0JBQ0QsSUFBSSxJQUFJLENBQUMsb0JBQW9CLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLFFBQVEsRUFBRSxDQUFDLFdBQVcsRUFBRSxLQUFLLFdBQVcsQ0FBQyxXQUFXLEVBQUUsRUFBRTtvQkFDeEYsT0FBTyxJQUFJLENBQUMsb0JBQW9CLENBQUMsQ0FBQyxDQUFDLENBQUM7aUJBQ3ZDO2FBQ0o7WUFDRCxPQUFPLFNBQVMsQ0FBQztRQUNyQixDQUFDO1FBRUQsb0NBQWEsR0FBYixVQUFjLEtBQWEsRUFBRSxJQUFjO1lBQ3ZDLE9BQU8sQ0FBQyxJQUFJLENBQUMsZUFBZSxFQUFFLElBQUksQ0FBQyxDQUFDO1lBQ3BDLElBQU0sSUFBSSxHQUFhLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUN2RCxJQUFJLElBQUksRUFBRTtnQkFDTixPQUFPLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEVBQUUsRUFBRSxJQUFJLENBQUMsQ0FBQzthQUN2QztRQUNMLENBQUM7UUFFRCwyQ0FBb0IsR0FBcEIsVUFBcUIsS0FBYSxFQUFFLElBQWM7WUFDOUMsT0FBTyxDQUFDLElBQUksQ0FBQyxzQkFBc0IsRUFBRSxJQUFJLENBQUMsQ0FBQztZQUMzQyxJQUFNLElBQUksR0FBYSxJQUFJLENBQUMsbUJBQW1CLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDdkQsSUFBSSxJQUFJLEVBQUU7Z0JBQ04sSUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsRUFBRSxFQUFFLElBQUksQ0FBQyxDQUFDO2dCQUMzQyxJQUFJLEtBQUssRUFBRTtvQkFDUCxJQUFNLElBQUksR0FBRyxFQUFFLENBQUM7b0JBQ2hCLEtBQUssSUFBSSxDQUFDLEdBQUcsS0FBSyxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRTt3QkFDeEMsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO3FCQUMvQjtvQkFDRCxPQUFPLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsQ0FBQztvQkFDM0IsSUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLGVBQWUsQ0FBQyxLQUFLLENBQUMsQ0FBQztvQkFDMUMsSUFBSSxLQUFLLEVBQUU7d0JBQ1AsT0FBTyxLQUFLLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDO3FCQUMvQjtpQkFDSjthQUNKO1FBQ0wsQ0FBQztRQUVELG9DQUFhLEdBQWIsVUFBYyxLQUFhLEVBQUUsSUFBUztZQUNsQyxPQUFPLENBQUMsSUFBSSxDQUFDLGVBQWUsRUFBRSxJQUFJLENBQUMsQ0FBQztZQUNwQyxJQUFNLElBQUksR0FBYSxJQUFJLENBQUMsbUJBQW1CLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDdkQsSUFBSSxJQUFJLEVBQUU7Z0JBQ04sSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsRUFBRSxFQUFFLElBQUksQ0FBQyxDQUFDO2FBQ2xDO1FBQ0wsQ0FBQztRQUVELGlDQUFVLEdBQVYsVUFBVyxLQUFhLEVBQUUsRUFBTyxFQUFFLElBQVk7WUFDM0MsT0FBTyxDQUFDLElBQUksQ0FBQyxxQkFBYyxLQUFLLGVBQUssRUFBRSxlQUFLLElBQUksTUFBRyxDQUFDLENBQUM7WUFDckQsSUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLGVBQWUsQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUMxQyxJQUFJLEtBQUssRUFBRTtnQkFDUCxJQUFNLE1BQU0sR0FBRyxLQUFLLENBQUMsVUFBVSxDQUFDLEVBQUUsRUFBRSxJQUFJLENBQUMsQ0FBQzthQUM3QztRQUNMLENBQUM7UUFFRCwrQkFBUSxHQUFSLFVBQVMsS0FBYSxFQUFFLElBQWU7WUFDbkMsT0FBTyxDQUFDLElBQUksQ0FBQyxtQkFBWSxLQUFLLGVBQUssSUFBSSxNQUFHLENBQUMsQ0FBQztZQUM1QyxJQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsZUFBZSxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQzFDLE9BQU8sS0FBSyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUNoQyxDQUFDO1FBRUQsd0NBQWlCLEdBQWpCLFVBQWtCLEtBQWEsRUFBRSxjQUF3QyxFQUFFLE9BQWlCO1lBQ3hGLElBQUksQ0FBQyxlQUFlLENBQUMsS0FBSyxDQUFDLEdBQUcsY0FBYyxDQUFDO1lBQzdDLE9BQU8sQ0FBQyxJQUFJLENBQUMsbUJBQW1CLENBQUMsQ0FBQztZQUNsQyxJQUFJLElBQUksQ0FBQyxJQUFJLEVBQUU7Z0JBQ1gsSUFBSSxDQUFDLHdCQUF3QixDQUFDLEtBQUssRUFBRSxjQUFjLENBQUMsQ0FBQztnQkFDckQsSUFBSSxPQUFPLEVBQUU7b0JBQ1QsSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLENBQUM7aUJBQy9CO2FBQ0o7UUFDTCxDQUFDO1FBQ08seUNBQWtCLEdBQTFCLFVBQTJCLFVBQWtCLEVBQUUsSUFBYyxFQUFFLE1BQXVCO1lBQ2xGLE9BQU8sQ0FBQyxJQUFJLENBQUMsb0JBQW9CLEVBQUUsSUFBSSxFQUFFLE1BQU0sQ0FBQyxDQUFDO1lBQ2pELElBQU0sWUFBWSxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBQ3JELElBQU0sYUFBYSxHQUFHLElBQUksQ0FBQyxlQUFlLENBQUMsVUFBVSxDQUFDLENBQUM7WUFDdkQsSUFBSSxhQUFhLEVBQUU7Z0JBQ2YsYUFBYSxDQUFDLGFBQWEsQ0FBQyxZQUFZLENBQUMsQ0FBQzthQUM3QztRQUNMLENBQUM7UUFFTyxxQ0FBYyxHQUF0QixVQUF1QixLQUFhLEVBQUUsSUFBYyxFQUFFLE1BQXVCO1lBQ3pFLE9BQU8sQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLEVBQUUsS0FBSyxFQUFFLElBQUksRUFBRSxNQUFNLENBQUMsQ0FBQztRQUN4RCxDQUFDO1FBRU8sb0NBQWEsR0FBckIsVUFBc0IsS0FBaUI7WUFDbkMsSUFBTSxHQUFHLEdBQUcsRUFBRSxDQUFDO1lBQ2YsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEtBQUssQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7Z0JBQ25DLElBQUksS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLG1CQUFtQixFQUFFLEtBQUssMEJBQWUsQ0FBQyxRQUFRLEVBQUU7b0JBQzdELEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7aUJBQ2hDO3FCQUFNO29CQUNILElBQUksS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLG1CQUFtQixFQUFFLEtBQUssMEJBQWUsQ0FBQyxhQUFhLEVBQUU7d0JBQ2xFLElBQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDO3dCQUNsRCxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsS0FBSyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTs0QkFDbkMsR0FBRyxDQUFDLElBQUksZ0JBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLEdBQUssS0FBSyxDQUFDLENBQUMsQ0FBQyxRQUFFLENBQUM7eUJBQzdDO3FCQUNKO2lCQUNKO2FBQ0o7WUFDRCxPQUFPLEdBQUcsQ0FBQztRQUNmLENBQUM7UUFFTyxvQ0FBYSxHQUFyQixVQUFzQixJQUFxQixFQUFFLFVBQXNCO1lBQy9ELEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxVQUFVLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO2dCQUN4QyxJQUFNLFFBQVEsR0FBRyxJQUFJLG1CQUFRLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksRUFBRSxZQUFZLENBQUMsWUFBWSxDQUFDLENBQUM7Z0JBQzlFLElBQUksVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sRUFBRTtvQkFDdEIsSUFBSSxDQUFDLGFBQWEsQ0FBQyxRQUFRLEVBQUUsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDO2lCQUN0RDtnQkFDRCxJQUFJLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDO2FBQzFCO1FBQ0wsQ0FBQztRQTFWTSx5QkFBWSxHQUFrQjtZQUNqQyxjQUFjLEVBQUUsYUFBYTtZQUM3QixVQUFVLEVBQUUsd0JBQWEsQ0FBQyxLQUFLO1NBQ2xDLENBQUM7UUF3Vk4sbUJBQUM7S0FBQSxDQTVWaUMsQ0FBQyxDQUFDLE9BQU8sR0E0VjFDO0lBNVZZLG9DQUFZOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQ3pEekI7UUFBQTtRQWFBLENBQUM7UUFaRyxrQ0FBTSxHQUFOLFVBQU8sSUFBYztZQUNqQixJQUFNLEtBQUssR0FBVSxJQUFJLENBQUMsSUFBSSxDQUFDO1lBQy9CLElBQU0sR0FBRyxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDMUMsSUFBTSxHQUFHLEdBQUcsS0FBSyxDQUFDLEtBQUssQ0FBQztZQUN4QixHQUFHLENBQUMsU0FBUyxHQUFHLEdBQUcsQ0FBQztZQUNwQixHQUFHLENBQUMsT0FBTyxDQUFDLE9BQU8sR0FBRyxHQUFHLENBQUM7WUFDMUIsR0FBRyxDQUFDLFlBQVksQ0FBQyxjQUFjLEVBQUUsR0FBRyxDQUFDLENBQUM7WUFDdEMsR0FBRyxDQUFDLEtBQUssR0FBRyxHQUFHLENBQUM7WUFDaEIsR0FBRyxDQUFDLFNBQVMsR0FBRyxTQUFTLENBQUM7WUFFMUIsT0FBTyxHQUFHLENBQUM7UUFDZixDQUFDO1FBQ0wsd0JBQUM7SUFBRCxDQUFDO0lBRUQ7UUFBNEIsaUNBQVE7UUFBcEM7O1FBcUZBLENBQUM7UUFwRkcsOEJBQU0sR0FBTixVQUFPLEtBQWM7WUFBckIsaUJBbUZDO1lBbEZHLEtBQUssR0FBRyxLQUFLLGFBQUwsS0FBSyxjQUFMLEtBQUssR0FBSSxDQUFDLENBQUM7WUFFbkIsSUFBSSxHQUFHLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQztZQUNuQixJQUFJLE9BQU8sR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDO1lBQzNCLElBQUksQ0FBQyxHQUFHLEVBQUU7Z0JBQ04sR0FBRyxHQUFHLElBQUksQ0FBQyxHQUFHLEdBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsQ0FBQztnQkFDL0MsR0FBRyxDQUFDLFNBQVMsR0FBRywwQkFBMEIsR0FBRyxLQUFLLENBQUM7Z0JBQ25ELE9BQU8sR0FBRyxJQUFJLENBQUMsT0FBTyxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLENBQUM7Z0JBQ3ZELE9BQU8sQ0FBQyxTQUFTLEdBQUcsU0FBUyxDQUFDO2dCQUU5QixHQUFHLENBQUMsV0FBVyxDQUFDLE9BQU8sQ0FBQyxDQUFDO2dCQUV6QixJQUFNLFVBQVUsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUN4RCwyQ0FBMkM7Z0JBRTNDLElBQU0sS0FBSyxHQUFVLElBQUksQ0FBQyxJQUFJLENBQUM7Z0JBRS9CLElBQUksS0FBSyxDQUFDLElBQUksRUFBRTtvQkFDWixJQUFNLEdBQUcsR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxDQUFDO29CQUMxQyxHQUFHLENBQUMsR0FBRyxHQUFHLEtBQUssQ0FBQyxJQUFJLENBQUM7b0JBQ3JCLEdBQUcsQ0FBQyxHQUFHLEdBQUcsT0FBTyxHQUFHLEtBQUssQ0FBQyxLQUFLLENBQUM7b0JBQ2hDLE9BQU8sQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLENBQUM7aUJBQzVCO2dCQUVELElBQU0sUUFBUSxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLENBQUM7Z0JBQy9DLFFBQVEsQ0FBQyxTQUFTLEdBQUcsV0FBVyxDQUFDO2dCQUNqQywrQ0FBK0M7Z0JBQy9DLElBQU0sS0FBSyxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLENBQUM7Z0JBQzVDLElBQU0sR0FBRyxHQUFHLEtBQUssQ0FBQyxLQUFLLENBQUM7Z0JBQ3hCLEtBQUssQ0FBQyxTQUFTLEdBQUcsR0FBRyxDQUFDO2dCQUN0QixLQUFLLENBQUMsT0FBTyxDQUFDLE9BQU8sR0FBRyxHQUFHLENBQUM7Z0JBQzVCLEtBQUssQ0FBQyxZQUFZLENBQUMsY0FBYyxFQUFFLEdBQUcsQ0FBQyxDQUFDO2dCQUN4QyxLQUFLLENBQUMsS0FBSyxHQUFHLEdBQUcsQ0FBQztnQkFDbEIsS0FBSyxDQUFDLFNBQVMsR0FBRyxTQUFTLENBQUM7Z0JBQzVCLGVBQWU7Z0JBQ2YsUUFBUSxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsQ0FBQztnQkFDNUIsT0FBTyxDQUFDLFdBQVcsQ0FBQyxRQUFRLENBQUMsQ0FBQztnQkFDOUIsSUFBSTtnQkFFSixJQUFJLEtBQUssS0FBSyxDQUFDLEVBQUU7b0JBQ2IsSUFBTSxhQUFhLEdBQUcsQ0FBQyxJQUFJLENBQUMsYUFBYSxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztvQkFDNUUsT0FBTyxDQUFDLGdCQUFnQixDQUFDLE9BQU8sRUFBRSxVQUFDLEVBQUUsSUFBSyxZQUFJLENBQUMsZUFBZSxDQUFDLEVBQUUsQ0FBQyxFQUF4QixDQUF3QixDQUFDLENBQUM7b0JBRXBFLElBQUksSUFBSSxDQUFDLFNBQVMsRUFBRTt3QkFDaEIsSUFBSSxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxDQUFDO3FCQUNwQzt5QkFBTTt3QkFDSCxJQUFJLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLENBQUM7cUJBQ3BDO29CQUVELElBQUksVUFBVSxHQUFHLENBQUMsRUFBRTt3QkFDaEIsSUFBSSxJQUFJLENBQUMsU0FBUyxFQUFFOzRCQUNoQixJQUFJLENBQUMsYUFBYSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLENBQUM7eUJBQzlDOzZCQUFNOzRCQUNILElBQUksQ0FBQyxhQUFhLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsQ0FBQzt5QkFDOUM7cUJBQ0o7b0JBQ0QsSUFBSSxDQUFDLFFBQVEsR0FBRyxhQUFhLENBQUM7b0JBQzlCLE9BQU8sQ0FBQyxXQUFXLENBQUMsYUFBYSxDQUFDLENBQUM7aUJBQ3RDO3FCQUFNO29CQUNILElBQUksQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsQ0FBQztpQkFDcEM7Z0JBRUQsSUFBSSxhQUFhLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQztnQkFDbEMsSUFBSSxhQUFhLEVBQUU7b0JBQ2YsYUFBYSxDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUM7aUJBQ2xDO2dCQUVELElBQUksVUFBVSxHQUFHLENBQUMsRUFBRTtvQkFDaEIsSUFBSSxDQUFDLGFBQWEsRUFBRTt3QkFDaEIsYUFBYSxHQUFHLElBQUksQ0FBQyxRQUFRLEdBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsQ0FBQzt3QkFDOUQsYUFBYSxDQUFDLFNBQVMsR0FBRyxlQUFlLENBQUM7d0JBQzFDLEdBQUcsQ0FBQyxXQUFXLENBQUMsYUFBYSxDQUFDLENBQUM7cUJBQ2xDO29CQUNELHdFQUF3RTtvQkFDeEUsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO3dCQUN6QyxhQUFhLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO3FCQUMvRDtpQkFDSjtnQkFDRCxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDLGFBQWEsSUFBSSxVQUFVLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQzthQUNyRjtZQUNELElBQUksQ0FBQyxXQUFXLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDO1lBQzNELE9BQU8sR0FBRyxDQUFDO1FBQ2YsQ0FBQztRQUNMLG9CQUFDO0lBQUQsQ0FBQyxDQXJGMkIsbUJBQVEsR0FxRm5DO0lBRUQsSUFBSSxRQUFRLEdBQVEsU0FBUyxDQUFDO0lBQzlCLFNBQVMsZUFBZTtRQUNwQixJQUFJLENBQUMsUUFBUSxFQUFFO1lBQ1g7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1lBeUNBO1lBQ0EsSUFBTSxDQUFDLEdBQUcseWdHQWlDakIsQ0FBQztZQUNNLElBQU0sTUFBTSxHQUFHLElBQUksU0FBUyxFQUFFLENBQUM7WUFDL0IsSUFBTSxHQUFHLEdBQUcsTUFBTSxDQUFDLGVBQWUsQ0FBQyxDQUFDLEVBQUUsV0FBVyxDQUFDLENBQUM7WUFDbkQsSUFBTSxRQUFRLEdBQUcsR0FBRyxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUMxQyxJQUFNLENBQUMsR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQ3hDLENBQUMsQ0FBQyxTQUFTLEdBQUcsQ0FBQyxDQUFDO1lBQ2hCLFFBQVEsR0FBRyxRQUFRLENBQUMsQ0FBQyx3QkFBd0I7U0FDaEQ7UUFDRCxPQUFPLFFBQVEsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDcEMsQ0FBQztJQUVELElBQU0sTUFBTTtJQUNSLHFRQUFxUTtJQUNyUSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsYUFBYSxFQUFFLGFBQWEsRUFBRSxhQUFhLEVBQUUsYUFBYSxFQUFFLGFBQWEsRUFBRSxhQUFhLEVBQUUsYUFBYSxFQUFFLGFBQWEsRUFBRSxhQUFhLEVBQUUsYUFBYSxFQUFFLGFBQWEsRUFBRSxhQUFhLEVBQUUsYUFBYSxFQUFFLGFBQWEsRUFBRSxhQUFhLENBQUMsQ0FBQztJQUVyUDtRQUF3Qiw2QkFBUTtRQUc1QixtQkFBWSxLQUFtQjttQkFDM0Isa0JBQU0sS0FBSyxDQUFDO1FBQ2hCLENBQUM7UUFFRCwwQkFBTSxHQUFOLFVBQU8sS0FBYztZQUFyQixpQkFrR0M7O1lBakdHLGlEQUFpRDtZQUNqRCxJQUFJLENBQUMsS0FBSyxFQUFFO2dCQUNSLEtBQUssR0FBRyxDQUFDLENBQUM7YUFDYjtZQUVELElBQUksR0FBRyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUM7WUFDbkIsSUFBSSxPQUFPLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQztZQUMzQixJQUFJLENBQUMsR0FBRyxFQUFFO2dCQUNOLEdBQUcsR0FBRyxJQUFJLENBQUMsR0FBRyxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLENBQUM7Z0JBQy9DLEdBQUcsQ0FBQyxTQUFTLEdBQUcsMEJBQTBCLEdBQUcsS0FBSyxDQUFDO2dCQUNuRCxPQUFPLEdBQUcsSUFBSSxDQUFDLE9BQU8sR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxDQUFDO2dCQUN2RCxHQUFHLENBQUMsV0FBVyxDQUFDLE9BQU8sQ0FBQyxDQUFDO2dCQUN6QixrREFBa0Q7Z0JBQ2xELE9BQU8sQ0FBQyxTQUFTLEdBQUcsU0FBUyxDQUFDO2dCQUM5QixzREFBc0Q7Z0JBQ3RELElBQU0sRUFBRSxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLENBQUM7Z0JBQ3pDLEVBQUUsQ0FBQyxTQUFTLEdBQUcsVUFBVSxDQUFDO2dCQUUxQixJQUFJLEtBQUssU0FBa0IsQ0FBQztnQkFDNUIsS0FBSyxHQUFHLElBQUksQ0FBQyxLQUFLLEdBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBQyxPQUFPLENBQUMsQ0FBQztnQkFDckQsS0FBSyxDQUFDLElBQUksR0FBRyxVQUFVLENBQUM7Z0JBQ3hCLEtBQUssQ0FBQyxFQUFFLEdBQUcsSUFBSSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDO2dCQUMvQix3Q0FBd0M7Z0JBQ3hDLHNDQUFzQztnQkFDdEMsK0hBQStIO2dCQUMvSCxnRkFBZ0Y7Z0JBQ2hGLEtBQUssQ0FBQyxnQkFBZ0IsQ0FBQyxRQUFRLEVBQUUsVUFBQyxFQUFFLElBQUssWUFBSSxDQUFDLGFBQWEsQ0FBQyxFQUFFLENBQUMsRUFBdEIsQ0FBc0IsQ0FBQyxDQUFDO2dCQUNqRSxFQUFFLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxDQUFDO2dCQUN0QixPQUFPLENBQUMsV0FBVyxDQUFDLEVBQUUsQ0FBQyxDQUFDO2dCQUN4QixJQUFNLEtBQUssR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLE9BQU8sQ0FBQyxDQUFDO2dCQUM5QyxLQUFLLENBQUMsT0FBTyxHQUFHLElBQUksR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQztnQkFDcEMsOEJBQThCO2dCQUM5QixFQUFFLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxDQUFDO2dCQUN0QixnREFBZ0Q7Z0JBQ2hELGtCQUFrQjtnQkFDbEIsTUFBTTtnQkFDTixJQUFNLE9BQUssR0FBaUIsSUFBSSxDQUFDLElBQUksQ0FBQztnQkFDdEMsbUVBQW1FO2dCQUVuRSxJQUFNLFVBQVUsR0FBRyw0QkFBaUIsRUFBQyxLQUFLLEVBQUUsT0FBTyxFQUFFLHFCQUFxQixDQUFDLENBQUM7Z0JBRTVFLElBQU0sR0FBRyxHQUFHLE9BQUssQ0FBQyxnQkFBZ0IsQ0FBQyxLQUFLLENBQUM7Z0JBQ3pDLElBQUksQ0FBQyxHQUFHLEVBQUU7b0JBQ04sUUFBUSxDQUFDO2lCQUNaO2dCQUNELFVBQVUsQ0FBQyxTQUFTLEdBQUcsR0FBRyxDQUFDO2dCQUMzQixVQUFVLENBQUMsT0FBTyxDQUFDLE9BQU8sR0FBRyxHQUFHLENBQUM7Z0JBQ2pDLFVBQVUsQ0FBQyxZQUFZLENBQUMsY0FBYyxFQUFFLEdBQUcsQ0FBQyxDQUFDO2dCQUM3QyxVQUFVLENBQUMsS0FBSyxHQUFHLEdBQUcsQ0FBQztnQkFFdkIsSUFBSSxPQUFLLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxLQUFLLEtBQUssRUFBRTtvQkFDdkMsSUFBTSxDQUFDLEdBQUcsVUFBQyxFQUFTO3dCQUNoQixrRUFBa0U7d0JBQ2xFLElBQU0sQ0FBQyxHQUFHLElBQUksR0FBRyxRQUFRLENBQU8sRUFBRSxDQUFDLE1BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQzt3QkFDbEQsSUFBSSxPQUFLLENBQUMsS0FBSyxFQUFFOzRCQUNQLE9BQUssQ0FBQyxLQUFNLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDO3lCQUNwQzs2QkFBTTs0QkFDSCxPQUFLLENBQUMsZ0JBQWdCLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsQ0FBQzt5QkFDakQ7b0JBQ0wsQ0FBQyxDQUFDO29CQUNGLG1HQUFtRztvQkFDbkcsSUFBTSxDQUFDLEdBQUcseUJBQUssQ0FBQyxnQkFBZ0IsMENBQUUsT0FBTywwQ0FBRyxTQUFTLENBQUMsbUNBQUksQ0FBQyxDQUFDO29CQUM1RCxJQUFNLEVBQUUsR0FBRyxHQUFHLEdBQUcsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDO29CQUUvQixJQUFNLE1BQU0sR0FBRyx1QkFBWSxFQUFDLEdBQUcsRUFBRSxLQUFLLEVBQUUsRUFBRSxDQUFDLFFBQVEsRUFBRSxFQUFFLENBQUMsRUFBRSxnQkFBZ0IsQ0FBQyxDQUFDO29CQUM1RSwrREFBK0Q7b0JBQy9ELGtDQUFrQztvQkFDbEMsR0FBRyxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsQ0FBQztpQkFDM0I7Z0JBRUQsSUFBSSxPQUFLLENBQUMsZ0JBQWdCLENBQUMsUUFBUSxJQUFJLE9BQUssQ0FBQyxnQkFBZ0IsQ0FBQyxRQUFRLEVBQUU7b0JBQ3BFLDZDQUE2QztvQkFDN0MsaUNBQWlDO29CQUNqQywrQkFBK0I7b0JBQy9CLGlDQUFpQztvQkFFakMsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLEVBQUUsRUFBRTt3QkFDMUIsK0RBQStEO3dCQUMvRCxJQUFNLEtBQUssR0FBRyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7d0JBQ3hCLElBQUksT0FBSyxDQUFDLGdCQUFnQixDQUFDLFFBQVEsSUFBSSxLQUFLLEdBQUcsT0FBSyxDQUFDLGdCQUFnQixDQUFDLFFBQVEsRUFBRTs0QkFDNUUsR0FBRyxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsR0FBRyxHQUFHLENBQUMsR0FBRyxVQUFVLENBQUMsQ0FBQzt5QkFDM0M7d0JBQ0QsSUFBSSxPQUFLLENBQUMsZ0JBQWdCLENBQUMsUUFBUSxJQUFJLEtBQUssR0FBRyxPQUFLLENBQUMsZ0JBQWdCLENBQUMsUUFBUSxFQUFFOzRCQUM1RSxHQUFHLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxHQUFHLFVBQVUsQ0FBQyxDQUFDO3lCQUMzQztxQkFDSjtvQkFDRCxHQUFHLENBQUMsV0FBVyxDQUFDLGVBQWUsRUFBRSxDQUFDLENBQUM7b0JBQ25DLE9BQU8sQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFLE9BQUssQ0FBQyxnQkFBZ0IsQ0FBQyxLQUFLLEVBQUUsR0FBRyxDQUFDLENBQUM7aUJBQ2hFO2dCQUVELElBQU0sUUFBUSxHQUFHLENBQUMsSUFBSSxDQUFDLFFBQVEsR0FBRyw0QkFBaUIsRUFBQyxNQUFNLEVBQUUsT0FBTyxFQUFFLFdBQVcsQ0FBQyxDQUFDLENBQUM7Z0JBRW5GLFFBQVEsQ0FBQyxnQkFBZ0IsQ0FBQyxPQUFPLEVBQUUsVUFBQyxFQUFFO29CQUNsQywwQkFBYSxDQUFDLHNCQUFzQixDQUFDLFFBQVEsQ0FBQyxLQUFJLEVBQUUsT0FBSyxDQUFDLENBQUM7Z0JBQy9ELENBQUMsQ0FBQyxDQUFDO2FBQ047WUFDRCxPQUFPLEdBQUcsQ0FBQztRQUNmLENBQUM7UUFFRCw2QkFBUyxHQUFULFVBQVUsTUFBa0M7WUFDeEMsUUFBUSxNQUFNLEVBQUU7Z0JBQ1osS0FBSyxTQUFTO29CQUNWLElBQUksQ0FBQyxRQUFRLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQztvQkFDeEMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxDQUFDO29CQUN2QyxNQUFNO2dCQUNWLEtBQUssT0FBTztvQkFDUixJQUFJLENBQUMsUUFBUSxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLENBQUM7b0JBQzFDLElBQUksQ0FBQyxRQUFRLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQztvQkFDckMsTUFBTTtnQkFDVjtvQkFDSSxJQUFJLENBQUMsUUFBUSxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUM7b0JBQ3hDLElBQUksQ0FBQyxRQUFRLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsQ0FBQzthQUNqRDtRQUNMLENBQUM7UUFDTCxnQkFBQztJQUFELENBQUMsQ0ExSHVCLG1CQUFRLEdBMEgvQjtJQUNEOztPQUVHO0lBQ0g7UUFBd0IsNkJBQVE7UUFNNUIsbUJBQVksSUFBa0IsRUFBRSxNQUF3QixFQUFFLE1BQXNCO1lBQWhGLFlBQ0ksa0JBQU0sSUFBSSxFQUFFLE1BQU0sRUFBRSxNQUFNLENBQUMsU0FFOUI7WUFORCwyQkFBcUIsR0FBRyxJQUFJLHVDQUFlLEVBQWlCLENBQUM7WUFLekQsS0FBSSxDQUFDLGdCQUFnQixHQUFHLE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQzs7UUFDcEQsQ0FBQztRQUVELDBCQUFNLEdBQU4sVUFBTyxLQUFhO1lBQXBCLGlCQWdGQztZQS9FRyxPQUFPLENBQUMsSUFBSSxDQUFDLHNDQUErQixJQUFJLENBQUMsYUFBYSxFQUFFLENBQUUsQ0FBQyxDQUFDO1lBQ3BFLElBQUksR0FBRyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUM7WUFDbkIsNkJBQTZCO1lBQzdCLElBQUksQ0FBQyxHQUFHLEVBQUU7Z0JBQ04sR0FBRyxHQUFHLElBQUksQ0FBQyxHQUFHLEdBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsQ0FBQztnQkFDL0MsR0FBRyxDQUFDLFNBQVMsR0FBRyxhQUFhLENBQUM7Z0JBQzlCLElBQU0sT0FBTyxHQUFHLENBQUMsSUFBSSxDQUFDLE9BQU8sR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7Z0JBQy9ELHdDQUF3QztnQkFDeEMsT0FBTyxDQUFDLFNBQVMsR0FBRyxTQUFTLENBQUM7Z0JBRTlCLEdBQUcsQ0FBQyxXQUFXLENBQUMsT0FBTyxDQUFDLENBQUM7Z0JBRXpCLDJDQUEyQztnQkFDM0MsSUFBTSxJQUFJLEdBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsQ0FBQztnQkFDM0MsSUFBSSxDQUFDLFNBQVMsR0FBRyxVQUFVLENBQUM7Z0JBRTVCLElBQU0sVUFBVSxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsR0FBRyxDQUFDLENBQUM7Z0JBQy9DLFVBQVUsQ0FBQyxTQUFTLEdBQUcsWUFBWSxDQUFDO2dCQUNwQyxVQUFVLENBQUMsZ0JBQWdCLENBQUMsT0FBTyxFQUFFLFVBQUMsRUFBRSxJQUFLLFlBQUksQ0FBQyxxQkFBcUIsQ0FBQyxRQUFRLENBQUMsS0FBSSxFQUFFLFNBQVMsQ0FBQyxFQUFwRCxDQUFvRCxDQUFDLENBQUM7Z0JBRW5HLElBQU0sYUFBYSxHQUFHLENBQUMsSUFBSSxDQUFDLGFBQWEsR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7Z0JBQzVFLGFBQWEsQ0FBQyxnQkFBZ0IsQ0FBQyxPQUFPLEVBQUUsVUFBQyxFQUFFLElBQUssWUFBSSxDQUFDLGVBQWUsQ0FBQyxFQUFFLENBQUMsRUFBeEIsQ0FBd0IsQ0FBQyxDQUFDO2dCQUUxRSw2Q0FBNkM7Z0JBQzdDLHVFQUF1RTtnQkFDdkUsSUFBSTtnQkFFSixPQUFPLENBQUMsU0FBUyxHQUFHLGNBQWMsQ0FBQztnQkFFbkMsSUFBSSxDQUFDLFFBQVEsR0FBRyxhQUFhLENBQUM7Z0JBQzlCLElBQUksQ0FBQyxXQUFXLENBQUMsVUFBVSxDQUFDLENBQUM7Z0JBQzdCLElBQUksQ0FBQyxXQUFXLENBQUMsYUFBYSxDQUFDLENBQUM7Z0JBRWhDLElBQU0sSUFBRSxHQUFxQixJQUFJLENBQUMsY0FBYyxFQUFFLENBQUM7Z0JBQ25ELElBQUksQ0FBQyxXQUFXLENBQUMsSUFBRSxDQUFDLENBQUM7Z0JBQ3JCLElBQU0sS0FBSyxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsT0FBTyxDQUFDLENBQUM7Z0JBQzlDLElBQUksQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLENBQUM7Z0JBQ3hCLEtBQUssQ0FBQyxnQkFBZ0IsQ0FBQyxPQUFPLEVBQUU7b0JBQzVCLElBQUUsQ0FBQyxLQUFLLEVBQUUsQ0FBQztnQkFDZixDQUFDLENBQUMsQ0FBQztnQkFFSCxPQUFPLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxDQUFDO2dCQUMxQixJQUFNLFFBQVEsR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxDQUFDO2dCQUMvQyxRQUFRLENBQUMsU0FBUyxHQUFHLFdBQVcsQ0FBQztnQkFDakMsK0NBQStDO2dCQUUvQyxJQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLE9BQU8sQ0FBQyxDQUFDO2dCQUVoRCxJQUFNLFVBQVUsR0FBRyw0QkFBaUIsRUFBQyxNQUFNLEVBQUUsT0FBTyxFQUFFLHFCQUFxQixDQUFDLENBQUM7Z0JBQzdFLFVBQVUsQ0FBQyxTQUFTLEdBQUcsR0FBRyxDQUFDO2dCQUMzQixVQUFVLENBQUMsT0FBTyxDQUFDLE9BQU8sR0FBRyxHQUFHLENBQUM7Z0JBQ2pDLFVBQVUsQ0FBQyxZQUFZLENBQUMsY0FBYyxFQUFFLEdBQUcsQ0FBQyxDQUFDO2dCQUM3QyxVQUFVLENBQUMsS0FBSyxHQUFHLEdBQUcsQ0FBQztnQkFFdkIsSUFBTSxRQUFRLEdBQUcsQ0FBQyxJQUFJLENBQUMsUUFBUSxHQUFHLDRCQUFpQixFQUFDLE1BQU0sRUFBRSxPQUFPLEVBQUUsV0FBVyxDQUFDLENBQUMsQ0FBQztnQkFDbkYsbUNBQW1DO2dCQUNuQyxRQUFRLENBQUMsZ0JBQWdCLENBQUMsT0FBTyxFQUFFLFVBQUMsRUFBRTtvQkFDbEMsMEJBQWEsQ0FBQyxzQkFBc0IsQ0FBQyxRQUFRLENBQUMsS0FBSSxFQUFFLEtBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztnQkFDbkUsQ0FBQyxDQUFDLENBQUM7Z0JBRUgsSUFBSSxJQUFJLENBQUMsZ0JBQWdCLEVBQUU7b0JBQ3ZCLElBQU0sU0FBUyxHQUFHLDRCQUFpQixFQUFDLEtBQUssRUFBRSxPQUFPLEVBQUUsb0JBQW9CLENBQUMsQ0FBQztvQkFDMUUsSUFBTSxFQUFFLEdBQUcsNEJBQWlCLEVBQUMsS0FBSyxFQUFFLFNBQVMsRUFBRSxJQUFJLENBQUMsQ0FBQztvQkFDckQsSUFBTSxJQUFJLEdBQUcsNEJBQWlCLEVBQUMsS0FBSyxFQUFFLFNBQVMsRUFBRSxNQUFNLENBQUMsQ0FBQztvQkFDekQsRUFBRSxDQUFDLGdCQUFnQixDQUFDLE9BQU8sRUFBRSxVQUFDLEVBQUUsSUFBSyxZQUFJLENBQUMsTUFBTSxFQUFFLEVBQWIsQ0FBYSxDQUFDLENBQUM7b0JBQ3BELElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxPQUFPLEVBQUUsVUFBQyxFQUFFLElBQUssWUFBSSxDQUFDLFFBQVEsRUFBRSxFQUFmLENBQWUsQ0FBQyxDQUFDO2lCQUMzRDtnQkFFRCxJQUFJLElBQUksQ0FBQyxPQUFPLEVBQUU7b0JBQ2QsT0FBTyxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsYUFBYSxFQUFFLENBQUMsQ0FBQztpQkFDN0M7Z0JBRUQsSUFBSSxhQUFhLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQztnQkFDbEMsSUFBSSxhQUFhLEVBQUU7b0JBQ2YsYUFBYSxDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUM7aUJBQ2xDO2dCQUNELElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLE9BQU8sR0FBRyxNQUFNLENBQUM7YUFDbkM7WUFDRCxPQUFPLEdBQUcsQ0FBQztRQUNmLENBQUM7UUFDRCwwQkFBTSxHQUFOO1lBQ0ksT0FBTyxDQUFDLElBQUksQ0FBQyxtQkFBbUIsRUFBRSxJQUFJLENBQUMsQ0FBQztZQUN4QyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLEVBQUUsRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDO1FBQ3BELENBQUM7UUFDRCw0QkFBUSxHQUFSO1lBQ0ksT0FBTyxDQUFDLElBQUksQ0FBQyxxQkFBcUIsRUFBRSxJQUFJLENBQUMsQ0FBQztZQUMxQyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLEVBQUUsRUFBRSxLQUFLLEVBQUUsQ0FBQyxDQUFDO1FBQ3JELENBQUM7UUFFRCw2QkFBUyxHQUFULFVBQVUsTUFBa0M7WUFDeEMsUUFBUSxNQUFNLEVBQUU7Z0JBQ1osS0FBSyxTQUFTO29CQUNWLElBQUksQ0FBQyxRQUFRLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQztvQkFDeEMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxDQUFDO29CQUN2QyxNQUFNO2dCQUNWLEtBQUssT0FBTztvQkFDUixJQUFJLENBQUMsUUFBUSxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLENBQUM7b0JBQzFDLElBQUksQ0FBQyxRQUFRLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQztvQkFDckMsTUFBTTtnQkFDVjtvQkFDSSxJQUFJLENBQUMsUUFBUSxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUM7b0JBQ3hDLElBQUksQ0FBQyxRQUFRLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsQ0FBQzthQUNqRDtRQUNMLENBQUM7UUFXTCxnQkFBQztJQUFELENBQUMsQ0E5SHVCLG1CQUFRLEdBOEgvQjtJQUVELElBQU0sZUFBZSxHQUFHLElBQUksaUJBQWlCLEVBQUUsQ0FBQztJQUVoRDtRQUFxQyxtQ0FBUztRQWdDMUMseUJBQVksT0FBNkI7WUFBekMsWUFDSSxrQkFBTSxPQUFPLENBQUMsU0FxQmpCO1lBMUNELHFCQUFlLEdBQStDLEVBQUUsQ0FBQztZQUNqRSx5QkFBbUIsR0FBK0IsRUFBRSxDQUFDO1lBRXJELDZCQUF1QixHQUFnQyxFQUFFLENBQUM7WUFFMUQsNkJBQXVCLEdBQWdDLEVBQUUsQ0FBQztZQWlCdEQsNENBQTRDO1lBQzVDLElBQUksT0FBTyxDQUFDLFNBQVMsRUFBRTtnQkFDbkIsS0FBSSxDQUFDLFNBQVMsR0FBRyxPQUFPLENBQUMsU0FBUyxDQUFDO2FBQ3RDO1lBQ0QsSUFBSSxPQUFPLENBQUMsVUFBVSxFQUFFO2dCQUNwQixLQUFJLENBQUMsVUFBVSxHQUFHLE9BQU8sQ0FBQyxVQUFVLENBQUM7Z0JBQ3JDLG9DQUFvQzthQUN2QztZQUNELEtBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQztZQUNuQixLQUFJLENBQUMsWUFBWSxFQUFFLENBQUM7WUFFcEIsS0FBSSxDQUFDLGlCQUFpQixHQUFHLFVBQUMsRUFBd0IsSUFBSyxZQUFJLENBQUMsZ0JBQWdCLENBQUMsRUFBRSxDQUFDLEVBQXpCLENBQXlCLENBQUM7WUFDakYsS0FBSSxDQUFDLGtCQUFrQixHQUFHLFVBQUMsSUFBYyxFQUFFLEdBQW9CLElBQUssWUFBSSxDQUFDLGlCQUFpQixDQUFDLElBQUksRUFBRSxHQUFHLENBQUMsRUFBakMsQ0FBaUMsQ0FBQztZQUV0RyxLQUFJLENBQUMscUJBQXFCLEdBQUcsVUFBQyxJQUFjLEVBQUUsR0FBb0IsSUFBSyxZQUFJLENBQUMsb0JBQW9CLENBQUMsSUFBSSxFQUFFLEdBQUcsQ0FBQyxFQUFwQyxDQUFvQyxDQUFDO1lBQzVHLEtBQUksQ0FBQyxvQkFBb0IsR0FBRyxVQUFDLElBQWUsSUFBSyxZQUFJLENBQUMsbUJBQW1CLENBQUMsSUFBSSxDQUFDLEVBQTlCLENBQThCLENBQUM7WUFFaEYsMEJBQWEsQ0FBQyxjQUFjLENBQUMsU0FBUyxDQUFDLFVBQUMsTUFBTSxFQUFFLEVBQUUsSUFBSyxZQUFJLENBQUMsZ0JBQWdCLENBQUMsTUFBTSxFQUFFLEVBQUUsQ0FBQyxFQUFqQyxDQUFpQyxDQUFDLENBQUM7WUFDMUYsMEJBQWEsQ0FBQyxZQUFZLENBQUMsU0FBUyxDQUFDLFVBQUMsTUFBTSxFQUFFLEVBQUUsSUFBSyxZQUFJLENBQUMsWUFBWSxDQUFDLE1BQU0sRUFBRSxFQUFFLENBQUMsRUFBN0IsQ0FBNkIsQ0FBQyxDQUFDO1lBQ3BGLDBCQUFhLENBQUMsWUFBWSxDQUFDLFNBQVMsQ0FBQyxVQUFDLE1BQU0sRUFBRSxFQUFFLElBQUssWUFBSSxDQUFDLFlBQVksQ0FBQyxNQUFNLEVBQUUsRUFBRSxDQUFDLEVBQTdCLENBQTZCLENBQUMsQ0FBQzs7UUFDeEYsQ0FBQztRQUVELDBDQUFnQixHQUFoQixVQUFpQixFQUF3QjtZQUNyQyxPQUFPLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDO1lBQzNCLElBQUksRUFBRSxDQUFDLEVBQUUsRUFBRTtnQkFDUCxJQUFJLENBQUMsS0FBSyxDQUFDLFVBQVUsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUM7Z0JBQy9CLEVBQUUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxXQUFXLEVBQUUsQ0FBQzthQUNwQztpQkFBTTtnQkFDSCxJQUFJLENBQUMsS0FBSyxDQUFDLFlBQVksQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUM7Z0JBQ2pDLEVBQUUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxZQUFZLEVBQUUsQ0FBQzthQUNyQztZQUNELHFDQUFxQztZQUNyQyxrQ0FBa0M7WUFDbEMsdUNBQXVDO1lBQ3ZDLGlEQUFpRDtZQUNqRCxLQUFLO1lBQ0wsMkZBQTJGO1lBQzNGLE9BQU8sQ0FBQyxJQUFJLENBQUMsa0JBQWtCLEVBQUUsRUFBRSxDQUFDLENBQUM7UUFDekMsQ0FBQztRQUVPLHFDQUFXLEdBQW5CLFVBQW9CLEdBQWU7WUFDL0IsSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQ3BDLENBQUM7UUFDTyx1Q0FBYSxHQUFyQixVQUFzQixHQUFlO1lBQ2pDLElBQUksQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUN0QyxDQUFDO1FBRUQscUNBQVcsR0FBWCxVQUFZLEtBQWEsRUFBRSxJQUFjLEVBQUUsR0FBb0I7WUFDM0QsT0FBTyxDQUFDLElBQUksQ0FBQyxzQkFBZSxLQUFLLGNBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLGVBQUssMEJBQWUsQ0FBQyxHQUFHLENBQUMsQ0FBRSxDQUFDLENBQUM7UUFDcEYsQ0FBQztRQUVELDJDQUFpQixHQUFqQixVQUFrQixLQUFjO1lBQzVCLDBCQUFhLENBQUMsb0JBQW9CLENBQUMsUUFBUSxDQUFNLElBQUksRUFBRSxLQUFLLENBQUMsQ0FBQztRQUNsRSxDQUFDO1FBRUQsMkNBQWlCLEdBQWpCLFVBQWtCLElBQWMsRUFBRSxHQUFvQjtZQUNsRCxPQUFPLENBQUMsSUFBSSxDQUFDLDRDQUFxQywwQkFBZSxDQUFDLEdBQUcsQ0FBQyxDQUFFLEVBQUUsSUFBSSxDQUFDLENBQUM7WUFDaEYsSUFBTSxVQUFVLEdBQUcsR0FBRyxLQUFLLDBCQUFlLENBQUMsUUFBUSxDQUFDO1lBQ3BELElBQU0sS0FBSyxHQUFpQixJQUFJLENBQUMsSUFBSSxDQUFDO1lBRXRDLElBQUksU0FBUyxHQUFHLElBQUksQ0FBQyx1QkFBdUIsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUM7WUFDdkQsSUFBSSxTQUFTLEVBQUU7Z0JBQ1gsU0FBUyxDQUFDLFdBQVcsQ0FBQyxVQUFVLENBQUMsQ0FBQztnQkFDbEMsV0FBVztnQkFDWCxXQUFXO2dCQUNYLDRGQUE0RjtnQkFDNUYseUVBQXlFO2dCQUN6RSw0RUFBNEU7Z0JBQzVFLHFDQUFxQztnQkFDckMsMERBQTBEO2dCQUMxRCx5Q0FBeUM7Z0JBQ3pDLG1EQUFtRDthQUN0RDtZQUNELEtBQUssQ0FBQyxXQUFXLENBQUMsVUFBVSxDQUFDLENBQUM7UUFDbEMsQ0FBQztRQUVELDhDQUFvQixHQUFwQixVQUFxQixJQUFjLEVBQUUsR0FBb0I7WUFDckQsSUFBTSxVQUFVLEdBQUcsR0FBRyxLQUFLLDBCQUFlLENBQUMsUUFBUSxDQUFDO1lBQ3BELElBQU0sS0FBSyxHQUFpQixJQUFJLENBQUMsSUFBSSxDQUFDO1lBQ3RDLEtBQUssQ0FBQyxXQUFXLENBQUMsVUFBVSxDQUFDLENBQUM7UUFDbEMsQ0FBQztRQUVELHFDQUFXLEdBQVg7WUFDSSxLQUFLLElBQUksQ0FBQyxJQUFJLElBQUksQ0FBQyx1QkFBdUIsRUFBRTtnQkFDeEMsSUFBTSxTQUFTLEdBQUcsSUFBSSxDQUFDLHVCQUF1QixDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUNsRCxJQUFJLENBQUMsbUJBQW1CLENBQUMsU0FBUyxDQUFDLENBQUM7YUFDdkM7WUFDRCxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsVUFBQyxJQUFJLElBQUssV0FBSSxDQUFDLFFBQVEsRUFBRSxFQUFmLENBQWUsQ0FBQyxDQUFDO1FBQ3ZELENBQUM7UUFFRCw2Q0FBbUIsR0FBbkIsVUFBb0IsSUFBYztZQUM5QixJQUFNLEtBQUssR0FBaUIsSUFBSSxDQUFDLElBQUksQ0FBQztZQUN0QyxJQUFNLFNBQVMsR0FBRyxJQUFJLENBQUMsdUJBQXVCLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1lBQ3pELE9BQU8sQ0FBQyxJQUFJLENBQUMsOEJBQXVCLFNBQVMsS0FBSyxJQUFJLENBQUUsQ0FBQyxDQUFDO1lBQzFELElBQUksU0FBUyxFQUFFO2dCQUNYLFNBQVMsQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLENBQUM7Z0JBQzdCLElBQUksQ0FBQyxLQUFLLENBQUMsVUFBVSxDQUFDLFNBQVMsQ0FBQyxDQUFDO2dCQUNqQyxPQUFPLElBQUksQ0FBQyx1QkFBdUIsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUM7YUFDakQ7UUFDTCxDQUFDO1FBRUQsMENBQWdCLEdBQWhCLFVBQWlCLElBQWMsRUFBRSxHQUFvQjtZQUFyRCxpQkFVQztZQVRHLGtFQUFrRTtZQUNsRSxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUU7Z0JBQ2xCLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxVQUFDLEtBQUs7b0JBQ3ZELElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztvQkFDeEIsS0FBSSxDQUFDLGlCQUFpQixDQUFDLEtBQUssQ0FBQyxDQUFDO2dCQUNsQyxDQUFDLENBQUMsQ0FBQzthQUNOO2lCQUFNO2dCQUNILElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO2FBQzNDO1FBQ0wsQ0FBQztRQUVELDBDQUFnQixHQUFoQixVQUFpQixVQUE0QjtZQUN6QyxvQ0FBb0M7WUFDcEMsSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsVUFBVSxDQUFDLENBQUM7UUFDckMsQ0FBQztRQUVELG1DQUFTLEdBQVQsVUFBVSxNQUFlO1lBQXpCLGlCQU9DO1lBTkcsSUFBSSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUM7WUFDckIsMEJBQWEsQ0FBQyxZQUFZLENBQUMsU0FBUyxDQUFDLFVBQUMsTUFBTSxFQUFFLEdBQUcsSUFBSyxZQUFJLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxFQUFyQixDQUFxQixDQUFDLENBQUM7WUFDN0UsMEJBQWEsQ0FBQyxjQUFjLENBQUMsU0FBUyxDQUFDLFVBQUMsTUFBTSxFQUFFLEdBQUcsSUFBSyxZQUFJLENBQUMsYUFBYSxDQUFDLEdBQUcsQ0FBQyxFQUF2QixDQUF1QixDQUFDLENBQUM7WUFDakYsSUFBSSxJQUFJLENBQUMsSUFBSSxFQUFFO2dCQUNYLElBQUksQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDO2FBQzNCO1FBQ0wsQ0FBQztRQUVPLHNDQUFZLEdBQXBCO1lBQ0ksSUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLFdBQUksQ0FBQyxJQUFJLEVBQUUsRUFBRSxVQUFVLEVBQUUsd0JBQWEsQ0FBQyxLQUFLLEVBQUUsaUJBQWlCLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQztRQUM5RixDQUFDO1FBRU8scUNBQVcsR0FBbkI7WUFDSSxPQUFPLENBQUMsSUFBSSxDQUFDLDZCQUE2QixDQUFDLENBQUM7WUFDNUMsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLFdBQUksQ0FBQyxJQUFJLEVBQUUsRUFBRSxVQUFVLEVBQUUsd0JBQWEsQ0FBQyxLQUFLLEVBQUUsaUJBQWlCLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQztZQUN6Rix1Q0FBdUM7WUFDdkMsMkRBQTJEO1lBQzNELElBQUk7WUFFSiw4Q0FBOEM7WUFDOUMseUVBQXlFO1lBQ3pFLElBQUk7UUFDUixDQUFDO1FBRU8seUNBQWUsR0FBdkIsVUFBd0IsS0FBWTtZQUFwQyxpQkFpQkM7WUFoQkcsSUFBTSxTQUFTLEdBQUcsSUFBSSxhQUFhLENBQUMsS0FBSyxFQUFFLElBQUksRUFBRSxFQUFFLFlBQVksRUFBRSxlQUFlLEVBQUUsQ0FBQyxDQUFDO1lBQ3BGLElBQUksS0FBSyxDQUFDLE1BQU0sRUFBRTtnQkFDZCxLQUFLLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxVQUFDLEtBQUs7b0JBQ3ZCLElBQU0sVUFBVSxHQUFHLEtBQUksQ0FBQyxlQUFlLENBQUMsS0FBSyxDQUFDLENBQUM7b0JBQy9DLFNBQVMsQ0FBQyxPQUFPLENBQUMsVUFBVSxDQUFDLENBQUM7Z0JBQ2xDLENBQUMsQ0FBQyxDQUFDO2FBQ047WUFDRCxJQUFJLEtBQUssQ0FBQyxNQUFNLEVBQUU7Z0JBQ2QsS0FBSyxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsVUFBQyxLQUFLO29CQUN2QixJQUFNLFNBQVMsR0FBRyxJQUFJLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQztvQkFDdkMsS0FBSSxDQUFDLHVCQUF1QixDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsR0FBRyxTQUFTLENBQUM7b0JBQ25ELFNBQVMsQ0FBQyxpQkFBaUIsQ0FBQyxTQUFTLENBQUMsS0FBSSxDQUFDLGtCQUFrQixDQUFDLENBQUM7b0JBQy9ELFNBQVMsQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLENBQUM7Z0JBQ2pDLENBQUMsQ0FBQyxDQUFDO2FBQ047WUFDRCxPQUFPLFNBQVMsQ0FBQztRQUNyQixDQUFDO1FBRU8sMENBQWdCLEdBQXhCO1lBQUEsaUJBZUM7WUFkRyxPQUFPLENBQUMsSUFBSSxDQUFDLDJCQUFvQixJQUFJLENBQUMsSUFBSSxDQUFFLENBQUMsQ0FBQztZQUM5QyxJQUFJLElBQUksQ0FBQyxJQUFJLEVBQUU7Z0JBQ1gsSUFBTSxZQUFVLEdBQWUsRUFBRSxDQUFDO2dCQUNsQyxJQUFJLElBQUksQ0FBQyxNQUFNLEVBQUU7b0JBQ2IsSUFBSSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsVUFBQyxLQUFLO3dCQUN0QixJQUFNLFNBQVMsR0FBRyxLQUFJLENBQUMsZUFBZSxDQUFDLEtBQUssQ0FBQyxDQUFDO3dCQUM5QyxJQUFJLFNBQVMsQ0FBQyxNQUFNLElBQUksU0FBUyxDQUFDLE1BQU0sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFOzRCQUNqRCxZQUFVLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDOzRCQUMzQixnQ0FBZ0M7eUJBQ25DO29CQUNMLENBQUMsQ0FBQyxDQUFDO29CQUNILElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLFlBQVUsQ0FBQyxDQUFDO2lCQUNsQzthQUNKO1FBQ0wsQ0FBQztRQUVELGtEQUF3QixHQUF4QixVQUF5QixLQUFhLEVBQUUsY0FBd0M7WUFBaEYsaUJBVUM7WUFURyxPQUFPLENBQUMsSUFBSSxDQUFDLG1DQUE0QixJQUFJLENBQUMsSUFBSSxDQUFFLENBQUMsQ0FBQztZQUN0RCxJQUFJLElBQUksQ0FBQyxJQUFJLEVBQUU7Z0JBQ1gsSUFBTSxVQUFVLEdBQUcsY0FBYyxDQUFDLGFBQWEsRUFBRSxDQUFDO2dCQUNsRCxJQUFNLFVBQVEsR0FBRyxJQUFJLG1CQUFRLENBQUMsS0FBSyxDQUFDLENBQUM7Z0JBQ3JDLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLFVBQVEsQ0FBQyxDQUFDO2dCQUM1QixJQUFJLENBQUMsYUFBYSxDQUFDLFVBQVEsRUFBRSxVQUFVLENBQUMsQ0FBQztnQkFDekMsSUFBSSxDQUFDLG1CQUFtQixDQUFDLEtBQUssQ0FBQyxHQUFHLFVBQVEsQ0FBQztnQkFDM0MsVUFBUSxDQUFDLGlCQUFpQixDQUFDLFNBQVMsQ0FBQyxVQUFDLElBQUksRUFBRSxNQUFNLElBQUssWUFBSSxDQUFDLGtCQUFrQixDQUFDLEtBQUssRUFBRSxVQUFRLEVBQUUsTUFBTSxDQUFDLEVBQWhELENBQWdELENBQUMsQ0FBQzthQUM1RztRQUNMLENBQUM7UUFFRCwyQ0FBaUIsR0FBakIsVUFBa0IsS0FBYSxFQUFFLFFBQStCO1lBQzVELHlEQUF5RDtZQUN6RCxJQUFJLElBQUksQ0FBQyxJQUFJLEVBQUU7Z0JBQ1gsSUFBTSxRQUFRLEdBQUcsSUFBSSxtQkFBUSxDQUFDLEtBQUssRUFBRSxTQUFTLEVBQUUsRUFBRSxVQUFVLEVBQUUsd0JBQWEsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDO2dCQUNyRixJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQztnQkFDNUIsUUFBUSxDQUFDLE9BQU8sQ0FBQyxVQUFDLFlBQVk7b0JBQzFCLElBQU0sUUFBUSxHQUFHLElBQUksbUJBQVEsQ0FBQyxZQUFZLEVBQUUsSUFBSSxFQUFFLEVBQUUsVUFBVSxFQUFFLHdCQUFhLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQztvQkFDdkYsUUFBUSxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQztnQkFDL0IsQ0FBQyxDQUFDLENBQUM7Z0JBQ0gsd0dBQXdHO2FBQzNHO1FBQ0wsQ0FBQztRQUVELCtCQUFLLEdBQUwsVUFBTSxHQUFVO1lBQ1osdUNBQXVDO1lBQ3ZDLElBQUksSUFBSSxDQUFDLFVBQVUsRUFBRTtnQkFDakIsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDO2dCQUNkLElBQUksQ0FBQyxJQUFJLEdBQUcsR0FBRyxDQUFDO2dCQUNoQixJQUFNLFNBQVMsR0FBRyxDQUFPLElBQUssQ0FBQyxVQUFVLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO2dCQUM3RCxTQUFTLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxlQUFlLENBQUMsQ0FBQztnQkFDekMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxXQUFXLENBQUMsU0FBUyxDQUFDLENBQUM7Z0JBQ3ZDLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLFFBQVEsRUFBRSxJQUFJLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxDQUFDO2dCQUMxQyxPQUFPLElBQUksQ0FBQzthQUNmO2lCQUFNO2dCQUNILE9BQU8saUJBQU0sS0FBSyxZQUFDLEdBQUcsQ0FBQyxDQUFDO2FBQzNCO1FBQ0wsQ0FBQztRQUVELCtCQUFLLEdBQUwsVUFBTSxHQUFVO1lBQ1osT0FBTyxDQUFDLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDO1lBQ25DLElBQUksQ0FBQyxJQUFJLEdBQUcsR0FBRyxDQUFDO1lBQ2hCLElBQUksR0FBRyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUM7WUFDcEIsSUFBSSxDQUFDLEdBQUcsRUFBRTtnQkFDTixJQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDO2dCQUNwQyxJQUFJLElBQUksQ0FBQyxTQUFTLEVBQUU7b0JBQ2hCLE9BQU8sQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztpQkFDekM7Z0JBQ0QsSUFBTSxLQUFLLEdBQUcsSUFBSSx5QkFBYSxDQUFDLFFBQVEsRUFBRSxPQUFPLENBQUMsQ0FBQztnQkFDbkQsSUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLEVBQUUsQ0FBQztnQkFDdEMsSUFBSSxJQUFJLENBQUMsU0FBUyxFQUFFO29CQUNoQixRQUFRLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7aUJBQzFDO2dCQUNELElBQU0sU0FBUyxHQUFHLENBQUMsSUFBSSxDQUFDLFNBQVMsR0FBRyxJQUFJLHFCQUFTLENBQUMsQ0FBQyxJQUFJLHlCQUFhLENBQUMsZUFBZSxFQUFFLE9BQU8sQ0FBQyxFQUFFLElBQUkseUJBQWEsQ0FBQyxxQkFBcUIsRUFBRSxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDdEosR0FBRyxHQUFHLFNBQVMsQ0FBQyxNQUFNLEVBQUUsQ0FBQztnQkFDekIsNEJBQTRCO2FBQy9CO1lBQ0QsbUNBQW1DO1lBQ25DLE9BQU8sR0FBRyxDQUFDO1FBQ2YsQ0FBQztRQUNELGtDQUFRLEdBQVIsVUFBUyxHQUFVO1lBQ2YsMENBQTBDO1FBQzlDLENBQUM7UUFFRCx1Q0FBYSxHQUFiLFVBQWMsS0FBYSxFQUFFLElBQWM7WUFDdkMsT0FBTyxDQUFDLElBQUksQ0FBQyxlQUFlLEVBQUUsSUFBSSxDQUFDLENBQUM7WUFDcEMsSUFBTSxJQUFJLEdBQWEsSUFBSSxDQUFDLG1CQUFtQixDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQ3ZELElBQUksSUFBSSxFQUFFO2dCQUNOLE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsRUFBRSxFQUFFLElBQUksQ0FBQyxDQUFDO2FBQ3ZDO1FBQ0wsQ0FBQztRQUVELDhDQUFvQixHQUFwQixVQUFxQixLQUFhLEVBQUUsSUFBYztZQUM5QyxPQUFPLENBQUMsSUFBSSxDQUFDLHNCQUFzQixFQUFFLElBQUksQ0FBQyxDQUFDO1lBQzNDLElBQU0sSUFBSSxHQUFhLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUN2RCxJQUFJLElBQUksRUFBRTtnQkFDTixJQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxFQUFFLEVBQUUsSUFBSSxDQUFDLENBQUM7Z0JBQzNDLElBQUksS0FBSyxFQUFFO29CQUNQLElBQU0sSUFBSSxHQUFHLEVBQUUsQ0FBQztvQkFDaEIsS0FBSyxJQUFJLENBQUMsR0FBRyxLQUFLLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFO3dCQUN4QyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7cUJBQy9CO29CQUNELE9BQU8sQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxDQUFDO29CQUMzQixJQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsZUFBZSxDQUFDLEtBQUssQ0FBQyxDQUFDO29CQUMxQyxJQUFJLEtBQUssRUFBRTt3QkFDUCxPQUFPLEtBQUssQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUM7cUJBQy9CO2lCQUNKO2FBQ0o7UUFDTCxDQUFDO1FBRUQsdUNBQWEsR0FBYixVQUFjLEtBQWEsRUFBRSxJQUFTO1lBQ2xDLE9BQU8sQ0FBQyxJQUFJLENBQUMsZUFBZSxFQUFFLElBQUksQ0FBQyxDQUFDO1lBQ3BDLElBQU0sSUFBSSxHQUFhLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUN2RCxJQUFJLElBQUksRUFBRTtnQkFDTixJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxFQUFFLEVBQUUsSUFBSSxDQUFDLENBQUM7YUFDbEM7UUFDTCxDQUFDO1FBRUQsb0NBQVUsR0FBVixVQUFXLEtBQWEsRUFBRSxFQUFPLEVBQUUsSUFBWTtZQUMzQyxPQUFPLENBQUMsSUFBSSxDQUFDLHFCQUFjLEtBQUssZUFBSyxFQUFFLGVBQUssSUFBSSxNQUFHLENBQUMsQ0FBQztZQUNyRCxJQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsZUFBZSxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQzFDLElBQUksS0FBSyxFQUFFO2dCQUNQLElBQU0sTUFBTSxHQUFHLEtBQUssQ0FBQyxVQUFVLENBQUMsRUFBRSxFQUFFLElBQUksQ0FBQyxDQUFDO2FBQzdDO1FBQ0wsQ0FBQztRQUVELGtDQUFRLEdBQVIsVUFBUyxLQUFhLEVBQUUsSUFBZTtZQUNuQyxPQUFPLENBQUMsSUFBSSxDQUFDLG1CQUFZLEtBQUssZUFBSyxJQUFJLE1BQUcsQ0FBQyxDQUFDO1lBQzVDLElBQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxlQUFlLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDMUMsT0FBTyxLQUFLLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ2hDLENBQUM7UUFFRCwyQ0FBaUIsR0FBakIsVUFBa0IsS0FBYSxFQUFFLGNBQXdDLEVBQUUsT0FBaUI7WUFDeEYsSUFBSSxDQUFDLGVBQWUsQ0FBQyxLQUFLLENBQUMsR0FBRyxjQUFjLENBQUM7WUFDN0MsT0FBTyxDQUFDLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO1lBQ2xDLElBQUksSUFBSSxDQUFDLElBQUksRUFBRTtnQkFDWCxJQUFJLENBQUMsd0JBQXdCLENBQUMsS0FBSyxFQUFFLGNBQWMsQ0FBQyxDQUFDO2dCQUNyRCxJQUFJLE9BQU8sRUFBRTtvQkFDVCxJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsQ0FBQztpQkFDL0I7YUFDSjtRQUNMLENBQUM7UUFDTyw0Q0FBa0IsR0FBMUIsVUFBMkIsVUFBa0IsRUFBRSxJQUFjLEVBQUUsTUFBdUI7WUFDbEYsT0FBTyxDQUFDLElBQUksQ0FBQyxvQkFBb0IsRUFBRSxJQUFJLEVBQUUsTUFBTSxDQUFDLENBQUM7WUFDakQsSUFBTSxZQUFZLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7WUFDckQsSUFBTSxhQUFhLEdBQUcsSUFBSSxDQUFDLGVBQWUsQ0FBQyxVQUFVLENBQUMsQ0FBQztZQUN2RCxJQUFJLGFBQWEsRUFBRTtnQkFDZixhQUFhLENBQUMsYUFBYSxDQUFDLFlBQVksQ0FBQyxDQUFDO2FBQzdDO1FBQ0wsQ0FBQztRQUVELHlGQUF5RjtRQUN6Riw0REFBNEQ7UUFDNUQsSUFBSTtRQUVJLHVDQUFhLEdBQXJCLFVBQXNCLEtBQWlCO1lBQ25DLElBQU0sR0FBRyxHQUFHLEVBQUUsQ0FBQztZQUNmLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxLQUFLLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO2dCQUNuQyxJQUFJLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxtQkFBbUIsRUFBRSxLQUFLLDBCQUFlLENBQUMsUUFBUSxFQUFFO29CQUM3RCxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO2lCQUNoQztxQkFBTTtvQkFDSCxJQUFJLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxtQkFBbUIsRUFBRSxLQUFLLDBCQUFlLENBQUMsYUFBYSxFQUFFO3dCQUNsRSxJQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQzt3QkFDbEQsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEtBQUssQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7NEJBQ25DLEdBQUcsQ0FBQyxJQUFJLGdCQUFFLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRSxHQUFLLEtBQUssQ0FBQyxDQUFDLENBQUMsUUFBRSxDQUFDO3lCQUM3QztxQkFDSjtpQkFDSjthQUNKO1lBQ0QsT0FBTyxHQUFHLENBQUM7UUFDZixDQUFDO1FBRU8sdUNBQWEsR0FBckIsVUFBc0IsSUFBcUIsRUFBRSxVQUFzQjtZQUMvRCxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsVUFBVSxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtnQkFDeEMsSUFBTSxRQUFRLEdBQUcsSUFBSSxtQkFBUSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLEVBQUUsMkJBQVksQ0FBQyxZQUFZLENBQUMsQ0FBQztnQkFDOUUsSUFBSSxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxFQUFFO29CQUN0QixJQUFJLENBQUMsYUFBYSxDQUFDLFFBQVEsRUFBRSxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUM7aUJBQ3REO2dCQUNELElBQUksQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUM7YUFDMUI7UUFDTCxDQUFDO1FBRUQsc0NBQVksR0FBWixVQUFhLE1BQW1CLEVBQUUsRUFBYzs7WUFDNUMsT0FBTyxDQUFDLElBQUksQ0FBQyxjQUFjLEVBQUUsTUFBTSxFQUFFLEVBQUUsQ0FBQyxDQUFDO1lBQ3pDLFVBQUksQ0FBQyx1QkFBdUIsQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQywwQ0FBRSxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUM7WUFDM0QsSUFBSSxJQUFJLENBQUMsdUJBQXVCLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsRUFBRTtnQkFDM0MsVUFBSSxDQUFDLHVCQUF1QixDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLDBDQUFFLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQzthQUM5RDtpQkFBTTtnQkFDSCxJQUFNLFNBQVMsR0FBRyxJQUFJLFNBQVMsQ0FBQyxFQUFFLENBQUMsS0FBSyxFQUFFLElBQUksRUFBRSxFQUFFLGdCQUFnQixFQUFFLElBQUksQ0FBQyxpQkFBaUIsRUFBRSxDQUFDLENBQUM7Z0JBQzlGLFNBQVMsQ0FBQyxpQkFBaUIsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLHFCQUFxQixDQUFDLENBQUM7Z0JBQ2xFLFNBQVMsQ0FBQyxxQkFBcUIsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLG9CQUFvQixDQUFDLENBQUM7Z0JBQ3JFLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxDQUFDO2dCQUM5QixJQUFJLENBQUMsdUJBQXVCLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsR0FBRyxTQUFTLENBQUM7Z0JBQ3RELFNBQVMsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUM7Z0JBQzVCLFNBQVMsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUM7Z0JBQzFCLElBQUksQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQzthQUMvQztRQUNMLENBQUM7UUFDRCwwQ0FBZ0IsR0FBaEIsVUFBaUIsTUFBa0IsRUFBRSxFQUFjOztZQUMvQyxPQUFPLENBQUMsSUFBSSxDQUFDLGtCQUFrQixFQUFFLE1BQU0sRUFBRSxFQUFFLENBQUMsQ0FBQztZQUM3QyxVQUFJLENBQUMsdUJBQXVCLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsMENBQUUsU0FBUyxDQUFDLFNBQVMsQ0FBQyxDQUFDO1lBQ2hFLFVBQUksQ0FBQyx1QkFBdUIsQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQywwQ0FBRSxTQUFTLENBQUMsU0FBUyxDQUFDLENBQUM7UUFDcEUsQ0FBQztRQUNELHNDQUFZLEdBQVosVUFBYSxNQUFtQixFQUFFLEVBQWM7O1lBQzVDLE9BQU8sQ0FBQyxJQUFJLENBQUMsa0JBQWtCLEVBQUUsTUFBTSxFQUFFLEVBQUUsQ0FBQyxDQUFDO1lBQzdDLFVBQUksQ0FBQyx1QkFBdUIsQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQywwQ0FBRSxTQUFTLENBQUMsT0FBTyxDQUFDLENBQUM7WUFDOUQsVUFBSSxDQUFDLHVCQUF1QixDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLDBDQUFFLFNBQVMsQ0FBQyxPQUFPLENBQUMsQ0FBQztZQUM5RCxVQUFJLENBQUMsdUJBQXVCLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsMENBQUUsV0FBVyxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQzlELFVBQUksQ0FBQyx1QkFBdUIsQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQywwQ0FBRSxXQUFXLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDbEUsQ0FBQztRQW5aTSw0QkFBWSxHQUFrQjtZQUNqQyxjQUFjLEVBQUUsYUFBYTtZQUM3QixVQUFVLEVBQUUsd0JBQWEsQ0FBQyxLQUFLO1NBQ2xDLENBQUM7UUFpWk4sc0JBQUM7S0FBQSxDQXJab0MsQ0FBQyxDQUFDLE9BQU8sR0FxWjdDO0lBclpZLDBDQUFlOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lDNWM1QjtRQUFtQyxpQ0FBUztRQVV4Qyx1QkFBWSxPQUF5QjtZQUFyQyxZQUNJLGtCQUFNLE9BQU8sQ0FBQyxTQUlqQjtZQVhELFlBQU0sR0FBbUIsRUFBRSxDQUFDO1lBUXhCLElBQU0sQ0FBQyxHQUFHLFVBQUMsTUFBa0IsRUFBRSxjQUEwQixJQUFLLFlBQUksQ0FBQyxlQUFlLENBQUMsTUFBTSxFQUFFLGNBQWMsQ0FBQyxFQUE1QyxDQUE0QyxDQUFDO1lBQzNHLDBCQUFhLENBQUMsWUFBWSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUN4QywwQkFBYSxDQUFDLGNBQWMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUM7O1FBQzlDLENBQUM7UUFFTyx1Q0FBZSxHQUF2QixVQUF3QixNQUFrQixFQUFFLEdBQWU7WUFDdkQsT0FBTyxDQUFDLElBQUksQ0FBQyxjQUFjLEVBQUUsR0FBRyxDQUFDLENBQUM7WUFDbEMsSUFBSSxHQUFHLENBQUMsS0FBSyxDQUFDLFVBQVUsRUFBRTtnQkFDdEIsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDO2FBQy9CO2lCQUFNO2dCQUNILElBQU0sR0FBRyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQztnQkFDM0MsSUFBSSxHQUFHLElBQUksQ0FBQyxFQUFFO29CQUNWLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQztpQkFDOUI7YUFDSjtZQUNELElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQztRQUN6QixDQUFDO1FBRUQsNkJBQUssR0FBTCxVQUFNLEdBQVU7WUFBaEIsaUJBcUJDO1lBcEJHLElBQUksQ0FBQyxJQUFJLEdBQUcsR0FBRyxDQUFDO1lBQ2hCLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFO2dCQUNYLElBQU0sR0FBRyxHQUFHLDRCQUFpQixFQUFDLEtBQUssRUFBRSxTQUFTLEVBQUUsc0JBQXNCLENBQUMsQ0FBQztnQkFDeEUsaUVBQWlFO2dCQUNqRSxJQUFNLElBQUksR0FBRyw0QkFBaUIsRUFBQyxNQUFNLEVBQUUsR0FBRyxDQUFDLENBQUM7Z0JBQzVDLEdBQUcsQ0FBQyxLQUFLLEdBQUcsU0FBUyxDQUFDO2dCQUN0QixJQUFJLENBQUMsU0FBUyxHQUFHLFNBQVMsQ0FBQztnQkFDM0IsR0FBRyxDQUFDLGdCQUFnQixDQUFDLE9BQU8sRUFBRSxVQUFDLEVBQUU7b0JBQzdCLEVBQUUsQ0FBQyxZQUFZLEdBQUcsSUFBSSxDQUFDO29CQUN2QixFQUFFLENBQUMsZUFBZSxFQUFFLENBQUM7b0JBQ3JCLEtBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQztvQkFDcEIsT0FBTyxJQUFJLENBQUM7Z0JBQ2hCLENBQUMsQ0FBQyxDQUFDO2dCQUNILElBQUksQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDO2dCQUVmLElBQUksQ0FBQyxhQUFhLEdBQUcsVUFBQyxFQUFjO29CQUNoQyxLQUFJLENBQUMsWUFBWSxFQUFFLENBQUM7Z0JBQ3hCLENBQUMsQ0FBQzthQUNMO1lBQ0QsT0FBTyxJQUFJLENBQUMsR0FBRyxDQUFDO1FBQ3BCLENBQUM7UUFFRCxvQ0FBWSxHQUFaO1lBQ0ksSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUU7Z0JBQ2pCLElBQUksQ0FBQyxVQUFVLEVBQUUsQ0FBQzthQUNyQjtpQkFBTTtnQkFDSCxJQUFJLENBQUMsU0FBUyxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUM7YUFDN0M7UUFDTCxDQUFDO1FBRUQsNENBQW9CLEdBQXBCOztZQUNJLE9BQU8sQ0FBQyxJQUFJLENBQUMsc0JBQXNCLENBQUMsQ0FBQztZQUNyQyxJQUFNLEdBQUcsR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQzFDLEdBQUcsQ0FBQyxTQUFTLEdBQUcsMkJBQTJCLENBQUM7WUFDNUMsSUFBTSxLQUFLLEdBQUcsNEJBQWlCLEVBQUMsS0FBSyxFQUFFLEdBQUcsRUFBRSxvQkFBb0IsQ0FBQyxDQUFDO1lBQ2xFLElBQUksV0FBSSxDQUFDLE1BQU0sMENBQUUsTUFBTSxJQUFHLENBQUMsRUFBRTtnQkFDekIsSUFBSSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsVUFBQyxLQUFLLEVBQUUsR0FBRztvQkFDM0IsT0FBTyxDQUFDLElBQUksQ0FBQyxnQkFBUyxHQUFHLENBQUUsRUFBRSxLQUFLLENBQUMsQ0FBQztvQkFDcEMsc0JBQXNCLENBQUMsS0FBSyxDQUFDLGdCQUFnQixFQUFFLEtBQUssQ0FBQyxDQUFDO2dCQUMxRCxDQUFDLENBQUMsQ0FBQzthQUNOO2lCQUFNO2dCQUNILDRCQUFpQixFQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUUsU0FBUyxFQUFFO29CQUNuQyxTQUFTLEVBQUUsaUNBQWlDO2lCQUMvQyxDQUFDLENBQUM7YUFDTjtZQUNELE9BQU8sR0FBRyxDQUFDO1FBQ2YsQ0FBQztRQUVELHdDQUFnQixHQUFoQjtZQUFBLGlCQVdDO1lBVkcsSUFBTSxHQUFHLEdBQUcsNEJBQWlCLEVBQUMsS0FBSyxFQUFFLFNBQVMsRUFBRSxtQkFBbUIsQ0FBQyxDQUFDO1lBQ3JFLElBQU0sUUFBUSxHQUFHLENBQUMsSUFBSSxDQUFDLGNBQWMsR0FBRyw0QkFBaUIsRUFBQyxLQUFLLEVBQUUsR0FBRyxFQUFFLHdCQUF3QixDQUFDLENBQUMsQ0FBQztZQUNqRyxJQUFNLFFBQVEsR0FBRyw0QkFBaUIsRUFBQyxNQUFNLEVBQUUsUUFBUSxDQUFDLENBQUM7WUFDckQsUUFBUSxDQUFDLFNBQVMsR0FBRyxTQUFTLENBQUM7WUFDL0IsSUFBTSxVQUFVLEdBQUcsNEJBQWlCLEVBQUMsR0FBRyxFQUFFLFFBQVEsRUFBRSxPQUFPLENBQUMsQ0FBQztZQUM3RCxVQUFVLENBQUMsZ0JBQWdCLENBQUMsT0FBTyxFQUFFLFVBQUMsRUFBRSxJQUFLLFlBQUksQ0FBQyxpQkFBaUIsRUFBRSxFQUF4QixDQUF3QixDQUFDLENBQUM7WUFDdkUsSUFBTSxLQUFLLEdBQUcsQ0FBQyxJQUFJLENBQUMsV0FBVyxHQUFHLElBQUksQ0FBQyxvQkFBb0IsRUFBRSxDQUFDLENBQUM7WUFDL0QsR0FBRyxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUN2QixHQUFHLENBQUMsV0FBVyxDQUFDLDRCQUFpQixFQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDO1lBQ3ZELE9BQU8sR0FBRyxDQUFDO1FBQ2YsQ0FBQztRQUVELHFDQUFhLEdBQWI7WUFDSSxJQUFJLElBQUksQ0FBQyxXQUFXLEVBQUU7Z0JBQ2xCLElBQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxvQkFBb0IsRUFBRSxDQUFDO2dCQUMxQyxJQUFJLENBQUMsV0FBVyxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsQ0FBQztnQkFDcEMsSUFBSSxDQUFDLFdBQVcsR0FBRyxLQUFLLENBQUM7YUFDNUI7UUFDTCxDQUFDO1FBRUQsa0NBQVUsR0FBVjtZQUNJLE9BQU8sQ0FBQyxJQUFJLENBQUMsWUFBWSxFQUFFLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztZQUN4QyxJQUFNLEdBQUcsR0FBRyxDQUFDLElBQUksQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDLGdCQUFnQixFQUFFLENBQUMsQ0FBQztZQUN2RCxHQUFHLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQztZQUMvQixDQUFDLENBQUMsUUFBUSxDQUFDLHVCQUF1QixDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBQ3hDLENBQUMsQ0FBQyxRQUFRLENBQUMsd0JBQXdCLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDekMsSUFBSSxDQUFDLElBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDOUMsQ0FBQztRQUVPLHlDQUFpQixHQUF6QjtZQUNJLE9BQU8sQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUM7WUFDNUIsSUFBSSxJQUFJLENBQUMsU0FBUyxJQUFJLElBQUksQ0FBQyxJQUFJLEVBQUU7Z0JBQzdCLHdEQUF3RDtnQkFDeEQsOEJBQThCO2dCQUM5QixJQUFJLENBQUMsU0FBUyxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLENBQUM7YUFDMUM7UUFDTCxDQUFDO1FBRUQsZ0NBQVEsR0FBUixVQUFTLEdBQVU7WUFDZixJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQztRQUNyQixDQUFDO1FBQ0wsb0JBQUM7SUFBRCxDQUFDLENBekhrQyxDQUFDLENBQUMsT0FBTyxHQXlIM0M7SUF6SFksc0NBQWE7SUEySDFCLFNBQWdCLHNCQUFzQixDQUFDLE1BQXdCLEVBQUUsR0FBbUI7O1FBQ2hGLE9BQU8sQ0FBQyxJQUFJLENBQUMsd0JBQXdCLEVBQUUsTUFBTSxDQUFDLENBQUM7UUFDL0MsNEJBQWlCLEVBQUMsSUFBSSxFQUFFLEdBQUcsRUFBRSxTQUFTLEVBQUU7WUFDcEMsU0FBUyxFQUFFLE1BQU0sQ0FBQyxLQUFLO1NBQzFCLENBQUMsQ0FBQztRQUNILElBQUk7WUFDQSxJQUFJLE1BQU0sQ0FBQyxJQUFJLEtBQUssU0FBUyxFQUFFO2dCQUMzQixJQUFJLE1BQU0sQ0FBQyxPQUFPLEVBQUU7b0JBQ2hCLE1BQU0sQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLFVBQUMsVUFBVTt3QkFDOUIsSUFBTSxHQUFHLEdBQUcsNEJBQWlCLEVBQUMsS0FBSyxFQUFFLEdBQUcsRUFBRSxZQUFZLENBQUMsQ0FBQzt3QkFDeEQsSUFBTSxhQUFhLEdBQUcsNEJBQWlCLEVBQUMsTUFBTSxFQUFFLEdBQUcsRUFBRSxNQUFNLENBQUMsQ0FBQzt3QkFDN0QsZ0RBQWdEO3dCQUNoRCwyREFBMkQ7d0JBQzNELElBQUksVUFBVSxHQUFHLFNBQVMsQ0FBQzt3QkFDM0IsSUFBSSxNQUFNLENBQUMsUUFBUSxLQUFLLE9BQU8sRUFBRTs0QkFDN0IscURBQXFEOzRCQUNyRCxVQUFVLEdBQUcsbUJBQW1CLENBQUMsVUFBVSxDQUFDLENBQUM7eUJBQ2hEOzZCQUFNLElBQUksTUFBTSxDQUFDLFFBQVEsS0FBSyxTQUFTLEVBQUU7NEJBQ3RDLFVBQVUsR0FBRyxtQkFBbUIsQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLENBQUM7eUJBQ3REOzZCQUFNLElBQUksTUFBTSxDQUFDLFFBQVEsS0FBSyxZQUFZLEVBQUU7NEJBQ3pDLFVBQVUsR0FBRyxzQkFBc0IsQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLENBQUM7eUJBQ3pEO3dCQUNELElBQUksVUFBVSxFQUFFOzRCQUNaLGFBQWEsQ0FBQyxXQUFXLENBQUMsVUFBVSxDQUFDLENBQUM7eUJBQ3pDO3dCQUNELElBQU0sYUFBYSxHQUFHLDRCQUFpQixFQUFDLE1BQU0sRUFBRSxHQUFHLENBQUMsQ0FBQzt3QkFDckQsYUFBYSxDQUFDLFNBQVMsR0FBRyxVQUFVLENBQUMsSUFBSSxDQUFDO29CQUM5QyxDQUFDLENBQUMsQ0FBQztpQkFDTjtxQkFBTTtvQkFDSCxJQUFJLFVBQVUsU0FBUyxDQUFDO29CQUN4QixJQUFJLE1BQU0sQ0FBQyxRQUFRLEtBQUssT0FBTyxFQUFFO3dCQUM3QixJQUFJLFlBQU0sQ0FBQyxLQUFLLDBDQUFFLFFBQVEsRUFBRTs0QkFDeEIsb0JBQW9CLENBQUMsR0FBRyxFQUFFLE1BQU0sQ0FBQyxDQUFDO3lCQUNyQzs2QkFBTTs0QkFDSCxVQUFVLEdBQUcsbUJBQW1CLENBQUMsTUFBTSxDQUFDLENBQUM7eUJBQzVDO3FCQUNKO3lCQUFNLElBQUksTUFBTSxDQUFDLFFBQVEsS0FBSyxTQUFTLEVBQUU7d0JBQ3RDLFVBQVUsR0FBRyxtQkFBbUIsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUM7cUJBQ2xEO3lCQUFNLElBQUksTUFBTSxDQUFDLFFBQVEsS0FBSyxZQUFZLEVBQUU7d0JBQ3pDLFVBQVUsR0FBRyxzQkFBc0IsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUM7cUJBQ3JEO29CQUNELElBQUksVUFBVSxFQUFFO3dCQUNaLElBQU0sR0FBRyxHQUFHLDRCQUFpQixFQUFDLEtBQUssRUFBRSxHQUFHLEVBQUUsWUFBWSxDQUFDLENBQUM7d0JBQ3hELElBQU0sYUFBYSxHQUFHLDRCQUFpQixFQUFDLE1BQU0sRUFBRSxHQUFHLEVBQUUsTUFBTSxDQUFDLENBQUM7d0JBQzdELGFBQWEsQ0FBQyxXQUFXLENBQUMsVUFBVSxDQUFDLENBQUM7d0JBQ3RDLGdEQUFnRDt3QkFDaEQsa0NBQWtDO3FCQUNyQztpQkFDSjthQUNKO2lCQUFNLElBQUksTUFBTSxDQUFDLElBQUksS0FBSyxLQUFLLEVBQUU7Z0JBQzlCLElBQU0sS0FBRyxHQUFHLDRCQUFpQixFQUFDLEtBQUssRUFBRSxHQUFHLEVBQUUsWUFBWSxDQUFDLENBQUM7Z0JBQ3hELElBQU0sU0FBUyxHQUFHLGVBQWUsQ0FBQyxNQUFNLENBQUMsQ0FBQztnQkFDMUMsSUFBTSxLQUFHLEdBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsQ0FBQztnQkFDMUMsS0FBRyxDQUFDLGdCQUFnQixDQUFDLE9BQU8sRUFBRSxVQUFDLEdBQUc7b0JBQzlCLElBQU0sR0FBRyxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsTUFBTSxDQUFDLENBQUM7b0JBQzNDLEdBQUcsQ0FBQyxTQUFTLEdBQUcsZ0RBQWdELENBQUM7b0JBQ2pFLEtBQUcsQ0FBQyxhQUFhLENBQUMsV0FBVyxDQUFDLEtBQUcsQ0FBQyxDQUFDO29CQUNuQyxLQUFHLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxDQUFDO2dCQUN6QixDQUFDLENBQUMsQ0FBQztnQkFDSCxLQUFHLENBQUMsR0FBRyxHQUFHLFNBQVMsQ0FBQztnQkFDcEIsS0FBRyxDQUFDLFdBQVcsQ0FBQyxLQUFHLENBQUMsQ0FBQzthQUN4QjtTQUNKO1FBQUMsT0FBTyxFQUFFLEVBQUU7WUFDVCxPQUFPLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1lBQ2xCLElBQU0sR0FBRyxHQUFHLDRCQUFpQixFQUFDLEtBQUssRUFBRSxHQUFHLEVBQUUsWUFBWSxDQUFDLENBQUM7WUFDeEQsSUFBTSxHQUFHLEdBQUcsNEJBQWlCLEVBQUMsTUFBTSxFQUFFLEdBQUcsQ0FBQyxDQUFDO1lBQzNDLEdBQUcsQ0FBQyxTQUFTLEdBQUcsbUNBQW1DLENBQUM7U0FDdkQ7SUFDTCxDQUFDO0lBcEVELHdEQW9FQztJQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7TUFnREU7SUFFRiwrRUFBK0U7SUFDL0UsdUNBQXVDO0lBQ3ZDLDRDQUE0QztJQUM1QyxpREFBaUQ7SUFDakQscURBQXFEO0lBQ3JELG1EQUFtRDtJQUNuRCx3REFBd0Q7SUFDeEQsc0RBQXNEO0lBQ3RELFlBQVk7SUFDWix5Q0FBeUM7SUFDekMsNkNBQTZDO0lBQzdDLFFBQVE7SUFDUix3QkFBd0I7SUFDeEIsSUFBSTtJQUVKLFNBQWdCLG1CQUFtQixDQUFDLEtBQW9DO1FBQ3BFLHVCQUF1QjtRQUN2Qix5Q0FBeUM7UUFDekMsSUFBSTtRQUNKLE9BQU8sQ0FBQyxJQUFJLENBQUMscUJBQXFCLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFDM0MsSUFBSSxLQUFLLENBQUMsSUFBSSxJQUFJLEtBQUssQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFO1lBQ2xDLElBQU0sR0FBRyxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDMUMsR0FBRyxDQUFDLEdBQUcsR0FBRyxLQUFLLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQztZQUM3QixHQUFHLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ25DLEdBQUcsQ0FBQyxNQUFNLEdBQUcsS0FBSyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDcEMsT0FBTyxHQUFHLENBQUM7U0FDZDtRQUNELElBQU0sS0FBSyxHQUFHLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQztRQUNoRCxPQUFPLGtCQUFrQixDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQ3JDLENBQUM7SUFkRCxrREFjQztJQUVELDhEQUE4RDtJQUM5RCw0MkNBQTQyQztJQUM1MkMsaURBQWlEO0lBQ2pELHFCQUFxQjtJQUNyQiwyQ0FBMkM7SUFDM0MsZ0RBQWdEO0lBQ2hELFVBQVU7SUFDVixrQkFBa0I7SUFDbEIsSUFBSTtJQUVKLFNBQVMsbUJBQW1CLENBQUMsS0FBdUI7UUFDaEQsSUFBSSxVQUFVLEdBQVksU0FBUyxDQUFDO1FBQ3BDLElBQU0sTUFBTSxHQUFHLHNDQUFpQixHQUFFLENBQUMsdUJBQXVCLENBQUM7UUFDM0QsSUFBTSxTQUFTLEdBQUcsZUFBZSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQ3pDLG9CQUFvQjtRQUNwQiw4QkFBOEI7UUFDOUIsSUFBSTtRQUNKLElBQUksTUFBTSxJQUFJLFNBQVMsRUFBRTtZQUNyQiw4Q0FBOEM7WUFDOUMsOENBQThDO1lBQzlDLElBQU0sR0FBRyxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDMUMsR0FBRyxDQUFDLEdBQUcsR0FBRyxNQUFNLENBQUM7WUFDakIsR0FBRyxDQUFDLGdCQUFnQixDQUFDLE9BQU8sRUFBRSxVQUFDLEdBQUc7Z0JBQzlCLGFBQWEsQ0FBQyxHQUFHLEVBQUUsU0FBUyxDQUFDLENBQUM7WUFDbEMsQ0FBQyxDQUFDLENBQUM7WUFDSCxHQUFHLENBQUMsS0FBSyxDQUFDLFFBQVEsR0FBRyxVQUFVLENBQUM7WUFDaEMsR0FBRyxDQUFDLEtBQUssQ0FBQyxLQUFLLEdBQUcsTUFBTSxDQUFDO1lBQ3pCLEdBQUcsQ0FBQyxLQUFLLEdBQUcsbUJBQW1CLENBQUM7WUFDaEMsd0NBQXdDO1lBQ3hDLFVBQVUsR0FBRyxHQUFHLENBQUM7U0FDcEI7UUFDRCxPQUFPLFVBQVUsQ0FBQztJQUN0QixDQUFDO0lBRUQsU0FBUyxlQUFlLENBQUMsS0FBdUI7UUFDNUMsSUFBSSxHQUFHLEdBQUcsU0FBUyxDQUFDO1FBQ3BCLElBQUksS0FBSyxDQUFDLFVBQVUsRUFBRTtZQUNsQixPQUFPLEtBQUssQ0FBQyxVQUFVLENBQUM7U0FDM0I7UUFDRCxJQUFJLEtBQUssQ0FBQyxHQUFHLEVBQUU7WUFDWCxJQUFJLEtBQUssQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxFQUFFO2dCQUN6QixHQUFHLEdBQUcsS0FBSyxDQUFDLEdBQUcsR0FBRywyREFBMkQsR0FBRyxLQUFLLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxHQUFHLHFDQUFxQyxDQUFDO2dCQUNoSixPQUFPLEdBQUcsQ0FBQzthQUNkO1lBQ0QsSUFBSSxLQUFLLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEVBQUU7Z0JBQzVCLEdBQUcsR0FBRyxLQUFLLENBQUMsR0FBRyxHQUFHLDREQUE0RCxHQUFHLEtBQUssQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLEdBQUcscUNBQXFDLENBQUM7Z0JBQ2pKLE9BQU8sR0FBRyxDQUFDO2FBQ2Q7WUFDRCxHQUFHLEdBQUcsS0FBSyxDQUFDLEdBQUcsR0FBRyw0REFBNEQsR0FBRyxLQUFLLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxHQUFHLHFDQUFxQyxDQUFDO1lBQ2pKLE9BQU8sR0FBRyxDQUFDO1NBQ2Q7SUFDTCxDQUFDO0lBQ0QsOEVBQThFO0lBQzlFLHVEQUF1RDtJQUN2RCxtREFBbUQ7SUFDbkQsaUNBQWlDO0lBQ2pDLElBQUk7SUFDSixTQUFTLGFBQWEsQ0FBQyxHQUFlLEVBQUUsR0FBVztRQUMvQyxJQUFNLE9BQU8sR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQzlDLElBQU0sR0FBRyxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLENBQUM7UUFFMUMsR0FBRyxDQUFDLGdCQUFnQixDQUFDLE9BQU8sRUFBRSxVQUFDLEdBQUc7WUFDOUIsSUFBTSxHQUFHLEdBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBQyxNQUFNLENBQUMsQ0FBQztZQUMzQyxHQUFHLENBQUMsU0FBUyxHQUFHLGdEQUFnRCxDQUFDO1lBQ2pFLEdBQUcsQ0FBQyxhQUFhLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBQ25DLE9BQU8sQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDN0IsQ0FBQyxDQUFDLENBQUM7UUFDSCxHQUFHLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQztRQUNkLE9BQU8sQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDekIsV0FBVyxDQUFDLEdBQUcsRUFBRSxPQUFPLENBQUMsQ0FBQztJQUM5QixDQUFDO0lBRUQsU0FBUyxjQUFjLENBQUMsS0FBa0I7UUFDdEMsT0FBTyxDQUFDLElBQUksQ0FBQyxhQUFhLEVBQUUsS0FBSyxFQUFFLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUNqRCxJQUFNLEVBQUUsR0FBaUIsRUFBRSxDQUFDO1FBQzVCLElBQUksS0FBSyxDQUFDLE1BQU0sRUFBRTtZQUNkLEVBQUUsQ0FBQyxNQUFNLEdBQUcsS0FBSyxDQUFDLEtBQUssQ0FBQztZQUN4QixFQUFFLENBQUMsYUFBYSxHQUFHLENBQUMsS0FBSyxDQUFDLE9BQU8sSUFBSSxDQUFDLENBQUMsQ0FBQyxRQUFRLEVBQUUsQ0FBQztZQUNuRCxFQUFFLENBQUMsV0FBVyxHQUFHLENBQUMsS0FBSyxDQUFDLE1BQU0sSUFBSSxDQUFDLENBQUMsQ0FBQyxRQUFRLEVBQUUsQ0FBQztZQUNoRCxFQUFFLENBQUMsYUFBYSxHQUFHLEtBQUssQ0FBQyxPQUFPLElBQUksRUFBRSxDQUFDO1lBQ3ZDLEVBQUUsQ0FBQyxjQUFjLEdBQUcsS0FBSyxDQUFDLFFBQVEsSUFBSSxFQUFFLENBQUM7WUFDekMsRUFBRSxDQUFDLGVBQWUsR0FBRyxLQUFLLENBQUMsU0FBUyxJQUFJLEVBQUUsQ0FBQztZQUMzQyxFQUFFLENBQUMsZ0JBQWdCLEdBQUcsS0FBSyxDQUFDLFVBQVUsSUFBSSxFQUFFLENBQUM7U0FDaEQ7YUFBTTtZQUNILEVBQUUsQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDO1NBQ3RCO1FBRUQsSUFBSSxLQUFLLENBQUMsSUFBSSxFQUFFO1lBQ1osRUFBRSxDQUFDLElBQUksR0FBRyxLQUFLLENBQUMsU0FBUyxJQUFJLEtBQUssQ0FBQyxLQUFLLENBQUM7WUFDekMsSUFBSSxLQUFLLENBQUMsV0FBVyxFQUFFO2dCQUNuQixFQUFFLENBQUMsT0FBTyxHQUFHLEtBQUssQ0FBQyxXQUFXLENBQUMsUUFBUSxFQUFFLENBQUM7YUFDN0M7WUFDRCxFQUFFLENBQUMsUUFBUSxHQUFHLEtBQUssQ0FBQyxRQUFRLElBQUksU0FBUyxDQUFDO1NBQzdDO2FBQU07WUFDSCxFQUFFLENBQUMsSUFBSSxHQUFHLE1BQU0sQ0FBQztTQUNwQjtRQUVELE9BQU8sRUFBRSxDQUFDO0lBQ2QsQ0FBQztJQUVELHNFQUFzRTtJQUN0RSxnREFBZ0Q7SUFDaEQsOEJBQThCO0lBQzlCLGdEQUFnRDtJQUNoRCxXQUFXO0lBQ1gsOERBQThEO0lBQzlELGtFQUFrRTtJQUVsRSx3Q0FBd0M7SUFDeEMsd0NBQXdDO0lBQ3hDLHdCQUF3QjtJQUN4QixJQUFJO0lBRUosU0FBUyxzQkFBc0IsQ0FBQyxLQUFVO1FBQ3RDLE9BQU8sQ0FBQyxJQUFJLENBQUMsd0JBQXdCLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFDOUMsSUFBTSxLQUFLLEdBQUcsSUFBSSxHQUFHLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEtBQUssRUFBRSxFQUFFLEVBQUUsTUFBTSxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUM7UUFDakUsSUFBTSxFQUFFLEdBQUcsY0FBYyx1QkFBTSxvQ0FBbUIsR0FBSyxLQUFLLEVBQUcsQ0FBQztRQUNoRSxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUMsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQztRQUNqQyxPQUFPLEtBQUssQ0FBQyxHQUFHLENBQUM7SUFDckIsQ0FBQztJQUVELG1FQUFtRTtJQUNuRSw4QkFBOEI7SUFDOUIsZ0RBQWdEO0lBQ2hELFdBQVc7SUFDWCxpQ0FBaUM7SUFDakMsa0VBQWtFO0lBQ2xFLG1CQUFtQjtJQUNuQixrRUFBa0U7SUFDbEUsOEJBQThCO0lBQzlCLG1FQUFtRTtJQUNuRSxrQ0FBa0M7SUFDbEMsbUNBQW1DO0lBQ25DLGdFQUFnRTtJQUNoRSw4QkFBOEI7SUFDOUIsOEJBQThCO0lBQzlCLFFBQVE7SUFDUixvREFBb0Q7SUFDcEQsc0NBQXNDO0lBQ3RDLHdCQUF3QjtJQUN4QixJQUFJO0lBRUosU0FBUyxtQkFBbUIsQ0FBQyxLQUFVO1FBQ25DLE9BQU8sQ0FBQyxJQUFJLENBQUMscUJBQXFCLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFDM0MsSUFBTSxLQUFLLEdBQUcsSUFBSSxHQUFHLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEtBQUssRUFBRSxFQUFFLEVBQUUsTUFBTSxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUM7UUFDakUsSUFBTSxFQUFFLEdBQUc7WUFDUCxNQUFNLEVBQUUsS0FBSyxJQUFJLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLFNBQVM7WUFDdEQsYUFBYSxFQUFFLEdBQUc7WUFDbEIsV0FBVyxFQUFFLEtBQUssSUFBSSxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHO1lBQ3ZELGFBQWEsRUFBRSxPQUFPO1lBQ3RCLGNBQWMsRUFBRSxPQUFPO1lBQ3ZCLGdFQUFnRTtZQUNoRSxJQUFJLEVBQUUsS0FBSyxhQUFMLEtBQUssdUJBQUwsS0FBSyxDQUFFLFNBQVM7WUFDdEIsV0FBVyxFQUFFLEtBQUssSUFBSSxLQUFLLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxLQUFLO1lBQ25FLFFBQVEsRUFBRSxTQUFTO1NBQ3RCLENBQUM7UUFDRixLQUFLLENBQUMsV0FBVyxDQUFDLHFCQUFxQixFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBQzdDLE9BQU8sS0FBSyxDQUFDLEdBQUcsQ0FBQztJQUNyQixDQUFDO0lBRUQsU0FBUyxvQkFBb0IsQ0FBQyxHQUFnQixFQUFFLE1BQXdCOztRQUNwRTs7Ozs7Ozs7Ozs7Ozs7OztZQWdCSTtRQUNKLEtBQUssSUFBSSxDQUFDLElBQUksTUFBTSxDQUFDLEtBQUssQ0FBQyxRQUFRLEVBQUU7WUFDakMsSUFBTSxHQUFHLEdBQUcsNEJBQWlCLEVBQUMsS0FBSyxFQUFFLEdBQUcsRUFBRSxZQUFZLENBQUMsQ0FBQztZQUN4RCxJQUFNLGFBQWEsR0FBRyw0QkFBaUIsRUFBQyxNQUFNLEVBQUUsR0FBRyxFQUFFLE1BQU0sQ0FBQyxDQUFDO1lBQzdELElBQU0sVUFBVSxHQUFHLG1CQUFtQixDQUFDLEVBQUUsU0FBUyxFQUFFLE1BQU0sQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUM7WUFDMUcsYUFBYSxDQUFDLFdBQVcsQ0FBQyxVQUFVLENBQUMsQ0FBQztZQUN0QyxJQUFNLGFBQWEsR0FBRyw0QkFBaUIsRUFBQyxNQUFNLEVBQUUsR0FBRyxDQUFDLENBQUM7WUFDckQsYUFBYSxDQUFDLFNBQVMsR0FBRyxrQkFBTSxDQUFDLGVBQWUsMENBQUcsQ0FBQyxDQUFDLG1DQUFJLENBQUMsQ0FBQztTQUM5RDtJQUNMLENBQUM7SUFFRCxTQUFTLGtCQUFrQixDQUFDLEtBQVU7UUFDbEMsSUFBTSxLQUFLLEdBQUcsSUFBSSxHQUFHLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEtBQUssRUFBRSxFQUFFLEVBQUUsTUFBTSxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUM7UUFDakUsT0FBTyxDQUFDLElBQUksQ0FBQyxvQkFBb0IsRUFBRSxLQUFLLENBQUMsQ0FBQztRQUMxQyxJQUFNLEVBQUUsR0FBRyxjQUFjLHVCQUFNLDRDQUEyQixHQUFLLEtBQUssRUFBRyxDQUFDO1FBQ3hFLEtBQUssQ0FBQyxTQUFTLENBQUMsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUM7UUFDaEMsT0FBTyxLQUFLLENBQUMsR0FBRyxDQUFDO0lBQ3JCLENBQUM7SUFFRCxTQUFTLFdBQVcsQ0FBQyxHQUFlLEVBQUUsT0FBb0I7UUFDdEQsSUFBTSxHQUFHLEdBQUcsNEJBQWlCLEVBQUMsS0FBSyxFQUFFLFNBQVMsRUFBRSxtQkFBbUIsQ0FBQyxDQUFDO1FBQ3JFLElBQU0sUUFBUSxHQUFHLDRCQUFpQixFQUFDLEtBQUssRUFBRSxHQUFHLEVBQUUsd0JBQXdCLENBQUMsQ0FBQztRQUN6RSxJQUFNLFFBQVEsR0FBRyw0QkFBaUIsRUFBQyxNQUFNLEVBQUUsUUFBUSxDQUFDLENBQUM7UUFDckQsUUFBUSxDQUFDLFNBQVMsR0FBRyxTQUFTLENBQUM7UUFDL0IsSUFBTSxVQUFVLEdBQUcsNEJBQWlCLEVBQUMsR0FBRyxFQUFFLFFBQVEsRUFBRSxPQUFPLENBQUMsQ0FBQztRQUM3RCxVQUFVLENBQUMsZ0JBQWdCLENBQUMsT0FBTyxFQUFFLFVBQUMsRUFBRTtZQUNwQyxJQUFJLEdBQUcsQ0FBQyxhQUFhLEVBQUU7Z0JBQ25CLEdBQUcsQ0FBQyxhQUFhLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxDQUFDO2FBQ3RDO1FBQ0wsQ0FBQyxDQUFDLENBQUM7UUFDSCxHQUFHLENBQUMsV0FBVyxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBRXpCLEdBQUcsQ0FBQyxLQUFLLENBQUMsUUFBUSxHQUFHLFVBQVUsQ0FBQztRQUNoQyxHQUFHLENBQUMsS0FBSyxDQUFDLElBQUksR0FBRyxHQUFHLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQztRQUNwQyxHQUFHLENBQUMsS0FBSyxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQztRQUNuQyxRQUFRLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUNuQyxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQzdkRDtRQUFBO1FBS0EsQ0FBQztRQUFELHlCQUFDO0lBQUQsQ0FBQztJQUxZLGdEQUFrQjtJQWlCL0I7UUFjSSxzQkFBWSxnQkFBa0M7WUFUOUMsZUFBVSxHQUFHLEtBQUssQ0FBQztZQUduQjs7ZUFFRztZQUNILFFBQUcsR0FBVyxDQUFDLENBQUMsQ0FBQztZQUliLElBQUksQ0FBQyxnQkFBZ0IsR0FBRyxnQkFBZ0IsQ0FBQztZQUN6QyxJQUFJLENBQUMsRUFBRSxHQUFHLFlBQVksQ0FBQyxTQUFTLEVBQUUsQ0FBQztRQUN2QyxDQUFDO1FBRUQsa0NBQVcsR0FBWCxVQUFZLFFBQWlCO1lBQ3pCLHlEQUF5RDtZQUN6RCxJQUFJLElBQUksQ0FBQyxVQUFVLEtBQUssUUFBUSxFQUFFO2dCQUM5QixJQUFJLENBQUMsVUFBVSxHQUFHLFFBQVEsQ0FBQztnQkFDM0IscUJBQWEsQ0FBQyxxQkFBcUIsQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFO29CQUMvQyxJQUFJLEVBQUUsUUFBUTtvQkFDZCxLQUFLLEVBQUUsSUFBSTtpQkFDZCxDQUFDLENBQUM7YUFDTjtRQUNMLENBQUM7UUEzQmMsc0JBQVMsR0FBRyxDQUFDLENBQUM7UUE0QmpDLG1CQUFDO0tBQUE7SUE3Qlksb0NBQVk7SUErQnpCO1FBQUE7WUFDSSxjQUFjO1lBRWQsNEJBQXVCLEdBQUcsSUFBSSx1Q0FBZSxFQUEwQyxDQUFDO1lBRXhGLGlCQUFZLEdBQUcsSUFBSSx1Q0FBZSxFQUFxQixDQUFDO1lBRXhELHNCQUFpQixHQUFHLElBQUksdUNBQWUsRUFBMEIsQ0FBQztZQUVsRSx5QkFBb0IsR0FBRyxJQUFJLHVDQUFlLEVBQXlCLENBQUM7WUFDcEUsMEJBQXFCLEdBQUcsSUFBSSx1Q0FBZSxFQUE0QixDQUFDO1lBRXhFLHlCQUFvQixHQUFHLElBQUksdUNBQWUsRUFBMkIsQ0FBQztZQUV0RSx1QkFBa0IsR0FBRyxJQUFJLHVDQUFlLEVBQTJCLENBQUM7WUFFcEUsaUJBQVksR0FBRyxJQUFJLHVDQUFlLEVBQTBCLENBQUM7WUFDN0QsbUJBQWMsR0FBRyxJQUFJLHVDQUFlLEVBQTBCLENBQUM7WUFFL0Qsd0JBQW1CLEdBQUcsSUFBSSx1Q0FBZSxFQUE4QixDQUFDO1lBRXhFLG1CQUFjLEdBQUcsSUFBSSx1Q0FBZSxFQUEwQixDQUFDO1lBRS9ELGlCQUFZLEdBQUcsSUFBSSx1Q0FBZSxFQUEyQixDQUFDO1lBRTlELGlCQUFZLEdBQUcsSUFBSSx1Q0FBZSxFQUEyQixDQUFDO1lBRTlELDJCQUFzQixHQUFHLElBQUksdUNBQWUsRUFBcUIsQ0FBQztRQUN0RSxDQUFDO1FBQUQsaUJBQUM7SUFBRCxDQUFDO0lBRVkscUJBQWEsR0FBRyxJQUFJLFVBQVUsRUFBRSxDQUFDO0lBRTlDLElBQU0sYUFBYSxHQUFtRDtRQUNsRSxFQUFFLFFBQVEsRUFBRSxtQkFBbUIsRUFBRSxTQUFTLEVBQUUsa0JBQWtCLEVBQUU7UUFDaEUsRUFBRSxRQUFRLEVBQUUsY0FBYyxFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQUU7UUFDbEQsRUFBRSxRQUFRLEVBQUUsYUFBYSxFQUFFLFNBQVMsRUFBRSxNQUFNLEVBQUU7UUFDOUMsRUFBRSxRQUFRLEVBQUUsV0FBVyxFQUFFLFNBQVMsRUFBRSxhQUFhLEVBQUU7UUFDbkQsRUFBRSxRQUFRLEVBQUUsaUJBQWlCLEVBQUUsU0FBUyxFQUFFLHdCQUF3QixFQUFFO0tBQ3ZFLENBQUM7SUFFRjtRQUFnQyw4QkFBUztRQWlDckMsb0JBQVksT0FBMkI7WUFBdkMsWUFDSSxrQkFBTSxPQUFPLENBQUMsU0FxQmpCO1lBOUNELFlBQU0sR0FBWSxJQUFJLENBQUM7WUFDdkIscUJBQWUsR0FBK0MsRUFBRSxDQUFDO1lBZ0JqRSxvQkFBYyxHQUFtQixFQUFFLENBQUM7WUFVaEMsSUFBSSxPQUFPLENBQUMsVUFBVSxFQUFFO2dCQUNwQixLQUFJLENBQUMsVUFBVSxHQUFHLE9BQU8sQ0FBQyxVQUFVLENBQUM7Z0JBQ3JDLE9BQU8sQ0FBQyxVQUFVLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO2dCQUNuRCxLQUFJLENBQUMsa0JBQWtCLEdBQUcsSUFBSSxpQ0FBZSxDQUFDLEVBQUUsVUFBVSxFQUFFLE9BQU8sQ0FBQyxVQUFVLEVBQUUsQ0FBQyxDQUFDO2dCQUNsRixLQUFJLENBQUMsYUFBYSxHQUFHLElBQUksNkNBQXFCLENBQUMsRUFBRSxRQUFRLEVBQUUsYUFBYSxFQUFFLENBQUMsQ0FBQztnQkFFNUUsSUFBTSxTQUFTLEdBQUcsQ0FBQyxLQUFJLENBQUMsdUJBQXVCLEdBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO2dCQUNqRixTQUFTLENBQUMsU0FBUyxHQUFHLGlCQUFpQixDQUFDO2FBQzNDO2lCQUFNO2dCQUNILEtBQUksQ0FBQyxrQkFBa0IsR0FBRyxJQUFJLDJCQUFZLENBQUMsRUFBRSxRQUFRLEVBQUUsU0FBUyxFQUFFLENBQUMsQ0FBQztnQkFDcEUsS0FBSSxDQUFDLGFBQWEsR0FBRyxJQUFJLDJCQUFZLENBQUM7b0JBQ2xDLFFBQVEsRUFBRSxTQUFTO29CQUNuQixTQUFTLEVBQUUsZ0JBQWdCO2lCQUM5QixDQUFDLENBQUM7YUFDTjtZQUVELEtBQUksQ0FBQyxTQUFTLEdBQUcsT0FBTyxDQUFDLFNBQVMsQ0FBQztZQUNuQyxLQUFJLENBQUMsUUFBUSxHQUFHLE9BQU8sQ0FBQyxRQUFRLENBQUM7WUFDakMsS0FBSSxDQUFDLFVBQVUsRUFBRSxDQUFDOztRQUN0QixDQUFDO1FBQ08sK0JBQVUsR0FBbEI7WUFBQSxpQkFXQztZQVZHLHFCQUFhLENBQUMsaUJBQWlCLENBQUMsU0FBUyxDQUFDLFVBQUMsTUFBTSxFQUFFLEdBQUcsSUFBSyxZQUFJLENBQUMsaUJBQWlCLENBQUMsTUFBTSxFQUFFLEdBQUcsQ0FBQyxFQUFuQyxDQUFtQyxDQUFDLENBQUM7WUFFaEcscUJBQWEsQ0FBQyxvQkFBb0IsQ0FBQyxTQUFTLENBQUMsVUFBQyxNQUFNLEVBQUUsS0FBSyxJQUFLLFlBQUksQ0FBQyxvQkFBb0IsQ0FBQyxNQUFNLEVBQUUsS0FBSyxDQUFDLEVBQXhDLENBQXdDLENBQUMsQ0FBQztZQUMxRyxxQkFBYSxDQUFDLHFCQUFxQixDQUFDLFNBQVMsQ0FBQyxVQUFDLE1BQU0sRUFBRSxjQUFjLElBQUssWUFBSSxDQUFDLHFCQUFxQixDQUFDLE1BQU0sRUFBRSxjQUFjLENBQUMsRUFBbEQsQ0FBa0QsQ0FBQyxDQUFDO1lBRTlILHFCQUFhLENBQUMsWUFBWSxDQUFDLFNBQVMsQ0FBQyxVQUFDLE1BQU0sRUFBRSxHQUFHLElBQUssWUFBSSxDQUFDLFlBQVksQ0FBQyxNQUFNLEVBQUUsR0FBRyxDQUFDLEVBQTlCLENBQThCLENBQUMsQ0FBQztZQUV0RixxQkFBYSxDQUFDLFlBQVksQ0FBQyxTQUFTLENBQUMsVUFBQyxNQUFNLEVBQUUsR0FBRyxJQUFLLFlBQUksQ0FBQyxZQUFZLENBQUMsTUFBTSxFQUFFLEdBQUcsQ0FBQyxFQUE5QixDQUE4QixDQUFDLENBQUM7WUFFdEYscUJBQWEsQ0FBQyxzQkFBc0IsQ0FBQyxTQUFTLENBQUMsVUFBQyxNQUFNLEVBQUUsVUFBVSxJQUFLLFlBQUksQ0FBQyxzQkFBc0IsQ0FBQyxNQUFNLEVBQUUsVUFBVSxDQUFDLEVBQS9DLENBQStDLENBQUMsQ0FBQztRQUM1SCxDQUFDO1FBRUQsc0NBQWlCLEdBQWpCLFVBQWtCLGNBQXdDLEVBQUUsT0FBZ0I7WUFBNUUsaUJBT0M7WUFORyxjQUFjLENBQUMsSUFBSSxDQUFDLGtCQUFrQixFQUFFLFVBQUMsR0FBRztnQkFDeEMsS0FBSSxDQUFDLGtCQUFrQixDQUFDLGlCQUFpQixDQUFDLFlBQVksRUFBRSxjQUFjLEVBQUUsT0FBTyxDQUFDLENBQUM7Z0JBQ2pGLEtBQUksQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLGNBQWMsQ0FBQyxDQUFDO1lBQ3RDLENBQUMsQ0FBQyxDQUFDO1lBQ0gsY0FBYyxDQUFDLGNBQWMsRUFBRSxDQUFDO1lBQ2hDLElBQUksQ0FBQyxlQUFlLENBQUMsWUFBWSxDQUFDLEdBQUcsY0FBYyxDQUFDO1FBQ3hELENBQUM7UUFDRCxpQ0FBWSxHQUFaLFVBQWEsRUFBa0I7WUFDM0IsSUFBTSxLQUFLLEdBQTZCLEVBQUUsQ0FBQyxNQUFNLENBQUM7WUFDbEQsSUFBTSxNQUFNLEdBQWlDLEVBQUcsQ0FBQyxNQUFNLENBQUM7WUFDeEQsSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLEVBQUUsTUFBTSxDQUFDLENBQUM7UUFDakMsQ0FBQztRQUNELG1DQUFjLEdBQWQsVUFBZSxFQUFrQjtZQUM3QixJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sRUFBRSxDQUFDO1FBQzNCLENBQUM7UUFFRCxtQ0FBYyxHQUFkLFVBQWUsQ0FBTyxFQUFFLE9BQWdCO1lBQ3BDLElBQUksQ0FBQyxRQUFRLENBQUMsY0FBYyxDQUFDLENBQUMsRUFBRSxPQUFPLENBQUMsQ0FBQztRQUM3QyxDQUFDO1FBRUQsMkNBQXNCLEdBQXRCLFVBQXVCLE1BQVcsRUFBRSxLQUFtQjtZQUNuRCxPQUFPLENBQUMsSUFBSSxDQUFDLHdCQUF3QixFQUFFLE1BQU0sRUFBRSxLQUFLLENBQUMsQ0FBQztZQUN0RCxJQUFNLElBQUksR0FBRyxJQUFJLENBQUM7WUFDbEIsSUFBTSxDQUFDLEdBQVM7Z0JBQ1osTUFBTSxFQUFFO29CQUNKLE9BQU8sQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLElBQUksQ0FBQyxDQUFDO29CQUM3QixJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRTt3QkFDWCxJQUFNLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxHQUFHLEdBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO3dCQUNyRCxDQUFDLENBQUMsU0FBUyxHQUFHLFdBQVcsQ0FBQzt3QkFDMUIsSUFBSSxLQUFLLENBQUMsZ0JBQWdCLENBQUMsS0FBSyxFQUFFOzRCQUM5Qiw0QkFBaUIsRUFBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLGlCQUFpQixFQUFFO2dDQUM1QyxTQUFTLEVBQUUsS0FBSyxDQUFDLGdCQUFnQixDQUFDLEtBQUs7NkJBQzFDLENBQUMsQ0FBQzt5QkFDTjt3QkFDRCxJQUFJLEtBQUssQ0FBQyxTQUFTLEVBQUU7NEJBQ2pCLElBQU0sS0FBRyxHQUFHLEtBQUssQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLEtBQUssS0FBSyxDQUFDLENBQUMsQ0FBQyxrR0FBa0csQ0FBQyxDQUFDLENBQUMsbUZBQW1GLENBQUM7NEJBQzdPLDRCQUFpQixFQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsaUJBQWlCLEVBQUU7Z0NBQzVDLFNBQVMsRUFBRSxLQUFHOzZCQUNqQixDQUFDLENBQUM7eUJBQ047d0JBQ0QsSUFBTSxVQUFVLEdBQUcsS0FBSyxDQUFDLGdCQUFnQixDQUFDO3dCQUMxQyxJQUFJLFVBQVUsQ0FBQyxRQUFRLEVBQUU7NEJBQ3JCLDRCQUFpQixFQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsb0JBQW9CLEVBQUU7Z0NBQy9DLFNBQVMsRUFBRSxlQUFlOzZCQUM3QixDQUFDLENBQUM7NEJBQ0gsNEJBQWlCLEVBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxnQkFBZ0IsRUFBRTtnQ0FDM0MsU0FBUyxFQUFFLFVBQVUsQ0FBQyxRQUFROzZCQUNqQyxDQUFDLENBQUM7eUJBQ047d0JBQ0QsSUFBSSxVQUFVLENBQUMsbUJBQW1CLEVBQUU7NEJBQ2hDLDRCQUFpQixFQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsb0JBQW9CLEVBQUU7Z0NBQy9DLFNBQVMsRUFBRSxTQUFTOzZCQUN2QixDQUFDLENBQUM7NEJBQ0gsNEJBQWlCLEVBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxnQkFBZ0IsRUFBRTtnQ0FDM0MsU0FBUyxFQUFFLFVBQVUsQ0FBQyxtQkFBbUI7NkJBQzVDLENBQUMsQ0FBQzt5QkFDTjt3QkFDRCxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxLQUFLLEdBQUcsYUFBYSxDQUFDLE1BQU0sRUFBRSxDQUFDLEdBQUcsS0FBSyxFQUFFLENBQUMsRUFBRSxFQUFFOzRCQUMxRCxJQUFNLGFBQWEsR0FBRyxhQUFhLENBQUMsQ0FBQyxDQUFDLENBQUM7NEJBQ3ZDLElBQUksVUFBVSxDQUFDLGFBQWEsQ0FBQyxRQUFRLENBQUMsRUFBRTtnQ0FDcEMsSUFBTSxDQUFDLEdBQUcsNEJBQWlCLEVBQUMsR0FBRyxFQUFFLENBQUMsRUFBRSxlQUFlLENBQUMsQ0FBQztnQ0FDckQsNEJBQWlCLEVBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxvQkFBb0IsRUFBRTtvQ0FDL0MsU0FBUyxFQUFFLGFBQWEsQ0FBQyxTQUFTO2lDQUNyQyxDQUFDLENBQUM7Z0NBQ0gsNEJBQWlCLEVBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSx1QkFBdUIsRUFBRTtvQ0FDbEQsU0FBUyxFQUFFLFVBQVUsQ0FBQyxhQUFhLENBQUMsUUFBUSxDQUFDO2lDQUNoRCxDQUFDLENBQUM7NkJBQ047eUJBQ0o7d0JBRUQsSUFBSSxHQUFHLFNBQVEsQ0FBQzt3QkFDaEIsSUFBSSxDQUFDLFNBQTJCLENBQUM7d0JBQ2pDLElBQU0sRUFBRSxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUM7d0JBQ3hCLElBQUksS0FBSyxDQUFDLFVBQVUsRUFBRTs0QkFDbEIsR0FBRyxHQUFHLFlBQVksQ0FBQzs0QkFDbkIsQ0FBQyxHQUFHLFVBQUMsR0FBRztnQ0FDSixLQUFLLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxDQUFDO2dDQUN6QiwrRkFBK0Y7Z0NBQy9GLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxFQUFFLENBQUM7NEJBQzNCLENBQUMsQ0FBQzt5QkFDTDs2QkFBTTs0QkFDSCxHQUFHLEdBQUcsWUFBWSxDQUFDOzRCQUNuQixDQUFDLEdBQUcsVUFBQyxHQUFHO2dDQUNKLEtBQUssQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUM7Z0NBQ3hCLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxFQUFFLENBQUM7Z0NBQ3ZCLG9GQUFvRjs0QkFDeEYsQ0FBQyxDQUFDO3lCQUNMO3dCQUNELElBQU0sT0FBTyxHQUFHLDRCQUFpQixFQUFDLEtBQUssRUFBRSxDQUFDLENBQUMsQ0FBQzt3QkFDNUMsSUFBTSxJQUFJLEdBQUcsNEJBQWlCLEVBQUMsUUFBUSxFQUFFLE9BQU8sQ0FBQyxDQUFDO3dCQUNsRCxJQUFJLENBQUMsZ0JBQWdCLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQyxDQUFDO3dCQUNsQyxJQUFJLENBQUMsU0FBUyxHQUFHLEdBQUcsQ0FBQztxQkFDeEI7b0JBQ0QsT0FBTyxJQUFJLENBQUMsR0FBRyxDQUFDO2dCQUNwQixDQUFDO2FBQ0osQ0FBQztZQUNGLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDckIsQ0FBQztRQUVELGlDQUFZLEdBQVosVUFBYSxNQUFtQixFQUFFLElBQVU7O1lBQ3hDLE9BQU8sQ0FBQyxJQUFJLENBQUMsY0FBYyxFQUFFLE1BQU0sRUFBRSxJQUFJLENBQUMsQ0FBQztZQUMzQyxJQUFJLElBQUksSUFBSSxJQUFJLFlBQVksMkJBQVUsRUFBRTtnQkFDcEMsSUFBSSxVQUFJLENBQUMsS0FBSywwQ0FBRSxlQUFlLEVBQUU7b0JBQzdCLElBQUksQ0FBQyxLQUFLLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsS0FBSyxDQUFDLENBQUM7b0JBQy9DLElBQUksSUFBSSxDQUFDLFlBQVksSUFBSSxJQUFJLENBQUMsWUFBWSxDQUFDLE9BQU8sS0FBSyxJQUFJLENBQUMsTUFBTSxFQUFFO3dCQUNoRSxJQUFJLENBQUMsWUFBWSxHQUFHLFNBQVMsQ0FBQztxQkFDakM7aUJBQ0o7YUFDSjtZQUNELElBQUksSUFBSSxDQUFDLFVBQVUsRUFBRTtnQkFDakIsSUFBSSxDQUFDLEdBQUcsQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO2dCQUN0QyxJQUFJLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsa0JBQWtCLENBQUMsQ0FBQzthQUNoRDtZQUNELElBQUksSUFBSSxDQUFDLGNBQWMsRUFBRTtnQkFDckIsUUFBUSxDQUFDLGNBQWMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLG1CQUFtQixDQUFDLENBQUM7YUFDdEU7UUFDTCxDQUFDO1FBRUQsc0NBQWlCLEdBQWpCLFVBQWtCLE1BQVcsRUFBRSxHQUFzQjtZQUNqRCxPQUFPLENBQUMsSUFBSSxDQUFDLG1CQUFtQixFQUFFLEdBQUcsQ0FBQyxDQUFDO1lBQ3ZDLElBQU0sS0FBSyxHQUFHLEdBQUcsQ0FBQyxjQUFjLENBQUM7WUFDakMsSUFBTSxRQUFRLEdBQUcsR0FBRyxDQUFDLE1BQU0sQ0FBQztZQUM1QixJQUFJLFdBQVcsR0FBRyxJQUFJLENBQUM7WUFDdkIsSUFBSSxJQUFJLENBQUMsWUFBWSxFQUFFO2dCQUNuQixXQUFXLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxPQUFPLEtBQUssS0FBSyxDQUFDO2dCQUNsRCxJQUFJLFFBQVEsQ0FBQyxRQUFRLEVBQUU7b0JBQ25CLElBQUksQ0FBQyxZQUFZLENBQUMsWUFBWSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLE9BQU8sRUFBRSxLQUFLLENBQUMsQ0FBQztpQkFDcEY7cUJBQU07b0JBQ0gsSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLEVBQUUsQ0FBQztpQkFDMUI7YUFDSjtZQUNELElBQUksV0FBVyxFQUFFO2dCQUNiLFFBQVEsQ0FBQyxlQUFlLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxDQUFDO2dCQUN0QyxJQUFJLFFBQVEsQ0FBQyxRQUFRLEVBQUU7b0JBQ25CLElBQU0sQ0FBQyxHQUFHLFFBQVEsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxVQUFVLENBQUMsQ0FBQztvQkFDdEQsSUFBTSxLQUFLLEdBQUcsQ0FBQyxDQUFDLEtBQUssRUFBRSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUM7b0JBQ2xGLEtBQUssQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLFVBQUMsR0FBRzt3QkFDckIsUUFBUSxDQUFDLGVBQWUsQ0FBQyxLQUFLLEVBQUUsS0FBSyxDQUFDLENBQUM7b0JBQzNDLENBQUMsQ0FBQyxDQUFDO2lCQUNOO3FCQUFNO29CQUNILElBQUksQ0FBQyxRQUFRLENBQUMsUUFBUSxFQUFFLEtBQUssQ0FBQyxDQUFDO2lCQUNsQztnQkFDRCxJQUFJLENBQUMsWUFBWSxHQUFHLEVBQUUsWUFBWSxFQUFFLFFBQVEsRUFBRSxPQUFPLEVBQUUsS0FBSyxFQUFFLENBQUM7YUFDbEU7UUFDTCxDQUFDO1FBRUQseUNBQW9CLEdBQXBCLFVBQXFCLE1BQW9CLEVBQUUsVUFBbUI7WUFDMUQsT0FBTyxDQUFDLElBQUksQ0FBQyxzQkFBc0IsRUFBRSxNQUFNLEVBQUUsVUFBVSxDQUFDLENBQUM7WUFDekQsSUFBSSxJQUFJLENBQUMsU0FBUyxFQUFFO2dCQUNoQixJQUFJLElBQUksQ0FBQyxTQUFTLEtBQUssVUFBVSxFQUFFO29CQUMvQixPQUFPO2lCQUNWO2dCQUNELElBQUksQ0FBQyxTQUFTLENBQUMsTUFBTSxFQUFFLENBQUM7YUFDM0I7WUFDRCxJQUFJLElBQUksQ0FBQyxHQUFHLEVBQUU7Z0JBQ1YsT0FBTyxDQUFDLElBQUksQ0FBQyxzQkFBc0IsRUFBRSxVQUFVLENBQUMsQ0FBQztnQkFDakQsT0FBTyxDQUFDLElBQUksQ0FBQyxpQkFBaUIsRUFBRSxVQUFVLENBQUMsQ0FBQztnQkFDdEMsVUFBVyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDL0IsSUFBSSxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsVUFBVSxDQUFDLENBQUM7Z0JBQzlCLE9BQU8sQ0FBQyxJQUFJLENBQUMsYUFBYSxFQUFFLFVBQVUsQ0FBQyxDQUFDO2dCQUN4QyxJQUFJLENBQUMsU0FBUyxHQUFHLFVBQVUsQ0FBQzthQUMvQjtpQkFBTTtnQkFDSCxPQUFPLENBQUMsSUFBSSxDQUFDLDRCQUE0QixDQUFDLENBQUM7YUFDOUM7UUFDTCxDQUFDO1FBRUQsb0NBQWUsR0FBZixVQUFnQixFQUFnQjtZQUM1QixPQUFPLENBQUMsSUFBSSxDQUFDLDRCQUE0QixDQUFDLENBQUM7WUFDM0MsSUFBSSxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQzVCLEVBQUUsQ0FBQyxHQUFHLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQyxNQUFNLENBQUM7WUFDcEMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7WUFDN0IscUJBQWEsQ0FBQyxZQUFZLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRTtnQkFDdEMsSUFBSSxFQUFFLGNBQWM7Z0JBQ3BCLEtBQUssRUFBRSxFQUFFO2FBQ1osQ0FBQyxDQUFDO1lBQ0gseUJBQXlCO1FBQzdCLENBQUM7UUFFRCxpQ0FBWSxHQUFaLFVBQWEsTUFBbUIsRUFBRSxHQUFlO1lBQzdDLE9BQU8sQ0FBQyxJQUFJLENBQUMseUJBQXlCLENBQUMsQ0FBQztZQUN4QyxJQUFJLEdBQUcsQ0FBQyxLQUFLLENBQUMsVUFBVSxFQUFFO2dCQUN0QixJQUFJLENBQUMsZUFBZSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQzthQUNuQztRQUNMLENBQUM7UUFFRCx1Q0FBa0IsR0FBbEIsVUFBbUIsRUFBZ0I7WUFDL0IsSUFBSSxDQUFDLEdBQUcsQ0FBQyxXQUFXLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQy9CLHFCQUFhLENBQUMsY0FBYyxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUU7Z0JBQ3hDLElBQUksRUFBRSxrQkFBa0I7Z0JBQ3hCLEtBQUssRUFBRSxFQUFFO2FBQ1osQ0FBQyxDQUFDO1lBQ0gsSUFBTSxHQUFHLEdBQW1CLEVBQUUsQ0FBQztZQUMvQixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7Z0JBQ2pELElBQUksRUFBRSxLQUFLLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDLEVBQUU7b0JBQy9CLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQyxNQUFNLENBQUM7b0JBQ3hDLEdBQUcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO2lCQUNwQzthQUNKO1lBQ0QsRUFBRSxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQztZQUNaLElBQUksQ0FBQyxjQUFjLEdBQUcsR0FBRyxDQUFDO1lBQzFCLHlCQUF5QjtRQUM3QixDQUFDO1FBRUQscUJBQXFCO1FBQ3JCLHVDQUF1QztRQUN2QyxtQ0FBbUM7UUFDbkMsOEJBQThCO1FBQzlCLFNBQVM7UUFDVCx3Q0FBd0M7UUFDeEMsNENBQTRDO1FBQzVDLDhCQUE4QjtRQUM5QixTQUFTO1FBQ1QsSUFBSTtRQUVKLDBDQUFxQixHQUFyQixVQUFzQixNQUFvQixFQUFFLEdBQWU7WUFDdkQsK0NBQStDO1lBQy9DLElBQUksSUFBSSxDQUFDLEdBQUcsRUFBRTtnQkFDVixJQUFJLEdBQUcsQ0FBQyxLQUFLLENBQUMsVUFBVSxFQUFFO29CQUN0QixJQUFJO3dCQUNBLElBQUksR0FBRyxDQUFDLEtBQUssSUFBSSxHQUFHLENBQUMsS0FBSyxDQUFDLEtBQUssRUFBRTs0QkFDOUIsSUFBSSxDQUFDLGVBQWUsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUM7eUJBQ25DOzZCQUFNOzRCQUNILHFCQUFhLENBQUMsY0FBYyxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUU7Z0NBQ3hDLElBQUksRUFBRSxlQUFlO2dDQUNyQixLQUFLLEVBQUUsR0FBRyxDQUFDLEtBQUs7NkJBQ25CLENBQUMsQ0FBQzt5QkFDTjtxQkFDSjtvQkFBQyxPQUFPLEVBQUUsRUFBRTt3QkFDVCxPQUFPLENBQUMsSUFBSSxDQUFDLCtCQUF1QixHQUFHLENBQUMsS0FBSyxDQUFDLGdCQUFnQixDQUFDLEtBQUssT0FBRyxFQUFFLEVBQUUsQ0FBQyxDQUFDO3FCQUNoRjtpQkFDSjtxQkFBTTtvQkFDSCxJQUFJLEdBQUcsQ0FBQyxLQUFLLENBQUMsS0FBSyxFQUFFO3dCQUNqQixJQUFJLENBQUMsa0JBQWtCLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDO3FCQUN0QztpQkFDSjthQUNKO1FBQ0wsQ0FBQztRQUVELDZCQUFRLEdBQVIsVUFBUyxJQUFVOztZQUNmLElBQUksSUFBSSxDQUFDLFVBQVUsRUFBRTtnQkFDakIsT0FBTyxDQUFDLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO2dCQUNqQyxJQUFJLENBQUMsa0JBQWtCLENBQUMsTUFBTSxFQUFFLENBQUM7Z0JBQ2pDLElBQUksQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQzthQUN0QztpQkFBTTtnQkFDSCxJQUFJLENBQUMsU0FBUyxFQUFFLENBQUM7YUFDcEI7WUFDRCxJQUFJLENBQUMsUUFBUSxDQUFDLGNBQWMsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUM7WUFDekMsSUFBSSxjQUFRLENBQUMsY0FBYyxDQUFDLE1BQU0sQ0FBQywwQ0FBRSxTQUFTLENBQUMsUUFBUSxDQUFDLG1CQUFtQixDQUFDLEVBQUU7Z0JBQzFFLFFBQVEsQ0FBQyxjQUFjLENBQUMsTUFBTSxDQUFDLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO2dCQUN0RSxJQUFJLENBQUMsY0FBYyxHQUFHLElBQUksQ0FBQzthQUM5QjtpQkFBTTtnQkFDSCxJQUFJLENBQUMsY0FBYyxHQUFHLEtBQUssQ0FBQzthQUMvQjtRQUNMLENBQUM7UUFFRCw2QkFBUSxHQUFSLFVBQVMsS0FBOEMsRUFBRSxNQUFvQztZQUN6RixJQUFJLEtBQUssYUFBTCxLQUFLLHVCQUFMLEtBQUssQ0FBRSxVQUFVLEVBQUU7Z0JBQ25CLElBQUksQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO2FBQzNDO2lCQUFNO2dCQUNILElBQUksTUFBTSxhQUFOLE1BQU0sdUJBQU4sTUFBTSxDQUFFLE9BQU8sRUFBRTtvQkFDakIsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLDJCQUFVLENBQUMsS0FBSyxFQUFFLE1BQU0sQ0FBQyxDQUFDLENBQUM7aUJBQ2hEO3FCQUFNO29CQUNILE9BQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLE1BQU0sQ0FBQyxDQUFDO2lCQUMvQjthQUNKO1FBQ0wsQ0FBQztRQUVELDBCQUFLLEdBQUwsVUFBTSxHQUFVO1lBQ1osc0RBQXNEO1lBQ3RELElBQUksSUFBSSxDQUFDLFVBQVUsRUFBRTtnQkFDakIsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDO2dCQUNkLElBQUksQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDO2dCQUNmLElBQU0sU0FBUyxHQUFHLENBQU8sSUFBSyxDQUFDLFVBQVUsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7Z0JBQzdELElBQUksQ0FBQyxVQUFVLENBQUMsV0FBVyxDQUFDLFNBQVMsQ0FBQyxDQUFDO2dCQUN2QyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxRQUFRLEVBQUUsSUFBSSxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsQ0FBQztnQkFDekMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDO2dCQUN4QyxJQUFJLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsa0JBQWtCLENBQUMsQ0FBQztnQkFDN0MsNENBQTRDO2dCQUM1QyxJQUFJLENBQUMsVUFBVSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsdUJBQXVCLENBQUMsQ0FBQztnQkFDMUQsc0RBQXNEO2dCQUN0RCx1REFBdUQ7Z0JBQ3ZELGlEQUFpRDtnQkFDakQsT0FBTyxJQUFJLENBQUM7YUFDZjtpQkFBTTtnQkFDSCwyQkFBMkI7Z0JBQzNCLGlCQUFNLEtBQUssWUFBQyxHQUFHLENBQUMsQ0FBQztnQkFDakIsSUFBSSxDQUFDLFNBQVMsQ0FBQyxLQUFLLEVBQUUsQ0FBQztnQkFDdkIsR0FBRyxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7Z0JBQzlCLE9BQU8sSUFBSSxDQUFDO2FBQ2Y7UUFDTCxDQUFDO1FBRUQsMEJBQUssR0FBTCxVQUFNLEdBQVU7WUFBaEIsaUJBOEZDO1lBN0ZHLE9BQU8sQ0FBQyxJQUFJLENBQUMsbUJBQW1CLENBQUMsQ0FBQztZQUNsQywyQkFBMkI7WUFDM0IsSUFBSSxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUM7WUFDZixJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRTtnQkFDWCxJQUFNLEdBQUcsR0FBRyw0QkFBaUIsRUFBQyxLQUFLLEVBQUUsU0FBUyxFQUFFLFNBQVMsQ0FBQyxDQUFDO2dCQUMzRCxJQUFNLE1BQU0sR0FBRyxDQUFDLElBQUksQ0FBQyxNQUFNLEdBQUcsNEJBQWlCLEVBQUMsS0FBSyxFQUFFLEdBQUcsRUFBRSxvQkFBb0IsQ0FBQyxDQUFDLENBQUM7Z0JBQ25GLElBQU0sU0FBUyxHQUFHLFFBQVEsQ0FBQyxjQUFjLENBQUMsZUFBZSxDQUFDLENBQUM7Z0JBRTNELElBQUksQ0FBQyxJQUFJLENBQUMsVUFBVSxFQUFFO29CQUNsQixJQUFNLE1BQU0sR0FBRyw0QkFBaUIsRUFBQyxHQUFHLEVBQUUsTUFBTSxFQUFFLGFBQWEsQ0FBQyxDQUFDO29CQUM3RCxNQUFNLENBQUMsZ0JBQWdCLENBQUMsV0FBVyxFQUFFLFVBQUMsQ0FBQyxJQUFLLFlBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLEVBQXBCLENBQW9CLENBQUMsQ0FBQztvQkFDbEUsNEJBQWlCLEVBQUMsS0FBSyxFQUFFLE1BQU0sQ0FBQyxDQUFDO29CQUNqQyxJQUFNLGFBQWEsR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxDQUFDO29CQUNwRCxDQUFDLENBQUMsUUFBUSxDQUFDLHVCQUF1QixDQUFDLGFBQWEsQ0FBQyxDQUFDO29CQUNsRCxDQUFDLENBQUMsUUFBUSxDQUFDLHdCQUF3QixDQUFDLGFBQWEsQ0FBQyxDQUFDO29CQUNuRCxhQUFhLENBQUMsU0FBUyxHQUFHLGdCQUFnQixDQUFDO29CQUUzQyxJQUFJLFNBQVMsRUFBRTt3QkFDWCxTQUFTLENBQUMsV0FBVyxDQUFDLGFBQWEsQ0FBQyxDQUFDO3FCQUN4Qzt5QkFBTTt3QkFDSCxNQUFNLENBQUMsV0FBVyxDQUFDLGFBQWEsQ0FBQyxDQUFDO3FCQUNyQztvQkFFRCxJQUFNLFdBQVMsR0FBRyxDQUFDLElBQUksQ0FBQyxTQUFTLEdBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDO29CQUNyRSxhQUFhLENBQUMsV0FBVyxDQUFDLFdBQVMsQ0FBQyxDQUFDO29CQUNyQyxXQUFTLENBQUMsSUFBSSxHQUFHLE1BQU0sQ0FBQztvQkFDeEIsb0VBQW9FO29CQUNwRSxXQUFTLENBQUMsZ0JBQWdCLENBQUMsU0FBUyxFQUFFLFVBQUMsRUFBRSxJQUFLLFlBQUksQ0FBQyxjQUFjLENBQUMsRUFBRSxDQUFDLEVBQXZCLENBQXVCLENBQUMsQ0FBQztvQkFDdkUsV0FBUyxDQUFDLFdBQVcsR0FBRyxPQUFPLENBQUM7b0JBRWhDLElBQU0sY0FBYyxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsR0FBRyxDQUFDLENBQUM7b0JBQ25ELGNBQWMsQ0FBQyxTQUFTLEdBQUcsb0JBQW9CLENBQUM7b0JBQ2hELGFBQWEsQ0FBQyxXQUFXLENBQUMsY0FBYyxDQUFDLENBQUM7b0JBQzFDLGNBQWMsQ0FBQyxnQkFBZ0IsQ0FBQyxPQUFPLEVBQUUsVUFBQyxFQUFFO3dCQUN4QyxXQUFTLENBQUMsS0FBSyxHQUFHLEVBQUUsQ0FBQzt3QkFDckIsS0FBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLEVBQUUsQ0FBQztvQkFDMUIsQ0FBQyxDQUFDLENBQUM7b0JBRUgsOEJBQVksRUFBQyxXQUFTLEVBQUU7d0JBQ3BCLFFBQVEsRUFBRSxVQUFDLElBQVMsRUFBRSxLQUF1QixJQUFLLFlBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxFQUFFLEtBQUssQ0FBQyxFQUF4QixDQUF3Qjt3QkFDMUUsYUFBYSxFQUFFLFVBQUMsS0FBdUIsSUFBSyxZQUFJLENBQUMsWUFBWSxDQUFDLEtBQUssQ0FBQyxFQUF4QixDQUF3Qjt3QkFDcEUsS0FBSyxFQUFFLElBQUksQ0FBQyxTQUFTO3dCQUNyQixTQUFTLEVBQUUsQ0FBQzt3QkFDWixXQUFXLEVBQUUsSUFBSTt3QkFDakIsU0FBUyxFQUFFLE1BQU07cUJBQ3BCLENBQUMsQ0FBQztpQkFDTjtxQkFBTTtvQkFDSCxJQUFNLFVBQVUsR0FBRyxDQUFDLElBQUksQ0FBQyxVQUFVLEdBQUcsSUFBSSwwQkFBYSxDQUFDO3dCQUNwRCxRQUFRLEVBQUUsVUFBQyxJQUFTLEVBQUUsS0FBdUIsSUFBSyxZQUFJLENBQUMsTUFBTSxDQUFDLElBQUksRUFBRSxLQUFLLENBQUMsRUFBeEIsQ0FBd0I7d0JBQzFFLGFBQWEsRUFBRSxVQUFDLEtBQXVCLElBQUssWUFBSSxDQUFDLFlBQVksQ0FBQyxLQUFLLENBQUMsRUFBeEIsQ0FBd0I7d0JBQ3BFLEtBQUssRUFBRSxJQUFJLENBQUMsU0FBUzt3QkFDckIsU0FBUyxFQUFFLENBQUM7d0JBQ1osV0FBVyxFQUFFLElBQUk7d0JBQ2pCLFNBQVMsRUFBRSxNQUFNO3FCQUNwQixDQUFDLENBQUMsQ0FBQztvQkFDSixHQUFHLENBQUMsVUFBVSxDQUFDLFVBQVUsQ0FBQyxDQUFDO29CQUMzQixHQUFHLENBQUMsVUFBVSxDQUNWLElBQUksMkJBQWMsQ0FBQzt3QkFDZixRQUFRLEVBQUUsVUFBVTt3QkFDcEIsU0FBUyxFQUFFLFdBQVc7d0JBQ3RCLE1BQU0sRUFBRSxVQUFDLElBQUk7NEJBQ1QsS0FBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQzt3QkFDeEIsQ0FBQztxQkFDSixDQUFDLENBQ0wsQ0FBQztvQkFDRixHQUFHLENBQUMsVUFBVSxDQUNWLElBQUksK0JBQWtCLENBQUM7d0JBQ25CLFFBQVEsRUFBRSxVQUFVO3FCQUN2QixDQUFDLENBQ0wsQ0FBQztpQkFDTDtnQkFFRCxDQUFDLENBQUMsUUFBUSxDQUFDLHVCQUF1QixDQUFDLEdBQUcsQ0FBQyxDQUFDO2dCQUN4QyxDQUFDLENBQUMsUUFBUSxDQUFDLHdCQUF3QixDQUFDLEdBQUcsQ0FBQyxDQUFDO2dCQUV6QyxJQUFJLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQztnQkFFZixJQUFJLElBQUksQ0FBQyxVQUFVLEVBQUU7b0JBQ2pCLElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSx5QkFBVyxDQUFDLEVBQUUsVUFBVSxFQUFFLElBQUksQ0FBQyx1QkFBdUIsRUFBRSxDQUFDLENBQUM7aUJBQ2pGO3FCQUFNO29CQUNILElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSx5QkFBVyxDQUFDLEVBQUUsUUFBUSxFQUFFLFNBQVMsRUFBRSxDQUFDLENBQUM7aUJBQzVEO2FBQ0o7WUFFRCxJQUFNLGFBQWEsR0FBRyxDQUFDLElBQUksQ0FBQyxhQUFhLEdBQUcsTUFBTSxHQUFHLEdBQUcsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDO1lBQ3BFLElBQUksQ0FBQyxVQUFVLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxhQUFhLENBQUMsQ0FBQztZQUM3QyxHQUFHLENBQUMsZ0JBQWdCLENBQUMsU0FBUyxFQUFFLFVBQUMsRUFBRTtnQkFDL0IsS0FBSSxDQUFDLFVBQVUsQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLEtBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQztnQkFDckQsSUFBTSxhQUFhLEdBQUcsQ0FBQyxLQUFJLENBQUMsYUFBYSxHQUFHLE1BQU0sR0FBRyxHQUFHLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQztnQkFDcEUsS0FBSSxDQUFDLFVBQVUsQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLGFBQWEsQ0FBQyxDQUFDO1lBQ2pELENBQUMsQ0FBQyxDQUFDO1lBRUgsT0FBTyxJQUFJLENBQUMsR0FBRyxDQUFDO1FBQ3BCLENBQUM7UUFDRCw2QkFBUSxHQUFSLFVBQVMsSUFBZTtZQUNwQixPQUFPLENBQUMsSUFBSSxDQUFDLFVBQVUsRUFBRSxJQUFJLENBQUMsQ0FBQztZQUMvQixRQUFRLENBQUMsY0FBYyxDQUFDLGNBQWMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxPQUFPLEdBQUcsRUFBRSxDQUFDO1lBQzNELElBQUksSUFBSSxDQUFDLGtCQUFrQixZQUFZLGlDQUFlLEVBQUU7Z0JBQ3BELElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxXQUFXLEVBQUUsQ0FBQzthQUN6QztZQUNELElBQUksQ0FBQyxVQUFVLENBQUMsWUFBWSxFQUFFLENBQUM7WUFDL0IsSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLEVBQUUsQ0FBQztZQUN0QixJQUFJLElBQUksQ0FBQyxRQUFRLEVBQUU7Z0JBQ2YsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDO2FBQ25CO1lBQ0QsSUFBSSxDQUFDLGFBQWEsQ0FBQyxlQUFlLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDMUMsQ0FBQztRQUVPLGlDQUFZLEdBQXBCLFVBQXFCLEtBQXVCO1lBQ3hDLE9BQU8sQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUM7WUFDN0IsSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDO1FBQ3hCLENBQUM7UUFDRCxpQ0FBWSxHQUFaO1lBQ0ksT0FBTyxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQztZQUM3QixJQUFJLENBQUMsUUFBUSxDQUFDLEtBQUssRUFBRSxDQUFDO1lBQ3RCLElBQUksSUFBSSxDQUFDLGtCQUFrQixDQUFDLGVBQWUsQ0FBQyxZQUFZLENBQUMsRUFBRTtnQkFDdkQsSUFBSSxDQUFDLGtCQUFrQixDQUFDLGVBQWUsQ0FBQyxZQUFZLENBQUMsQ0FBQyxtQkFBbUIsRUFBRSxDQUFDO2FBQy9FO1lBQ0QsSUFBSSxJQUFJLENBQUMsU0FBUyxFQUFFO2dCQUNoQixJQUFJLENBQUMsU0FBUyxDQUFDLE1BQU0sRUFBRSxDQUFDO2dCQUN4QixJQUFJLENBQUMsU0FBUyxHQUFHLFNBQVMsQ0FBQzthQUM5QjtRQUNMLENBQUM7UUFFRCxVQUFVO1FBQ0YsMkJBQU0sR0FBZCxVQUFlLElBQVMsRUFBRSxLQUF1QjtZQUM3QywyQkFBMkI7WUFFM0IsSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDO1lBRXBCLElBQUksQ0FBQyxTQUFTLEVBQUUsQ0FBQztZQUNqQixJQUFJLEtBQUksYUFBSixJQUFJLHVCQUFKLElBQUksQ0FBRSxLQUFLLE1BQUssT0FBTyxFQUFFO2dCQUN6QixxQkFBYSxDQUFDLHNCQUFzQixDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO2FBQ25FO2lCQUFNLElBQUksSUFBSSxFQUFFO2dCQUNiLElBQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUM7Z0JBQ3BDLE9BQU8sQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLElBQUksQ0FBQyxDQUFDO2FBQy9CO1lBRUQsa0NBQWtDO1lBQ2xDLG1DQUFtQztZQUNuQywyQ0FBMkM7WUFDM0MsK0NBQStDO1lBQy9DLDJFQUEyRTtZQUMzRSxtQkFBbUI7WUFDbkIsMERBQTBEO1lBQzFELHdCQUF3QjtZQUN4Qiw0Q0FBNEM7WUFDNUMsWUFBWTtZQUNaLFFBQVE7WUFDUixXQUFXO1lBQ1gsNkNBQTZDO1lBQzdDLG1DQUFtQztZQUNuQywwRUFBMEU7WUFDMUUsa0RBQWtEO1lBQ2xELHFCQUFxQjtZQUNyQixvRUFBb0U7WUFDcEUseUNBQXlDO1lBQ3pDLFlBQVk7WUFDWixTQUFTO1lBQ1QsSUFBSTtRQUNSLENBQUM7UUFFRCxnQ0FBVyxHQUFYLFVBQVksSUFBUztZQUNqQixPQUFPLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDO1lBQzVCLElBQU0sSUFBSSxHQUFHLENBQUMsSUFBSSxDQUFDLFNBQVMsR0FBRyxDQUFDLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsUUFBUSxFQUFFO2dCQUM1RCxLQUFLLEVBQUUsVUFBVSxPQUFPO29CQUNwQixPQUFPLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxTQUFTLEVBQUUsTUFBTSxFQUFFLFNBQVMsRUFBRSxNQUFNLEVBQUUsQ0FBQztnQkFDbkUsQ0FBQzthQUNKLENBQUMsQ0FBQyxDQUFDO1lBQ0osSUFBSSxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUM7WUFDeEIsSUFBSSxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxDQUFDLENBQUM7WUFDckMsT0FBTyxJQUFJLENBQUM7UUFDaEIsQ0FBQztRQUVPLG1DQUFjLEdBQXRCLFVBQXVCLEVBQWM7WUFDakMsT0FBTyxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsRUFBRSxFQUFFLENBQUMsQ0FBQztRQUN2QyxDQUFDO1FBRU8saUNBQVksR0FBcEIsVUFBcUIsQ0FBZTtZQUNoQyxPQUFPLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDO1lBQzdCLElBQUksSUFBSSxDQUFDLE1BQU0sRUFBRTtnQkFDYixJQUFJLENBQUMsUUFBUSxFQUFFLENBQUM7YUFDbkI7aUJBQU07Z0JBQ0gsSUFBSSxDQUFDLFNBQVMsRUFBRSxDQUFDO2FBQ3BCO1FBQ0wsQ0FBQztRQUVELDhCQUFTLEdBQVQ7WUFDSSxJQUFJLElBQUksQ0FBQyxVQUFVLEVBQUU7Z0JBQ2pCLElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDO2dCQUNuQixJQUFJLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUMsUUFBUSxFQUFFLFFBQVEsQ0FBQyxDQUFDO2dCQUNsRCxJQUFJLENBQUMsR0FBRyxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUM7Z0JBQzNDLElBQUksQ0FBQyxHQUFHLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO2dCQUNoRCx1Q0FBdUM7Z0JBQ3ZDLElBQUksQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztnQkFDbkMsSUFBSSxDQUFDLFVBQVUsR0FBRyxLQUFLLENBQUM7YUFDM0I7UUFDTCxDQUFDO1FBQ0QsNkJBQVEsR0FBUjtZQUNJLElBQUksQ0FBQyxJQUFJLENBQUMsVUFBVSxFQUFFO2dCQUNsQixJQUFJLENBQUMsTUFBTSxHQUFHLEtBQUssQ0FBQztnQkFDcEIsSUFBSSxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsT0FBTyxDQUFDLFFBQVEsRUFBRSxRQUFRLENBQUMsQ0FBQztnQkFDbEQsSUFBSSxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDO2dCQUN4QyxJQUFJLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsa0JBQWtCLENBQUMsQ0FBQztnQkFDN0MsMkNBQTJDO2dCQUMzQyxJQUFJLENBQUMsR0FBRyxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7Z0JBQ3RDLElBQUksQ0FBQyxVQUFVLEdBQUcsSUFBSSxDQUFDO2FBQzFCO1FBQ0wsQ0FBQztRQUVELDZCQUFRLEdBQVIsVUFBUyxHQUFVO1lBQ2YsT0FBTyxDQUFDLElBQUksQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDO1lBQ3JDLElBQUksQ0FBQyxHQUFHLEdBQUcsSUFBSSxDQUFDO1FBQ3BCLENBQUM7UUFFRCxrQ0FBYSxHQUFiLFVBQWMsVUFBOEIsRUFBRSxPQUFtQztZQUM3RSxJQUFJLENBQUMsYUFBYSxDQUFDLGFBQWEsQ0FBQyxVQUFVLEVBQUUsT0FBTyxDQUFDLENBQUM7UUFDMUQsQ0FBQztRQUNMLGlCQUFDO0lBQUQsQ0FBQyxDQXJrQitCLENBQUMsQ0FBQyxPQUFPLEdBcWtCeEM7SUFya0JZLGdDQUFVOzs7Ozs7Ozs7Ozs7Ozs7OztJQ2xHdkIsU0FBUyxZQUFZLENBQUMsQ0FBUztRQUMzQixJQUFJLE1BQU0sR0FBRyxFQUFFLENBQUM7UUFDaEIsSUFBSSxDQUFDLEVBQUU7WUFDSCxJQUFJLENBQUMsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUMsTUFBTSxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7Z0JBQ3hELGlDQUFpQztnQkFDakMsd0VBQXdFO2dCQUN4RSxxRUFBcUU7Z0JBQ3JFLGdDQUFnQztnQkFDaEMsTUFBTSxHQUFHLENBQUMsQ0FBQzthQUNkO2lCQUFNO2dCQUNILElBQU0sRUFBRSxHQUFHLENBQUMsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUM7Z0JBQzVCLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEtBQUssR0FBRyxFQUFFLENBQUMsTUFBTSxFQUFFLENBQUMsR0FBRyxLQUFLLEVBQUUsQ0FBQyxFQUFFLEVBQUU7b0JBQy9DLElBQU0sSUFBSSxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztvQkFDbkIsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFO3dCQUNQLE1BQU0sSUFBSSxHQUFHLENBQUM7cUJBQ2pCO29CQUNELElBQUksSUFBSSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLEVBQUU7d0JBQzVCLE1BQU0sSUFBSSxXQUFXLENBQUM7d0JBQ3RCLE1BQU0sSUFBSSxJQUFJLENBQUM7d0JBQ2YsTUFBTSxJQUFJLElBQUksQ0FBQzt3QkFDZixNQUFNLElBQUksSUFBSSxDQUFDO3dCQUNmLE1BQU0sSUFBSSxNQUFNLENBQUM7cUJBQ3BCO3lCQUFNO3dCQUNILE1BQU0sSUFBSSxJQUFJLENBQUM7cUJBQ2xCO2lCQUNKO2FBQ0o7U0FDSjtRQUNELE9BQU8sTUFBTSxDQUFDO0lBQ2xCLENBQUM7SUFPRDtRQU1JLG9CQUFZLEtBQXVCLEVBQUUsTUFBOEI7WUFDL0QsT0FBTyxDQUFDLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO1lBQ2xDLElBQUksQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDO1lBQ25CLElBQUksQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDO1FBQ3pCLENBQUM7UUFFRCw2QkFBUSxHQUFSOztZQUNJLE9BQU8sVUFBSSxDQUFDLEtBQUssQ0FBQyxrQkFBa0IsQ0FBQywwQ0FBRSxLQUFLLENBQUM7UUFDakQsQ0FBQztRQUVELDJCQUFNLEdBQU47O1lBQ0ksSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUU7Z0JBQ1gsSUFBSSxVQUFJLENBQUMsS0FBSywwQ0FBRSxZQUFZLEVBQUU7b0JBQzFCLElBQUksQ0FBQyxHQUFHLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxZQUFZLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO2lCQUM5RTtxQkFBTTtvQkFDSCxJQUFJLENBQUMsR0FBRyxHQUFHLElBQUksQ0FBQyxjQUFjLEVBQUUsQ0FBQztpQkFDcEM7YUFDSjtZQUNELE9BQU8sSUFBSSxDQUFDLEdBQUcsQ0FBQztRQUNwQixDQUFDO1FBRUQsbUNBQWMsR0FBZDs7WUFDSSxPQUFPLENBQUMsSUFBSSxDQUFDLGdCQUFnQixFQUFFLElBQUksQ0FBQyxDQUFDO1lBQ3JDLElBQU0sR0FBRyxHQUFHLDRCQUFpQixFQUFDLEtBQUssRUFBRSxTQUFTLEVBQUUsV0FBVyxDQUFDLENBQUM7WUFDN0QsNEJBQWlCLEVBQUMsSUFBSSxFQUFFLEdBQUcsRUFBRSxnQkFBZ0IsRUFBRTtnQkFDM0MsU0FBUyxFQUFFLFVBQUksQ0FBQyxLQUFLLENBQUMsa0JBQWtCLENBQUMsMENBQUUsS0FBSzthQUNuRCxDQUFDLENBQUM7WUFDSCxPQUFPLENBQUMsSUFBSSxDQUFDLFVBQUksQ0FBQyxLQUFLLENBQUMsa0JBQWtCLENBQUMsMENBQUUsS0FBSyxDQUFDLENBQUM7WUFDcEQsaURBQWlEO1lBRWpELElBQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsWUFBTSxJQUFJLENBQUMsTUFBTywwQ0FBRSxPQUFPLDBDQUFFLFVBQVUsQ0FBQztZQUUzRixJQUFNLFFBQVEsR0FBcUIsSUFBSSxDQUFDLEtBQUssQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO1lBQ2xFLElBQUksUUFBUSxhQUFSLFFBQVEsdUJBQVIsUUFBUSxDQUFFLGVBQWUsRUFBRTtnQkFDM0IsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO2dCQUNWLEtBQUssSUFBSSxDQUFDLElBQUksUUFBUSxDQUFDLGVBQWUsRUFBRTtvQkFDcEMsSUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO29CQUNoQixJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyx3QkFBd0IsRUFBRTt3QkFDekMsSUFBTSxDQUFDLEdBQUcsNEJBQWlCLEVBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxjQUFjLENBQUMsQ0FBQzt3QkFDdEQsNEJBQWlCLEVBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxtQkFBbUIsRUFBRTs0QkFDOUMsU0FBUyxFQUFFLFFBQVEsQ0FBQyxlQUFlLENBQUMsQ0FBQyxDQUFDO3lCQUN6QyxDQUFDLENBQUM7d0JBRUgsSUFBSSxPQUFPLENBQUMsS0FBSyxRQUFRLElBQUksQ0FBQyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUU7NEJBQ2pELENBQUMsR0FBRyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUM7eUJBQ3ZCO3dCQUNELDRCQUFpQixFQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsc0JBQXNCLEVBQUU7NEJBQ2pELFNBQVMsRUFBRSxDQUFDO3lCQUNmLENBQUMsQ0FBQzt3QkFDSCxDQUFDLEVBQUUsQ0FBQzt3QkFDSixvREFBb0Q7cUJBQ3ZEO2lCQUNKO2dCQUNELElBQUksQ0FBQyxLQUFLLENBQUMsRUFBRTtvQkFDVCw0QkFBaUIsRUFBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLG1CQUFtQixFQUFFO3dCQUM3QyxTQUFTLEVBQUUscUNBQXFDO3FCQUNuRCxDQUFDLENBQUM7aUJBQ047Z0JBQ0Qsd0NBQXdDO2dCQUN4QyxrREFBa0Q7Z0JBQ2xELGlEQUFpRDtnQkFDakQsd0NBQXdDO2dCQUN4QyxJQUFJO2FBQ1A7aUJBQU07Z0JBQ0gsZ0NBQWdDO2dCQUNoQyw0QkFBaUIsRUFBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLG1CQUFtQixFQUFFO29CQUM3QyxTQUFTLEVBQUUscUNBQXFDO2lCQUNuRCxDQUFDLENBQUM7YUFDTjtZQUNELE9BQU8sR0FBRyxDQUFDO1FBQ2YsQ0FBQztRQUNMLGlCQUFDO0lBQUQsQ0FBQztJQTdFWSxnQ0FBVTtJQStFdkI7UUFPSSx3QkFBWSxJQUFlLEVBQUUsS0FBK0IsRUFBRSxPQUFpQztZQUMzRixPQUFPLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxDQUFDO1lBQzlCLElBQUksQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDO1lBQ25CLElBQUksQ0FBQyxPQUFPLEdBQUcsT0FBTyxDQUFDO1lBQ3ZCLElBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDO1FBQ3hCLENBQUM7UUFFRCwrQkFBTSxHQUFOO1lBQUEsaUJBb0JDO1lBbkJHLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFO2dCQUNYLElBQU0sU0FBTyxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLENBQUM7Z0JBQzlDLFNBQU8sQ0FBQyxTQUFTLEdBQUcsZ0JBQWdCLENBQUM7Z0JBQ3JDLElBQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUM7Z0JBQzdCLElBQU0sS0FBRyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsWUFBWSxDQUFDO2dCQUVwQyxJQUFJLE9BQU8sSUFBSSxPQUFPLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtvQkFDL0IsT0FBTyxDQUFDLE9BQU8sQ0FBQyxVQUFDLE1BQU07d0JBQ25CLElBQU0sT0FBTyxHQUFHLEtBQUcsQ0FBQyxjQUFjLENBQUMsS0FBSSxDQUFDLEtBQUssRUFBRSxNQUFNLENBQUMsQ0FBQzt3QkFDdkQsU0FBTyxDQUFDLFdBQVcsQ0FBQyxPQUFPLENBQUMsQ0FBQzt3QkFDN0IsT0FBTyxDQUFDLFNBQVMsR0FBRyxXQUFXLENBQUM7d0JBQ2hDLE9BQU8sQ0FBQyxnQkFBZ0IsQ0FBQyxPQUFPLEVBQUUsVUFBQyxFQUFFLElBQUssWUFBSSxDQUFDLGdCQUFnQixDQUFDLEVBQUUsR0FBRyxFQUFlLEVBQUUsQ0FBQyxNQUFNLEVBQUUsSUFBSSxFQUFFLE1BQU0sRUFBRSxDQUFDLEVBQXBFLENBQW9FLENBQUMsQ0FBQztvQkFDcEgsQ0FBQyxDQUFDLENBQUM7aUJBQ047cUJBQU07b0JBQ0gsNEJBQWlCLEVBQUMsR0FBRyxFQUFFLFNBQU8sQ0FBQyxDQUFDLFNBQVMsR0FBRywwQkFBMEIsQ0FBQztpQkFDMUU7Z0JBQ0QsSUFBSSxDQUFDLEdBQUcsR0FBRyxTQUFPLENBQUM7YUFDdEI7WUFDRCxPQUFPLElBQUksQ0FBQyxHQUFHLENBQUM7UUFDcEIsQ0FBQztRQUVELHlDQUFnQixHQUFoQixVQUFpQixLQUFxQjtZQUNsQyxJQUFJLElBQUksQ0FBQyxpQkFBaUIsRUFBRTtnQkFDeEIsSUFBSSxDQUFDLGlCQUFpQixDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDO2dCQUN4RCxJQUFJLElBQUksQ0FBQyxpQkFBaUIsS0FBSyxLQUFLLEVBQUU7b0JBQ2xDLElBQUksQ0FBQyxpQkFBaUIsR0FBRyxTQUFTLENBQUM7b0JBQ25DLDBCQUFhLENBQUMsdUJBQXVCLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRSxTQUFTLENBQUMsQ0FBQztpQkFDbkU7YUFDSjtZQUNELElBQUksQ0FBQyxpQkFBaUIsR0FBRyxLQUFLLENBQUM7WUFDL0IsMEJBQWEsQ0FBQyx1QkFBdUIsQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUNqRSxPQUFPLENBQUMsSUFBSSxDQUFDLGtCQUFrQixFQUFFLEtBQUssQ0FBQyxDQUFDO1FBQzVDLENBQUM7UUFFRCw4QkFBSyxHQUFMLFVBQU0sTUFBbUI7WUFDckIsT0FBTyxDQUFDLElBQUksQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDO1FBQ3pDLENBQUM7UUFDRCxpQ0FBUSxHQUFSO1lBQ0ksSUFBSSxJQUFJLENBQUMsT0FBTyxFQUFFO2dCQUNkLElBQUksQ0FBQyxPQUFPLENBQUMsTUFBTSxFQUFFLENBQUM7YUFDekI7WUFDRCxPQUFPLENBQUMsSUFBSSxDQUFDLHlCQUF5QixDQUFDLENBQUM7UUFDNUMsQ0FBQztRQUNMLHFCQUFDO0lBQUQsQ0FBQztJQTFEWSx3Q0FBYzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUMvRzNCO1FBQW1DLGlDQUFPO1FBY3RDLHVCQUFZLE1BQWlDO1lBQTdDLFlBQ0ksa0JBQU0sTUFBTSxDQUFDLFNBSWhCO1lBbEJELHVCQUFpQixHQUFHLElBQUksNEJBQWUsRUFBMEIsQ0FBQztZQWU5RCxLQUFJLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQztZQUNyQixNQUFNLENBQUMsZ0JBQWdCLEdBQUcsVUFBQyxFQUFFLElBQUssWUFBSSxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsRUFBdkIsQ0FBdUIsQ0FBQztZQUMxRCxNQUFNLENBQUMsb0JBQW9CLEdBQUcsVUFBQyxFQUFFLElBQUssWUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsRUFBdEIsQ0FBc0IsQ0FBQzs7UUFDakUsQ0FBQztRQUNELG1DQUFXLEdBQVgsVUFBWSxTQUFrQjtZQUMxQixJQUFJLElBQUksQ0FBQyxTQUFTLEVBQUU7Z0JBQ2hCLElBQUksU0FBUyxFQUFFO29CQUNYLElBQUksQ0FBQyxTQUFTLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxXQUFXLENBQUMsQ0FBQztpQkFDN0M7cUJBQU07b0JBQ0gsSUFBSSxDQUFDLFNBQVMsQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLFdBQVcsQ0FBQyxDQUFDO2lCQUNoRDthQUNKO1FBQ0wsQ0FBQztRQUVELDZCQUFLLEdBQUwsVUFBTSxHQUFVO1lBQWhCLGlCQW9DQztZQW5DRyxPQUFPLENBQUMsSUFBSSxDQUFDLHFCQUFxQixDQUFDLENBQUM7WUFDcEMsSUFBSSxDQUFDLFVBQVUsR0FBRyw0QkFBaUIsRUFBQyxLQUFLLEVBQUUsU0FBUyxFQUFFLGdCQUFnQixDQUFDLENBQUM7WUFDeEUsSUFBTSxJQUFJLEdBQUcsQ0FBQyxJQUFJLENBQUMsS0FBSyxHQUFHLDRCQUFpQixFQUFDLFFBQVEsRUFBRSxJQUFJLENBQUMsVUFBVSxFQUFFLHlCQUF5QixDQUFDLENBQUMsQ0FBQztZQUNwRyxJQUFJLENBQUMsU0FBUyxHQUFHLGlCQUFpQixDQUFDO1lBQ25DLDRCQUFpQixFQUFDLEdBQUcsRUFBRSxJQUFJLENBQUMsQ0FBQztZQUU3QixJQUFJLENBQUMsU0FBUyxHQUFHLFVBQUMsR0FBZTtnQkFDN0Isa0RBQWtEO2dCQUNsRCxLQUFJLENBQUMsZUFBZSxFQUFFLENBQUM7WUFDM0IsQ0FBQyxDQUFDO1lBQ0YsSUFBSSxDQUFDLGdCQUFnQixDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7WUFDL0Msa0JBQVEsQ0FBQyx1QkFBdUIsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7WUFFbEQsSUFBSSxDQUFDLGlCQUFpQixFQUFFLENBQUM7WUFDekIsSUFBSSxDQUFDLFVBQVUsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1lBRTVDLHVEQUF1RDtZQUN2RCx5REFBeUQ7WUFDekQsa0VBQWtFO1lBQ2xFLG9FQUFvRTtZQUNwRSxzRUFBc0U7WUFDdEUsd0VBQXdFO1lBQ3hFLHdFQUF3RTtZQUN4RSwwR0FBMEc7WUFDMUcsS0FBSztZQUNMLFFBQVEsQ0FBQyxnQkFBZ0IsQ0FBQyxTQUFTLEVBQUUsVUFBQyxHQUFrQjtnQkFDcEQsSUFBSSxHQUFHLENBQUMsT0FBTyxJQUFJLEdBQUcsQ0FBQyxHQUFHLEtBQUssR0FBRyxFQUFFO29CQUNoQyxPQUFPLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO29CQUNsQixLQUFJLENBQUMsZUFBZSxFQUFFLENBQUM7b0JBQ3ZCLEtBQUksQ0FBQyxVQUFVLENBQUMsS0FBSyxFQUFFLENBQUM7b0JBQ3hCLEdBQUcsQ0FBQyxjQUFjLEVBQUUsQ0FBQztpQkFDeEI7WUFDTCxDQUFDLENBQUMsQ0FBQztZQUVILE9BQU8sSUFBSSxDQUFDLFVBQVUsQ0FBQztRQUMzQixDQUFDO1FBRUQsZ0NBQVEsR0FBUixVQUFTLEdBQVU7WUFDZixJQUFJLENBQUMsS0FBSyxDQUFDLG1CQUFtQixDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7UUFDNUQsQ0FBQztRQUVELHlDQUFpQixHQUFqQjtZQUFBLGlCQXNCQztZQXJCRyxJQUFNLFNBQVMsR0FBRyxDQUFDLElBQUksQ0FBQyxTQUFTLEdBQUcsNEJBQWlCLEVBQUMsS0FBSyxFQUFFLFNBQVMsRUFBRSxRQUFRLENBQUMsQ0FBQyxDQUFDO1lBQ25GLDRCQUFpQixFQUFDLEtBQUssRUFBRSxTQUFTLEVBQUUsa0JBQWtCLENBQUMsQ0FBQztZQUN4RCxJQUFNLGFBQWEsR0FBRyw0QkFBaUIsRUFBQyxLQUFLLEVBQUUsU0FBUyxFQUFFLGdCQUFnQixDQUFDLENBQUM7WUFDNUUsSUFBTSxTQUFTLEdBQUcsQ0FBQyxJQUFJLENBQUMsU0FBUyxHQUFHLDRCQUFpQixFQUFDLEtBQUssRUFBRSxTQUFTLEVBQUUsV0FBVyxDQUFDLENBQUMsQ0FBQztZQUN0RixTQUFTLENBQUMsZ0JBQWdCLENBQUMsT0FBTyxFQUFFLFVBQUMsRUFBRSxJQUFLLFlBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxFQUFFLENBQUMsRUFBekIsQ0FBeUIsQ0FBQyxDQUFDO1lBRXZFLElBQU0sU0FBUyxHQUFHLENBQUMsSUFBSSxDQUFDLFVBQVUsR0FBRyxJQUFJLENBQUMsU0FBUyxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQztZQUN2RixhQUFhLENBQUMsV0FBVyxDQUFDLFNBQVMsQ0FBQyxDQUFDO1lBQ3JDLFNBQVMsQ0FBQyxJQUFJLEdBQUcsTUFBTSxDQUFDO1lBRXhCLFNBQVMsQ0FBQyxXQUFXLEdBQUcsdUJBQXVCLENBQUM7WUFFaEQsSUFBTSxjQUFjLEdBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUNuRCxjQUFjLENBQUMsU0FBUyxHQUFHLG9CQUFvQixDQUFDO1lBQ2hELGFBQWEsQ0FBQyxXQUFXLENBQUMsY0FBYyxDQUFDLENBQUM7WUFDMUMsY0FBYyxDQUFDLGdCQUFnQixDQUFDLE9BQU8sRUFBRSxVQUFDLEVBQUU7Z0JBQ3hDLFNBQVMsQ0FBQyxLQUFLLEdBQUcsRUFBRSxDQUFDO2dCQUNyQixLQUFJLENBQUMsWUFBWSxFQUFFLENBQUM7WUFDeEIsQ0FBQyxDQUFDLENBQUM7WUFFSCw4QkFBWSxFQUFDLFNBQVMsRUFBRSxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDekMsQ0FBQztRQUVELHVDQUFlLEdBQWY7WUFDSSxJQUFJLENBQUMsVUFBVSxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUM7WUFDM0MsSUFBSSxDQUFDLFNBQVMsQ0FBQyxLQUFLLEVBQUUsQ0FBQztRQUMzQixDQUFDO1FBQ0Qsd0NBQWdCLEdBQWhCLFVBQWlCLEVBQWM7WUFDM0IsSUFBSSxDQUFDLFVBQVUsQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBQy9DLENBQUM7UUFFRCxvQ0FBWSxHQUFaO1lBQ0ksSUFBSSxDQUFDLFVBQVUsQ0FBQyxLQUFLLEdBQUcsRUFBRSxDQUFDO1lBQzNCLElBQUksQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLFNBQVMsRUFBRSxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7UUFDckQsQ0FBQztRQUNMLG9CQUFDO0lBQUQsQ0FBQyxDQTVHa0MsaUJBQU8sR0E0R3pDO0lBNUdZLHNDQUFhOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQ0sxQjtRQUFpQywrQkFBUztRQWN0QyxxQkFBWSxPQUF1QjtZQUFuQyxZQUNJLGtCQUFNLE9BQU8sQ0FBQyxTQWtDakI7WUEzQ0Qsb0JBQWMsR0FBVSxFQUFFLENBQUM7WUFDM0IsYUFBTyxHQUFXLENBQUMsQ0FBQztZQVNoQixLQUFJLENBQUMsVUFBVSxHQUFHLE9BQU8sQ0FBQyxVQUFVLENBQUM7WUFDckMsSUFBTSxHQUFHLEdBQUcsS0FBSSxDQUFDLEdBQUcsR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQ3JELEdBQUcsQ0FBQyxTQUFTLEdBQUcsVUFBVSxDQUFDO1lBQzNCLElBQU0sT0FBTyxHQUFHLEtBQUksQ0FBQyxjQUFjLEdBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUNwRSxPQUFPLENBQUMsU0FBUyxHQUFHLGNBQWMsQ0FBQztZQUNuQyxLQUFJLENBQUMsUUFBUSxHQUFHLDRCQUFpQixFQUFDLE1BQU0sRUFBRSxPQUFPLENBQUMsQ0FBQztZQUNuRCxJQUFNLE9BQU8sR0FBRyxLQUFJLENBQUMsT0FBTyxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsTUFBTSxDQUFDLENBQUM7WUFDOUQsT0FBTyxDQUFDLFdBQVcsQ0FBQyxPQUFPLENBQUMsQ0FBQztZQUM3QixJQUFNLFVBQVUsR0FBRyxLQUFJLENBQUMsVUFBVSxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsR0FBRyxDQUFDLENBQUU7WUFDbEUsVUFBVSxDQUFDLFNBQVMsR0FBRyxPQUFPLENBQUM7WUFDL0IsT0FBTyxDQUFDLFdBQVcsQ0FBQyxVQUFVLENBQUMsQ0FBQztZQUNoQyxvREFBb0Q7WUFDcEQsa0NBQWtDO1lBQ2xDLG9DQUFvQztZQUNwQyx3Q0FBd0M7WUFFeEMsT0FBTyxDQUFDLGdCQUFnQixDQUFDLE9BQU8sRUFBRSxVQUFDLEVBQUUsSUFBRyxZQUFJLENBQUMsZ0JBQWdCLEVBQUUsRUFBdkIsQ0FBdUIsQ0FBQyxDQUFDO1lBQ2pFLHdDQUF3QztZQUN4QyxLQUFJLENBQUMsV0FBVyxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDakQsS0FBSSxDQUFDLFdBQVcsQ0FBQyxTQUFTLEdBQUcsa0JBQWtCLENBQUM7WUFDaEQsR0FBRyxDQUFDLFdBQVcsQ0FBQyxLQUFJLENBQUMsV0FBVyxDQUFDLENBQUM7WUFFbEMsSUFBTSxpQkFBaUIsR0FBRyxVQUFDLEVBQUU7Z0JBQ3pCLEVBQUUsQ0FBQyxlQUFlLEVBQUUsQ0FBQztnQkFDckIsT0FBTyxLQUFLLENBQUM7WUFDakIsQ0FBQztZQUNELENBQUMsQ0FBQyxRQUFRLENBQUMsdUJBQXVCLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDeEMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyx3QkFBd0IsQ0FBQyxHQUFHLENBQUMsQ0FBQzs7WUFDekMsMkRBQTJEO1lBQzNELG9EQUFvRDtZQUNwRCxzREFBc0Q7WUFDdEQsd0RBQXdEO1lBQ3hELG9EQUFvRDtRQUN4RCxDQUFDO1FBQ08sc0NBQWdCLEdBQXhCO1lBQ0ksSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDO1FBQ2xCLENBQUM7UUFFRCwyQkFBSyxHQUFMLFVBQU0sR0FBVTtZQUNaLHNDQUFzQztZQUN0QyxJQUFJLElBQUksQ0FBQyxVQUFVLEVBQUU7Z0JBQ2pCLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQztnQkFDbEIsSUFBSSxDQUFDLElBQUksR0FBRyxHQUFHLENBQUM7Z0JBQ2hCLElBQU0sU0FBUyxHQUFTLElBQUssQ0FBQyxVQUFVLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztnQkFDdkQsSUFBSSxDQUFDLFVBQVUsQ0FBQyxXQUFXLENBQUMsU0FBUyxDQUFDLENBQUM7Z0JBQzNDLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLFFBQVEsRUFBRSxJQUFJLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxDQUFDO2dCQUN0QyxPQUFPLElBQUksQ0FBQzthQUNmO2lCQUFNO2dCQUNILE9BQU8saUJBQU0sS0FBSyxZQUFDLEdBQUcsQ0FBQyxDQUFDO2FBQzNCO1FBQ0wsQ0FBQztRQUVELDJCQUFLLEdBQUwsVUFBTSxHQUFTO1lBQ1gsT0FBTyxJQUFJLENBQUMsR0FBRyxDQUFDO1FBQ3BCLENBQUM7UUFFRCx3QkFBd0I7UUFDeEIsZ0RBQWdEO1FBQ2hELElBQUk7UUFFSiwyQkFBSyxHQUFMO1lBQ0ksT0FBTyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztZQUN0QixJQUFJLElBQVMsQ0FBQztZQUNkLE9BQU8sSUFBSSxHQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsR0FBRyxFQUFFLEVBQUU7Z0JBQ25DLElBQUksSUFBSSxDQUFDLFFBQVEsRUFBRTtvQkFDZixJQUFJLENBQUMsUUFBUSxFQUFFLENBQUM7aUJBQ25CO2dCQUNELDBCQUFhLENBQUMsWUFBWSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUM7YUFDbkQ7WUFDRCxJQUFJLENBQUMsY0FBYyxHQUFHLEVBQUUsQ0FBQztZQUN6QixJQUFJLElBQUksQ0FBQyxXQUFXLENBQUMsVUFBVSxFQUFFO2dCQUM3QixJQUFJLENBQUMsV0FBVyxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLFVBQVUsQ0FBQyxDQUFDO2FBQzdEO1lBQ0QsSUFBSSxJQUFJLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLEVBQUU7Z0JBQ3hDLElBQUksQ0FBQyxHQUFHLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQzthQUM3QztRQUNMLENBQUM7UUFFRCxvQ0FBYyxHQUFkLFVBQWUsQ0FBTSxFQUFFLE9BQWU7WUFDbEMsT0FBTyxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUUsQ0FBQyxDQUFDLENBQUM7WUFDM0IsSUFBSSxPQUFPLEVBQUU7Z0JBQ1QsSUFBSSxDQUFDLGVBQWUsQ0FBQyxDQUFDLENBQUMsQ0FBQzthQUMzQjtpQkFBTTtnQkFDSCxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDO2FBQ3ZCO1lBQ0QsSUFBSSxDQUFDLENBQUMsS0FBSyxFQUFFO2dCQUNULENBQUMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUM7YUFDakI7UUFDTCxDQUFDO1FBRU8scUNBQWUsR0FBdkIsVUFBd0IsSUFBUztZQUM3QixPQUFPLENBQUMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLENBQUM7WUFDaEMsSUFBSSxPQUFZLENBQUM7WUFDakIsT0FBTyxPQUFPLEdBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxHQUFHLEVBQUUsRUFBRTtnQkFDdEMsSUFBSSxPQUFPLENBQUMsUUFBUSxFQUFFO29CQUNsQixPQUFPLENBQUMsUUFBUSxFQUFFLENBQUM7aUJBQ3RCO2FBQ0o7WUFDRCxJQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUM7WUFDMUIsSUFBSSxJQUFJLENBQUMsV0FBVyxDQUFDLFVBQVUsRUFBRTtnQkFDN0IsT0FBTyxDQUFDLElBQUksQ0FBQyxtQkFBbUIsRUFBRSxJQUFJLENBQUMsV0FBVyxDQUFDLFVBQVUsQ0FBQyxDQUFDO2dCQUMvRCxJQUFJLENBQUMsV0FBVyxDQUFDLFlBQVksQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLFdBQVcsQ0FBQyxVQUFVLENBQUMsQ0FBQzthQUNuRTtpQkFBTTtnQkFDSCxPQUFPLENBQUMsSUFBSSxDQUFDLG1CQUFtQixDQUFDLENBQUM7Z0JBQ2xDLElBQUksQ0FBQyxHQUFHLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxjQUFjLEVBQUUsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDO2dCQUM3RCxJQUFJLENBQUMsV0FBVyxDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUMsQ0FBQzthQUNyQztZQUNELElBQUksQ0FBQyxjQUFjLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUNqQyxDQUFDO1FBQ08saUNBQVcsR0FBbkIsVUFBb0IsSUFBUztZQUN6QixJQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUM7WUFDMUIsT0FBTyxDQUFDLElBQUksQ0FBQywyQkFBMkIsRUFBRSxHQUFHLENBQUMsQ0FBQztZQUMvQyxHQUFHLENBQUMsRUFBRSxHQUFDLE9BQU8sR0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDO1lBQzVCLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQztZQUNmLElBQUksSUFBSSxDQUFDLFdBQVcsQ0FBQyxVQUFVLEVBQUU7Z0JBQzdCLE9BQU8sQ0FBQyxJQUFJLENBQUMscUJBQWMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLGlCQUFPLEdBQUcsQ0FBQyxFQUFFLENBQUUsQ0FBQyxDQUFDO2dCQUM3RSxJQUFJLENBQUMsV0FBVyxDQUFDLFlBQVksQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLFdBQVcsQ0FBQyxVQUFVLENBQUMsQ0FBQztnQkFDaEUsSUFBSSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7YUFDbEM7aUJBQU07Z0JBQ0gsT0FBTyxDQUFDLElBQUksQ0FBQyw2QkFBc0IsR0FBRyxDQUFDLEVBQUUsa0JBQWUsQ0FBQztnQkFDekQsSUFBSSxDQUFDLEdBQUcsQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLGNBQWMsRUFBRSxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUM7Z0JBQzdELElBQUksQ0FBQyxXQUFXLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxDQUFDO2dCQUNsQyxJQUFJLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQzthQUNsQztZQUNELElBQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDO1lBQzdELElBQUksQ0FBQyxRQUFRLENBQUMsU0FBUyxHQUFHLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDO1lBRXJELE9BQU8sQ0FBQyxJQUFJLENBQUMsMEJBQW1CLElBQUksQ0FBQyxjQUFjLENBQUMsTUFBTSxDQUFFLEVBQUUsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDO1lBQ25GLElBQUksSUFBSSxDQUFDLGNBQWMsQ0FBQyxNQUFNLEtBQUcsQ0FBQyxFQUFFO2dCQUNoQyxJQUFJLENBQUMsVUFBVSxDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUMsTUFBTSxFQUFFLE9BQU8sQ0FBQyxDQUFDO2dCQUNuRCxJQUFJLENBQUMsVUFBVSxDQUFDLEtBQUssR0FBRyxXQUFXLENBQUM7YUFDdkM7aUJBQU07Z0JBQ0gsSUFBSSxDQUFDLFVBQVUsQ0FBQyxTQUFTLENBQUMsT0FBTyxDQUFDLE9BQU8sRUFBRSxNQUFNLENBQUMsQ0FBQztnQkFDbkQsSUFBSSxDQUFDLFVBQVUsQ0FBQyxLQUFLLEdBQUcsUUFBUSxDQUFDO2FBQ3BDO1FBQ0wsQ0FBQztRQUVELDRCQUFNLEdBQU47WUFDSSxPQUFPLENBQUMsSUFBSSxDQUFDLGlCQUFVLElBQUksQ0FBQyxjQUFjLENBQUMsTUFBTSxDQUFFLEVBQUUsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDO1lBQzFFLElBQUksSUFBSSxDQUFDLFdBQVcsQ0FBQyxVQUFVLEVBQUU7Z0JBRTdCLElBQU0sY0FBYyxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsR0FBRyxFQUFFLENBQUM7Z0JBQ2pELE9BQU8sQ0FBQyxJQUFJLENBQUMsaUJBQVUsSUFBSSxDQUFDLGNBQWMsQ0FBQyxNQUFNLENBQUUsRUFBRSxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUM7Z0JBQzFFLElBQUksY0FBYyxFQUFFO29CQUNoQixJQUFJLElBQUksQ0FBQyxjQUFjLENBQUMsTUFBTSxHQUFDLENBQUMsRUFBRTt3QkFDOUIsSUFBTSxXQUFXLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLE1BQU0sR0FBQyxDQUFDLENBQUMsQ0FBQzt3QkFDdEUsT0FBTyxDQUFDLElBQUksQ0FBQyxpQkFBVSxjQUFjLENBQUMsTUFBTSxFQUFFLENBQUMsSUFBSSxDQUFDLGlCQUFPLFdBQVcsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBRSxFQUFFLGNBQWMsRUFBRSxXQUFXLENBQUMsQ0FBQzt3QkFDdEgsSUFBSSxDQUFDLFdBQVcsQ0FBQyxZQUFZLENBQUMsV0FBVyxDQUFDLE1BQU0sRUFBRSxFQUFFLElBQUksQ0FBQyxXQUFXLENBQUMsVUFBVSxDQUFDLENBQUM7cUJBQ3BGO3lCQUNJO3dCQUNELE9BQU8sQ0FBQyxJQUFJLENBQUMsaUJBQVUsY0FBYyxDQUFDLElBQUksQ0FBQywyQkFBd0IsQ0FBQyxDQUFDO3dCQUNyRSxJQUFJLENBQUMsV0FBVyxDQUFDLFdBQVcsQ0FBQyxjQUFjLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQzt3QkFDdEQsSUFBSSxDQUFDLEdBQUcsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDO3FCQUM3QztvQkFDRCxJQUFJLGNBQWMsQ0FBQyxRQUFRLEVBQUU7d0JBQ3pCLGNBQWMsQ0FBQyxRQUFRLEVBQUUsQ0FBQztxQkFDN0I7b0JBQ0QsMEJBQWEsQ0FBQyxZQUFZLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRSxjQUFjLENBQUMsQ0FBQztpQkFDN0Q7YUFDSjtZQUNELE9BQU8sQ0FBQyxJQUFJLENBQUMsa0NBQWtDLEVBQUUsSUFBSSxDQUFDLFVBQVUsQ0FBQyxTQUFTLENBQUMsQ0FBQztZQUM1RSxJQUFJLElBQUksQ0FBQyxjQUFjLENBQUMsTUFBTSxJQUFFLENBQUMsRUFBRTtnQkFDL0IsSUFBSSxDQUFDLFVBQVUsQ0FBQyxTQUFTLENBQUMsT0FBTyxDQUFDLE1BQU0sRUFBRSxPQUFPLENBQUMsQ0FBQzthQUN0RDtpQkFBTTtnQkFDSCxJQUFJLENBQUMsVUFBVSxDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUMsT0FBTyxFQUFFLE1BQU0sQ0FBQyxDQUFDO2FBQ3REO1FBQ0wsQ0FBQztRQUNMLGtCQUFDO0lBQUQsQ0FBQyxDQXZMZ0MsQ0FBQyxDQUFDLE9BQU8sR0F1THpDO0lBdkxZLGtDQUFXOzs7Ozs7Ozs7Ozs7Ozs7OztJQ0x4QixTQUFnQixjQUFjLENBQUMsS0FBb0I7O1FBQy9DLElBQU0sR0FBRyxHQUFHLFFBQVEsQ0FBQyxlQUFlLENBQUMsNEJBQTRCLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFDMUUsSUFBTSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEtBQUssQ0FBQyxNQUFNLENBQUM7UUFDM0IsSUFBSSxHQUFHLENBQUMsT0FBTyxDQUFDLE9BQU8sRUFBRTtZQUNyQixHQUFHLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBQzFCLEdBQUcsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDMUIsR0FBRyxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQztZQUM5QixHQUFHLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDO1NBQ2xDO2FBQU07WUFDSCxJQUFNLGFBQWEsR0FBRyxNQUFNLEdBQUcsQ0FBQyxDQUFDLFFBQVEsRUFBRSxHQUFHLEdBQUcsR0FBRyxDQUFDLENBQUMsUUFBUSxFQUFFLENBQUM7WUFDakUsR0FBRyxDQUFDLFlBQVksQ0FBQyxTQUFTLEVBQUUsYUFBYSxDQUFDLENBQUM7U0FDOUM7UUFFRCxHQUFHLENBQUMsWUFBWSxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQztRQUN4QyxHQUFHLENBQUMsWUFBWSxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQztRQUV6QywwQkFBMEI7UUFDMUIsSUFBSSxHQUFHLEdBQUcsQ0FBQyxDQUFDO1FBQ1osSUFBSSxNQUFNLEdBQUcsS0FBSyxDQUFDLE1BQU0sQ0FBQztRQUMxQixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsS0FBSyxDQUFDLFFBQVEsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7WUFDNUMsR0FBRyxJQUFJLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDO1NBQ2xDO1FBQ0QsNkNBQTZDO1FBQzdDLElBQUksVUFBVSxHQUFHLENBQUMsRUFDZCxRQUFRLEdBQUcsQ0FBQyxDQUFDO1FBQ2pCLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxLQUFLLENBQUMsUUFBUSxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtZQUM1QyxJQUFNLE9BQU8sR0FBRyxLQUFLLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ2xDLElBQU0sS0FBSyxHQUFHLENBQUMsT0FBTyxDQUFDLEtBQUssR0FBRyxDQUFDLEdBQUcsSUFBSSxDQUFDLEVBQUUsQ0FBQyxHQUFHLEdBQUcsQ0FBQztZQUNsRCxRQUFRLElBQUksS0FBSyxDQUFDO1lBQ2xCLElBQU0sT0FBTyxHQUFHLE9BQU8sQ0FBQyxNQUFNLEVBQUU7Z0JBQzVCLEVBQUUsRUFBRSxNQUFNO2dCQUNWLEVBQUUsRUFBRSxNQUFNO2dCQUNWLEVBQUUsRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxHQUFHLE1BQU0sR0FBRyxNQUFNO2dCQUN4QyxFQUFFLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsR0FBRyxNQUFNLEdBQUcsTUFBTTtnQkFDeEMsTUFBTSxFQUFFLEtBQUssQ0FBQyxLQUFLO2dCQUNuQixhQUFhLEVBQUUsS0FBSyxDQUFDLGFBQWE7Z0JBQ2xDLFdBQVcsRUFBRSxLQUFLLENBQUMsWUFBWTthQUNsQyxDQUFDLENBQUM7WUFDSCxHQUFHLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1lBQ3BCLElBQU0sT0FBTyxHQUFHLElBQUksR0FBRyxNQUFNLEdBQUcsR0FBRyxHQUFHLE1BQU0sR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsR0FBRyxNQUFNLEdBQUcsTUFBTSxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsR0FBRyxNQUFNLEdBQUcsTUFBTSxDQUFDLEdBQUcsR0FBRyxHQUFHLElBQUksR0FBRyxNQUFNLEdBQUcsR0FBRyxHQUFHLE1BQU0sR0FBRyxLQUFLLEdBQUcsQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxLQUFLLEdBQUcsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxHQUFHLE1BQU0sR0FBRyxNQUFNLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxHQUFHLE1BQU0sR0FBRyxNQUFNLENBQUMsR0FBRyxHQUFHLEdBQUcsR0FBRyxDQUFDO1lBQy9VLElBQU0sT0FBTyxHQUFHLE9BQU8sQ0FBQyxNQUFNLEVBQUU7Z0JBQzVCLENBQUMsRUFBRSxPQUFPO2dCQUNWLElBQUksRUFBRSxPQUFPLENBQUMsS0FBSyxDQUFDLElBQUk7Z0JBQ3hCLE9BQU8sRUFBRSxPQUFPLENBQUMsS0FBSyxDQUFDLE9BQU87Z0JBQzlCLE1BQU0sRUFBRSxXQUFLLENBQUMsS0FBSyxtQ0FBSSxNQUFNO2dCQUM3QixhQUFhLEVBQUUsV0FBSyxDQUFDLGFBQWEsbUNBQUksS0FBSztnQkFDM0MsV0FBVyxFQUFFLFdBQUssQ0FBQyxZQUFZLG1DQUFJLEdBQUc7YUFDekMsQ0FBQyxDQUFDO1lBQ0gsR0FBRyxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQztZQUNwQixVQUFVLElBQUksS0FBSyxDQUFDO1NBQ3ZCO1FBQ0QsT0FBTyxHQUFHLENBQUM7SUFDZixDQUFDO0lBcERELHdDQW9EQztJQUVELG9DQUFvQztJQUNwQyxTQUFTLE9BQU8sQ0FBQyxHQUFXLEVBQUUsS0FBa0M7UUFDNUQsSUFBTSxFQUFFLEdBQUcsUUFBUSxDQUFDLGVBQWUsQ0FBQyw0QkFBNEIsRUFBRSxHQUFHLENBQUMsQ0FBQztRQUN2RSxLQUFLLElBQUksQ0FBQyxJQUFJLEtBQUssRUFBRTtZQUNqQixFQUFFLENBQUMsWUFBWSxDQUFDLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUNoQztRQUNELE9BQU8sRUFBRSxDQUFDO0lBQ2QsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUN2RUQsU0FBUyxVQUFVLENBQUMsRUFBYyxFQUFFLEtBQWU7UUFDL0MsS0FBSyxJQUFJLENBQUMsSUFBSSxLQUFLLEVBQUU7WUFDakIsRUFBRSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDMUI7SUFDTCxDQUFDO0lBeUNEO1FBR0ksd0JBQVksRUFBSyxFQUFFLEtBQWdCO1lBQy9CLElBQUksQ0FBQyxHQUFHLEdBQUcsRUFBRSxDQUFDO1lBQ2QsSUFBSSxLQUFLLEVBQUU7Z0JBQ1AsVUFBVSxDQUFDLEVBQUUsRUFBRSxLQUFLLENBQUMsQ0FBQzthQUN6QjtRQUNMLENBQUM7UUFFRCxvQ0FBVyxHQUFYLFVBQVksS0FBZ0I7WUFDeEIsVUFBVSxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFDaEMsQ0FBQztRQUVELCtCQUFNLEdBQU47WUFDSSxPQUFPLElBQUksQ0FBQyxHQUFHLENBQUM7UUFDcEIsQ0FBQztRQUVELHNDQUFhLEdBQWI7WUFDSSxPQUFPLElBQUksQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDO1FBQy9CLENBQUM7UUFFRCxzQ0FBYSxHQUFiLFVBQWMsS0FBZTtZQUN6QixPQUFPLElBQUksQ0FBQyxHQUFHLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQ3pDLENBQUM7UUFDRCx3Q0FBZSxHQUFmLFVBQWdCLEtBQWU7WUFDM0IsT0FBTyxJQUFJLENBQUMsR0FBRyxDQUFDLGVBQWUsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUMzQyxDQUFDO1FBQ0QsdUNBQWMsR0FBZDtZQUNJLE9BQU8sSUFBSSxDQUFDLEdBQUcsQ0FBQyxjQUFjLEVBQUUsQ0FBQztRQUNyQyxDQUFDO1FBQ0QseUNBQWdCLEdBQWhCLFVBQWlCLFFBQWdCO1lBQzdCLE9BQU8sSUFBSSxDQUFDLEdBQUcsQ0FBQyxnQkFBZ0IsQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUMvQyxDQUFDO1FBQ0wscUJBQUM7SUFBRCxDQUFDO0lBbENZLHdDQUFjO0lBb0MzQjtRQUE0QiwwQkFBZ0M7UUFDeEQsZ0JBQVksRUFBVSxFQUFFLEVBQVUsRUFBRSxNQUFjLEVBQUUsS0FBZ0I7WUFBcEUsWUFDSSxrQkFBTSxRQUFRLENBQUMsZUFBZSxDQUFDLDRCQUE0QixFQUFFLFFBQVEsQ0FBQyxFQUFFLEtBQUssQ0FBQyxTQUVqRjtZQURHLEtBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxFQUFFLEVBQUUsRUFBRSxNQUFNLENBQUMsQ0FBQzs7UUFDaEMsQ0FBQztRQUVELHVCQUFNLEdBQU4sVUFBTyxFQUFVLEVBQUUsRUFBVSxFQUFFLE1BQWM7WUFDekMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxZQUFZLENBQUMsR0FBRyxFQUFFLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO1lBQzNDLElBQUksQ0FBQyxHQUFHLENBQUMsWUFBWSxDQUFDLElBQUksRUFBRSxNQUFNLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztZQUN4QyxJQUFJLENBQUMsR0FBRyxDQUFDLFlBQVksQ0FBQyxJQUFJLEVBQUUsTUFBTSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFDNUMsQ0FBQztRQUNMLGFBQUM7SUFBRCxDQUFDLENBWDJCLGNBQWMsR0FXekM7SUFYWSx3QkFBTTtJQWFuQjtRQUEwQix3QkFBOEI7UUFDcEQsY0FBWSxFQUFVLEVBQUUsRUFBVSxFQUFFLEVBQVUsRUFBRSxFQUFVLEVBQUUsS0FBZ0I7WUFBNUUsWUFDSSxrQkFBTSxRQUFRLENBQUMsZUFBZSxDQUFDLDRCQUE0QixFQUFFLE1BQU0sQ0FBQyxFQUFFLEtBQUssQ0FBQyxTQUUvRTtZQURHLEtBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUM7O1FBQ2hDLENBQUM7UUFFRCxxQkFBTSxHQUFOLFVBQU8sRUFBVSxFQUFFLEVBQVUsRUFBRSxFQUFVLEVBQUUsRUFBVTtZQUNqRCxJQUFJLENBQUMsR0FBRyxDQUFDLFlBQVksQ0FBQyxJQUFJLEVBQUUsTUFBTSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7WUFDeEMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxZQUFZLENBQUMsSUFBSSxFQUFFLE1BQU0sQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1lBQ3hDLElBQUksQ0FBQyxHQUFHLENBQUMsWUFBWSxDQUFDLElBQUksRUFBRSxNQUFNLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztZQUN4QyxJQUFJLENBQUMsR0FBRyxDQUFDLFlBQVksQ0FBQyxJQUFJLEVBQUUsTUFBTSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7WUFFeEMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEdBQUcsTUFBTSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1lBQ2xDLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxHQUFHLE1BQU0sQ0FBQyxFQUFFLENBQUMsQ0FBQztZQUNsQyxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsR0FBRyxNQUFNLENBQUMsRUFBRSxDQUFDLENBQUM7WUFDbEMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEdBQUcsTUFBTSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQ3RDLENBQUM7UUFDTCxXQUFDO0lBQUQsQ0FBQyxDQWpCeUIsY0FBYyxHQWlCdkM7SUFqQlksb0JBQUk7SUFtQmpCO1FBQThCLDRCQUFrQztRQUM1RCxrQkFBWSxNQUEyQixFQUFFLEtBQWdCO1lBQXpELFlBQ0ksa0JBQU0sUUFBUSxDQUFDLGVBQWUsQ0FBQyw0QkFBNEIsRUFBRSxVQUFVLENBQUMsRUFBRSxLQUFLLENBQUMsU0FFbkY7WUFERyxLQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDOztRQUN4QixDQUFDO1FBRUQseUJBQU0sR0FBTixVQUFPLE1BQTJCO1lBQzlCLDhDQUE4QztZQUM5QyxJQUFJLE1BQU0sRUFBRTtnQkFDUixJQUFJLE9BQU8sTUFBTSxLQUFLLFFBQVEsRUFBRTtvQkFDNUIsSUFBSSxDQUFDLEdBQUcsQ0FBQyxZQUFZLENBQUMsUUFBUSxFQUFFLE1BQU0sQ0FBQyxDQUFDO2lCQUMzQztxQkFBTTtvQkFDSCxJQUFJLE1BQU0sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO3dCQUNuQixJQUFJLENBQUMsR0FBRyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxHQUFHLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQzt3QkFDMUMsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsS0FBSyxHQUFHLE1BQU0sQ0FBQyxNQUFNLEVBQUUsQ0FBQyxHQUFHLEtBQUssRUFBRSxDQUFDLEVBQUUsRUFBRTs0QkFDbkQsQ0FBQyxJQUFJLEdBQUcsR0FBRyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxHQUFHLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQzt5QkFDaEQ7d0JBQ0QsSUFBSSxDQUFDLEdBQUcsQ0FBQyxZQUFZLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQyxDQUFDO3FCQUN0QztpQkFDSjthQUNKO1FBQ0wsQ0FBQztRQUNMLGVBQUM7SUFBRCxDQUFDLENBdEI2QixjQUFjLEdBc0IzQztJQXRCWSw0QkFBUTtJQXdCckI7UUFBNkIsMkJBQWlDO1FBQzFELGlCQUFZLE1BQTJCLEVBQUUsS0FBZ0I7WUFBekQsWUFDSSxrQkFBTSxRQUFRLENBQUMsZUFBZSxDQUFDLDRCQUE0QixFQUFFLFNBQVMsQ0FBQyxFQUFFLEtBQUssQ0FBQyxTQUVsRjtZQURHLEtBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUM7O1FBQ3hCLENBQUM7UUFFRCx3QkFBTSxHQUFOLFVBQU8sTUFBMkI7WUFDOUIsOENBQThDO1lBQzlDLElBQUksTUFBTSxFQUFFO2dCQUNSLElBQUksT0FBTyxNQUFNLEtBQUssUUFBUSxFQUFFO29CQUM1QixJQUFJLENBQUMsR0FBRyxDQUFDLFlBQVksQ0FBQyxRQUFRLEVBQUUsTUFBTSxDQUFDLENBQUM7aUJBQzNDO3FCQUFNO29CQUNILElBQUksTUFBTSxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7d0JBQ25CLElBQUksQ0FBQyxHQUFHLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHLEdBQUcsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO3dCQUMxQyxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxLQUFLLEdBQUcsTUFBTSxDQUFDLE1BQU0sRUFBRSxDQUFDLEdBQUcsS0FBSyxFQUFFLENBQUMsRUFBRSxFQUFFOzRCQUNuRCxDQUFDLElBQUksR0FBRyxHQUFHLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHLEdBQUcsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO3lCQUNoRDt3QkFDRCxJQUFJLENBQUMsR0FBRyxDQUFDLFlBQVksQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDLENBQUM7cUJBQ3RDO2lCQUNKO2FBQ0o7UUFDTCxDQUFDO1FBQ0wsY0FBQztJQUFELENBQUMsQ0F0QjRCLGNBQWMsR0FzQjFDO0lBdEJZLDBCQUFPO0lBd0JwQjtRQUlJLGFBQVksT0FBaUU7WUFDekUsSUFBTSxHQUFHLEdBQWtCLFFBQVEsQ0FBQyxlQUFlLENBQUMsNEJBQTRCLEVBQUUsS0FBSyxDQUFDLENBQUM7WUFDekYsSUFBSSxPQUFPLEVBQUU7Z0JBQ1QsSUFBSSxHQUFHLENBQUMsT0FBTyxDQUFDLE9BQU8sRUFBRTtvQkFDckIsR0FBRyxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxDQUFDLENBQUM7b0JBQ2xDLEdBQUcsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUMsR0FBRyxPQUFPLENBQUMsQ0FBQyxDQUFDO29CQUNsQyxHQUFHLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxLQUFLLEdBQUcsT0FBTyxDQUFDLEtBQUssQ0FBQztvQkFDMUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsTUFBTSxHQUFHLE9BQU8sQ0FBQyxNQUFNLENBQUM7aUJBQy9DO3FCQUFNO29CQUNILHVHQUF1RztvQkFDdkcsSUFBTSxhQUFhLEdBQUcsRUFBRSxHQUFHLE9BQU8sQ0FBQyxDQUFDLENBQUMsUUFBUSxFQUFFLEdBQUcsR0FBRyxHQUFHLE9BQU8sQ0FBQyxDQUFDLENBQUMsUUFBUSxFQUFFLEdBQUcsR0FBRyxHQUFHLE9BQU8sQ0FBQyxLQUFLLENBQUMsUUFBUSxFQUFFLEdBQUcsR0FBRyxHQUFHLE9BQU8sQ0FBQyxNQUFNLENBQUMsUUFBUSxFQUFFLENBQUM7b0JBQ2hKLEdBQUcsQ0FBQyxZQUFZLENBQUMsU0FBUyxFQUFFLGFBQWEsQ0FBQyxDQUFDO29CQUMzQyxPQUFPLENBQUMsS0FBSyxDQUFDLGFBQWEsRUFBRSxHQUFHLENBQUMsT0FBTyxDQUFDLENBQUM7aUJBQzdDO2FBQ0o7WUFDRCxJQUFJLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQztRQUNuQixDQUFDO1FBRUQseUJBQVcsR0FBWDtZQUNJLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFO2dCQUNULElBQUksQ0FBQyxDQUFDLEdBQUcsUUFBUSxDQUFDLGVBQWUsQ0FBQyw0QkFBNEIsRUFBRSxHQUFHLENBQUMsQ0FBQztnQkFDckUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO2FBQ2hDO1lBQ0QsT0FBTyxJQUFJLENBQUMsQ0FBQyxDQUFDO1FBQ2xCLENBQUM7UUFFRCx1QkFBUyxHQUFULFVBQVUsRUFBVSxFQUFFLEVBQVUsRUFBRSxNQUFjLEVBQUUsS0FBZ0I7WUFDOUQsSUFBTSxNQUFNLEdBQUcsSUFBSSxNQUFNLENBQUMsRUFBRSxFQUFFLEVBQUUsRUFBRSxNQUFNLEVBQUUsS0FBSyxDQUFDLENBQUM7WUFDakQsSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDM0MsT0FBTyxNQUFNLENBQUM7UUFDbEIsQ0FBQztRQUVELHFCQUFPLEdBQVAsVUFBUSxFQUFVLEVBQUUsRUFBVSxFQUFFLEVBQVUsRUFBRSxFQUFVLEVBQUUsS0FBZ0I7WUFDcEUsSUFBTSxJQUFJLEdBQUcsSUFBSSxJQUFJLENBQUMsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEtBQUssQ0FBQyxDQUFDO1lBQzdDLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBQ3pDLE9BQU8sSUFBSSxDQUFDO1FBQ2hCLENBQUM7UUFFRCx5QkFBVyxHQUFYLFVBQVksTUFBMkIsRUFBRSxLQUFnQjtZQUNyRCxJQUFNLE9BQU8sR0FBRyxJQUFJLFFBQVEsQ0FBQyxNQUFNLEVBQUUsS0FBSyxDQUFDLENBQUM7WUFDNUMsSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFDLFdBQVcsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDNUMsT0FBTyxPQUFPLENBQUM7UUFDbkIsQ0FBQztRQUVELHlCQUFXLEdBQVgsVUFBWSxNQUEyQixFQUFFLEtBQWdCO1lBQ3JELElBQU0sT0FBTyxHQUFHLElBQUksT0FBTyxDQUFDLE1BQU0sRUFBRSxLQUFLLENBQUMsQ0FBQztZQUMzQyxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUMsV0FBVyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUM1QyxPQUFPLE9BQU8sQ0FBQztRQUNuQixDQUFDO1FBQ0wsVUFBQztJQUFELENBQUM7SUFyRFksa0JBQUc7Ozs7Ozs7Ozs7Ozs7QUNqS2Y7Ozs7R0FJRzs7OztJQTBFSixTQUF3QixZQUFZLENBQTZCLEtBQXVCLEVBQUUsUUFBaUM7UUFFdkgseUNBQXlDO1FBQ3pDLElBQU0sR0FBRyxHQUFHLFFBQVEsQ0FBQztRQUVyQixJQUFNLFNBQVMsR0FBbUIsR0FBRyxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUMzRCxJQUFNLGNBQWMsR0FBRyxTQUFTLENBQUMsS0FBSyxDQUFDO1FBQ3ZDLElBQU0sU0FBUyxHQUFHLFNBQVMsQ0FBQyxTQUFTLENBQUM7UUFDdEMsSUFBTSxhQUFhLEdBQUcsU0FBUyxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLENBQUMsSUFBSSxTQUFTLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO1FBQ2hHLElBQU0sY0FBYyxHQUFHLFFBQVEsQ0FBQyxjQUFjLElBQUksQ0FBQyxDQUFDO1FBQ3BELElBQU0sYUFBYSxHQUFHLFFBQVEsQ0FBQyxhQUFhLElBQUksS0FBSyxDQUFDO1FBQ3RELElBQU0sU0FBUyxHQUFHLFFBQVEsQ0FBQyxTQUFTLElBQUksTUFBTSxDQUFDO1FBQy9DLElBQU0sWUFBWSxHQUFHLFFBQVEsQ0FBQyxZQUFZLENBQUM7UUFFM0MsNkZBQTZGO1FBQzdGLElBQU0sY0FBYyxHQUFHLGFBQWEsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUM7UUFFekQsSUFBSSxhQUFhLEdBQUcsSUFBSSxDQUFDO1FBRXpCLElBQUksS0FBSyxHQUFRLEVBQUUsQ0FBQztRQUNwQixJQUFJLFVBQVUsR0FBRyxFQUFFLENBQUM7UUFDcEIsSUFBTSxNQUFNLEdBQUcsUUFBUSxDQUFDLFNBQVMsSUFBSSxDQUFDLENBQUM7UUFDdkMsSUFBTSxXQUFXLEdBQUcsUUFBUSxDQUFDLFdBQVcsQ0FBQztRQUN6QyxJQUFJLFFBQVEsR0FBTSxRQUFRLENBQUMsS0FBSyxDQUFDO1FBQ2pDLElBQUksUUFBUSxFQUFFO1lBQ1YsS0FBSyxDQUFDLEtBQUssR0FBRyxRQUFRLENBQUMsU0FBUyxDQUFDLENBQUM7U0FDckM7UUFDRCxJQUFJLGVBQWUsR0FBRyxDQUFDLENBQUM7UUFDeEIsSUFBSSxhQUFrQyxDQUFDO1FBRXZDLElBQUksYUFBYSxHQUFDLENBQUMsQ0FBQztRQUNwQixJQUFJLFVBQWlCLENBQUM7UUFFdEIsSUFBSSxDQUFDLEtBQUssRUFBRTtZQUNSLE1BQU0sSUFBSSxLQUFLLENBQUMsaUJBQWlCLENBQUMsQ0FBQztTQUN0QztRQUVELElBQUksUUFBUSxHQUFtQixFQUFFLENBQUM7UUFFbEMsU0FBUyxDQUFDLFNBQVMsR0FBRyxlQUFlLEdBQUcsQ0FBQyxRQUFRLENBQUMsU0FBUyxJQUFJLEVBQUUsQ0FBQyxDQUFDO1FBRW5FLDhGQUE4RjtRQUM5RixjQUFjLENBQUMsUUFBUSxHQUFHLFVBQVUsQ0FBQztRQUVyQzs7V0FFRztRQUNILFNBQVMsTUFBTTtZQUNYLElBQU0sTUFBTSxHQUFHLFNBQVMsQ0FBQyxVQUFVLENBQUM7WUFDcEMsSUFBSSxNQUFNLEVBQUU7Z0JBQ1IsTUFBTSxDQUFDLFdBQVcsQ0FBQyxTQUFTLENBQUMsQ0FBQzthQUNqQztRQUNMLENBQUM7UUFFRDs7V0FFRztRQUNILFNBQVMsa0JBQWtCO1lBQ3ZCLElBQUksYUFBYSxFQUFFO2dCQUNmLE1BQU0sQ0FBQyxZQUFZLENBQUMsYUFBYSxDQUFDLENBQUM7YUFDdEM7UUFDTCxDQUFDO1FBRUQ7O1dBRUc7UUFDSCxTQUFTLE1BQU07WUFDWCxJQUFJLENBQUMsU0FBUyxDQUFDLFVBQVUsRUFBRTtnQkFDdkIsR0FBRyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsU0FBUyxDQUFDLENBQUM7YUFDbkM7UUFDTCxDQUFDO1FBRUQ7O1dBRUc7UUFDSCxTQUFTLGtCQUFrQjtZQUN2QixPQUFPLENBQUMsQ0FBQyxTQUFTLENBQUMsVUFBVSxDQUFDO1FBQ2xDLENBQUM7UUFFRDs7V0FFRztRQUNILFNBQVMsS0FBSztZQUNWLDZEQUE2RDtZQUM3RCxlQUFlLEVBQUUsQ0FBQztZQUVsQixLQUFLLEdBQUcsRUFBRSxDQUFDO1lBQ1gsVUFBVSxHQUFHLEVBQUUsQ0FBQztZQUNoQixRQUFRLEdBQUcsU0FBUyxDQUFDO1lBQ3JCLE1BQU0sRUFBRSxDQUFDO1lBQ1QsVUFBVSxHQUFHLFNBQVMsQ0FBQztZQUV2QixLQUFLLElBQUksQ0FBQyxHQUFDLENBQUMsRUFBRSxDQUFDLEdBQUMsUUFBUSxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtnQkFDbEMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUM7YUFDM0I7UUFDTCxDQUFDO1FBRUQ7O1dBRUc7UUFDSCxTQUFTLGNBQWM7WUFFbkIsa0NBQWtDO1lBQ2xDLElBQUksQ0FBQyxrQkFBa0IsRUFBRSxFQUFFO2dCQUN2QixPQUFPO2FBQ1Y7WUFFRCxjQUFjLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQztZQUUvQixJQUFJLEtBQUssR0FBRyxLQUFLLENBQUMsV0FBVyxHQUFHLElBQUksQ0FBQztZQUNyQyxRQUFRO1lBQ1IseUVBQXlFO1lBQ3pFLGlCQUFpQjtZQUNqQix3QkFBd0I7WUFDeEIsSUFBSTtZQUdKLGNBQWMsQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDO1lBRTdCLElBQUksU0FBUyxHQUFHLENBQUMsQ0FBQztZQUNsQixJQUFJLFFBQVEsR0FBRyxLQUFLLENBQUMsV0FBVyxDQUFDO1lBQ2pDLElBQUksU0FBMkMsQ0FBQztZQUVoRCxTQUFTLElBQUk7Z0JBQ1QsSUFBTSxLQUFLLEdBQUcsR0FBRyxDQUFDLGVBQThCLENBQUM7Z0JBQ2pELElBQU0sU0FBUyxHQUFHLEtBQUssQ0FBQyxTQUFTLElBQUksR0FBRyxDQUFDLElBQUksQ0FBQyxTQUFTLElBQUksQ0FBQyxDQUFDO2dCQUM3RCxJQUFNLFVBQVUsR0FBRyxLQUFLLENBQUMsVUFBVSxJQUFJLEdBQUcsQ0FBQyxJQUFJLENBQUMsVUFBVSxJQUFJLENBQUMsQ0FBQztnQkFDaEUsSUFBTSxTQUFTLEdBQUcsTUFBTSxDQUFDLFdBQVcsSUFBSSxLQUFLLENBQUMsU0FBUyxDQUFDO2dCQUN4RCxJQUFNLFVBQVUsR0FBRyxNQUFNLENBQUMsV0FBVyxJQUFJLEtBQUssQ0FBQyxVQUFVLENBQUM7Z0JBRTFELFNBQVMsR0FBRyxLQUFLLENBQUMsYUFBYSxDQUFDLHFCQUFxQixFQUFFLENBQUM7Z0JBRXhELElBQU0sR0FBRyxHQUFHLFNBQVMsQ0FBQyxHQUFHLEdBQUcsS0FBSyxDQUFDLFlBQVksR0FBRyxTQUFTLEdBQUcsU0FBUyxHQUFHLENBQUMsQ0FBQztnQkFDM0UsSUFBTSxJQUFJLEdBQUcsU0FBUyxDQUFDLElBQUksR0FBRyxVQUFVLEdBQUcsVUFBVSxDQUFDO2dCQUV0RCxjQUFjLENBQUMsR0FBRyxHQUFHLEdBQUcsR0FBRyxJQUFJLENBQUM7Z0JBQ2hDLGNBQWMsQ0FBQyxJQUFJLEdBQUcsSUFBSSxHQUFHLElBQUksQ0FBQztnQkFFbEMsU0FBUyxHQUFHLE1BQU0sQ0FBQyxXQUFXLEdBQUcsQ0FBQyxTQUFTLENBQUMsR0FBRyxHQUFHLEtBQUssQ0FBQyxZQUFZLEdBQUcsQ0FBQyxDQUFDLENBQUM7Z0JBRTFFLElBQUksU0FBUyxHQUFHLENBQUMsRUFBRTtvQkFDZixTQUFTLEdBQUcsQ0FBQyxDQUFDO2lCQUNqQjtnQkFFRCxRQUFRLEdBQUcsTUFBTSxDQUFDLFVBQVUsR0FBRyxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUM7Z0JBRS9DLGNBQWMsQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLElBQUksQ0FBQztnQkFDaEMsY0FBYyxDQUFDLE1BQU0sR0FBRyxFQUFFLENBQUM7Z0JBQzNCLGNBQWMsQ0FBQyxJQUFJLEdBQUcsSUFBSSxHQUFHLElBQUksQ0FBQztnQkFDbEMsY0FBYyxDQUFDLFNBQVMsR0FBRyxTQUFTLEdBQUcsSUFBSSxDQUFDO2dCQUM1QyxjQUFjLENBQUMsUUFBUSxHQUFHLEtBQUssQ0FBQyxhQUFhLENBQUMsV0FBVyxHQUFHLElBQUksQ0FBQztnQkFHakUsSUFBSSxRQUFRLEdBQUMsR0FBRyxFQUFFO29CQUNkLGNBQWMsQ0FBQyxLQUFLLEdBQUcsT0FBTyxDQUFDO29CQUMvQixjQUFjLENBQUMsUUFBUSxHQUFHLFFBQVEsR0FBSSxJQUFJLENBQUM7aUJBQzlDO1lBQ0wsQ0FBQztZQUVELGdIQUFnSDtZQUNoSCxJQUFJLEVBQUUsQ0FBQztZQUNQLElBQUksRUFBRSxDQUFDO1lBRVAsSUFBSSxRQUFRLENBQUMsU0FBUyxJQUFJLFNBQVMsRUFBRTtnQkFDakMsUUFBUSxDQUFDLFNBQVMsQ0FBQyxLQUFLLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRSxTQUFTLENBQUMsQ0FBQzthQUM5RDtRQUNMLENBQUM7UUFFRDs7V0FFRztRQUNILFNBQVMsTUFBTTtZQUNYLHNEQUFzRDtZQUN0RCxPQUFPLFNBQVMsQ0FBQyxVQUFVLEVBQUU7Z0JBQ3pCLFNBQVMsQ0FBQyxXQUFXLENBQUMsU0FBUyxDQUFDLFVBQVUsQ0FBQyxDQUFDO2FBQy9DO1lBRUQsa0RBQWtEO1lBQ2xELElBQU0sTUFBTSxHQUFHLFFBQVEsQ0FBQyxNQUFNLElBQUksVUFBUyxJQUFPLEVBQUUsWUFBb0I7Z0JBQ3BFLElBQU0sV0FBVyxHQUFHLEdBQUcsQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLENBQUM7Z0JBQzdDLElBQU0sUUFBUSxHQUFHLEdBQUcsQ0FBQyxhQUFhLENBQUMsT0FBTyxDQUFDLENBQUM7Z0JBQzVDLFFBQVEsQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLEVBQUUsQ0FBQztnQkFDM0MsV0FBVyxDQUFDLFdBQVcsQ0FBQyxRQUFRLENBQUMsQ0FBQztnQkFDbEMsSUFBSSxJQUFJLENBQUMsT0FBTyxDQUFDLEtBQUssT0FBTyxFQUFFO29CQUMzQixXQUFXLENBQUMsS0FBSyxHQUFrQixJQUFJLENBQUMsT0FBTyxDQUFFLENBQUMsZ0JBQWdCLENBQUMsUUFBUSxDQUFDO2lCQUMvRTtnQkFDRCxPQUFPLFdBQVcsQ0FBQztZQUN2QixDQUFDLENBQUM7WUFDRix5QkFBeUI7WUFDekIsZ0NBQWdDO1lBQ2hDLElBQUk7WUFFSix5Q0FBeUM7WUFDekMsSUFBTSxXQUFXLEdBQUcsUUFBUSxDQUFDLFdBQVcsSUFBSSxVQUFTLFNBQWlCLEVBQUUsWUFBb0I7Z0JBQ3hGLElBQU0sUUFBUSxHQUFHLEdBQUcsQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLENBQUM7Z0JBQzFDLFFBQVEsQ0FBQyxXQUFXLEdBQUcsU0FBUyxDQUFDO2dCQUNqQyxPQUFPLFFBQVEsQ0FBQztZQUNwQixDQUFDLENBQUM7WUFDRixVQUFVO1lBQ1YsMENBQTBDO1lBQzFDLElBQUk7WUFFSixJQUFNLFFBQVEsR0FBRyxHQUFHLENBQUMsc0JBQXNCLEVBQUUsQ0FBQztZQUM5QyxJQUFJLFNBQVMsR0FBRyxNQUFNLENBQUM7WUFFdkIsS0FBSyxDQUFDLE9BQU8sQ0FBQyxVQUFTLElBQU87Z0JBRTFCLElBQUksSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLElBQUksQ0FBQyxPQUFPLENBQUMsS0FBSyxTQUFTLEVBQUU7b0JBQzlDLFNBQVMsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7b0JBQzFCLElBQU0sUUFBUSxHQUFHLFdBQVcsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLEVBQUUsVUFBVSxDQUFDLENBQUM7b0JBQ3hELElBQUksUUFBUSxFQUFFO3dCQUNWLFFBQVEsQ0FBQyxTQUFTLElBQUksUUFBUSxDQUFDO3dCQUMvQixRQUFRLENBQUMsV0FBVyxDQUFDLFFBQVEsQ0FBQyxDQUFDO3FCQUNsQztpQkFDSjtnQkFDRCxJQUFNLEdBQUcsR0FBRyxNQUFNLENBQUMsSUFBSSxFQUFFLFVBQVUsQ0FBQyxDQUFDO2dCQUNyQyxJQUFJLEdBQUcsRUFBRTtvQkFDTCxHQUFHLENBQUMsZ0JBQWdCLENBQUMsT0FBTyxFQUFFLFVBQVMsRUFBYzt3QkFDakQsS0FBSyxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7d0JBQzlCLFFBQVEsQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLEtBQUssQ0FBQyxDQUFDO3dCQUMvQixPQUFPLENBQUMsSUFBSSxDQUFDLHVCQUF1QixDQUFDLENBQUM7d0JBQ3RDLGFBQWEsR0FBRyxJQUFJLENBQUM7d0JBQ3JCLEtBQUssRUFBRSxDQUFDO3dCQUNSLEVBQUUsQ0FBQyxjQUFjLEVBQUUsQ0FBQzt3QkFDcEIsRUFBRSxDQUFDLGVBQWUsRUFBRSxDQUFDO29CQUN6QixDQUFDLENBQUMsQ0FBQztvQkFDSCxJQUFJLElBQUksS0FBSyxRQUFRLEVBQUU7d0JBQ25CLEdBQUcsQ0FBQyxTQUFTLElBQUksV0FBVyxDQUFDO3FCQUNoQztvQkFDRCxRQUFRLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxDQUFDO2lCQUM3QjtZQUNMLENBQUMsQ0FBQyxDQUFDO1lBQ0gsU0FBUyxDQUFDLFdBQVcsQ0FBQyxRQUFRLENBQUMsQ0FBQztZQUNoQyxJQUFJLEtBQUssQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO2dCQUNsQixJQUFJLFFBQVEsQ0FBQyxRQUFRLEVBQUU7b0JBQ25CLElBQU0sS0FBSyxHQUFHLEdBQUcsQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLENBQUM7b0JBQ3ZDLEtBQUssQ0FBQyxTQUFTLEdBQUcsT0FBTyxDQUFDO29CQUMxQixLQUFLLENBQUMsV0FBVyxHQUFHLFFBQVEsQ0FBQyxRQUFRLENBQUM7b0JBQ3RDLFNBQVMsQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLENBQUM7aUJBQ2hDO3FCQUFNO29CQUNILEtBQUssRUFBRSxDQUFDO29CQUNSLE9BQU87aUJBQ1Y7YUFDSjtZQUVELE1BQU0sRUFBRSxDQUFDO1lBQ1QsY0FBYyxFQUFFLENBQUM7WUFFakIsWUFBWSxFQUFFLENBQUM7UUFDbkIsQ0FBQztRQUVELFNBQVMsaUJBQWlCO1lBQ3RCLElBQUksa0JBQWtCLEVBQUUsRUFBRTtnQkFDdEIsTUFBTSxFQUFFLENBQUM7YUFDWjtRQUNMLENBQUM7UUFFRCxTQUFTLGtCQUFrQjtZQUN2QixpQkFBaUIsRUFBRSxDQUFDO1FBQ3hCLENBQUM7UUFFRCxTQUFTLGtCQUFrQixDQUFDLENBQVE7WUFDaEMsSUFBSSxDQUFDLENBQUMsTUFBTSxLQUFLLFNBQVMsRUFBRTtnQkFDeEIsaUJBQWlCLEVBQUUsQ0FBQzthQUN2QjtpQkFBTTtnQkFDSCxDQUFDLENBQUMsY0FBYyxFQUFFLENBQUM7YUFDdEI7UUFDTCxDQUFDO1FBRUQsU0FBUyxpQkFBaUIsQ0FBQyxFQUFpQjtZQUN4QyxJQUFNLE9BQU8sR0FBRyxFQUFFLENBQUMsS0FBSyxJQUFJLEVBQUUsQ0FBQyxPQUFPLElBQUksQ0FBQyxDQUFDO1lBSTVDLElBQU0sTUFBTSxHQUFHLDRKQUFxSCxDQUFDO1lBQ3JJLEtBQWtCLFVBQU0sRUFBTixpQkFBTSxFQUFOLG9CQUFNLEVBQU4sSUFBTSxFQUFFO2dCQUFyQixJQUFNLEdBQUc7Z0JBQ1YsSUFBSSxPQUFPLEtBQUssR0FBRyxFQUFFO29CQUNqQixPQUFPO2lCQUNWO2FBQ0o7WUFFRCxJQUFJLE9BQU8sZ0JBQVcsSUFBSSxPQUFPLGlCQUFZLEVBQUU7Z0JBQzNDLE9BQU87YUFDVjtZQUVELDRDQUE0QztZQUM1QyxJQUFJLE9BQU8sa0JBQWMsSUFBSSxrQkFBa0IsRUFBRSxFQUFFO2dCQUMvQyxPQUFPO2FBQ1Y7WUFFRCxVQUFVLGtCQUF1QixDQUFDO1FBQ3RDLENBQUM7UUFFRDs7V0FFRztRQUNILFNBQVMsWUFBWTtZQUNqQixJQUFNLFFBQVEsR0FBRyxTQUFTLENBQUMsc0JBQXNCLENBQUMsVUFBVSxDQUFDLENBQUM7WUFDOUQsSUFBSSxRQUFRLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtnQkFDckIsSUFBSSxPQUFPLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBbUIsQ0FBQztnQkFFNUMscUJBQXFCO2dCQUNyQixJQUFNLFFBQVEsR0FBRyxPQUFPLENBQUMsc0JBQXdDLENBQUM7Z0JBQ2xFLElBQUksUUFBUSxJQUFJLFFBQVEsQ0FBQyxTQUFTLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLHNCQUFzQixFQUFFO29CQUM1RixPQUFPLEdBQUcsUUFBUSxDQUFDO2lCQUN0QjtnQkFFRCxJQUFJLE9BQU8sQ0FBQyxTQUFTLEdBQUcsU0FBUyxDQUFDLFNBQVMsRUFBRTtvQkFDekMsU0FBUyxDQUFDLFNBQVMsR0FBRyxPQUFPLENBQUMsU0FBUyxDQUFDO2lCQUMzQztxQkFBTTtvQkFDSCxJQUFNLFlBQVksR0FBRyxPQUFPLENBQUMsU0FBUyxHQUFHLE9BQU8sQ0FBQyxZQUFZLENBQUM7b0JBQzlELElBQU0sZUFBZSxHQUFHLFNBQVMsQ0FBQyxTQUFTLEdBQUcsU0FBUyxDQUFDLFlBQVksQ0FBQztvQkFDckUsSUFBSSxZQUFZLEdBQUcsZUFBZSxFQUFFO3dCQUNoQyxTQUFTLENBQUMsU0FBUyxJQUFJLFlBQVksR0FBRyxlQUFlLENBQUM7cUJBQ3pEO2lCQUNKO2FBQ0o7UUFDTCxDQUFDO1FBRUQ7O1dBRUc7UUFDSCxTQUFTLFVBQVU7WUFDZixJQUFJLEtBQUssQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO2dCQUNsQixRQUFRLEdBQUcsU0FBUyxDQUFDO2FBQ3hCO2lCQUFNO2dCQUNILElBQUksUUFBUSxLQUFLLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRTtvQkFDdkIsUUFBUSxHQUFHLEtBQUssQ0FBQyxLQUFLLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDO2lCQUN0QztxQkFBTTtvQkFDSCxLQUFLLElBQUksQ0FBQyxHQUFHLEtBQUssQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUU7d0JBQ3ZDLElBQUksUUFBUSxLQUFLLEtBQUssQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxFQUFFOzRCQUNsQyxRQUFRLEdBQUcsS0FBSyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQzs0QkFDeEIsTUFBTTt5QkFDVDtxQkFDSjtpQkFDSjthQUNKO1FBQ0wsQ0FBQztRQUVEOztXQUVHO1FBQ0gsU0FBUyxVQUFVO1lBQ2YsSUFBSSxLQUFLLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtnQkFDbEIsUUFBUSxHQUFHLFNBQVMsQ0FBQzthQUN4QjtZQUNELElBQUksQ0FBQyxRQUFRLElBQUksUUFBUSxLQUFLLEtBQUssQ0FBQyxLQUFLLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxFQUFFO2dCQUNuRCxRQUFRLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUNwQixPQUFPO2FBQ1Y7WUFDRCxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFO2dCQUN6QyxJQUFJLFFBQVEsS0FBSyxLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUU7b0JBQ3ZCLFFBQVEsR0FBRyxLQUFLLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO29CQUN4QixNQUFNO2lCQUNUO2FBQ0o7UUFDTCxDQUFDO1FBRUQsU0FBUyxtQkFBbUIsQ0FBQyxFQUFpQjtZQUMxQyxJQUFNLE9BQU8sR0FBRyxFQUFFLENBQUMsS0FBSyxJQUFJLEVBQUUsQ0FBQyxPQUFPLElBQUksQ0FBQyxDQUFDO1lBRTVDLElBQUksYUFBYSxFQUFFO2dCQUNmLElBQUksUUFBUSxDQUFDLGFBQWEsRUFBRTtvQkFDeEIsT0FBTyxDQUFDLElBQUksQ0FBQyxxQkFBcUIsRUFBRSxFQUFFLENBQUMsQ0FBQztvQkFDeEMsUUFBUSxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsQ0FBQztpQkFDakM7Z0JBQ0QsYUFBYSxHQUFHLEtBQUssQ0FBQzthQUN6QjtZQUVELElBQUksRUFBRSxDQUFDLE9BQU8sSUFBSSxFQUFFLElBQUksRUFBRSxDQUFDLE9BQU8sRUFBRTtnQkFDMUIsRUFBRSxDQUFDLE1BQU8sQ0FBQyxNQUFNLEVBQUU7YUFDNUI7WUFFRCxJQUFJLE9BQU8sZ0JBQVksSUFBSSxPQUFPLGtCQUFjLElBQUksT0FBTyxpQkFBYSxFQUFFO2dCQUN0RSxJQUFNLG9CQUFvQixHQUFHLGtCQUFrQixFQUFFLENBQUM7Z0JBRWxELElBQUksT0FBTyxpQkFBYSxFQUFFO29CQUN0QixLQUFLLEVBQUUsQ0FBQztvQkFDUixZQUFZO2lCQUNmO3FCQUFNO29CQUNILElBQUksQ0FBQyxrQkFBa0IsSUFBSSxLQUFLLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTt3QkFDekMsT0FBTztxQkFDVjtvQkFDRCxPQUFPLGdCQUFZO3dCQUNmLENBQUMsQ0FBQyxVQUFVLEVBQUU7d0JBQ2QsQ0FBQyxDQUFDLFVBQVUsRUFBRSxDQUFDO29CQUNuQixNQUFNLEVBQUUsQ0FBQztpQkFDWjtnQkFFRCxFQUFFLENBQUMsY0FBYyxFQUFFLENBQUM7Z0JBQ3BCLElBQUksb0JBQW9CLEVBQUU7b0JBQ3RCLEVBQUUsQ0FBQyxlQUFlLEVBQUUsQ0FBQztpQkFDeEI7Z0JBRUQsT0FBTzthQUNWO1lBRUQsSUFBSSxPQUFPLG1CQUFlLEVBQUU7Z0JBQ3hCLElBQUksUUFBUSxFQUFFO29CQUNWLEtBQUssQ0FBQyxLQUFLLEdBQUcsUUFBUSxDQUFDLFNBQVMsQ0FBQyxDQUFDO29CQUNsQyxRQUFRLENBQUMsUUFBUSxDQUFDLFFBQVEsRUFBRSxLQUFLLENBQUMsQ0FBQztvQkFDbkMsT0FBTyxDQUFDLElBQUksQ0FBQyx1QkFBdUIsQ0FBQyxDQUFDO29CQUN0QyxhQUFhLEdBQUcsSUFBSSxDQUFDO29CQUNyQixLQUFLLEVBQUUsQ0FBQztpQkFDWDtnQkFFRCxJQUFJLGFBQWEsRUFBRTtvQkFDZixFQUFFLENBQUMsY0FBYyxFQUFFLENBQUM7aUJBQ3ZCO2FBQ0o7UUFDTCxDQUFDO1FBRUQsU0FBUyxpQkFBaUI7WUFDdEIsSUFBSSxXQUFXLEVBQUU7Z0JBQ2IsVUFBVSxlQUFvQixDQUFDO2FBQ2xDO1lBQ0QsSUFBSSxZQUFZLEVBQUU7Z0JBQ2QsS0FBSyxHQUFHLFlBQVksQ0FBQztnQkFDckIsTUFBTSxFQUFFLENBQUM7YUFDWjtZQUNELElBQUksS0FBSyxFQUFFO2dCQUNQLEtBQUssQ0FBQyxNQUFNLEVBQUUsQ0FBQzthQUNsQjtRQUNMLENBQUM7UUFFRCwrQ0FBK0M7UUFDL0MsMEVBQTBFO1FBQzFFLDRGQUE0RjtRQUM1Rix5RUFBeUU7UUFDekUsK0RBQStEO1FBQy9ELHNEQUFzRDtRQUV0RCwrQkFBK0I7UUFDL0Isb0VBQW9FO1FBQ3BFLGdDQUFnQztRQUNoQywrREFBK0Q7UUFDL0QsMEVBQTBFO1FBQzFFLDhFQUE4RTtRQUM5RSx3Q0FBd0M7UUFDeEMsd0NBQXdDO1FBQ3hDLDBFQUEwRTtRQUMxRSxnQ0FBZ0M7UUFDaEMsb0JBQW9CO1FBQ3BCLHlDQUF5QztRQUN6QyxzRUFBc0U7UUFDdEUsZUFBZTtRQUNmLG1CQUFtQjtRQUNuQixRQUFRO1FBQ1IsSUFBSTtRQUVKLFNBQVMsa0JBQWtCLENBQUMsQ0FBUTtZQUNoQyxhQUFhLEdBQUcsYUFBYSxHQUFHLENBQUMsQ0FBQztZQUNsQyxPQUFPLENBQUMsSUFBSSxDQUFDLDZCQUFzQixDQUFDLGdCQUFNLGFBQWEsQ0FBRSxDQUFDO1lBQzFELElBQUksYUFBYSxHQUFDLENBQUMsRUFBRTtnQkFDakIsYUFBYSxHQUFHLENBQUMsQ0FBQzthQUNyQjtZQUNELElBQUksYUFBYSxLQUFLLENBQUMsRUFBRTtnQkFDckIsdUNBQXVDO2dCQUN2QyxJQUFJLFFBQVEsQ0FBQyxnQkFBZ0IsRUFBRTtvQkFDM0IsUUFBUSxDQUFDLGdCQUFnQixDQUFDLEtBQUssQ0FBQztpQkFDbkM7Z0JBQUEsQ0FBQzthQUNMO2lCQUFNO2dCQUNILDZCQUE2QjtnQkFDN0IsSUFBSSxRQUFRLENBQUMsb0JBQW9CLEVBQUU7b0JBQy9CLFFBQVEsQ0FBQyxvQkFBb0IsQ0FBQyxLQUFLLENBQUM7aUJBQ3ZDO2dCQUFBLENBQUM7YUFDTDtRQUNMLENBQUM7UUFFRCxTQUFTLGFBQWEsQ0FBQyxDQUFjO1lBQ2pDLFFBQVEsR0FBRyxRQUFRLENBQUMsTUFBTSxDQUFFLFVBQUMsQ0FBQztnQkFDMUIsT0FBTyxDQUFDLEtBQUcsQ0FBQztZQUNoQixDQUFDLENBQUMsQ0FBQztRQUNQLENBQUM7UUFFRCxTQUFTLFVBQVUsQ0FBQyxPQUFxQjtZQUNyQyxtRUFBbUU7WUFDbkUscUZBQXFGO1lBQ3JGLGtFQUFrRTtZQUNsRSx3REFBd0Q7WUFDeEQsSUFBTSxvQkFBb0IsR0FBRyxFQUFFLGVBQWUsQ0FBQztZQUMvQyxtRUFBbUU7WUFDbkUsSUFBTSxHQUFHLEdBQUcsS0FBSyxDQUFDLEtBQUssQ0FBQztZQUN4QixnRUFBZ0U7WUFDaEUsSUFBSSxHQUFHLENBQUMsTUFBTSxJQUFJLE1BQU0sSUFBSyxHQUFHLEtBQUssVUFBVSxFQUFFO2dCQUM3QyxJQUFJLEdBQUcsS0FBSyxVQUFVLEVBQUU7b0JBQ3BCLE9BQU8sQ0FBQyxJQUFJLENBQUMsY0FBTyxHQUFHLGNBQUksVUFBVSxDQUFFLENBQUM7aUJBQzNDO2dCQUNELFVBQVUsR0FBRyxHQUFHLENBQUM7Z0JBRWpCLGtCQUFrQixFQUFFLENBQUM7Z0JBQ3JCLGFBQWEsR0FBRyxNQUFNLENBQUMsVUFBVSxDQUFDO29CQUM5QixrQkFBa0IsQ0FBQyxDQUFDLENBQUMsQ0FBQztvQkFDdEIsSUFBTSxPQUFPLEdBQWdCLFFBQVEsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7b0JBQ2pELFFBQVEsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7b0JBQ3ZCLE9BQU8sQ0FBQyxJQUFJLENBQUUsVUFBQyxRQUFhO3dCQUN4QixPQUFPLENBQUMsSUFBSSxDQUFDLHNCQUFzQixFQUFFLFFBQVEsQ0FBQyxDQUFDO3dCQUMvQywySEFBMkg7d0JBQzNILElBQUksZUFBZSxLQUFLLG9CQUFvQixJQUFJLFFBQVEsRUFBRTs0QkFDdEQsS0FBSyxHQUFHLFFBQVEsQ0FBQzs0QkFDakIsVUFBVSxHQUFHLEdBQUcsQ0FBQzs0QkFDakIsUUFBUSxHQUFHLEtBQUssQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQzs0QkFDbkQsTUFBTSxFQUFFLENBQUM7eUJBQ1o7d0JBQ0Qsa0JBQWtCLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQzt3QkFDdkIsYUFBYSxDQUFDLE9BQU8sQ0FBQyxDQUFDO29CQUMzQixDQUFDLENBQUMsQ0FBQyxPQUFLLEVBQUMsVUFBQyxNQUFNO3dCQUNaLE9BQU8sQ0FBQyxJQUFJLENBQUMscUJBQXFCLEVBQUUsTUFBTSxDQUFDLENBQUM7d0JBQzVDLGtCQUFrQixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7d0JBQ3ZCLGFBQWEsQ0FBQyxPQUFPLENBQUMsQ0FBQztvQkFDM0IsQ0FBQyxDQUFDLENBQUM7Z0JBRVAsQ0FBQyxFQUFFLE9BQU8scUJBQTBCLENBQUMsQ0FBQyxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7YUFDOUQ7aUJBQU07Z0JBQ0gsT0FBTyxDQUFDLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO2dCQUNsQyxLQUFLLEVBQUUsQ0FBQzthQUVYO1FBQ0wsQ0FBQztRQUVELFNBQVMsZ0JBQWdCO1lBQ3JCLHVIQUF1SDtZQUN2SCxVQUFVLENBQUM7Z0JBQ1AsSUFBSSxHQUFHLENBQUMsYUFBYSxLQUFLLEtBQUssRUFBRTtvQkFDN0IsS0FBSyxFQUFFLENBQUM7aUJBQ1g7WUFDTCxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUM7UUFDWixDQUFDO1FBRUQ7O1dBRUc7UUFDSCxTQUFTLENBQUMsZ0JBQWdCLENBQUMsV0FBVyxFQUFFLFVBQVMsR0FBVTtZQUN2RCxHQUFHLENBQUMsZUFBZSxFQUFFLENBQUM7WUFDdEIsR0FBRyxDQUFDLGNBQWMsRUFBRSxDQUFDO1FBQ3pCLENBQUMsQ0FBQyxDQUFDO1FBRUg7OztXQUdHO1FBQ0gsU0FBUyxDQUFDLGdCQUFnQixDQUFDLE9BQU8sRUFBRSxjQUFNLFlBQUssQ0FBQyxLQUFLLEVBQUUsRUFBYixDQUFhLENBQUMsQ0FBQztRQUV6RDs7V0FFRztRQUNILFNBQVMsT0FBTztZQUNaLEtBQUssQ0FBQyxtQkFBbUIsQ0FBQyxPQUFPLEVBQUUsaUJBQWlCLENBQUMsQ0FBQztZQUN0RCxLQUFLLENBQUMsbUJBQW1CLENBQUMsU0FBUyxFQUFFLG1CQUFtQixDQUFDLENBQUM7WUFDMUQsS0FBSyxDQUFDLG1CQUFtQixDQUFDLGNBQWMsRUFBRSxpQkFBdUQsQ0FBQyxDQUFDO1lBQ25HLEtBQUssQ0FBQyxtQkFBbUIsQ0FBQyxNQUFNLEVBQUUsZ0JBQWdCLENBQUMsQ0FBQztZQUNwRCxNQUFNLENBQUMsbUJBQW1CLENBQUMsUUFBUSxFQUFFLGtCQUFrQixDQUFDLENBQUM7WUFDekQsR0FBRyxDQUFDLG1CQUFtQixDQUFDLFFBQVEsRUFBRSxrQkFBa0IsRUFBRSxJQUFJLENBQUMsQ0FBQztZQUM1RCxrQkFBa0IsRUFBRSxDQUFDO1lBQ3JCLEtBQUssRUFBRSxDQUFDO1FBQ1osQ0FBQztRQUVELHVCQUF1QjtRQUN2QixLQUFLLENBQUMsZ0JBQWdCLENBQUMsU0FBUyxFQUFFLG1CQUFtQixDQUFDLENBQUM7UUFDdkQsS0FBSyxDQUFDLGdCQUFnQixDQUFDLGNBQWMsRUFBRSxpQkFBdUQsQ0FBQyxDQUFDO1FBQ2hHLEtBQUssQ0FBQyxnQkFBZ0IsQ0FBQyxNQUFNLEVBQUUsZ0JBQWdCLENBQUMsQ0FBQztRQUNqRCxLQUFLLENBQUMsZ0JBQWdCLENBQUMsT0FBTyxFQUFFLGlCQUFpQixDQUFDLENBQUM7UUFDbkQsTUFBTSxDQUFDLGdCQUFnQixDQUFDLFFBQVEsRUFBRSxrQkFBa0IsQ0FBQyxDQUFDO1FBQ3RELEdBQUcsQ0FBQyxnQkFBZ0IsQ0FBQyxRQUFRLEVBQUUsa0JBQWtCLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFFekQsT0FBTztZQUNILE9BQU87U0FDVixDQUFDO0lBQ04sQ0FBQztJQXhqQkQsa0NBd2pCQzs7Ozs7Ozs7Ozs7Ozs7Ozs7SUN0b0JELFNBQVMsc0JBQXNCLENBQUMsQ0FBUztRQUNyQyxJQUFNLE1BQU0sR0FBRyxFQUFFLENBQUM7UUFDbEIsSUFBSSxLQUFLLEdBQUcsRUFBRSxDQUFDO1FBQ2YsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7WUFDL0IsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssR0FBRyxJQUFJLEtBQUssQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO2dCQUNsQyxNQUFNLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO2dCQUNuQixLQUFLLEdBQUcsR0FBRyxDQUFDO2FBQ2Y7aUJBQU07Z0JBQ0gsS0FBSyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDZCxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxHQUFHLEVBQUU7b0JBQ2QsTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztvQkFDbkIsS0FBSyxHQUFHLEVBQUUsQ0FBQztpQkFDZDthQUNKO1NBQ0o7UUFDRCxNQUFNLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQ25CLE9BQU8sTUFBTSxDQUFDO0lBQ2xCLENBQUM7SUFFRCxTQUFnQixtQkFBbUIsQ0FBQyxDQUFTO1FBQ3pDLElBQU0sTUFBTSxHQUFHLHNCQUFzQixDQUFDLENBQUMsQ0FBQyxDQUFDO1FBRXpDLE9BQU8sQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7UUFDeEIsT0FBTyxVQUFDLEdBQVE7WUFDWixPQUFPLENBQUMsSUFBSSxDQUFDLHNEQUFzRCxDQUFDLENBQUM7WUFDckUsT0FBTyxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsR0FBRyxDQUFDLENBQUM7WUFFM0IsSUFBSSxNQUFNLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtnQkFDckIsT0FBTyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7YUFDekI7WUFDRCxDQUFDLEdBQUcsRUFBRSxDQUFDO1lBQ1AsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7Z0JBQ3BDLElBQU0sS0FBSyxHQUFHLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDeEIsSUFBSSxLQUFLLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxFQUFFO29CQUN2QixJQUFNLElBQUksR0FBRyxLQUFLLENBQUMsU0FBUyxDQUFDLENBQUMsRUFBRSxLQUFLLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDO29CQUNsRCxJQUFNLENBQUMsR0FBRyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUM7b0JBQ3BCLENBQUMsSUFBSSxDQUFDLENBQUM7aUJBQ1Y7cUJBQU07b0JBQ0gsQ0FBQyxJQUFJLEtBQUssQ0FBQztpQkFDZDthQUNKO1lBQ0QsT0FBTyxDQUFDLENBQUM7UUFDYixDQUFDLENBQUM7SUFDTixDQUFDO0lBeEJELGtEQXdCQztJQUFBLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUN0QkY7UUFVSSxrQkFBWSxHQUFXLEVBQUUsT0FBcUI7WUFUOUMsWUFBTyxHQUFpQjtnQkFDcEIsVUFBVSxFQUFFLFNBQVM7Z0JBQ3JCLGNBQWMsRUFBRSxDQUFDLFNBQVMsQ0FBQztnQkFDM0Isb0JBQW9CLEVBQUUsU0FBUztnQkFDL0Isa0JBQWtCLEVBQUUsU0FBUzthQUNoQztZQUtHLElBQUksQ0FBQyxPQUFPLHlCQUFRLElBQUksQ0FBQyxPQUFPLEdBQUssT0FBTyxDQUFFLENBQUM7WUFDL0MsSUFBSSxDQUFDLElBQUksR0FBRyxHQUFHLENBQUM7UUFDcEIsQ0FBQztRQUVELDBCQUFPLEdBQVAsVUFBUSxLQUFZO1lBQXBCLGlCQTRDQztZQTNDRyxJQUFJLElBQUksQ0FBQyxjQUFjLEVBQUU7Z0JBQ3JCLE9BQU8sQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUM7Z0JBQzVCLElBQUksQ0FBQyxjQUFjLENBQUMsS0FBSyxFQUFFLENBQUM7YUFDL0I7WUFDRCxJQUFNLE1BQU0sY0FDUixJQUFJLEVBQUUsUUFBUSxFQUNkLEdBQUcsRUFBRSxJQUFJLENBQUMsSUFBSSxFQUNkLEtBQUssRUFBRSxLQUFLLENBQUMsV0FBVyxFQUFFLElBQ3ZCLElBQUksQ0FBQyxPQUFPLENBQUMsb0JBQW9CLENBQ3ZDO1lBQ0QsSUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxVQUFVLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQyxNQUFNLENBQUMsQ0FBQztZQUNsRSxJQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsY0FBYyxHQUFHLElBQUksY0FBYyxFQUFFLENBQUM7WUFDdkQsSUFBTSxPQUFPLEdBQUcsSUFBSSxPQUFPLENBQUMsVUFBQyxPQUFPLEVBQUUsTUFBTTtnQkFDeEMsR0FBRyxDQUFDLFNBQVMsR0FBRztvQkFDWixJQUFJLEdBQUcsQ0FBQyxNQUFNLEtBQUssR0FBRyxFQUFFO3dCQUNwQixJQUFNLElBQUksR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxZQUFZLENBQUMsQ0FBQzt3QkFDMUMsSUFBTSxJQUFJLEdBQUcsS0FBSSxDQUFDLGVBQWUsQ0FBQyxJQUFJLEVBQUUsTUFBTSxDQUFDLENBQUM7d0JBQ2hELE9BQU8sQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7d0JBQ3pCLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztxQkFDakI7eUJBQ0k7d0JBQ0QsTUFBTSxDQUFDOzRCQUNILE1BQU0sRUFBRSxHQUFHLENBQUMsTUFBTTs0QkFDbEIsVUFBVSxFQUFFLEdBQUcsQ0FBQyxVQUFVO3lCQUM3QixDQUFDLENBQUM7cUJBQ047Z0JBQ0wsQ0FBQyxDQUFDO2dCQUNGLEdBQUcsQ0FBQyxPQUFPLEdBQUcsVUFBVSxFQUFFO29CQUN0QixNQUFNLENBQUM7d0JBQ0gsTUFBTSxFQUFFLElBQUksQ0FBQyxNQUFNO3dCQUNuQixVQUFVLEVBQUUsR0FBRyxDQUFDLFVBQVU7d0JBQzFCLEtBQUssRUFBRSxFQUFFO3FCQUNaLENBQUMsQ0FBQztnQkFDUCxDQUFDLENBQUM7Z0JBQ0YsR0FBRyxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsR0FBRyxDQUFDLENBQUM7Z0JBQ3JCLE9BQU8sQ0FBQyxJQUFJLENBQUMsd0JBQWdCLEdBQUcsT0FBRyxDQUFDLENBQUM7Z0JBQ3JDLEdBQUcsQ0FBQyxJQUFJLEVBQUUsQ0FBQztZQUNmLENBQUMsQ0FBQyxDQUFDO1lBQ0gsT0FBTyxDQUFDLFFBQVEsQ0FBQyxHQUFHO2dCQUNoQixHQUFHLENBQUMsS0FBSyxFQUFFLENBQUM7Z0JBQ1osT0FBTyxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQztZQUNqQyxDQUFDO1lBQ0QsT0FBTyxPQUFPLENBQUM7UUFDbkIsQ0FBQztRQUNEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7TUFpQ0Y7UUFDRSwwQkFBTyxHQUFQLFVBQVEsS0FBWTtZQUNoQixPQUFPLElBQUksQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDL0IsQ0FBQztRQUVELDBCQUFPLEdBQVAsVUFBUSxNQUFlLEVBQUUsS0FBSyxFQUFFLEVBQVcsRUFBRSxPQUFXO1lBQXhELGlCQXNCQztZQXJCRyxJQUFNLEVBQUUsR0FBRyxNQUFNLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBQ2hDLElBQUksTUFBTSxHQUFHO2dCQUNULElBQUksRUFBRSxTQUFTO2dCQUNmLEdBQUcsRUFBRSxJQUFJLENBQUMsSUFBSTtnQkFDZCxLQUFLLEVBQUUsTUFBTSxDQUFDLEdBQUcsR0FBRyxHQUFHLEdBQUcsTUFBTSxDQUFDLEdBQUc7Z0JBQ3BDLElBQUksRUFBRSxFQUFFLENBQUMsT0FBTyxFQUFFLEdBQUcsR0FBRyxHQUFHLEVBQUUsQ0FBQyxRQUFRLEVBQUUsR0FBRyxHQUFHLEdBQUcsRUFBRSxDQUFDLE9BQU8sRUFBRSxHQUFHLEdBQUcsR0FBRyxFQUFFLENBQUMsUUFBUSxFQUFFO2dCQUNuRixTQUFTLEVBQUUsTUFBTTthQUNwQixDQUFDO1lBQ0YsTUFBTSx5QkFBUSxJQUFJLENBQUMsT0FBTyxDQUFDLGtCQUFrQixHQUFLLE1BQU0sQ0FBRSxDQUFDO1lBRTNELElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxVQUFVLEVBQUUsTUFBTSxDQUFDLENBQUMsSUFBSSxDQUMvQyxjQUFJO2dCQUNBLEVBQUUsQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLEtBQUksQ0FBQyxzQkFBc0IsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO1lBQ3hELENBQUMsQ0FDSixDQUFDO1lBRUYsV0FBVztZQUNYLCtCQUErQjtZQUMvQixjQUFjO1lBQ2QsNkVBQTZFO1lBQzdFLEtBQUs7UUFDVCxDQUFDO1FBRUQsa0NBQWUsR0FBZixVQUFnQixJQUFJLEVBQUUsS0FBSztZQUV2Qiw4REFBOEQ7WUFDOUQsSUFBTSxPQUFPLEdBQUcsRUFBRSxDQUFDO1lBQ25CLElBQU0sS0FBSyxHQUFHLEtBQUssQ0FBQyxPQUFLLEVBQUM7WUFFMUIsNkJBQTZCO1lBQzdCLElBQUksSUFBSSxJQUFJLElBQUksQ0FBQyxRQUFRLEVBQUU7Z0JBQ3ZCLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtvQkFDM0MsSUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQztvQkFDM0IsSUFBSSxDQUFDLENBQUMsVUFBVSxDQUFDLFlBQVksS0FBSyxTQUFTLEVBQUU7d0JBQ3pDLE9BQU8sQ0FBQyxJQUFJLENBQUM7NEJBQ1QsSUFBSSxFQUFFLElBQUksQ0FBQywwQkFBMEIsQ0FBQyxDQUFDLENBQUM7NEJBQ3hDLEtBQUssRUFBRSxDQUFDLENBQUMsVUFBVSxDQUFDLFlBQVk7NEJBQ2hDLDhFQUE4RTs0QkFDOUUsT0FBTyxFQUFFLENBQUM7eUJBR2IsQ0FBQyxDQUFDO3FCQUNOO3lCQUFNLElBQUksQ0FBQyxDQUFDLFVBQVUsQ0FBQyxZQUFZLEtBQUssUUFBUSxFQUFFO3dCQUMvQyxPQUFPLENBQUMsSUFBSSxDQUFDOzRCQUNULElBQUksRUFBRSxJQUFJLENBQUMsMEJBQTBCLENBQUMsQ0FBQyxDQUFDOzRCQUN4QyxLQUFLLEVBQUUsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxZQUFZOzRCQUNoQyw4RUFBOEU7NEJBQzlFLE9BQU8sRUFBRSxDQUFDO3lCQUdiLENBQUMsQ0FBQztxQkFDTjt5QkFBTSxJQUFJLENBQUMsQ0FBQyxVQUFVLENBQUMsWUFBWSxLQUFLLGNBQWMsRUFBRTt3QkFDckQsT0FBTyxDQUFDLElBQUksQ0FBQzs0QkFDVCxJQUFJLEVBQUUsSUFBSSxDQUFDLCtCQUErQixDQUFDLENBQUMsQ0FBQzs0QkFDN0MsS0FBSyxFQUFFLENBQUMsQ0FBQyxVQUFVLENBQUMsWUFBWTs0QkFDaEMsOEVBQThFOzRCQUM5RSxPQUFPLEVBQUUsQ0FBQzt5QkFHYixDQUFDLENBQUM7cUJBQ047eUJBQU0sSUFBSSxDQUFDLENBQUMsVUFBVSxDQUFDLFlBQVksS0FBSyxVQUFVLEVBQUU7d0JBQ2pELE9BQU8sQ0FBQyxJQUFJLENBQUM7NEJBQ1QsSUFBSSxFQUFFLElBQUksQ0FBQywyQkFBMkIsQ0FBQyxDQUFDLENBQUM7NEJBQ3pDLEtBQUssRUFBRSxDQUFDLENBQUMsVUFBVSxDQUFDLFlBQVk7NEJBQ2hDLDhFQUE4RTs0QkFDOUUsT0FBTyxFQUFFLENBQUM7eUJBR2IsQ0FBQyxDQUFDO3FCQUNOO3lCQUFNO3dCQUNILE9BQU8sQ0FBQyxJQUFJLENBQUM7NEJBQ1QsSUFBSSxFQUFFLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDLENBQUM7NEJBQ2pDLEtBQUssRUFBRSxDQUFDLENBQUMsVUFBVSxDQUFDLFlBQVk7NEJBQ2hDLDhFQUE4RTs0QkFDOUUsT0FBTyxFQUFFLENBQUM7eUJBR2IsQ0FBQyxDQUFDO3FCQUNOO2lCQUNKO2FBQ0o7WUFDRCxPQUFPLE9BQU8sQ0FBQztRQUNuQixDQUFDO1FBRUQseUNBQXNCLEdBQXRCLFVBQXVCLElBQUk7WUFDdkIsSUFBTSxPQUFPLEdBQUcsRUFBRSxDQUFDO1lBQ25CLElBQUksSUFBSSxJQUFJLElBQUksQ0FBQyxRQUFRLEVBQUU7Z0JBQ3ZCLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtvQkFDM0MsSUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQztvQkFDM0IsSUFBSSxDQUFDLENBQUMsVUFBVSxDQUFDLFlBQVksS0FBSyxTQUFTLEVBQUU7d0JBQ3pDLE9BQU8sQ0FBQyxJQUFJLENBQUM7NEJBQ1QsSUFBSSxFQUFFLElBQUksQ0FBQywwQkFBMEIsQ0FBQyxDQUFDLENBQUM7NEJBQ3hDLElBQUksRUFBRSxJQUFJLENBQUMsT0FBTyxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVM7NEJBQzFFLE9BQU8sRUFBRSxDQUFDOzRCQUNWLFVBQVUsRUFBRSxDQUFDLENBQUMsVUFBVTs0QkFDeEIsTUFBTSxFQUFFLElBQUksQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsUUFBUSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQzt5QkFDN0UsQ0FBQyxDQUFDO3FCQUNOO2lCQUNKO2FBQ0o7WUFDRCxPQUFPLE9BQU8sQ0FBQztRQUNuQixDQUFDO1FBRUQsOENBQTJCLEdBQTNCLFVBQTRCLENBQUM7WUFDekIsSUFBTSxJQUFJLEdBQUcsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxlQUFlLENBQUMsQ0FBQztZQUMzQyxJQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBQzlCLE9BQU8sQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUM7UUFDckQsQ0FBQztRQUVELGtEQUErQixHQUEvQixVQUFnQyxDQUFDO1lBQzdCLElBQU0sYUFBYSxHQUFHLENBQUMsQ0FBQyxVQUFVLENBQUMsZUFBZSxDQUFDLENBQUM7WUFDcEQsSUFBTSxpQkFBaUIsR0FBRyxDQUFDLENBQUMsVUFBVSxDQUFDLG1CQUFtQixDQUFDLENBQUM7WUFFNUQsSUFBTSxHQUFHLEdBQUcsYUFBYSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUN2QyxJQUFJLElBQUksR0FBRyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsYUFBYSxDQUFDLFNBQVMsQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLGFBQWEsQ0FBQztZQUN2RSxJQUFJLGlCQUFpQixJQUFJLElBQUksS0FBSyxpQkFBaUIsRUFBRTtnQkFDakQsSUFBSSxJQUFJLElBQUksR0FBRyxpQkFBaUIsQ0FBQzthQUNwQztZQUNELE9BQU8sSUFBSSxDQUFDO1FBQ2hCLENBQUM7UUFFRCw2Q0FBMEIsR0FBMUIsVUFBMkIsQ0FBQztZQUN4QixJQUFNLGFBQWEsR0FBRyxDQUFDLENBQUMsVUFBVSxDQUFDLGVBQWUsQ0FBQyxDQUFDO1lBQ3BELElBQU0saUJBQWlCLEdBQUcsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO1lBQzVELElBQU0sWUFBWSxHQUFHLENBQUMsQ0FBQyxVQUFVLENBQUMsY0FBYyxDQUFDLENBQUM7WUFDbEQsSUFBTSxHQUFHLEdBQUcsYUFBYSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUN2QywyQ0FBMkM7WUFDM0MsSUFBSSxJQUFJLEdBQUcsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLGFBQWEsQ0FBQyxTQUFTLENBQUMsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxhQUFhLENBQUM7WUFFdkUsSUFBSSxpQkFBaUIsSUFBSSxJQUFJLEtBQUssaUJBQWlCLEVBQUU7Z0JBQ2pELElBQUksSUFBSSxJQUFJLEdBQUcsaUJBQWlCLENBQUM7YUFDcEM7WUFDRCxJQUFJLElBQUksSUFBSSxHQUFHLFlBQVksQ0FBQztZQUM1QixPQUFPLElBQUksQ0FBQztRQUNoQixDQUFDO1FBRUQsNkNBQTBCLEdBQTFCLFVBQTJCLENBQUM7WUFDeEIsSUFBTSxhQUFhLEdBQUcsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxlQUFlLENBQUMsQ0FBQztZQUNwRCxJQUFNLGlCQUFpQixHQUFHLENBQUMsQ0FBQyxVQUFVLENBQUMsbUJBQW1CLENBQUMsQ0FBQztZQUM1RCxJQUFNLFlBQVksR0FBRyxDQUFDLENBQUMsVUFBVSxDQUFDLGNBQWMsQ0FBQyxDQUFDO1lBQ2xELElBQU0sR0FBRyxHQUFHLGFBQWEsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDdkMsSUFBSSxJQUFJLEdBQUcsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLGFBQWEsQ0FBQyxTQUFTLENBQUMsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxhQUFhLENBQUM7WUFFdkUsSUFBSSxpQkFBaUIsSUFBSSxJQUFJLEtBQUssaUJBQWlCLEVBQUU7Z0JBQ2pELElBQUksSUFBSSxJQUFJLEdBQUcsaUJBQWlCLENBQUM7YUFDcEM7WUFDRCxJQUFJLElBQUksSUFBSSxHQUFHLFlBQVksQ0FBQztZQUU1QixJQUFNLFVBQVUsR0FBRyxDQUFDLENBQUMsVUFBVSxDQUFDLFlBQVksQ0FBQyxDQUFDO1lBQzlDLElBQU0saUJBQWlCLEdBQUcsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO1lBQzVELElBQUksVUFBVSxFQUFFO2dCQUNaLElBQUksSUFBSSxHQUFHLEdBQUcsVUFBVSxDQUFDO2FBQzVCO1lBQ0QsSUFBSSxpQkFBaUIsRUFBRTtnQkFDbkIsSUFBSSxJQUFJLGlCQUFpQixDQUFDO2FBQzdCO1lBRUQsT0FBTyxJQUFJLENBQUM7UUFDaEIsQ0FBQztRQUVELHNDQUFtQixHQUFuQixVQUFvQixDQUFDO1lBQ2pCLElBQUksSUFBVyxDQUFDO1lBQ2hCLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsSUFBSSxJQUFJLENBQUMsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLGNBQWMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7Z0JBQ2xFLElBQUksR0FBRyxDQUFDLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7YUFDdkQ7WUFDRCxJQUFJLENBQUMsQ0FBQyxVQUFVLENBQUMsWUFBWSxLQUFLLGNBQWMsSUFBSSxDQUFDLENBQUMsVUFBVSxDQUFDLFlBQVksS0FBSyxVQUFVLEVBQUU7Z0JBQzFGLElBQUksR0FBRyxHQUFHLENBQUMsQ0FBQyxVQUFVLENBQUMsU0FBUyxDQUFDLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDO2dCQUMvQyxJQUFJLEdBQUcsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsU0FBUyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxTQUFTLENBQUMsQ0FBQzthQUMxRjtZQUNELE9BQU8sSUFBSSxDQUFDO1FBQ2hCLENBQUM7UUFDTCxlQUFDO0lBQUQsQ0FBQztJQTlRWSw0QkFBUTs7Ozs7Ozs7Ozs7Ozs7Ozs7SUNuQnJCO1FBTUksdUJBQVksS0FBWSxFQUFFLE9BQW1CO1lBQ3pDLElBQUksQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDO1lBQ25CLElBQUksQ0FBQyxPQUFPLEdBQUcsT0FBTyxDQUFDO1FBQzNCLENBQUM7UUFFRCw4QkFBTSxHQUFOO1lBQ0ksSUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLEdBQUcsR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQ3JELEdBQUcsQ0FBQyxTQUFTLEdBQUcsZ0JBQWdCLENBQUM7WUFDakMsSUFBTSxRQUFRLEdBQUcsNEJBQWlCLEVBQUMsS0FBSyxFQUFFLEdBQUcsQ0FBQyxDQUFDO1lBQy9DLElBQU0sSUFBSSxHQUFHLDRCQUFpQixFQUFDLE1BQU0sRUFBRSxRQUFRLENBQUMsQ0FBQztZQUNqRCxJQUFNLENBQUMsR0FBRyw0QkFBaUIsRUFBQyxNQUFNLEVBQUUsUUFBUSxFQUFFLE1BQU0sQ0FBQyxDQUFDO1lBQ3RELElBQUksQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQztZQUM1QixRQUFRLENBQUMsZ0JBQWdCLENBQUMsT0FBTyxFQUFFLFVBQUMsR0FBRyxJQUFJLEdBQUcsQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxHQUFDLENBQUMsQ0FBQztZQUM1RSxJQUFJLElBQUksQ0FBQyxPQUFPLEVBQUU7Z0JBQ2QsR0FBRyxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7YUFDakM7WUFDRCxPQUFPLEdBQUcsQ0FBQztRQUNmLENBQUM7UUFFRCxvQ0FBWSxHQUFaLFVBQWEsUUFBZ0I7WUFDekIsSUFBSSxRQUFRLEVBQUU7Z0JBQ1YsSUFBSSxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQzthQUN0QztpQkFBTTtnQkFDSCxJQUFJLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDO2FBQ25DO1FBQ0wsQ0FBQztRQUVMLG9CQUFDO0lBQUQsQ0FBQztJQWpDWSxzQ0FBYTtJQWtDMUI7UUFJSSxtQkFBWSxLQUFxQjtZQUM3QixJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztRQUN2QixDQUFDO1FBRUQsMEJBQU0sR0FBTjtZQUNJLElBQU0sR0FBRyxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDMUMsR0FBRyxDQUFDLFNBQVMsR0FBRyxXQUFXLENBQUM7WUFDNUIsSUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQztZQUN6QixLQUFLLElBQUksQ0FBQyxHQUFDLENBQUMsRUFBRSxDQUFDLEdBQUMsS0FBSyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtnQkFDL0IsSUFBTSxPQUFPLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDO2dCQUNsQyxJQUFJLENBQUMsS0FBRyxDQUFDLEVBQUU7b0JBQ1AsT0FBTyxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLENBQUM7aUJBQ25DO2dCQUNELEdBQUcsQ0FBQyxXQUFXLENBQUMsT0FBTyxDQUFDLENBQUM7YUFDNUI7WUFDRCxPQUFPLEdBQUcsQ0FBQztRQUNmLENBQUM7UUFFTCxnQkFBQztJQUFELENBQUM7SUF0QlksOEJBQVM7Ozs7Ozs7Ozs7Ozs7Ozs7O0lDdEJ0QjtRQXNCSSxjQUFZLEtBQXNCLEVBQUUsS0FBZ0I7WUFBcEQsaUJBd0JDO1lBeENELGVBQVUsR0FBaUIsd0JBQWEsQ0FBQyxNQUFNLENBQUM7WUFNaEQsc0JBQWlCLEdBQUcsSUFBSSx1Q0FBZSxFQUE2QixDQUFDO1lBRXJFLFNBQUksR0FBbUIsSUFBSSxDQUFDO1lBRTVCLFVBQUssR0FBb0IsRUFBRSxDQUFDO1lBUXhCLElBQUksS0FBSyxFQUFFO2dCQUNQLEtBQUssSUFBSSxDQUFDLElBQUksS0FBSyxFQUFFO29CQUNqQixJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQztpQkFDckI7Z0JBQ0QsSUFBSSxLQUFLLENBQUMsaUJBQWlCLEVBQUU7b0JBQ3pCLElBQUksQ0FBQyx3QkFBd0IsR0FBRyxVQUFDLElBQUksRUFBRSxRQUFRLElBQUssWUFBSSxDQUFDLGtCQUFrQixDQUFDLElBQUksRUFBRSxRQUFRLENBQUMsRUFBdkMsQ0FBdUMsQ0FBQztpQkFDL0Y7YUFDSjtZQUNELElBQUksQ0FBQywwQkFBMEIsR0FBRyxVQUFDLElBQUksRUFBRSxNQUFNLElBQUssWUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLEVBQUUsTUFBTSxDQUFDLEVBQS9CLENBQStCLENBQUM7WUFDcEYsSUFBSSxLQUFLLEVBQUU7Z0JBQ1AsSUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7Z0JBQ25CLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEtBQUssR0FBRyxLQUFLLENBQUMsTUFBTSxFQUFFLENBQUMsR0FBRyxLQUFLLEVBQUUsQ0FBQyxFQUFFLEVBQUU7b0JBQ2xELEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDO29CQUN0QixLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsaUJBQWlCLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQywwQkFBMEIsQ0FBQyxDQUFDO29CQUN0RSxJQUFJLElBQUksQ0FBQyxpQkFBaUIsRUFBRTt3QkFDeEIsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLGNBQWMsQ0FBQyxTQUFTLENBQUUsSUFBSSxDQUFDLHdCQUF3QixDQUFFLENBQUM7cUJBQ3RFO2lCQUNKO2FBQ0o7aUJBQ0k7Z0JBQ0QsSUFBSSxDQUFDLEtBQUssR0FBRyxFQUFFLENBQUM7YUFDbkI7UUFDTCxDQUFDO1FBRUQsc0JBQU8sR0FBUDtZQUNJLElBQU0sSUFBSSxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDM0MsSUFBSSxDQUFDLFNBQVMsR0FBRyxlQUFlO1lBQ2hDLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEtBQUssR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sRUFBRSxDQUFDLEdBQUcsS0FBSyxFQUFFLENBQUMsRUFBRSxFQUFFO2dCQUN2RCxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQzthQUM1QztZQUNELE9BQU8sSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUM7UUFDNUIsQ0FBQztRQUdELHdCQUFTLEdBQVQsVUFBVSxTQUEyQixFQUFFLFFBQTBCO1lBQWpFLGlCQUlDO1lBSEcsSUFBSSxDQUFDLE1BQU0sRUFBRTtZQUNiLElBQUksQ0FBQyxHQUFHLGNBQU0sWUFBSSxDQUFDLE1BQU0sRUFBRSxFQUFiLENBQWE7WUFDM0IsTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDO1FBQzdCLENBQUM7UUFHRCxzQkFBTyxHQUFQO1lBQ0ksSUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQztZQUN2QixJQUFNLFNBQVMsR0FBRyxFQUFFLENBQUM7WUFFckIsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsS0FBSyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxFQUFFLENBQUMsR0FBRyxLQUFLLEVBQUUsQ0FBQyxFQUFFLEVBQUU7Z0JBQ3ZELFNBQVMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDO2FBQzFDO1lBQ0QsSUFBSSxDQUFDLGVBQWUsT0FBcEIsSUFBSSxFQUFvQixTQUFTLEVBQUU7WUFDbkMsT0FBTyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUM7WUFDdkIsT0FBTyxJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQztRQUM1QixDQUFDO1FBRUQseUJBQVUsR0FBVixVQUFXLENBQVU7WUFDakIsT0FBTyxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUM7WUFDMUIsSUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDbEMsSUFBSSxHQUFHLEdBQUMsQ0FBQyxFQUFFO2dCQUNQLElBQU0sU0FBUyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxHQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUNwQyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsR0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7Z0JBQ3RCLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLEdBQUcsU0FBUyxDQUFDO2FBQy9CO1lBQ0QsSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDO1FBQ25CLENBQUM7UUFDRCwyQkFBWSxHQUFaLFVBQWEsQ0FBVTtZQUNuQixPQUFPLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQztZQUM1QixJQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNsQyxJQUFJLEdBQUcsR0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sR0FBQyxDQUFDLEVBQUU7Z0JBQ3pCLElBQU0sU0FBUyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxHQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUNwQyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsR0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7Z0JBQ3RCLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLEdBQUcsU0FBUyxDQUFDO2FBQy9CO1lBQ0QsSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDO1FBQ25CLENBQUM7UUFFRCxxQkFBTSxHQUFOO1lBQ0ksdUZBQXVGO1lBQ3ZGLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEtBQUssR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sRUFBRSxDQUFDLEdBQUcsS0FBSyxFQUFFLENBQUMsRUFBRSxFQUFFO2dCQUN2RCxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDO2FBQzFCO1FBQ0wsQ0FBQztRQUVELHNCQUFPLEdBQVAsVUFBUSxJQUFjO1lBQ2xCLGlDQUFpQztZQUNqQyxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQztZQUNsQixJQUFJLENBQUMsaUJBQWlCLENBQUMsU0FBUyxDQUFFLElBQUksQ0FBQywwQkFBMEIsQ0FBRSxDQUFDO1lBQ3BFLElBQUksSUFBSSxDQUFDLGlCQUFpQixFQUFFO2dCQUN4QixJQUFJLENBQUMsY0FBYyxDQUFDLFNBQVMsQ0FBRSxJQUFJLENBQUMsd0JBQXdCLENBQUUsQ0FBQzthQUNsRTtZQUNELElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQztZQUNyQixJQUFJLElBQUksQ0FBQyxJQUFJLEVBQUU7Z0JBQ1gsSUFBSSxFQUFFLEdBQUcsSUFBSSxDQUFDLE1BQU0sRUFBRTtnQkFDdEIsSUFBSSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsRUFBRSxDQUFDLENBQUM7YUFDN0I7UUFDTCxDQUFDO1FBRUQsdUJBQVEsR0FBUixVQUFTLEtBQWlCO1lBQ3RCLGlDQUFpQztZQUNqQyxJQUFNLFFBQVEsR0FBYyxFQUFFLENBQUM7WUFDL0IsSUFBTSxDQUFDLEdBQUcsUUFBUSxDQUFDLHNCQUFzQixFQUFFLENBQUM7WUFDNUMsS0FBSyxJQUFJLENBQUMsR0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFDLEtBQUssQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7Z0JBQy9CLElBQU0sSUFBSSxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUM7Z0JBQ3JCLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDO2dCQUNsQixJQUFJLENBQUMsaUJBQWlCLENBQUMsU0FBUyxDQUFFLElBQUksQ0FBQywwQkFBMEIsQ0FBRSxDQUFDO2dCQUNwRSxJQUFJLElBQUksQ0FBQyxpQkFBaUIsRUFBRTtvQkFDeEIsSUFBSSxDQUFDLGNBQWMsQ0FBQyxTQUFTLENBQUUsSUFBSSxDQUFDLHdCQUF3QixDQUFFLENBQUM7aUJBQ2xFO2dCQUNELElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQztnQkFDckIsUUFBUSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztnQkFDcEIsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQzthQUNoQztZQUNELElBQUksSUFBSSxDQUFDLElBQUksRUFBRTtnQkFFWCx5QkFBeUI7Z0JBQ3pCLElBQUksQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDO2FBQzVCO1FBQ0wsQ0FBQztRQUVELHlCQUFVLEdBQVYsVUFBVyxJQUFjLEVBQUUsR0FBVTtZQUNqQyxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQztZQUNsQixJQUFJLENBQUMsaUJBQWlCLENBQUMsU0FBUyxDQUFFLElBQUksQ0FBQywwQkFBMEIsQ0FBRSxDQUFDO1lBQ3BFLElBQUksSUFBSSxDQUFDLGlCQUFpQixFQUFFO2dCQUN4QixJQUFJLENBQUMsY0FBYyxDQUFDLFNBQVMsQ0FBRSxJQUFJLENBQUMsd0JBQXdCLENBQUUsQ0FBQzthQUNsRTtZQUNELElBQUksS0FBSyxHQUFtQixFQUFFLENBQUM7WUFDL0IsS0FBSyxJQUFJLENBQUMsR0FBQyxDQUFDLEVBQUUsS0FBSyxHQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxFQUFFLENBQUMsR0FBQyxLQUFLLEVBQUUsQ0FBQyxFQUFFLEVBQUU7Z0JBQ2pELElBQUksQ0FBQyxLQUFHLEdBQUcsRUFBRTtvQkFDVCxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO2lCQUNwQjtnQkFDRCxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQzthQUM3QjtZQUNELElBQUksR0FBRyxHQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxFQUFFO2dCQUN2QixJQUFJLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLEVBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUM7YUFDN0Q7aUJBQ0k7Z0JBQ0QsSUFBSSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDO2FBQ3ZDO1lBQ0QsSUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLO1FBQ3RCLENBQUM7UUFFRCx1QkFBUSxHQUFSLFVBQVMsSUFBUSxFQUFFLElBQWM7WUFDN0IsSUFBSSxLQUFLLEdBQW1CLElBQUksRUFBQyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUM7WUFDM0QsSUFBSSxLQUFLLEVBQUU7Z0JBQ1AsS0FBSyxJQUFJLENBQUMsR0FBQyxDQUFDLEVBQUUsS0FBSyxHQUFDLEtBQUssQ0FBQyxNQUFNLEVBQUUsQ0FBQyxHQUFDLEtBQUssRUFBRSxDQUFDLEVBQUUsRUFBRTtvQkFDNUMsSUFBSSxJQUFJLEtBQUssS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksRUFBRTt3QkFDeEIsT0FBTyxLQUFLLENBQUMsQ0FBQyxDQUFDO3FCQUNsQjt5QkFDSTt3QkFDRCxJQUFJLE1BQUksR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7d0JBQ3hDLElBQUksTUFBSSxFQUFFOzRCQUNOLE9BQU8sTUFBSSxDQUFDO3lCQUNmO3FCQUNKO2lCQUNKO2FBQ0o7WUFDRCxPQUFPLElBQUk7UUFDZixDQUFDO1FBRUQseUJBQVUsR0FBVixVQUFXLElBQVEsRUFBRSxJQUFZO1lBQzdCLEtBQUssSUFBSSxDQUFDLEdBQUMsQ0FBQyxFQUFFLEtBQUssR0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sRUFBRSxDQUFDLEdBQUMsS0FBSyxFQUFFLENBQUMsRUFBRSxFQUFFO2dCQUNqRCxJQUFJLFFBQVEsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUM7Z0JBQ3BELElBQUksUUFBUSxFQUFFO29CQUNYLE9BQU8sUUFBUSxDQUFDO2lCQUNsQjthQUNKO1FBQ0wsQ0FBQztRQUNELDJCQUFZLEdBQVosVUFBYSxJQUFRLEVBQUUsSUFBWTtZQUMvQixLQUFLLElBQUksQ0FBQyxHQUFDLENBQUMsRUFBRSxLQUFLLEdBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLEVBQUUsQ0FBQyxHQUFDLEtBQUssRUFBRSxDQUFDLEVBQUUsRUFBRTtnQkFDakQsSUFBSSxRQUFRLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxZQUFZLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDO2FBQ3pEO1FBQ0wsQ0FBQztRQUVELGtDQUFtQixHQUFuQixVQUFvQixJQUFRLEVBQUUsSUFBWTtZQUN0QyxLQUFLLElBQUksQ0FBQyxHQUFDLENBQUMsRUFBRSxLQUFLLEdBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLEVBQUUsQ0FBQyxHQUFDLEtBQUssRUFBRSxDQUFDLEVBQUUsRUFBRTtnQkFDakQsSUFBSSxRQUFRLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQztnQkFDbkQsd0NBQXdDO2dCQUN4QyxJQUFJLFFBQVEsRUFBRTtvQkFDVixPQUFPLFFBQVEsQ0FBQztpQkFDbkI7YUFDSjtRQUNMLENBQUM7UUFFRCx3QkFBUyxHQUFUO1lBQ0ksS0FBSyxJQUFJLENBQUMsR0FBQyxDQUFDLEVBQUUsS0FBSyxHQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxFQUFFLENBQUMsR0FBQyxLQUFLLEVBQUUsQ0FBQyxFQUFFLEVBQUU7Z0JBQ2pELElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxFQUFFLENBQUM7YUFDMUI7UUFDTCxDQUFDO1FBRUQseUJBQVUsR0FBVixVQUFXLElBQWM7WUFDckIsb0NBQW9DO1lBQ3BDLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDO1lBQ2xCLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLDBCQUEwQixDQUFDLENBQUM7WUFDcEUsSUFBSSxJQUFJLENBQUMsaUJBQWlCLEVBQUU7Z0JBQ3hCLElBQUksQ0FBQyxjQUFjLENBQUMsV0FBVyxDQUFFLElBQUksQ0FBQyx3QkFBd0IsQ0FBRSxDQUFDO2FBQ3BFO1lBQ0QsbURBQW1EO1lBRW5ELElBQUksSUFBSSxDQUFDLE1BQU0sRUFBRTtnQkFDYixJQUFJLENBQUMsTUFBTSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUM7YUFDakM7aUJBQ0k7Z0JBQ0QsSUFBSSxLQUFLLEdBQW1CLEVBQUU7Z0JBQzlCLEtBQUssSUFBSSxDQUFDLEdBQUMsQ0FBQyxFQUFFLEtBQUssR0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sRUFBRSxDQUFDLEdBQUMsS0FBSyxFQUFFLENBQUMsRUFBRSxFQUFFO29CQUNqRCxJQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEtBQUcsSUFBSSxFQUFFO3dCQUN0QixLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztxQkFDN0I7eUJBQ0k7d0JBQ0QsT0FBTyxDQUFDLElBQUksQ0FBQyxhQUFhLEdBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztxQkFDaEQ7aUJBQ0o7Z0JBQ0QsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDO2dCQUNkLElBQUksQ0FBQyxLQUFLLEdBQUcsS0FBSzthQUNyQjtRQUdMLENBQUM7UUFFRCx1QkFBUSxHQUFSLFVBQVMsRUFBVztZQUNoQixJQUFJLENBQUMsTUFBTSxFQUFFO1FBQ2pCLENBQUM7UUFHRCxvQkFBSyxHQUFMLFVBQU0sSUFBaUI7WUFBdkIsaUJBU0M7WUFSRyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRTtnQkFDWixJQUFJLENBQUMsT0FBTyxFQUFFO2dCQUNkLE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQyxRQUFRLEVBQUUsVUFBQyxFQUFVLElBQUssWUFBSSxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUMsRUFBakIsQ0FBaUIsQ0FBQzthQUN2RTtZQUNELElBQUksSUFBSSxHQUFHLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQztZQUN6QixJQUFJLENBQUMsZ0JBQWdCLENBQUMsUUFBUSxFQUFFLFVBQUMsRUFBVSxJQUFLLFlBQUksQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDLEVBQWpCLENBQWlCLENBQUM7WUFDbEUsSUFBSSxDQUFDLGdCQUFnQixDQUFDLFFBQVEsRUFBRSxVQUFDLEVBQVUsSUFBSyxZQUFJLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxFQUFqQixDQUFpQixDQUFDO1lBQ2xFLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDO1FBQ25DLENBQUM7UUFFRCxzQkFBTyxHQUFQO1lBQ0ksT0FBTyxDQUFDLElBQUksQ0FBQyxJQUFJLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDNUYsQ0FBQztRQUVELG9DQUFxQixHQUFyQjtZQUNJLE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMscUJBQXFCLEVBQUUsQ0FBRSxDQUFDLENBQUMsSUFBSTtRQUM3RixDQUFDO1FBRUQscUJBQU0sR0FBTjtZQUNJLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQztRQUNyQixDQUFDO1FBRUQ7O1dBRUc7UUFDSCwwQkFBVyxHQUFYO1lBQ0ksSUFBSSxNQUFNLEdBQUcsRUFBRSxDQUFDO1lBQ2hCLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEtBQUssR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sRUFBRSxDQUFDLEdBQUcsS0FBSyxFQUFFLENBQUMsRUFBRSxFQUFFO2dCQUN2RCxNQUFNLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLFdBQVcsRUFBRSxDQUFDLENBQUM7YUFDdkQ7WUFDRCxPQUFPLE1BQU0sQ0FBQztRQUNsQixDQUFDO1FBR0QsaUNBQWtCLEdBQWxCLFVBQW1CLElBQWMsRUFBRSxRQUFpQjtZQUNoRCxPQUFPLENBQUMsSUFBSSxDQUFDLG9CQUFvQixDQUFDLENBQUM7WUFDbkMsSUFBSSxRQUFRLElBQUksSUFBSSxDQUFDLGlCQUFpQixFQUFFO2dCQUNwQyxJQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUNqRCxLQUFLLElBQUksQ0FBQyxHQUFDLENBQUMsRUFBRSxDQUFDLEdBQUMsS0FBSyxFQUFFLENBQUMsRUFBRSxFQUFFO29CQUN4QixJQUFJLElBQUksS0FBSyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFO3dCQUN4QixJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsRUFBRSxDQUFDO3FCQUM1QjtpQkFDSjthQUNKO1FBQ0wsQ0FBQztRQUdELHFDQUFxQztRQUNyQywyQkFBWSxHQUFaLFVBQWEsSUFBYSxFQUFFLE1BQXNCO1lBQzlDLHdLQUF3SztZQUN4SyxJQUFJLElBQUksQ0FBQyxVQUFVLEtBQUcsd0JBQWEsQ0FBQyxNQUFNLEVBQUU7Z0JBQ3hDLElBQUksSUFBSSxDQUFDLFlBQVksRUFBRTtvQkFDbkIsZ0dBQWdHO29CQUNoRyxJQUFJLElBQUksQ0FBQyxZQUFZLEtBQUcsSUFBSSxFQUFFO3dCQUMxQixJQUFJLENBQUMsWUFBWSxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsQ0FBQztxQkFDeEM7aUJBQ0o7Z0JBQ0QsSUFBSSxJQUFJLElBQUksSUFBSSxDQUFDLGVBQWUsS0FBRywwQkFBZSxDQUFDLFFBQVEsRUFBRTtvQkFDekQsSUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUM7b0JBQ3pCLDhCQUE4QjtvQkFDOUIsSUFBSSxDQUFDLGlCQUFpQixDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsWUFBWSxFQUFFLE1BQU0sQ0FBQyxDQUFDO2lCQUM5RDtxQkFDSTtvQkFDRCw4QkFBOEI7b0JBQzlCLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLE1BQU0sQ0FBQyxDQUFDO2lCQUNqRDthQUNKO2lCQUNJO2dCQUNELElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLE1BQU0sQ0FBQyxDQUFDO2FBQ2pEO1FBQ0wsQ0FBQztRQTFUTSxnQ0FBMkIsR0FBRyxxQkFBcUIsQ0FBQztRQUNwRCx3QkFBbUIsR0FBRyxlQUFlLENBQUM7UUFDdEMsMEJBQXFCLEdBQUcsaUJBQWlCLENBQUM7UUEwVHJELFdBQUM7S0FBQTtJQTlUWSxvQkFBSTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUNSakIsSUFBWSxhQU1YO0lBTkQsV0FBWSxhQUFhO1FBQ3JCLG1EQUFLO1FBQ0wscURBQU07UUFDTixtREFBSztRQUNMLDRDQUE0QztRQUM1QywrREFBVztJQUNmLENBQUMsRUFOVyxhQUFhLEdBQWIscUJBQWEsS0FBYixxQkFBYSxRQU14QjtJQW9DRCx1QkFBdUI7SUFHdkIsSUFBTSxjQUFjLEdBQWlCO1FBQ2pDLE1BQU0sRUFBRSxVQUFDLElBQWM7WUFDbkIsSUFBTSxHQUFHLEdBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUMxQyxJQUFJLE9BQU8sSUFBSSxDQUFDLElBQUksS0FBSyxRQUFRLEVBQUU7Z0JBQy9CLEdBQUcsQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQztnQkFDMUIsR0FBRyxDQUFDLE9BQU8sQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQztnQkFDaEMsR0FBRyxDQUFDLFlBQVksQ0FBQyxjQUFjLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO2dCQUM1QyxHQUFHLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUM7YUFDekI7aUJBQ0k7Z0JBQ0QsSUFBTSxHQUFHLEdBQUcsQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLEVBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUM7Z0JBQ25GLElBQUksQ0FBQyxHQUFHLEVBQUU7b0JBQ04sUUFBUTtpQkFDWDtnQkFDRCxHQUFHLENBQUMsU0FBUyxHQUFHLEdBQUcsQ0FBQztnQkFDcEIsR0FBRyxDQUFDLE9BQU8sQ0FBQyxPQUFPLEdBQUcsR0FBRyxDQUFDO2dCQUMxQixHQUFHLENBQUMsWUFBWSxDQUFDLGNBQWMsRUFBRSxHQUFHLENBQUMsQ0FBQztnQkFDdEMsR0FBRyxDQUFDLEtBQUssR0FBRyxHQUFHLENBQUM7YUFDbkI7WUFDRCxHQUFHLENBQUMsU0FBUyxHQUFHLFNBQVMsQ0FBQztZQUMxQixPQUFPLEdBQUc7UUFDZCxDQUFDO0tBQ0o7SUFFRCxJQUFZLGVBSVg7SUFKRCxXQUFZLGVBQWU7UUFDdkIsNkRBQVE7UUFDUixpRUFBVTtRQUNWLHVFQUFhO0lBQ2pCLENBQUMsRUFKVyxlQUFlLEdBQWYsdUJBQWUsS0FBZix1QkFBZSxRQUkxQjtJQUVEO1FBd0RJLGtCQUFZLElBQVMsRUFBRSxNQUF3QixFQUFFLE1BQXNCO1lBQXZFLGlCQThCQztZQS9FRCxzQkFBaUIsR0FBRyxJQUFJLHVDQUFlLEVBQTZCLENBQUM7WUFDckUsbUJBQWMsR0FBRyxJQUFJLHVDQUFlLEVBQXFCLENBQUM7WUFRMUQsaUJBQVksR0FBaUIsY0FBYyxDQUFDO1lBSzVDLDZCQUE2QjtZQUM3QixvQkFBZSxHQUFvQixlQUFlLENBQUMsVUFBVSxDQUFDO1lBSTlELG1CQUFjLEdBQUcsS0FBSyxDQUFDO1lBUXZCLGtCQUFhLEdBQUcsS0FBSztZQWtCckIsYUFBUSxHQUFHLFFBQVEsQ0FBQyxTQUFTLENBQUM7WUFFOUIsY0FBUyxHQUFZLElBQUksQ0FBQztZQUd0QixJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQztZQUNqQixJQUFJLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQztZQUNyQixJQUFJLENBQUMsMEJBQTBCLEdBQUcsVUFBQyxJQUFjLEVBQUUsZUFBZ0MsSUFBSyxZQUFJLENBQUMsYUFBYSxDQUFDLElBQUksRUFBRSxlQUFlLENBQUMsRUFBekMsQ0FBeUMsQ0FBQztZQUNsSSxJQUFJLE1BQU0sRUFBRTtnQkFDUixLQUFLLElBQUksQ0FBQyxJQUFJLE1BQU0sRUFBRTtvQkFDbEIsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxDQUFDLENBQUM7aUJBQ3RCO2dCQUNELElBQUksTUFBTSxDQUFDLGlCQUFpQixFQUFFO29CQUMxQixJQUFJLENBQUMsd0JBQXdCLEdBQUcsVUFBQyxJQUFJLEVBQUUsUUFBUSxJQUFLLFlBQUksQ0FBQyxrQkFBa0IsQ0FBQyxJQUFJLEVBQUUsUUFBUSxDQUFDLEVBQXZDLENBQXVDLENBQUM7aUJBQy9GO2FBQ0o7WUFFRCxJQUFJLE1BQU0sSUFBSSxNQUFNLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtnQkFDN0IsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsS0FBSyxHQUFHLE1BQU0sQ0FBQyxNQUFNLEVBQUUsQ0FBQyxHQUFHLEtBQUssRUFBRSxDQUFDLEVBQUUsRUFBRTtvQkFDbkQsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLGlCQUFpQixDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsMEJBQTBCLENBQUMsQ0FBQztvQkFDdkUsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUM7b0JBQ3hCLElBQUksTUFBTSxhQUFOLE1BQU0sdUJBQU4sTUFBTSxDQUFFLGlCQUFpQixFQUFFO3dCQUMzQixNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsY0FBYyxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsd0JBQXdCLENBQUMsQ0FBQztxQkFDckU7aUJBQ0o7YUFDSjtZQUVELElBQUksSUFBSSxDQUFDLE9BQU8sRUFBRTtnQkFDZCxJQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsT0FBTztnQkFDNUIsSUFBSSxDQUFDLEdBQUcsVUFBQyxHQUFHLElBQUssWUFBSSxDQUFDLGFBQWEsQ0FBQyxHQUFHLENBQUMsRUFBdkIsQ0FBdUI7Z0JBQ3hDLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxPQUFPLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO29CQUNyQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQztpQkFDNUI7YUFDSjtRQUNMLENBQUM7UUFHRCxnQ0FBYSxHQUFiLFVBQWMsR0FBRztZQUNiLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQztRQUNsQixDQUFDO1FBRUQsMEJBQU8sR0FBUDtZQUNJLElBQUksSUFBSSxDQUFDLElBQUksRUFBRTtnQkFDWCxPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFO2FBQzdCO1lBQ0QsT0FBTyxDQUFDLENBQUM7UUFDYixDQUFDO1FBRUQsMEJBQU8sR0FBUCxVQUFRLElBQVU7WUFDZCxJQUFJLENBQUMsSUFBSSxHQUFHLElBQUk7WUFDaEIsSUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLE1BQU07WUFDMUIsSUFBSSxNQUFNLElBQUksTUFBTSxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7Z0JBQzdCLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEtBQUssR0FBRyxNQUFNLENBQUMsTUFBTSxFQUFFLENBQUMsR0FBRyxLQUFLLEVBQUUsQ0FBQyxFQUFFLEVBQUU7b0JBQ25ELE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7aUJBQzNCO2FBQ0o7UUFDTCxDQUFDO1FBRUQsNEJBQVMsR0FBVCxVQUFVLE1BQXVCO1lBQzdCLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQztZQUNyQixJQUFJLE1BQU0sSUFBSSxNQUFNLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtnQkFDN0IsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsS0FBSyxHQUFHLE1BQU0sQ0FBQyxNQUFNLEVBQUUsQ0FBQyxHQUFHLEtBQUssRUFBRSxDQUFDLEVBQUUsRUFBRTtvQkFDbkQsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLGlCQUFpQixDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsMEJBQTBCLENBQUMsQ0FBQztvQkFDdkUsbURBQW1EO29CQUNuRCxzREFBc0Q7b0JBQ3RELE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLEdBQUcsSUFBSTtvQkFDdkIsSUFBSSxJQUFJLENBQUMsSUFBSSxFQUFFO3dCQUNYLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQztxQkFDL0I7aUJBQ0o7YUFDSjtZQUNELElBQUksQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDO1lBQ3JCLElBQUksQ0FBQyxNQUFNLEVBQUU7UUFDakIsQ0FBQztRQUdELDJCQUFRLEdBQVIsVUFBUyxJQUFTLEVBQUUsSUFBYTtZQUM3QiwwREFBMEQ7WUFDMUQsSUFBSSxDQUFDLElBQUksSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLElBQUksQ0FBQyxJQUFJLElBQUksQ0FBQyxJQUFJLEtBQUssSUFBSSxFQUFFO2dCQUMxRCxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7YUFDakI7aUJBQ0ksSUFBSSxJQUFJLENBQUMsTUFBTSxFQUFFO2dCQUNsQixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxLQUFLLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLEVBQUUsQ0FBQyxHQUFHLEtBQUssRUFBRSxDQUFDLEVBQUUsRUFBRTtvQkFDeEQsSUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQztvQkFDcEQsSUFBSSxRQUFRLEVBQUU7d0JBQ1YsUUFBUSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQzt3QkFDcEIsT0FBTyxRQUFRLENBQUM7cUJBQ25CO2lCQUNKO2FBQ0o7UUFDTCxDQUFDO1FBRUQsNkJBQVUsR0FBVixVQUFXLElBQVMsRUFBRSxJQUFhO1lBQy9CLDBEQUEwRDtZQUMxRCxJQUFJLENBQUMsSUFBSSxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssSUFBSSxDQUFDLElBQUksSUFBSSxDQUFDLElBQUksS0FBSyxJQUFJLEVBQUU7Z0JBQzFELHdDQUF3QztnQkFDeEMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQztnQkFDdkIsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO2FBQ2pCO2lCQUNJLElBQUksSUFBSSxDQUFDLE1BQU0sRUFBRTtnQkFDbEIsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsS0FBSyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxFQUFFLENBQUMsR0FBRyxLQUFLLEVBQUUsQ0FBQyxFQUFFLEVBQUU7b0JBQ3hELElBQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUM7b0JBQ3RELElBQUksUUFBUSxFQUFFO3dCQUNWLFFBQVEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7d0JBQ3BCLE9BQU8sUUFBUSxDQUFDO3FCQUNuQjtpQkFDSjthQUNKO1FBQ0wsQ0FBQztRQUdELCtCQUFZLEdBQVosVUFBYSxJQUFTLEVBQUUsSUFBWTtZQUNoQyxJQUFJLENBQUMsSUFBSSxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssSUFBSSxDQUFDLElBQUksSUFBSSxDQUFDLElBQUksS0FBSyxJQUFJLEVBQUU7Z0JBQzFELElBQUksQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDO2dCQUN2QixPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7YUFDakI7aUJBQ0ksSUFBSSxJQUFJLENBQUMsTUFBTSxFQUFFO2dCQUNsQixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxLQUFLLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLEVBQUUsQ0FBQyxHQUFHLEtBQUssRUFBRSxDQUFDLEVBQUUsRUFBRTtvQkFDeEQsSUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxZQUFZLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQztvQkFDeEQsSUFBSSxRQUFRLEVBQUU7d0JBQ1YsUUFBUSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQzt3QkFDcEIsT0FBTyxRQUFRLENBQUM7cUJBQ25CO2lCQUNKO2FBQ0o7UUFDTCxDQUFDO1FBRUQsMEJBQU8sR0FBUCxVQUFRLEtBQWU7WUFDbkIsa0RBQWtEO1lBQ2xELGlGQUFpRjtZQUNqRixLQUFLLENBQUMsaUJBQWlCLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQywwQkFBMEIsQ0FBQyxDQUFDO1lBQ25FLElBQUksSUFBSSxDQUFDLGNBQWMsRUFBRTtnQkFDckIsS0FBSyxDQUFDLGNBQWMsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLHdCQUF3QixDQUFDLENBQUM7YUFDakU7WUFDRCxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRTtnQkFDZCxJQUFJLENBQUMsTUFBTSxHQUFHLEVBQUU7YUFDbkI7WUFDRCxLQUFLLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQztZQUNwQixLQUFLLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUN6QixJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUV4QixJQUFJLElBQUksQ0FBQyxHQUFHLEVBQUU7Z0JBQ1YsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUU7b0JBQ2hCLElBQU0sYUFBYSxHQUFHLElBQUksQ0FBQyxRQUFRLEdBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsQ0FBQztvQkFDcEUsYUFBYSxDQUFDLFNBQVMsR0FBRyxlQUFlO29CQUN6QyxJQUFJLENBQUMsR0FBRyxDQUFDLFdBQVcsQ0FBQyxhQUFhLENBQUMsQ0FBQztvQkFDcEMsMkNBQTJDO2lCQUM5QztnQkFDRCxJQUFJLENBQUMsUUFBUSxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDO2dCQUUxRCxJQUFNLFVBQVUsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFFdkQsaURBQWlEO2dCQUNqRCxtRUFBbUU7Z0JBRW5FLElBQU0sR0FBRyxHQUFHLFFBQVEsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUMsTUFBTSxDQUFDO2dCQUM5QyxJQUFJLEtBQUssR0FBRyxHQUFHLENBQUM7Z0JBQ2hCLElBQUksVUFBVSxHQUFHLENBQUMsRUFBRTtvQkFDaEIscUVBQXFFO29CQUNyRSw0SEFBNEg7b0JBQzVILHFKQUFxSjtvQkFDckosSUFBSSxJQUFJLENBQUMsV0FBVyxFQUFFLEVBQUU7d0JBQ3BCLDREQUE0RDt3QkFDNUQsSUFBSSxDQUFDLFFBQVEsQ0FBQyxTQUFTLENBQUMsT0FBTyxDQUFDLFFBQVEsRUFBRSxRQUFRLENBQUMsQ0FBQzt3QkFFcEQsSUFBSSxDQUFDLGFBQWEsQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxDQUFDO3dCQUMzQyxJQUFJLENBQUMsYUFBYSxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUM7cUJBQ2pEO3lCQUNJO3dCQUNELGdGQUFnRjt3QkFDaEYsSUFBSSxDQUFDLFFBQVEsQ0FBQyxTQUFTLENBQUMsT0FBTyxDQUFDLFFBQVEsRUFBRSxRQUFRLENBQUMsQ0FBQzt3QkFFcEQsSUFBSSxDQUFDLGFBQWEsQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxDQUFDO3dCQUMzQyxJQUFJLENBQUMsYUFBYSxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUM7cUJBQ2pEO29CQUNELElBQUksQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQztpQkFDekM7cUJBQ0k7b0JBQ0QscUVBQXFFO29CQUNyRSxxSkFBcUo7aUJBQ3hKO2FBQ0o7UUFDTCxDQUFDO1FBSUQseUJBQU0sR0FBTjtZQUNJLElBQUksQ0FBQyxHQUFHLENBQUMsTUFBTSxFQUFFLENBQUM7UUFDdEIsQ0FBQztRQUVELGdDQUFhLEdBQWI7WUFDSSxJQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDO1lBQzNCLElBQUksTUFBTSxJQUFJLE1BQU0sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO2dCQUM3QixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxLQUFLLEdBQUcsTUFBTSxDQUFDLE1BQU0sRUFBRSxDQUFDLEdBQUcsS0FBSyxFQUFFLENBQUMsRUFBRSxFQUFFO29CQUNuRCxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsaUJBQWlCLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQywwQkFBMEIsQ0FBQyxDQUFDO2lCQUM1RTthQUNKO1lBQ0QsSUFBSSxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUM7UUFDdkIsQ0FBQztRQUVELCtCQUFZLEdBQVosVUFBYSxJQUFjO1lBQ3ZCLElBQUksS0FBSyxHQUFvQixFQUFFO1lBQy9CLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEtBQUssR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sRUFBRSxDQUFDLEdBQUcsS0FBSyxFQUFFLENBQUMsRUFBRSxFQUFFO2dCQUN4RCxJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEtBQUssSUFBSSxFQUFFO29CQUN6QixLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztpQkFDOUI7cUJBQ0k7b0JBQ0QsT0FBTyxDQUFDLElBQUksQ0FBQyxhQUFhLEdBQUcsQ0FBQyxFQUFFLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztpQkFDbkQ7YUFDSjtZQUNELElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLDBCQUEwQixDQUFDLENBQUM7WUFDcEUsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDO1lBQ2QsSUFBSSxDQUFDLE1BQU0sR0FBRyxLQUFLO1lBQ25CLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQztRQUNsQixDQUFDO1FBR0QsOEJBQVcsR0FBWDtZQUNJLE9BQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQztZQUN0QixnRUFBZ0U7UUFDcEUsQ0FBQztRQUVEOztXQUVHO1FBQ0gseUJBQU0sR0FBTixVQUFPLGVBQXdCO1lBQzNCLElBQUksSUFBSSxDQUFDLFNBQVMsRUFBRTtnQkFDaEIsSUFBSSxDQUFDLFNBQVMsR0FBRyxLQUFLLENBQUM7Z0JBQ3ZCLElBQUksSUFBSSxDQUFDLEdBQUcsRUFBRTtvQkFDVixJQUFJLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUMsUUFBUSxFQUFFLFFBQVEsQ0FBQyxDQUFDO29CQUMvQyxJQUFJLENBQUMsYUFBYSxDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUMsUUFBUSxFQUFFLFFBQVEsQ0FBQyxDQUFDO2lCQUM1RDthQUNKO1lBQ0QsSUFBSSxDQUFDLGVBQWUsSUFBSSxJQUFJLENBQUMsTUFBTSxFQUFFO2dCQUNqQyxLQUFLLElBQUksQ0FBQyxHQUFDLENBQUMsRUFBRSxLQUFLLEdBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLEVBQUUsQ0FBQyxHQUFDLEtBQUssRUFBRSxDQUFDLEVBQUUsRUFBRTtvQkFDbEQsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLEVBQUUsQ0FBQztpQkFDM0I7YUFDSjtRQUNMLENBQUM7UUFFRCwyQkFBUSxHQUFSO1lBQ0ksSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUU7Z0JBQ2pCLElBQUksQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDO2dCQUN0QixJQUFJLElBQUksQ0FBQyxHQUFHLEVBQUU7b0JBQ1YsSUFBSSxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsT0FBTyxDQUFDLFFBQVEsRUFBRSxRQUFRLENBQUMsQ0FBQztvQkFDL0MsSUFBSSxDQUFDLGFBQWEsQ0FBQyxTQUFTLENBQUMsT0FBTyxDQUFDLFFBQVEsRUFBRSxRQUFRLENBQUMsQ0FBQztpQkFDNUQ7YUFDSjtRQUNMLENBQUM7UUFDRCxnQ0FBYSxHQUFiO1lBQ0ksSUFBSSxJQUFJLENBQUMsVUFBVSxLQUFLLFNBQVMsRUFBRTtnQkFDL0IsT0FBTyxJQUFJLENBQUMsVUFBVSxDQUFDO2FBQzFCO2lCQUNJO2dCQUNELElBQUksSUFBSSxDQUFDLE1BQU0sRUFBRTtvQkFDYixPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsYUFBYSxFQUFFLENBQUM7aUJBQ3RDO3FCQUNJO29CQUNELElBQUksSUFBSSxDQUFDLElBQUksRUFBRTt3QkFDWCxPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDO3FCQUMvQjtpQkFDSjthQUNKO1lBQ0QsT0FBTyxhQUFhLENBQUMsTUFBTTtRQUMvQixDQUFDO1FBQ0w7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztVQThIRTtRQUNFLHlCQUFNLEdBQU4sVUFBTyxLQUFhO1lBQXBCLGlCQWdJQztZQS9IRyx5RkFBeUY7WUFDekYsSUFBTSxHQUFHLEdBQUcsUUFBUSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxNQUFNLENBQUM7WUFDOUMsSUFBSSxDQUFDLEtBQUssRUFBRTtnQkFDUixLQUFLLEdBQUcsQ0FBQyxDQUFDO2FBQ2I7WUFDRCxJQUFJLFNBQVMsR0FBRyxDQUFDLENBQUM7WUFDbEIscUJBQXFCO1lBRXJCLElBQUksR0FBRyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUM7WUFDbkIsSUFBSSxPQUFPLEdBQUcsSUFBSSxDQUFDLE9BQU87WUFDMUIsSUFBSSxDQUFDLEdBQUcsRUFBRTtnQkFDTixHQUFHLEdBQUcsSUFBSSxDQUFDLEdBQUcsR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxDQUFDO2dCQUMvQyxHQUFHLENBQUMsU0FBUyxHQUFHLGFBQWE7b0JBQzdCLE9BQU8sR0FBRyxJQUFJLENBQUMsT0FBTyxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLENBQUM7Z0JBQ3ZELE9BQU8sQ0FBQyxFQUFFLEdBQUcsU0FBUyxHQUFHLFFBQVEsQ0FBQyxXQUFXLEVBQUU7Z0JBQy9DLE9BQU8sQ0FBQyxTQUFTLEdBQUcsU0FBUyxDQUFDO2dCQUM5Qix5REFBeUQ7Z0JBRXpELElBQUksQ0FBQyxJQUFJLENBQUMsY0FBYyxFQUFFO29CQUN0QixHQUFHLENBQUMsV0FBVyxDQUFDLE9BQU8sQ0FBQyxDQUFDO2lCQUM1QjtnQkFFRCxJQUFNLFVBQVUsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDdkQsSUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDO2dCQUN4QyxJQUFNLElBQUksR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxDQUFDO2dCQUMzQyxJQUFJLENBQUMsU0FBUyxHQUFHLFVBQVUsQ0FBQztnQkFFNUIsSUFBTSxhQUFhLEdBQUcsSUFBSSxDQUFDLGFBQWEsR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLE1BQU0sQ0FBQyxDQUFDO2dCQUMxRSxhQUFhLENBQUMsZ0JBQWdCLENBQUMsT0FBTyxFQUFFLFVBQUMsRUFBRSxJQUFLLFlBQUksQ0FBQyxlQUFlLENBQUMsRUFBRSxDQUFDLEVBQXhCLENBQXdCLENBQUMsQ0FBQztnQkFDMUUsU0FBUyxFQUFFLENBQUM7Z0JBRVosSUFBSSxJQUFJLENBQUMsU0FBUyxFQUFFO29CQUNoQixJQUFJLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLENBQUM7aUJBQ3BDO3FCQUNJO29CQUNELElBQUksQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsQ0FBQztpQkFDcEM7Z0JBRUQsSUFBSSxVQUFVLEdBQUcsQ0FBQyxFQUFFO29CQUNoQixnSkFBZ0o7b0JBQ2hKLElBQUksSUFBSSxDQUFDLFNBQVMsRUFBRTt3QkFDaEIsSUFBSSxDQUFDLGFBQWEsQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxDQUFDO3FCQUM5Qzt5QkFDSTt3QkFDRCxJQUFJLENBQUMsYUFBYSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLENBQUM7cUJBQzlDO2lCQUNKO3FCQUNJO29CQUNELElBQUksVUFBVSxLQUFLLGFBQWEsQ0FBQyxNQUFNLEVBQUU7d0JBQ3JDLE9BQU8sQ0FBQyxnQkFBZ0IsQ0FBQyxPQUFPLEVBQUUsVUFBQyxFQUFFLElBQUssWUFBSSxDQUFDLFdBQVcsQ0FBQyxFQUFFLENBQUMsRUFBcEIsQ0FBb0IsQ0FBQyxDQUFDO3FCQUNuRTtvQkFDRCw2REFBNkQ7b0JBQzdELElBQUksVUFBVSxLQUFLLGFBQWEsQ0FBQyxLQUFLLEVBQUU7d0JBQ3BDLHFKQUFxSjt3QkFDckosMERBQTBEO3FCQUM3RDt5QkFBTTt3QkFDSCwwREFBMEQ7d0JBQzFELGlKQUFpSjtxQkFDcEo7b0JBQ0QsSUFBSSxHQUFHLEdBQUcsQ0FBQyxFQUFFO3dCQUNULE9BQU8sQ0FBQyxTQUFTLEdBQUcsY0FBYztxQkFDckM7b0JBQ0QscUNBQXFDO2lCQUN4QztnQkFDRCxJQUFJLENBQUMsUUFBUSxHQUFHLGFBQWE7Z0JBQzdCLElBQUksQ0FBQyxXQUFXLENBQUMsYUFBYSxDQUFDLENBQUM7Z0JBQ2hDLElBQUksVUFBVSxLQUFLLGFBQWEsQ0FBQyxLQUFLLEVBQUU7b0JBQ3BDLElBQU0sSUFBRSxHQUFxQixJQUFJLENBQUMsY0FBYyxFQUFFO29CQUNsRCxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUUsQ0FBQyxDQUFDO29CQUNyQixJQUFNLE9BQUssR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLE9BQU8sQ0FBQyxDQUFDO29CQUM5QyxJQUFJLENBQUMsV0FBVyxDQUFDLE9BQUssQ0FBQyxDQUFDO29CQUN4QixPQUFLLENBQUMsZ0JBQWdCLENBQUMsT0FBTyxFQUFFLGNBQWMsSUFBRSxDQUFDLEtBQUssRUFBRSxFQUFDLENBQUMsQ0FBQyxDQUFDO29CQUM1RCxTQUFTLEVBQUUsQ0FBQztpQkFDZjtxQkFBTSxJQUFJLFVBQVUsS0FBSyxhQUFhLENBQUMsS0FBSyxFQUFFO29CQUMzQyxJQUFNLElBQUUsR0FBcUIsSUFBSSxDQUFDLGdCQUFnQixFQUFFO29CQUNwRCxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUUsQ0FBQyxDQUFDO29CQUNyQixJQUFNLE9BQUssR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLE9BQU8sQ0FBQyxDQUFDO29CQUM5QyxJQUFJLENBQUMsV0FBVyxDQUFDLE9BQUssQ0FBQztvQkFDdkIsT0FBSyxDQUFDLGdCQUFnQixDQUFDLE9BQU8sRUFBRTt3QkFDNUIsSUFBRSxDQUFDLEtBQUssRUFBRSxDQUFDO29CQUNmLENBQUMsQ0FBQyxDQUFDO29CQUNILFNBQVMsRUFBRSxDQUFDO2lCQUNmO2dCQUNELGlCQUFpQjtnQkFDakIsS0FBSyxJQUFJLENBQUMsR0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFDLEtBQUssRUFBRyxDQUFDLEVBQUUsRUFBRTtvQkFDekIsSUFBTSxVQUFVLEdBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBQyxNQUFNLENBQUMsQ0FBQztvQkFDbEQsVUFBVSxDQUFDLFNBQVMsR0FBRyxhQUFhLENBQUM7b0JBQ3JDLE9BQU8sQ0FBQyxXQUFXLENBQUMsVUFBVSxDQUFDLENBQUM7b0JBQ2hDLFdBQVc7aUJBQ2Q7Z0JBQ0QsaUNBQWlDO2dCQUNqQyxPQUFPLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxDQUFDO2dCQUMxQixJQUFNLFFBQVEsR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQztnQkFDOUMsUUFBUSxDQUFDLFNBQVMsR0FBRyxXQUFXO2dCQUNoQyxJQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUM7Z0JBQzVDLElBQUksS0FBSyxFQUFFO29CQUNQLFFBQVEsQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDO29CQUMzQixPQUFPLENBQUMsV0FBVyxDQUFDLFFBQVEsQ0FBQyxDQUFDO2lCQUNqQztnQkFFRCxJQUFJLElBQUksQ0FBQyxPQUFPLEVBQUU7b0JBQ2QsT0FBTyxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsYUFBYSxFQUFFLENBQUM7aUJBQzVDO2dCQUVELElBQUksYUFBYSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUM7Z0JBQ2xDLElBQUksYUFBYSxFQUFFO29CQUNmLGFBQWEsQ0FBQyxTQUFTLEdBQUcsSUFBSTtpQkFDakM7Z0JBRUQsSUFBSSxVQUFVLEdBQUcsQ0FBQyxFQUFFO29CQUNoQixJQUFJLENBQUMsYUFBYSxFQUFFO3dCQUNoQixhQUFhLEdBQUcsSUFBSSxDQUFDLFFBQVEsR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxDQUFDO3dCQUM5RCxhQUFhLENBQUMsU0FBUyxHQUFHLGVBQWU7d0JBQ3pDLEdBQUcsQ0FBQyxXQUFXLENBQUMsYUFBYSxDQUFDLENBQUM7d0JBQy9CLHVDQUF1QztxQkFDMUM7b0JBQ0QsSUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssR0FBRyxTQUFTLENBQUMsQ0FBQztvQkFDckUsdURBQXVEO29CQUN2RCxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7d0JBQ3pDLGFBQWEsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQztxQkFDaEU7aUJBRUo7Z0JBQ0QsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsT0FBTyxHQUFHLENBQUMsSUFBSSxDQUFDLGFBQWEsSUFBSSxVQUFVLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDO2FBQ3ZGO1lBQ0QsSUFBSSxDQUFDLFdBQVcsR0FBRyxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxHQUFHLFNBQVMsQ0FBQyxDQUFDO1lBQ3JFLE9BQU8sR0FBRztRQUNkLENBQUM7UUFHRCwwQ0FBMEM7UUFDMUMsMkVBQTJFO1FBQzNFLHFEQUFxRDtRQUNyRCxvQkFBb0I7UUFDcEIscUJBQXFCO1FBQ3JCLGdCQUFnQjtRQUNoQix5QkFBeUI7UUFDekIsNEJBQTRCO1FBRTVCLDBCQUEwQjtRQUMxQixpQ0FBaUM7UUFDakMsa0JBQWtCO1FBQ2xCLDBEQUEwRDtRQUMxRCx5Q0FBeUM7UUFDekMsa0VBQWtFO1FBQ2xFLHNFQUFzRTtRQUN0RSx5Q0FBeUM7UUFDekMsb0NBQW9DO1FBRXBDLGtFQUFrRTtRQUNsRSxtREFBbUQ7UUFDbkQsc0RBQXNEO1FBQ3RELHVDQUF1QztRQUV2QyxxRkFBcUY7UUFDckYscUZBQXFGO1FBQ3JGLHVCQUF1QjtRQUV2QixnQ0FBZ0M7UUFDaEMsZ0RBQWdEO1FBQ2hELFlBQVk7UUFDWixxQ0FBcUM7UUFDckMsZ0RBQWdEO1FBQ2hELGdCQUFnQjtRQUVoQixnQ0FBZ0M7UUFDaEMsK0pBQStKO1FBQy9KLHdEQUF3RDtRQUN4RCw4REFBOEQ7UUFDOUQsZ0JBQWdCO1FBQ2hCLHlDQUF5QztRQUN6Qyw4REFBOEQ7UUFDOUQsZ0NBQWdDO1FBQ2hDLFlBQVk7UUFDWixpQkFBaUI7UUFDakIseURBQXlEO1FBQ3pELG1GQUFtRjtRQUNuRixnQkFBZ0I7UUFDaEIsNEVBQTRFO1FBQzVFLHdEQUF3RDtRQUN4RCx3S0FBd0s7UUFDeEssNkVBQTZFO1FBQzdFLHVCQUF1QjtRQUN2Qiw2RUFBNkU7UUFDN0Usb0tBQW9LO1FBQ3BLLGdCQUFnQjtRQUNoQiw2QkFBNkI7UUFDN0IscURBQXFEO1FBQ3JELGdCQUFnQjtRQUNoQixvREFBb0Q7UUFDcEQsWUFBWTtRQUNaLHdDQUF3QztRQUN4QywyQ0FBMkM7UUFDM0Msb0RBQW9EO1FBQ3BELGlFQUFpRTtRQUNqRSxvQ0FBb0M7UUFDcEMsNkRBQTZEO1FBQzdELHVDQUF1QztRQUN2Qyw4RUFBOEU7UUFDOUUsd0NBQXdDO1FBQ3hDLDJEQUEyRDtRQUMzRCxtRUFBbUU7UUFDbkUsb0NBQW9DO1FBQ3BDLDZEQUE2RDtRQUM3RCxzQ0FBc0M7UUFDdEMsNkRBQTZEO1FBQzdELDhCQUE4QjtRQUM5QixrQkFBa0I7UUFDbEIsMkJBQTJCO1FBRTNCLFlBQVk7UUFFWix3Q0FBd0M7UUFDeEMsaUVBQWlFO1FBQ2pFLG9EQUFvRDtRQUNwRCwrQ0FBK0M7UUFDL0MsWUFBWTtRQUNaLHFDQUFxQztRQUNyQyx5REFBeUQ7UUFDekQsMkNBQTJDO1FBQzNDLHVEQUF1RDtRQUN2RCx1QkFBdUI7UUFDdkIsMENBQTBDO1FBQzFDLDZDQUE2QztRQUM3QyxZQUFZO1FBRVosOEJBQThCO1FBQzlCLHdEQUF3RDtRQUN4RCxZQUFZO1FBRVosNkNBQTZDO1FBQzdDLCtCQUErQjtRQUMvQiw2Q0FBNkM7UUFDN0MsWUFBWTtRQUVaLGdDQUFnQztRQUNoQyxvQ0FBb0M7UUFDcEMsaUZBQWlGO1FBQ2pGLDREQUE0RDtRQUM1RCxrREFBa0Q7UUFDbEQsMERBQTBEO1FBQzFELGdCQUFnQjtRQUNoQiw2REFBNkQ7UUFDN0Qsd0ZBQXdGO1FBQ3hGLGdCQUFnQjtRQUVoQixrQkFBa0I7UUFDbEIsK0ZBQStGO1FBQy9GLFFBQVE7UUFDUiwwQ0FBMEM7UUFDMUMsaUJBQWlCO1FBQ2pCLElBQUk7UUFFSixnQ0FBYSxHQUFiO1lBQUEsaUJBVUM7WUFURyxJQUFJLE1BQU0sR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQztZQUMxQyxNQUFNLENBQUMsU0FBUyxHQUFHLG1CQUFtQjtvQ0FDN0IsQ0FBQztnQkFDTixJQUFNLENBQUMsR0FBRyxPQUFLLE9BQU8sQ0FBQyxDQUFDLENBQUM7Z0JBQ3pCLElBQUksQ0FBQyxDQUFDLFVBQVUsRUFBRTtvQkFDZCxNQUFNLENBQUMsV0FBVyxDQUFDLE9BQUssVUFBVSxDQUFDLENBQUMsQ0FBQyxJQUFJLEVBQUUsY0FBTSxRQUFDLENBQUMsUUFBUSxDQUFDLEtBQUksQ0FBQyxJQUFJLENBQUMsRUFBckIsQ0FBcUIsQ0FBQyxDQUFDO2lCQUMzRTs7O1lBSkwsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRTt3QkFBbkMsQ0FBQzthQUtUO1lBQ0QsT0FBTyxNQUFNO1FBQ2pCLENBQUM7UUFFRCw2QkFBVSxHQUFWLFVBQVcsSUFBWSxFQUFFLEVBQWlCO1lBQ3RDLElBQU0sRUFBRSxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsR0FBRyxDQUFDO1lBQ3RDLEVBQUUsQ0FBQyxLQUFLLENBQUMsUUFBUSxHQUFHLE9BQU87WUFDM0IsRUFBRSxDQUFDLEtBQUssQ0FBQyxVQUFVLEdBQUcsTUFBTTtZQUM1QixFQUFFLENBQUMsU0FBUyxHQUFHLFNBQVMsR0FBRyxJQUFJO1lBQy9CLEVBQUUsQ0FBQyxPQUFPLEdBQUcsRUFBRTtZQUNmLE9BQU8sRUFBRSxDQUFDO1FBQ2QsQ0FBQztRQUVEOztXQUVHO1FBQ0gsaUNBQWMsR0FBZDtZQUFBLGlCQVlDO1lBWEcsSUFBSSxLQUF1QixDQUFDO1lBQzVCLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFO2dCQUNiLEtBQUssR0FBRyxJQUFJLENBQUMsS0FBSyxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsT0FBTyxDQUFDLENBQUM7Z0JBQ3JELEtBQUssQ0FBQyxJQUFJLEdBQUcsVUFBVSxDQUFDO2dCQUN4QixLQUFLLENBQUMsU0FBUyxHQUFHLGtCQUFrQixDQUFDO2dCQUNyQyxLQUFLLENBQUMsWUFBWSxDQUFDLFlBQVksRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO2dCQUMvQyxLQUFLLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQyxlQUFlLEtBQUssZUFBZSxDQUFDLFFBQVEsSUFBSSxJQUFJLENBQUMsZUFBZSxLQUFLLGVBQWUsQ0FBQyxhQUFhLENBQUM7Z0JBQzVILEtBQUssQ0FBQyxhQUFhLEdBQUcsSUFBSSxDQUFDLGVBQWUsS0FBSyxlQUFlLENBQUMsYUFBYSxDQUFDO2dCQUM3RSxLQUFLLENBQUMsZ0JBQWdCLENBQUMsUUFBUSxFQUFFLFVBQUMsRUFBRSxJQUFLLFlBQUksQ0FBQyxhQUFhLENBQUMsRUFBRSxDQUFDLEVBQXRCLENBQXNCLENBQUMsQ0FBQzthQUNwRTtZQUNELE9BQU8sSUFBSSxDQUFDLEtBQUs7UUFDckIsQ0FBQztRQUVELG1DQUFnQixHQUFoQjtZQUFBLGlCQVdDO1lBVkcsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUU7Z0JBQ2IsSUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLEtBQUssR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLE9BQU8sQ0FBQyxDQUFDO2dCQUMzRCxLQUFLLENBQUMsSUFBSSxHQUFHLE9BQU8sQ0FBQztnQkFDckIsS0FBSyxDQUFDLFNBQVMsR0FBRyxrQkFBa0IsQ0FBQztnQkFDckMsS0FBSyxDQUFDLFlBQVksQ0FBQyxZQUFZLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztnQkFDL0MsS0FBSyxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUMsZUFBZSxLQUFHLGVBQWUsQ0FBQyxRQUFRLENBQUM7Z0JBQ2hFLEtBQUssQ0FBQyxnQkFBZ0IsQ0FBQyxRQUFRLEVBQUUsVUFBQyxFQUFFLElBQUssWUFBSSxDQUFDLGFBQWEsQ0FBQyxFQUFFLENBQUMsRUFBdEIsQ0FBc0IsQ0FBQyxDQUFDO2dCQUNqRSxJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQzthQUN0QjtZQUNELE9BQU8sSUFBSSxDQUFDLEtBQUs7UUFDckIsQ0FBQztRQUVELGdDQUFhLEdBQWIsVUFBYyxHQUFRO1lBQ2xCLDRIQUE0SDtZQUM1SCxzQkFBc0I7WUFDdEIsSUFBSSxJQUFJLENBQUMsTUFBTSxFQUFFO2dCQUNiLElBQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDO2dCQUN0QyxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7b0JBQ3pDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLFVBQVUsQ0FBQyxDQUFDO2lCQUMxQzthQUNKO2lCQUNJO2dCQUNELElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUM7YUFDdkM7WUFDRCxHQUFHLENBQUMsY0FBYyxFQUFFLENBQUM7UUFDekIsQ0FBQztRQUlELDhCQUFXLEdBQVgsVUFBWSxHQUFlO1lBQ3ZCLE9BQU8sQ0FBQyxJQUFJLENBQUMsc0JBQXNCLENBQUM7WUFDcEMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsZUFBZSxLQUFHLGVBQWUsQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUN4RSxDQUFDO1FBRUQsa0NBQWUsR0FBZixVQUFnQixHQUFlO1lBQzNCLHFEQUFxRDtZQUNyRCxJQUFJLElBQUksQ0FBQyxNQUFNLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO2dCQUN2QyxJQUFJLElBQUksQ0FBQyxTQUFTLEVBQUU7b0JBQ2hCLElBQUksQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxRQUFRLEVBQUUsUUFBUSxDQUFDLENBQUM7b0JBQy9DLHVEQUF1RDtvQkFDdkQsSUFBSSxDQUFDLGFBQWEsQ0FBQyxTQUFTLENBQUMsT0FBTyxDQUFDLFFBQVEsRUFBRSxRQUFRLENBQUMsQ0FBQztpQkFDNUQ7cUJBQ0k7b0JBQ0QsSUFBSSxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsT0FBTyxDQUFDLFFBQVEsRUFBRSxRQUFRLENBQUMsQ0FBQztvQkFDL0MsdURBQXVEO29CQUN2RCxJQUFJLENBQUMsYUFBYSxDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUMsUUFBUSxFQUFFLFFBQVEsQ0FBQyxDQUFDO2lCQUM1RDtnQkFDRCxJQUFJLENBQUMsU0FBUyxHQUFDLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQztnQkFDL0IsSUFBSSxDQUFDLGNBQWMsQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO2FBQ3ZEO1lBQ0QsR0FBRyxDQUFDLHdCQUF3QixFQUFFLENBQUM7UUFDbkMsQ0FBQztRQUVELDBCQUEwQjtRQUMxQix3QkFBd0I7UUFDeEIscUNBQXFDO1FBQ3JDLFFBQVE7UUFDUiw0QkFBNEI7UUFDNUIsSUFBSTtRQUVKLHNDQUFtQixHQUFuQjtZQUNJLG9CQUFvQjtZQUNwQixnQ0FBZ0M7WUFDaEMsc0dBQXNHO1lBQ3RHLFFBQVE7WUFDUix5Q0FBeUM7WUFDekMsSUFBSTtZQUNKLGdGQUFnRjtZQUNoRixPQUFPLElBQUksQ0FBQyxlQUFlLENBQUM7UUFDaEMsQ0FBQztRQUVEOzs7O1VBSUU7UUFFRixxQ0FBa0IsR0FBbEI7WUFDSSxJQUFJLEtBQUssR0FBRyxDQUFDLENBQUM7WUFDZCxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7Z0JBQ3pDLG9GQUFvRjtnQkFDcEYsSUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxtQkFBbUIsRUFBRSxDQUFDO2dCQUNyRCxJQUFJLE9BQU8sS0FBRyxlQUFlLENBQUMsUUFBUSxFQUFFO29CQUNuQyxLQUFLLEVBQUUsQ0FBQztpQkFDWjtxQkFBTTtvQkFDSCxJQUFJLE9BQU8sS0FBRyxlQUFlLENBQUMsYUFBYSxFQUFFO3dCQUN6QyxPQUFPLGVBQWUsQ0FBQyxhQUFhLENBQUM7cUJBQ3hDO2lCQUNKO2FBQ0o7WUFDRCxJQUFJLEtBQUssS0FBSyxDQUFDO2dCQUFFLE9BQU8sZUFBZSxDQUFDLFVBQVUsQ0FBQztZQUNuRCxPQUFPLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLGVBQWUsQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDLGVBQWUsQ0FBQyxRQUFRLENBQUM7UUFDbkcsQ0FBQztRQUVELHFDQUFrQixHQUFsQixVQUFtQixJQUFjLEVBQUUsUUFBaUI7WUFDaEQsT0FBTyxDQUFDLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDO1lBQ25DLElBQUksUUFBUSxJQUFJLElBQUksQ0FBQyxpQkFBaUIsRUFBRTtnQkFDcEMsSUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDbkQsS0FBSyxJQUFJLENBQUMsR0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFDLEtBQUssRUFBRSxDQUFDLEVBQUUsRUFBRTtvQkFDeEIsSUFBSSxJQUFJLEtBQUssSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRTt3QkFDekIsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLEVBQUUsQ0FBQztxQkFDN0I7aUJBQ0o7YUFDSjtRQUNMLENBQUM7UUFHRCxnQ0FBYSxHQUFiLFVBQWMsQ0FBVyxFQUFFLGVBQWdDO1lBQ3ZELCtIQUErSDtZQUMvSCxJQUFNLFNBQVMsR0FBRyxJQUFJLENBQUMsa0JBQWtCLEVBQUUsQ0FBQztZQUM1QyxJQUFJLElBQUksQ0FBQyxLQUFLLEVBQUU7Z0JBQ1osSUFBSSxTQUFTLEtBQUssZUFBZSxDQUFDLFVBQVUsRUFBRTtvQkFDMUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLEdBQUcsS0FBSyxDQUFDO29CQUMzQixJQUFJLENBQUMsS0FBSyxDQUFDLGFBQWEsR0FBRyxLQUFLLENBQUM7aUJBQ3BDO3FCQUNJO29CQUNELElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQztvQkFDMUIsSUFBSSxDQUFDLEtBQUssQ0FBQyxhQUFhLEdBQUcsU0FBUyxLQUFLLGVBQWUsQ0FBQyxhQUFhLENBQUM7aUJBQzFFO2FBQ0o7WUFDRCw2SEFBNkg7WUFDN0gscUJBQXFCO1lBQ3JCLElBQUksQ0FBQyxlQUFlLEdBQUcsU0FBUyxDQUFDO1lBQ2pDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLFNBQVMsQ0FBQyxDQUFDO1FBR3JELENBQUM7UUFHRCw4QkFBVyxHQUFYO1lBQ0ksSUFBSSxHQUFHLEdBQWUsRUFBRSxDQUFDO1lBQ3pCLElBQUksSUFBSSxDQUFDLGVBQWUsS0FBRyxlQUFlLENBQUMsUUFBUSxJQUFJLElBQUksQ0FBQyxlQUFlLEtBQUcsZUFBZSxDQUFDLGFBQWEsRUFBRTtnQkFDekcsSUFBSSxJQUFJLENBQUMsZUFBZSxLQUFHLGVBQWUsQ0FBQyxRQUFRLEVBQUU7b0JBQ2pELEdBQUcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO2lCQUN2QjtnQkFDRCxJQUFJLElBQUksQ0FBQyxNQUFNLEVBQUU7b0JBQ2IsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO3dCQUN6QyxHQUFHLEdBQUcsR0FBRyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLFdBQVcsRUFBRSxDQUFDLENBQUM7cUJBQ2xEO2lCQUNKO2FBQ0o7WUFDRCxPQUFPLEdBQUcsQ0FBQztRQUNmLENBQUM7UUFHRCw4QkFBVyxHQUFYLFVBQVksUUFBaUI7WUFFekIsT0FBTyxDQUFDLElBQUksQ0FBQyxzQkFBZSxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksRUFBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSw0QkFBa0IsYUFBYSxDQUFDLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQyxDQUFFLENBQUMsQ0FBQztZQUNsSyxPQUFPLENBQUMsSUFBSSxDQUFDLHNCQUFzQixFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUNoRCxJQUFNLGdCQUFnQixHQUFHLFFBQVEsQ0FBQyxDQUFDLENBQUMsZUFBZSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsZUFBZSxDQUFDLFVBQVUsQ0FBQztZQUMxRixJQUFJLGdCQUFnQixLQUFLLElBQUksQ0FBQyxlQUFlLEVBQUU7Z0JBQzNDLE9BQU87YUFDVjtZQUNELElBQUksSUFBSSxDQUFDLGFBQWEsRUFBRSxLQUFLLGFBQWEsQ0FBQyxNQUFNLEVBQUU7Z0JBQy9DLElBQUksSUFBSSxDQUFDLE9BQU8sRUFBRTtvQkFDZCxJQUFJLElBQUksQ0FBQyxlQUFlLEtBQUcsZUFBZSxDQUFDLFVBQVUsRUFBRTt3QkFDbkQsSUFBSSxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxDQUFDO3FCQUMxQzt5QkFBTTt3QkFDSCxJQUFJLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLENBQUM7cUJBQzdDO2lCQUNKO2FBQ0o7aUJBQ0k7Z0JBQ0QsSUFBSSxJQUFJLENBQUMsS0FBSyxFQUFFO29CQUNaLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxHQUFHLFFBQVEsQ0FBQztpQkFDakM7Z0JBQ0QsSUFBSSxJQUFJLENBQUMsTUFBTSxFQUFFO29CQUNiLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTt3QkFDekMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsUUFBUSxDQUFDLENBQUM7cUJBQ3hDO2lCQUNKO2FBQ0o7WUFDRCxJQUFJLENBQUMsZUFBZSxHQUFHLFFBQVEsQ0FBQyxDQUFDLENBQUMsZUFBZSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsZUFBZSxDQUFDLFVBQVUsQ0FBQztZQUN4RixJQUFJLENBQUMsaUJBQWlCLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsZUFBZSxDQUFDLENBQUM7UUFDaEUsQ0FBQztRQUVELG9DQUFvQztRQUNwQyxxR0FBcUc7UUFDckcsd0NBQXdDO1FBQ3hDLGtCQUFrQjtRQUNsQixRQUFRO1FBQ1IsMEJBQTBCO1FBQzFCLCtCQUErQjtRQUMvQix5REFBeUQ7UUFDekQsWUFBWTtRQUNaLGlCQUFpQjtRQUNqQixzREFBc0Q7UUFDdEQsWUFBWTtRQUNaLFFBQVE7UUFDUixzQ0FBc0M7UUFDdEMsSUFBSTtRQUVKLHlCQUFNLEdBQU47WUFDSSxJQUFNLFNBQVMsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDO1lBQ3RDLFVBQVU7WUFDVixnREFBZ0Q7WUFDaEQsa0VBQWtFO1lBQ2xFLElBQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxNQUFNO1lBQzFCLElBQUksTUFBTSxJQUFJLE1BQU0sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO2dCQUM3QixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxLQUFLLEdBQUcsTUFBTSxDQUFDLE1BQU0sRUFBRSxDQUFDLEdBQUcsS0FBSyxFQUFFLENBQUMsRUFBRSxFQUFFO29CQUNuRCxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxFQUFFLENBQUM7aUJBQ3RCO2FBQ0o7aUJBQ0k7Z0JBQ0QsSUFBSSxPQUFPLEdBQUcsSUFBSSxDQUFDLE9BQU87Z0JBQzFCLElBQUksTUFBTSxHQUFHLE9BQU8sQ0FBQyxxQkFBcUIsRUFBRTtnQkFDNUMsa0NBQWtDO2dCQUNsQyxJQUFJLEVBQUUsR0FBa0IsRUFBRTtnQkFDMUIsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxVQUFVLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO29CQUNoRCxJQUFJLE9BQUssR0FBNkIsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7b0JBRXpELElBQUksUUFBUSxHQUFHLE9BQUssQ0FBQyxxQkFBcUIsRUFBRTtvQkFDNUMsNENBQTRDO29CQUM1QyxFQUFFLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQztpQkFDM0I7Z0JBQ0QsOENBQThDO2dCQUM5QyxJQUFNLEtBQUssR0FBNkIsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7Z0JBQzNELCtDQUErQztnQkFDL0Msb0RBQW9EO2dCQUNwRCxJQUFNLENBQUMsR0FBVyxDQUFDLFNBQVMsR0FBRyxNQUFNLENBQUMsSUFBSSxHQUFHLEtBQUssQ0FBQyxxQkFBcUIsRUFBRSxDQUFDLElBQUksR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQ3hGLDJFQUEyRTtnQkFDM0UsK0hBQStIO2dCQUMvSCxLQUFLLENBQUMsS0FBSyxDQUFDLEtBQUssR0FBRyxDQUFDLEdBQUcsSUFBSTthQUMvQjtRQUNMLENBQUM7UUFJTSxvQkFBVyxHQUFsQixVQUFtQixJQUFjO1lBQzdCLElBQU0sTUFBTSxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUM7WUFDdEIsSUFBSSxNQUFNLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQztZQUN6QixPQUFPLE1BQU0sRUFBRTtnQkFDWCxNQUFNLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQztnQkFDbkIsTUFBTSxHQUFHLE1BQU0sQ0FBQyxNQUFNO2FBQ3pCO1lBQ0QsT0FBTyxNQUFNLENBQUMsT0FBTyxFQUFFLENBQUM7UUFDNUIsQ0FBQztRQTM4Qk0sb0JBQVcsR0FBRyxDQUFDLENBQUM7UUE0Q2hCLGtCQUFTLEdBQUc7WUFDZixTQUFTLEVBQUcsVUFBVTtZQUN0QixZQUFZLEVBQUUsU0FBUztZQUN2QixXQUFXLEVBQUUsUUFBUTtTQUN4QjtRQTY1QkwsZUFBQztLQUFBO0lBLzhCWSw0QkFBUTtJQW05QnJCO1FBQXdDLHNDQUFRO1FBRTVDLDRCQUFZLElBQVMsRUFBRSxNQUF1QixFQUFFLE1BQXNCO1lBQXRFLFlBQ0ksa0JBQU0sSUFBSSxFQUFFLE1BQU0sRUFBRSxNQUFNLENBQUMsU0FLOUI7WUFKRyxLQUFJLENBQUMsVUFBVSxHQUFHLGFBQWEsQ0FBQyxXQUFXO1lBQzNDLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEtBQUssR0FBRyxNQUFNLENBQUMsTUFBTSxFQUFFLENBQUMsR0FBRyxLQUFLLEVBQUUsQ0FBQyxFQUFFLEVBQUU7Z0JBQ25ELE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxVQUFVLEdBQUcsYUFBYSxDQUFDLEtBQUs7YUFDN0M7O1FBQ0wsQ0FBQztRQUVELGlFQUFpRTtRQUNqRSxzSkFBc0o7UUFDdEosbUVBQW1FO1FBQ25FLElBQUk7UUFFSiwwQ0FBYSxHQUFiLFVBQWMsSUFBYyxFQUFFLE1BQXVCO1lBQ2pELDBHQUEwRztZQUMxRyw0SUFBNEk7WUFDNUksSUFBSSxJQUFJLENBQUMsbUJBQW1CLEVBQUUsS0FBRyxlQUFlLENBQUMsUUFBUSxFQUFFO2dCQUN2RCxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxLQUFLLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLEVBQUUsQ0FBQyxHQUFHLEtBQUssRUFBRSxDQUFDLEVBQUUsRUFBRTtvQkFDeEQsSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxLQUFLLElBQUksRUFBRTt3QkFDekIsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDO3FCQUNwQztpQkFDSjtnQkFDRCwrRUFBK0U7Z0JBQy9FLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLGVBQWUsQ0FBQyxRQUFRLENBQUMsQ0FBQzthQUNuRTtRQUNMLENBQUM7UUFDTCx5QkFBQztJQUFELENBQUMsQ0E1QnVDLFFBQVEsR0E0Qi9DO0lBNUJZLGdEQUFrQjs7Ozs7Ozs7Ozs7Ozs7QUNwaUNsQjtBQUNiO0FBQ0Esa0RBQWtELFFBQVE7QUFDMUQseUNBQXlDLFFBQVE7QUFDakQseURBQXlELFFBQVE7QUFDakU7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHlCQUF5QixHQUFHLHFCQUFxQixHQUFHLHNCQUFzQjtBQUMxRSxtQkFBbUIsbUJBQU8sQ0FBQywrRUFBYztBQUN6QyxxQkFBcUIsbUJBQU8sQ0FBQyxtRkFBZ0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsMkJBQTJCO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0NBQWdDO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxHQUFHO0FBQ2xCLGVBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxrQ0FBa0M7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxnQkFBZ0I7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQyw0Q0FBNEM7QUFDNUMsb0NBQW9DO0FBQ3BDLG9DQUFvQztBQUNwQyxvQ0FBb0M7QUFDcEMsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCx5QkFBeUI7Ozs7Ozs7Ozs7OztBQ2pSWjtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsb0JBQW9CLEdBQUcscUJBQXFCLEdBQUcseUJBQXlCLEdBQUcsc0JBQXNCO0FBQ2pHLG9CQUFvQixtQkFBTyxDQUFDLGlGQUFlO0FBQzNDLGtEQUFpRCxFQUFFLHFDQUFxQyx3Q0FBd0MsRUFBQztBQUNqSSxxREFBb0QsRUFBRSxxQ0FBcUMsMkNBQTJDLEVBQUM7QUFDdkksaURBQWdELEVBQUUscUNBQXFDLHVDQUF1QyxFQUFDO0FBQy9ILHFCQUFxQixtQkFBTyxDQUFDLG1GQUFnQjtBQUM3QyxnREFBK0MsRUFBRSxxQ0FBcUMsdUNBQXVDLEVBQUM7Ozs7Ozs7Ozs7OztBQ2hCakg7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELHVCQUF1Qjs7Ozs7Ozs7Ozs7O0FDbkJWO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLEdBQUc7QUFDbEIsZUFBZSxZQUFZO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsb0JBQW9COzs7Ozs7Ozs7Ozs7QUM5Q1A7QUFDYjtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQixzQ0FBc0Msa0JBQWtCO0FBQ3ZGLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsQ0FBQztBQUNELDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx5QkFBeUIsR0FBRyxpQkFBaUIsR0FBRywyQkFBMkIsR0FBRyx1QkFBdUI7QUFDckcsaUJBQWlCLG1CQUFPLENBQUMsc0VBQVU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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LHFDQUFxQywwQ0FBMEMsRUFBQztBQUNySSxzREFBcUQsRUFBRSxxQ0FBcUMsNENBQTRDLEVBQUM7QUFDekksOENBQTZDLEVBQUUscUNBQXFDLG9DQUFvQyxFQUFDOzs7Ozs7O1VDN0J6SDtVQUNBOztVQUVBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBOztVQUVBO1VBQ0E7O1VBRUE7VUFDQTtVQUNBOzs7OztXQ3RCQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLHlDQUF5Qyx3Q0FBd0M7V0FDakY7V0FDQTtXQUNBOzs7OztXQ1BBOzs7OztXQ0FBO1dBQ0E7V0FDQTtXQUNBLHVEQUF1RCxpQkFBaUI7V0FDeEU7V0FDQSxnREFBZ0QsYUFBYTtXQUM3RDs7Ozs7VUVOQTtVQUNBO1VBQ0E7VUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2t2cG9ydGFsLy4vbm9kZV9tb2R1bGVzL0BnbGFydGVrL2xlYWZsZXQubWFya2VyY2x1c3Rlci9kaXN0L2xlYWZsZXQubWFya2VyY2x1c3Rlci1zcmMuanMiLCJ3ZWJwYWNrOi8va3Zwb3J0YWwvLi9ub2RlX21vZHVsZXMvZnVzZS5qcy9kaXN0L2Z1c2UuZXNtLmpzIiwid2VicGFjazovL2t2cG9ydGFsLy4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvZGlzdC9sZWFmbGV0LXNyYy5qcyIsIndlYnBhY2s6Ly9rdnBvcnRhbC8uL3NyYy9jc3MvZW5lcmdpZWF0bGFzLnNjc3M/MjZhZSIsIndlYnBhY2s6Ly9rdnBvcnRhbC8uL25vZGVfbW9kdWxlcy9zdGUtY29yZS9kaXN0L2Rpc3BhdGNoaW5nLmpzIiwid2VicGFjazovL2t2cG9ydGFsLy4vbm9kZV9tb2R1bGVzL3N0ZS1jb3JlL2Rpc3QvaW5kZXguanMiLCJ3ZWJwYWNrOi8va3Zwb3J0YWwvLi9ub2RlX21vZHVsZXMvc3RlLWNvcmUvZGlzdC9tYW5hZ2VtZW50LmpzIiwid2VicGFjazovL2t2cG9ydGFsLy4vbm9kZV9tb2R1bGVzL3N0ZS1jb3JlL2Rpc3Qvc3Vic2NyaXB0aW9uLmpzIiwid2VicGFjazovL2t2cG9ydGFsLy4vbm9kZV9tb2R1bGVzL3N0ZS1ldmVudHMvZGlzdC9ldmVudHMuanMiLCJ3ZWJwYWNrOi8va3Zwb3J0YWwvLi9ub2RlX21vZHVsZXMvc3RlLWV2ZW50cy9kaXN0L2luZGV4LmpzIiwid2VicGFjazovL2t2cG9ydGFsLy4vbm9kZV9tb2R1bGVzL3N0ZS1zaWduYWxzL2Rpc3QvaW5kZXguanMiLCJ3ZWJwYWNrOi8va3Zwb3J0YWwvLi9ub2RlX21vZHVsZXMvc3RlLXNpZ25hbHMvZGlzdC9zaWduYWxzLmpzIiwid2VicGFjazovL2t2cG9ydGFsLy4vbm9kZV9tb2R1bGVzL3N0ZS1zaW1wbGUtZXZlbnRzL2Rpc3QvaW5kZXguanMiLCJ3ZWJwYWNrOi8va3Zwb3J0YWwvLi9ub2RlX21vZHVsZXMvc3RlLXNpbXBsZS1ldmVudHMvZGlzdC9zaW1wbGUtZXZlbnRzLmpzIiwid2VicGFjazovL2t2cG9ydGFsLy4vbm9kZV9tb2R1bGVzL3N0cm9uZ2x5LXR5cGVkLWV2ZW50cy9kaXN0L2luZGV4LmpzIiwid2VicGFjazovL2t2cG9ydGFsLy4vc3JjL0VuZXJnaWVBdGxhcy50cyIsIndlYnBhY2s6Ly9rdnBvcnRhbC8uL3NyYy90cy9MYXllckxvYWRlci50cyIsIndlYnBhY2s6Ly9rdnBvcnRhbC8uL3NyYy90cy9NYXBBcHAudHMiLCJ3ZWJwYWNrOi8va3Zwb3J0YWwvLi9zcmMvdHMvTWFwQ2xhc3NQYXJzZXIudHMiLCJ3ZWJwYWNrOi8va3Zwb3J0YWwvLi9zcmMvdHMvUGllY2hhcnRMYXllci50cyIsIndlYnBhY2s6Ly9rdnBvcnRhbC8uL3NyYy90cy9VdGlsLnRzIiwid2VicGFjazovL2t2cG9ydGFsLy4vc3JjL3RzL2NvbmYvTWFwRGVzY3JpcHRpb24udHMiLCJ3ZWJwYWNrOi8va3Zwb3J0YWwvLi9zcmMvdHMvY29udHJvbHMvQXR0cmlidXRpb25DdHJsLnRzIiwid2VicGFjazovL2t2cG9ydGFsLy4vc3JjL3RzL2NvbnRyb2xzL0Jhc2VsYXllclNlbGVjdG9yQ3RybC50cyIsIndlYnBhY2s6Ly9rdnBvcnRhbC8uL3NyYy90cy9jb250cm9scy9DYXRlZ29yaWVMYXllci50cyIsIndlYnBhY2s6Ly9rdnBvcnRhbC8uL3NyYy90cy9jb250cm9scy9JY29uQWN0aW9uLnRzIiwid2VicGFjazovL2t2cG9ydGFsLy4vc3JjL3RzL2NvbnRyb2xzL0xheWVyQ29udHJvbC50cyIsIndlYnBhY2s6Ly9rdnBvcnRhbC8uL3NyYy90cy9jb250cm9scy9MYXllckNvbnRyb2xWYXIudHMiLCJ3ZWJwYWNrOi8va3Zwb3J0YWwvLi9zcmMvdHMvY29udHJvbHMvTGVnZW5kQ29udHJvbC50cyIsIndlYnBhY2s6Ly9rdnBvcnRhbC8uL3NyYy90cy9jb250cm9scy9NYXBDb250cm9sLnRzIiwid2VicGFjazovL2t2cG9ydGFsLy4vc3JjL3RzL2NvbnRyb2xzL01hcmtlckxpc3RWaWV3LnRzIiwid2VicGFjazovL2t2cG9ydGFsLy4vc3JjL3RzL2NvbnRyb2xzL1NlYXJjaEN0cmwudHMiLCJ3ZWJwYWNrOi8va3Zwb3J0YWwvLi9zcmMvdHMvY29udHJvbHMvVmlld0NvbnRyb2wudHMiLCJ3ZWJwYWNrOi8va3Zwb3J0YWwvLi9zcmMvdHMvc3ZnL3BpZWNoYXJ0LnRzIiwid2VicGFjazovL2t2cG9ydGFsLy4vc3JjL3RzL3N2Zy9zdmcudHMiLCJ3ZWJwYWNrOi8va3Zwb3J0YWwvLi9zcmMvdHMvdXRpbC9BdXRvY29tcGxldGVyLnRzIiwid2VicGFjazovL2t2cG9ydGFsLy4vc3JjL3RzL3V0aWwvRm9ybWF0RXhwcmVzc2lvbi50cyIsIndlYnBhY2s6Ly9rdnBvcnRhbC8uL3NyYy90cy91dGlsL0wuR2VvY29kZXJNVi50cyIsIndlYnBhY2s6Ly9rdnBvcnRhbC8uL3NyYy90cy93aWRnZXQvQWNjb3JkaW9uLnRzIiwid2VicGFjazovL2t2cG9ydGFsLy4uL3RyZWVjb21wb25lbnQvc3JjL3RzL1RyZWUudHMiLCJ3ZWJwYWNrOi8va3Zwb3J0YWwvLi4vdHJlZWNvbXBvbmVudC9zcmMvdHMvVHJlZU5vZGUudHMiLCJ3ZWJwYWNrOi8va3Zwb3J0YWwvLi4vdHJlZWNvbXBvbmVudC9ub2RlX21vZHVsZXMvc3RlLWNvcmUvZGlzdC9kaXNwYXRjaGluZy5qcyIsIndlYnBhY2s6Ly9rdnBvcnRhbC8uLi90cmVlY29tcG9uZW50L25vZGVfbW9kdWxlcy9zdGUtY29yZS9kaXN0L2luZGV4LmpzIiwid2VicGFjazovL2t2cG9ydGFsLy4uL3RyZWVjb21wb25lbnQvbm9kZV9tb2R1bGVzL3N0ZS1jb3JlL2Rpc3QvbWFuYWdlbWVudC5qcyIsIndlYnBhY2s6Ly9rdnBvcnRhbC8uLi90cmVlY29tcG9uZW50L25vZGVfbW9kdWxlcy9zdGUtY29yZS9kaXN0L3N1YnNjcmlwdGlvbi5qcyIsIndlYnBhY2s6Ly9rdnBvcnRhbC8uLi90cmVlY29tcG9uZW50L25vZGVfbW9kdWxlcy9zdGUtZXZlbnRzL2Rpc3QvZXZlbnRzLmpzIiwid2VicGFjazovL2t2cG9ydGFsLy4uL3RyZWVjb21wb25lbnQvbm9kZV9tb2R1bGVzL3N0ZS1ldmVudHMvZGlzdC9pbmRleC5qcyIsIndlYnBhY2s6Ly9rdnBvcnRhbC8uLi90cmVlY29tcG9uZW50L25vZGVfbW9kdWxlcy9zdGUtc2lnbmFscy9kaXN0L2luZGV4LmpzIiwid2VicGFjazovL2t2cG9ydGFsLy4uL3RyZWVjb21wb25lbnQvbm9kZV9tb2R1bGVzL3N0ZS1zaWduYWxzL2Rpc3Qvc2lnbmFscy5qcyIsIndlYnBhY2s6Ly9rdnBvcnRhbC8uLi90cmVlY29tcG9uZW50L25vZGVfbW9kdWxlcy9zdGUtc2ltcGxlLWV2ZW50cy9kaXN0L2luZGV4LmpzIiwid2VicGFjazovL2t2cG9ydGFsLy4uL3RyZWVjb21wb25lbnQvbm9kZV9tb2R1bGVzL3N0ZS1zaW1wbGUtZXZlbnRzL2Rpc3Qvc2ltcGxlLWV2ZW50cy5qcyIsIndlYnBhY2s6Ly9rdnBvcnRhbC8uLi90cmVlY29tcG9uZW50L25vZGVfbW9kdWxlcy9zdHJvbmdseS10eXBlZC1ldmVudHMvZGlzdC9pbmRleC5qcyIsIndlYnBhY2s6Ly9rdnBvcnRhbC93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly9rdnBvcnRhbC93ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMiLCJ3ZWJwYWNrOi8va3Zwb3J0YWwvd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCIsIndlYnBhY2s6Ly9rdnBvcnRhbC93ZWJwYWNrL3J1bnRpbWUvbWFrZSBuYW1lc3BhY2Ugb2JqZWN0Iiwid2VicGFjazovL2t2cG9ydGFsL3dlYnBhY2svYmVmb3JlLXN0YXJ0dXAiLCJ3ZWJwYWNrOi8va3Zwb3J0YWwvd2VicGFjay9zdGFydHVwIiwid2VicGFjazovL2t2cG9ydGFsL3dlYnBhY2svYWZ0ZXItc3RhcnR1cCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogTGVhZmxldC5tYXJrZXJjbHVzdGVyIDEuNC40K21hc3Rlci5jODE4OTI3LFxuICogUHJvdmlkZXMgQmVhdXRpZnVsIEFuaW1hdGVkIE1hcmtlciBDbHVzdGVyaW5nIGZ1bmN0aW9uYWxpdHkgZm9yIExlYWZsZXQsIGEgSlMgbGlicmFyeSBmb3IgaW50ZXJhY3RpdmUgbWFwcy5cbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9MZWFmbGV0L0xlYWZsZXQubWFya2VyY2x1c3RlclxuICogKGMpIDIwMTItMjAxNywgRGF2ZSBMZWF2ZXIsIHNtYXJ0cmFrXG4gKi9cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG5cdHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcblx0KGdsb2JhbCA9IGdsb2JhbCB8fCBzZWxmLCBmYWN0b3J5KChnbG9iYWwuTGVhZmxldCA9IGdsb2JhbC5MZWFmbGV0IHx8IHt9LCBnbG9iYWwuTGVhZmxldC5tYXJrZXJjbHVzdGVyID0ge30pKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cykgeyAndXNlIHN0cmljdCc7XG5cblx0Lypcblx0ICogTC5NYXJrZXJDbHVzdGVyR3JvdXAgZXh0ZW5kcyBMLkZlYXR1cmVHcm91cCBieSBjbHVzdGVyaW5nIHRoZSBtYXJrZXJzIGNvbnRhaW5lZCB3aXRoaW5cblx0ICovXG5cblx0dmFyIE1hcmtlckNsdXN0ZXJHcm91cCA9IEwuTWFya2VyQ2x1c3Rlckdyb3VwID0gTC5GZWF0dXJlR3JvdXAuZXh0ZW5kKHtcblxuXHRcdG9wdGlvbnM6IHtcblx0XHRcdG1heENsdXN0ZXJSYWRpdXM6IDgwLCAvL0EgY2x1c3RlciB3aWxsIGNvdmVyIGF0IG1vc3QgdGhpcyBtYW55IHBpeGVscyBmcm9tIGl0cyBjZW50ZXJcblx0XHRcdGljb25DcmVhdGVGdW5jdGlvbjogbnVsbCxcblx0XHRcdGNsdXN0ZXJQYW5lOiBMLk1hcmtlci5wcm90b3R5cGUub3B0aW9ucy5wYW5lLFxuXG5cdFx0XHRzcGlkZXJmeU9uTWF4Wm9vbTogdHJ1ZSxcblx0XHRcdHNob3dDb3ZlcmFnZU9uSG92ZXI6IHRydWUsXG5cdFx0XHR6b29tVG9Cb3VuZHNPbkNsaWNrOiB0cnVlLFxuXHRcdFx0c2luZ2xlTWFya2VyTW9kZTogZmFsc2UsXG5cblx0XHRcdGRpc2FibGVDbHVzdGVyaW5nQXRab29tOiBudWxsLFxuXG5cdFx0XHQvLyBTZXR0aW5nIHRoaXMgdG8gZmFsc2UgcHJldmVudHMgdGhlIHJlbW92YWwgb2YgYW55IGNsdXN0ZXJzIG91dHNpZGUgb2YgdGhlIHZpZXdwb2ludCwgd2hpY2hcblx0XHRcdC8vIGlzIHRoZSBkZWZhdWx0IGJlaGF2aW91ciBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucy5cblx0XHRcdHJlbW92ZU91dHNpZGVWaXNpYmxlQm91bmRzOiB0cnVlLFxuXG5cdFx0XHQvLyBTZXQgdG8gZmFsc2UgdG8gZGlzYWJsZSBhbGwgYW5pbWF0aW9ucyAoem9vbSBhbmQgc3BpZGVyZnkpLlxuXHRcdFx0Ly8gSWYgZmFsc2UsIG9wdGlvbiBhbmltYXRlQWRkaW5nTWFya2VycyBiZWxvdyBoYXMgbm8gZWZmZWN0LlxuXHRcdFx0Ly8gSWYgTC5Eb21VdGlsLlRSQU5TSVRJT04gaXMgZmFsc3ksIHRoaXMgb3B0aW9uIGhhcyBubyBlZmZlY3QuXG5cdFx0XHRhbmltYXRlOiB0cnVlLFxuXG5cdFx0XHQvL1doZXRoZXIgdG8gYW5pbWF0ZSBhZGRpbmcgbWFya2VycyBhZnRlciBhZGRpbmcgdGhlIE1hcmtlckNsdXN0ZXJHcm91cCB0byB0aGUgbWFwXG5cdFx0XHQvLyBJZiB5b3UgYXJlIGFkZGluZyBpbmRpdmlkdWFsIG1hcmtlcnMgc2V0IHRvIHRydWUsIGlmIGFkZGluZyBidWxrIG1hcmtlcnMgbGVhdmUgZmFsc2UgZm9yIG1hc3NpdmUgcGVyZm9ybWFuY2UgZ2FpbnMuXG5cdFx0XHRhbmltYXRlQWRkaW5nTWFya2VyczogZmFsc2UsXG5cblx0XHRcdC8vIE1ha2UgaXQgcG9zc2libGUgdG8gcHJvdmlkZSBjdXN0b20gZnVuY3Rpb24gdG8gY2FsY3VsYXRlIHNwaWRlcmZ5IHNoYXBlIHBvc2l0aW9uc1xuXHRcdFx0c3BpZGVyZnlTaGFwZVBvc2l0aW9uczogbnVsbCxcblxuXHRcdFx0Ly9JbmNyZWFzZSB0byBpbmNyZWFzZSB0aGUgZGlzdGFuY2UgYXdheSB0aGF0IHNwaWRlcmZpZWQgbWFya2VycyBhcHBlYXIgZnJvbSB0aGUgY2VudGVyXG5cdFx0XHRzcGlkZXJmeURpc3RhbmNlTXVsdGlwbGllcjogMSxcblxuXHRcdFx0Ly8gTWFrZSBpdCBwb3NzaWJsZSB0byBzcGVjaWZ5IGEgcG9seWxpbmUgb3B0aW9ucyBvbiBhIHNwaWRlciBsZWdcblx0XHRcdHNwaWRlckxlZ1BvbHlsaW5lT3B0aW9uczogeyB3ZWlnaHQ6IDEuNSwgY29sb3I6ICcjMjIyJywgb3BhY2l0eTogMC41IH0sXG5cblx0XHRcdC8vIFdoZW4gYnVsayBhZGRpbmcgbGF5ZXJzLCBhZGRzIG1hcmtlcnMgaW4gY2h1bmtzLiBNZWFucyBhZGRMYXllcnMgbWF5IG5vdCBhZGQgYWxsIHRoZSBsYXllcnMgaW4gdGhlIGNhbGwsIG90aGVycyB3aWxsIGJlIGxvYWRlZCBkdXJpbmcgc2V0VGltZW91dHNcblx0XHRcdGNodW5rZWRMb2FkaW5nOiBmYWxzZSxcblx0XHRcdGNodW5rSW50ZXJ2YWw6IDIwMCwgLy8gcHJvY2VzcyBtYXJrZXJzIGZvciBhIG1heGltdW0gb2YgfiBuIG1pbGxpc2Vjb25kcyAodGhlbiB0cmlnZ2VyIHRoZSBjaHVua1Byb2dyZXNzIGNhbGxiYWNrKVxuXHRcdFx0Y2h1bmtEZWxheTogNTAsIC8vIGF0IHRoZSBlbmQgb2YgZWFjaCBpbnRlcnZhbCwgZ2l2ZSBuIG1pbGxpc2Vjb25kcyBiYWNrIHRvIHN5c3RlbS9icm93c2VyXG5cdFx0XHRjaHVua1Byb2dyZXNzOiBudWxsLCAvLyBwcm9ncmVzcyBjYWxsYmFjazogZnVuY3Rpb24ocHJvY2Vzc2VkLCB0b3RhbCwgZWxhcHNlZCkgKGUuZy4gZm9yIGEgcHJvZ3Jlc3MgaW5kaWNhdG9yKVxuXG5cdFx0XHQvL09wdGlvbnMgdG8gcGFzcyB0byB0aGUgTC5Qb2x5Z29uIGNvbnN0cnVjdG9yXG5cdFx0XHRwb2x5Z29uT3B0aW9uczoge31cblx0XHR9LFxuXG5cdFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0XHRcdEwuVXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuXHRcdFx0aWYgKCF0aGlzLm9wdGlvbnMuaWNvbkNyZWF0ZUZ1bmN0aW9uKSB7XG5cdFx0XHRcdHRoaXMub3B0aW9ucy5pY29uQ3JlYXRlRnVuY3Rpb24gPSB0aGlzLl9kZWZhdWx0SWNvbkNyZWF0ZUZ1bmN0aW9uO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9mZWF0dXJlR3JvdXAgPSBMLmZlYXR1cmVHcm91cCgpO1xuXHRcdFx0dGhpcy5fZmVhdHVyZUdyb3VwLmFkZEV2ZW50UGFyZW50KHRoaXMpO1xuXG5cdFx0XHR0aGlzLl9ub25Qb2ludEdyb3VwID0gTC5mZWF0dXJlR3JvdXAoKTtcblx0XHRcdHRoaXMuX25vblBvaW50R3JvdXAuYWRkRXZlbnRQYXJlbnQodGhpcyk7XG5cblx0XHRcdHRoaXMuX2luWm9vbUFuaW1hdGlvbiA9IDA7XG5cdFx0XHR0aGlzLl9uZWVkc0NsdXN0ZXJpbmcgPSBbXTtcblx0XHRcdHRoaXMuX25lZWRzUmVtb3ZpbmcgPSBbXTsgLy9NYXJrZXJzIHJlbW92ZWQgd2hpbGUgd2UgYXJlbid0IG9uIHRoZSBtYXAgbmVlZCB0byBiZSBrZXB0IHRyYWNrIG9mXG5cdFx0XHQvL1RoZSBib3VuZHMgb2YgdGhlIGN1cnJlbnRseSBzaG93biBhcmVhIChmcm9tIF9nZXRFeHBhbmRlZFZpc2libGVCb3VuZHMpIFVwZGF0ZWQgb24gem9vbS9tb3ZlXG5cdFx0XHR0aGlzLl9jdXJyZW50U2hvd25Cb3VuZHMgPSBudWxsO1xuXG5cdFx0XHR0aGlzLl9xdWV1ZSA9IFtdO1xuXG5cdFx0XHR0aGlzLl9jaGlsZE1hcmtlckV2ZW50SGFuZGxlcnMgPSB7XG5cdFx0XHRcdCdkcmFnc3RhcnQnOiB0aGlzLl9jaGlsZE1hcmtlckRyYWdTdGFydCxcblx0XHRcdFx0J21vdmUnOiB0aGlzLl9jaGlsZE1hcmtlck1vdmVkLFxuXHRcdFx0XHQnZHJhZ2VuZCc6IHRoaXMuX2NoaWxkTWFya2VyRHJhZ0VuZCxcblx0XHRcdH07XG5cblx0XHRcdC8vIEhvb2sgdGhlIGFwcHJvcHJpYXRlIGFuaW1hdGlvbiBtZXRob2RzLlxuXHRcdFx0dmFyIGFuaW1hdGUgPSBMLkRvbVV0aWwuVFJBTlNJVElPTiAmJiB0aGlzLm9wdGlvbnMuYW5pbWF0ZTtcblx0XHRcdEwuZXh0ZW5kKHRoaXMsIGFuaW1hdGUgPyB0aGlzLl93aXRoQW5pbWF0aW9uIDogdGhpcy5fbm9BbmltYXRpb24pO1xuXHRcdFx0Ly8gUmVtZW1iZXIgd2hpY2ggTWFya2VyQ2x1c3RlciBjbGFzcyB0byBpbnN0YW50aWF0ZSAoYW5pbWF0ZWQgb3Igbm90KS5cblx0XHRcdHRoaXMuX21hcmtlckNsdXN0ZXIgPSBhbmltYXRlID8gTC5NYXJrZXJDbHVzdGVyIDogTC5NYXJrZXJDbHVzdGVyTm9uQW5pbWF0ZWQ7XG5cdFx0fSxcblxuXHRcdGFkZExheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcblxuXHRcdFx0aWYgKGxheWVyIGluc3RhbmNlb2YgTC5MYXllckdyb3VwKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmFkZExheWVycyhbbGF5ZXJdKTtcblx0XHRcdH1cblxuXHRcdFx0Ly9Eb24ndCBjbHVzdGVyIG5vbiBwb2ludCBkYXRhXG5cdFx0XHRpZiAoIWxheWVyLmdldExhdExuZykge1xuXHRcdFx0XHR0aGlzLl9ub25Qb2ludEdyb3VwLmFkZExheWVyKGxheWVyKTtcblx0XHRcdFx0dGhpcy5maXJlKCdsYXllcmFkZCcsIHsgbGF5ZXI6IGxheWVyIH0pO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH1cblxuXHRcdFx0aWYgKCF0aGlzLl9tYXApIHtcblx0XHRcdFx0dGhpcy5fbmVlZHNDbHVzdGVyaW5nLnB1c2gobGF5ZXIpO1xuXHRcdFx0XHR0aGlzLmZpcmUoJ2xheWVyYWRkJywgeyBsYXllcjogbGF5ZXIgfSk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGhpcy5oYXNMYXllcihsYXllcikpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9XG5cblxuXHRcdFx0Ly9JZiB3ZSBoYXZlIGFscmVhZHkgY2x1c3RlcmVkIHdlJ2xsIG5lZWQgdG8gYWRkIHRoaXMgb25lIHRvIGEgY2x1c3RlclxuXG5cdFx0XHRpZiAodGhpcy5fdW5zcGlkZXJmeSkge1xuXHRcdFx0XHR0aGlzLl91bnNwaWRlcmZ5KCk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX2FkZExheWVyKGxheWVyLCB0aGlzLl9tYXhab29tKTtcblx0XHRcdHRoaXMuZmlyZSgnbGF5ZXJhZGQnLCB7IGxheWVyOiBsYXllciB9KTtcblxuXHRcdFx0Ly8gUmVmcmVzaCBib3VuZHMgYW5kIHdlaWdodGVkIHBvc2l0aW9ucy5cblx0XHRcdHRoaXMuX3RvcENsdXN0ZXJMZXZlbC5fcmVjYWxjdWxhdGVCb3VuZHMoKTtcblxuXHRcdFx0dGhpcy5fcmVmcmVzaENsdXN0ZXJzSWNvbnMoKTtcblxuXHRcdFx0Ly9Xb3JrIG91dCB3aGF0IGlzIHZpc2libGVcblx0XHRcdHZhciB2aXNpYmxlTGF5ZXIgPSBsYXllcixcblx0XHRcdCAgICBjdXJyZW50Wm9vbSA9IHRoaXMuX3pvb207XG5cdFx0XHRpZiAobGF5ZXIuX19wYXJlbnQpIHtcblx0XHRcdFx0d2hpbGUgKHZpc2libGVMYXllci5fX3BhcmVudC5fem9vbSA+PSBjdXJyZW50Wm9vbSkge1xuXHRcdFx0XHRcdHZpc2libGVMYXllciA9IHZpc2libGVMYXllci5fX3BhcmVudDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGhpcy5fY3VycmVudFNob3duQm91bmRzLmNvbnRhaW5zKHZpc2libGVMYXllci5nZXRMYXRMbmcoKSkpIHtcblx0XHRcdFx0aWYgKHRoaXMub3B0aW9ucy5hbmltYXRlQWRkaW5nTWFya2Vycykge1xuXHRcdFx0XHRcdHRoaXMuX2FuaW1hdGlvbkFkZExheWVyKGxheWVyLCB2aXNpYmxlTGF5ZXIpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuX2FuaW1hdGlvbkFkZExheWVyTm9uQW5pbWF0ZWQobGF5ZXIsIHZpc2libGVMYXllcik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH0sXG5cblx0XHRyZW1vdmVMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XG5cblx0XHRcdGlmIChsYXllciBpbnN0YW5jZW9mIEwuTGF5ZXJHcm91cCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5yZW1vdmVMYXllcnMoW2xheWVyXSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vTm9uIHBvaW50IGxheWVyc1xuXHRcdFx0aWYgKCFsYXllci5nZXRMYXRMbmcpIHtcblx0XHRcdFx0dGhpcy5fbm9uUG9pbnRHcm91cC5yZW1vdmVMYXllcihsYXllcik7XG5cdFx0XHRcdHRoaXMuZmlyZSgnbGF5ZXJyZW1vdmUnLCB7IGxheWVyOiBsYXllciB9KTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9XG5cblx0XHRcdGlmICghdGhpcy5fbWFwKSB7XG5cdFx0XHRcdGlmICghdGhpcy5fYXJyYXlTcGxpY2UodGhpcy5fbmVlZHNDbHVzdGVyaW5nLCBsYXllcikgJiYgdGhpcy5oYXNMYXllcihsYXllcikpIHtcblx0XHRcdFx0XHR0aGlzLl9uZWVkc1JlbW92aW5nLnB1c2goeyBsYXllcjogbGF5ZXIsIGxhdGxuZzogbGF5ZXIuX2xhdGxuZyB9KTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLmZpcmUoJ2xheWVycmVtb3ZlJywgeyBsYXllcjogbGF5ZXIgfSk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIWxheWVyLl9fcGFyZW50KSB7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGhpcy5fdW5zcGlkZXJmeSkge1xuXHRcdFx0XHR0aGlzLl91bnNwaWRlcmZ5KCk7XG5cdFx0XHRcdHRoaXMuX3Vuc3BpZGVyZnlMYXllcihsYXllcik7XG5cdFx0XHR9XG5cblx0XHRcdC8vUmVtb3ZlIHRoZSBtYXJrZXIgZnJvbSBjbHVzdGVyc1xuXHRcdFx0dGhpcy5fcmVtb3ZlTGF5ZXIobGF5ZXIsIHRydWUpO1xuXHRcdFx0dGhpcy5maXJlKCdsYXllcnJlbW92ZScsIHsgbGF5ZXI6IGxheWVyIH0pO1xuXG5cdFx0XHQvLyBSZWZyZXNoIGJvdW5kcyBhbmQgd2VpZ2h0ZWQgcG9zaXRpb25zLlxuXHRcdFx0dGhpcy5fdG9wQ2x1c3RlckxldmVsLl9yZWNhbGN1bGF0ZUJvdW5kcygpO1xuXG5cdFx0XHR0aGlzLl9yZWZyZXNoQ2x1c3RlcnNJY29ucygpO1xuXG5cdFx0XHRsYXllci5vZmYodGhpcy5fY2hpbGRNYXJrZXJFdmVudEhhbmRsZXJzLCB0aGlzKTtcblxuXHRcdFx0aWYgKHRoaXMuX2ZlYXR1cmVHcm91cC5oYXNMYXllcihsYXllcikpIHtcblx0XHRcdFx0dGhpcy5fZmVhdHVyZUdyb3VwLnJlbW92ZUxheWVyKGxheWVyKTtcblx0XHRcdFx0aWYgKGxheWVyLmNsdXN0ZXJTaG93KSB7XG5cdFx0XHRcdFx0bGF5ZXIuY2x1c3RlclNob3coKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9LFxuXG5cdFx0Ly9UYWtlcyBhbiBhcnJheSBvZiBtYXJrZXJzIGFuZCBhZGRzIHRoZW0gaW4gYnVsa1xuXHRcdGFkZExheWVyczogZnVuY3Rpb24gKGxheWVyc0FycmF5LCBza2lwTGF5ZXJBZGRFdmVudCkge1xuXHRcdFx0aWYgKCFMLlV0aWwuaXNBcnJheShsYXllcnNBcnJheSkpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuYWRkTGF5ZXIobGF5ZXJzQXJyYXkpO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgZmcgPSB0aGlzLl9mZWF0dXJlR3JvdXAsXG5cdFx0XHQgICAgbnBnID0gdGhpcy5fbm9uUG9pbnRHcm91cCxcblx0XHRcdCAgICBjaHVua2VkID0gdGhpcy5vcHRpb25zLmNodW5rZWRMb2FkaW5nLFxuXHRcdFx0ICAgIGNodW5rSW50ZXJ2YWwgPSB0aGlzLm9wdGlvbnMuY2h1bmtJbnRlcnZhbCxcblx0XHRcdCAgICBjaHVua1Byb2dyZXNzID0gdGhpcy5vcHRpb25zLmNodW5rUHJvZ3Jlc3MsXG5cdFx0XHQgICAgbCA9IGxheWVyc0FycmF5Lmxlbmd0aCxcblx0XHRcdCAgICBvZmZzZXQgPSAwLFxuXHRcdFx0ICAgIG9yaWdpbmFsQXJyYXkgPSB0cnVlLFxuXHRcdFx0ICAgIG07XG5cblx0XHRcdGlmICh0aGlzLl9tYXApIHtcblx0XHRcdFx0dmFyIHN0YXJ0ZWQgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuXHRcdFx0XHR2YXIgcHJvY2VzcyA9IEwuYmluZChmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0dmFyIHN0YXJ0ID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcblxuXHRcdFx0XHRcdC8vIE1ha2Ugc3VyZSB0byB1bnNwaWRlcmZ5IGJlZm9yZSBzdGFydGluZyB0byBhZGQgc29tZSBsYXllcnNcblx0XHRcdFx0XHRpZiAodGhpcy5fbWFwICYmIHRoaXMuX3Vuc3BpZGVyZnkpIHtcblx0XHRcdFx0XHRcdHRoaXMuX3Vuc3BpZGVyZnkoKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRmb3IgKDsgb2Zmc2V0IDwgbDsgb2Zmc2V0KyspIHtcblx0XHRcdFx0XHRcdGlmIChjaHVua2VkICYmIG9mZnNldCAlIDIwMCA9PT0gMCkge1xuXHRcdFx0XHRcdFx0XHQvLyBldmVyeSBjb3VwbGUgaHVuZHJlZCBtYXJrZXJzLCBpbnN0cnVtZW50IHRoZSB0aW1lIGVsYXBzZWQgc2luY2UgcHJvY2Vzc2luZyBzdGFydGVkOlxuXHRcdFx0XHRcdFx0XHR2YXIgZWxhcHNlZCA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCkgLSBzdGFydDtcblx0XHRcdFx0XHRcdFx0aWYgKGVsYXBzZWQgPiBjaHVua0ludGVydmFsKSB7XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7IC8vIGJlZW4gd29ya2luZyB0b28gaGFyZCwgdGltZSB0byB0YWtlIGEgYnJlYWsgOi0pXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0bSA9IGxheWVyc0FycmF5W29mZnNldF07XG5cblx0XHRcdFx0XHRcdC8vIEdyb3VwIG9mIGxheWVycywgYXBwZW5kIGNoaWxkcmVuIHRvIGxheWVyc0FycmF5IGFuZCBza2lwLlxuXHRcdFx0XHRcdFx0Ly8gU2lkZSBlZmZlY3RzOlxuXHRcdFx0XHRcdFx0Ly8gLSBUb3RhbCBpbmNyZWFzZXMsIHNvIGNodW5rUHJvZ3Jlc3MgcmF0aW8ganVtcHMgYmFja3dhcmQuXG5cdFx0XHRcdFx0XHQvLyAtIEdyb3VwcyBhcmUgbm90IGluY2x1ZGVkIGluIHRoaXMgZ3JvdXAsIG9ubHkgdGhlaXIgbm9uLWdyb3VwIGNoaWxkIGxheWVycyAoaGFzTGF5ZXIpLlxuXHRcdFx0XHRcdFx0Ly8gQ2hhbmdpbmcgYXJyYXkgbGVuZ3RoIHdoaWxlIGxvb3BpbmcgZG9lcyBub3QgYWZmZWN0IHBlcmZvcm1hbmNlIGluIGN1cnJlbnQgYnJvd3NlcnM6XG5cdFx0XHRcdFx0XHQvLyBodHRwOi8vanNwZXJmLmNvbS9mb3ItbG9vcC1jaGFuZ2luZy1sZW5ndGgvNlxuXHRcdFx0XHRcdFx0aWYgKG0gaW5zdGFuY2VvZiBMLkxheWVyR3JvdXApIHtcblx0XHRcdFx0XHRcdFx0aWYgKG9yaWdpbmFsQXJyYXkpIHtcblx0XHRcdFx0XHRcdFx0XHRsYXllcnNBcnJheSA9IGxheWVyc0FycmF5LnNsaWNlKCk7XG5cdFx0XHRcdFx0XHRcdFx0b3JpZ2luYWxBcnJheSA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHRoaXMuX2V4dHJhY3ROb25Hcm91cExheWVycyhtLCBsYXllcnNBcnJheSk7XG5cdFx0XHRcdFx0XHRcdGwgPSBsYXllcnNBcnJheS5sZW5ndGg7XG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvL05vdCBwb2ludCBkYXRhLCBjYW4ndCBiZSBjbHVzdGVyZWRcblx0XHRcdFx0XHRcdGlmICghbS5nZXRMYXRMbmcpIHtcblx0XHRcdFx0XHRcdFx0bnBnLmFkZExheWVyKG0pO1xuXHRcdFx0XHRcdFx0XHRpZiAoIXNraXBMYXllckFkZEV2ZW50KSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5maXJlKCdsYXllcmFkZCcsIHsgbGF5ZXI6IG0gfSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGlmICh0aGlzLmhhc0xheWVyKG0pKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR0aGlzLl9hZGRMYXllcihtLCB0aGlzLl9tYXhab29tKTtcblx0XHRcdFx0XHRcdGlmICghc2tpcExheWVyQWRkRXZlbnQpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5maXJlKCdsYXllcmFkZCcsIHsgbGF5ZXI6IG0gfSk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vSWYgd2UganVzdCBtYWRlIGEgY2x1c3RlciBvZiBzaXplIDIgdGhlbiB3ZSBuZWVkIHRvIHJlbW92ZSB0aGUgb3RoZXIgbWFya2VyIGZyb20gdGhlIG1hcCAoaWYgaXQgaXMpIG9yIHdlIG5ldmVyIHdpbGxcblx0XHRcdFx0XHRcdGlmIChtLl9fcGFyZW50KSB7XG5cdFx0XHRcdFx0XHRcdGlmIChtLl9fcGFyZW50LmdldENoaWxkQ291bnQoKSA9PT0gMikge1xuXHRcdFx0XHRcdFx0XHRcdHZhciBtYXJrZXJzID0gbS5fX3BhcmVudC5nZXRBbGxDaGlsZE1hcmtlcnMoKSxcblx0XHRcdFx0XHRcdFx0XHQgICAgb3RoZXJNYXJrZXIgPSBtYXJrZXJzWzBdID09PSBtID8gbWFya2Vyc1sxXSA6IG1hcmtlcnNbMF07XG5cdFx0XHRcdFx0XHRcdFx0ZmcucmVtb3ZlTGF5ZXIob3RoZXJNYXJrZXIpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKGNodW5rUHJvZ3Jlc3MpIHtcblx0XHRcdFx0XHRcdC8vIHJlcG9ydCBwcm9ncmVzcyBhbmQgdGltZSBlbGFwc2VkOlxuXHRcdFx0XHRcdFx0Y2h1bmtQcm9ncmVzcyhvZmZzZXQsIGwsIChuZXcgRGF0ZSgpKS5nZXRUaW1lKCkgLSBzdGFydGVkKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBDb21wbGV0ZWQgcHJvY2Vzc2luZyBhbGwgbWFya2Vycy5cblx0XHRcdFx0XHRpZiAob2Zmc2V0ID09PSBsKSB7XG5cblx0XHRcdFx0XHRcdC8vIFJlZnJlc2ggYm91bmRzIGFuZCB3ZWlnaHRlZCBwb3NpdGlvbnMuXG5cdFx0XHRcdFx0XHR0aGlzLl90b3BDbHVzdGVyTGV2ZWwuX3JlY2FsY3VsYXRlQm91bmRzKCk7XG5cblx0XHRcdFx0XHRcdHRoaXMuX3JlZnJlc2hDbHVzdGVyc0ljb25zKCk7XG5cblx0XHRcdFx0XHRcdHRoaXMuX3RvcENsdXN0ZXJMZXZlbC5fcmVjdXJzaXZlbHlBZGRDaGlsZHJlblRvTWFwKG51bGwsIHRoaXMuX3pvb20sIHRoaXMuX2N1cnJlbnRTaG93bkJvdW5kcyk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHNldFRpbWVvdXQocHJvY2VzcywgdGhpcy5vcHRpb25zLmNodW5rRGVsYXkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSwgdGhpcyk7XG5cblx0XHRcdFx0cHJvY2VzcygpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIG5lZWRzQ2x1c3RlcmluZyA9IG5ldyBBcnJheShsIC0gb2Zmc2V0KTtcdC8vIGltcHJvdmUgcGVyZm9ybWFuY2UgYnkgcHJlYWxsb2NhdGluZyB0aGUgbWF4aW11bSBzaXplIG9mIG91ciBhcnJheVxuXHRcdFx0XHR2YXIgdGFpbCA9IDA7XG5cblx0XHRcdFx0Zm9yICg7IG9mZnNldCA8IGw7IG9mZnNldCsrKSB7XG5cdFx0XHRcdFx0bSA9IGxheWVyc0FycmF5W29mZnNldF07XG5cblx0XHRcdFx0XHQvLyBHcm91cCBvZiBsYXllcnMsIGFwcGVuZCBjaGlsZHJlbiB0byBsYXllcnNBcnJheSBhbmQgc2tpcC5cblx0XHRcdFx0XHRpZiAobSBpbnN0YW5jZW9mIEwuTGF5ZXJHcm91cCkge1xuXHRcdFx0XHRcdFx0aWYgKG9yaWdpbmFsQXJyYXkpIHtcblx0XHRcdFx0XHRcdFx0bGF5ZXJzQXJyYXkgPSBsYXllcnNBcnJheS5zbGljZSgpO1xuXHRcdFx0XHRcdFx0XHRvcmlnaW5hbEFycmF5ID0gZmFsc2U7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR0aGlzLl9leHRyYWN0Tm9uR3JvdXBMYXllcnMobSwgbGF5ZXJzQXJyYXkpO1xuXHRcdFx0XHRcdFx0bCA9IGxheWVyc0FycmF5Lmxlbmd0aDtcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vTm90IHBvaW50IGRhdGEsIGNhbid0IGJlIGNsdXN0ZXJlZFxuXHRcdFx0XHRcdGlmICghbS5nZXRMYXRMbmcpIHtcblx0XHRcdFx0XHRcdG5wZy5hZGRMYXllcihtKTtcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICh0aGlzLmhhc0xheWVyKG0pKSB7XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRuZWVkc0NsdXN0ZXJpbmdbdGFpbCsrXSA9IG07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRuZWVkc0NsdXN0ZXJpbmcgPSBuZWVkc0NsdXN0ZXJpbmcuc2xpY2UoMCwgdGFpbCk7XHQvLyB0cnVuY2F0ZSBlbXB0eSBlbGVtZW50c1xuXHRcdFx0XHR0aGlzLl9uZWVkc0NsdXN0ZXJpbmcucHVzaC5hcHBseSh0aGlzLl9uZWVkc0NsdXN0ZXJpbmcsIG5lZWRzQ2x1c3RlcmluZyk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9LFxuXG5cdFx0Ly9UYWtlcyBhbiBhcnJheSBvZiBtYXJrZXJzIGFuZCByZW1vdmVzIHRoZW0gaW4gYnVsa1xuXHRcdHJlbW92ZUxheWVyczogZnVuY3Rpb24gKGxheWVyc0FycmF5KSB7XG5cdFx0XHR2YXIgaSwgbSxcblx0XHRcdCAgICBsID0gbGF5ZXJzQXJyYXkubGVuZ3RoLFxuXHRcdFx0ICAgIGZnID0gdGhpcy5fZmVhdHVyZUdyb3VwLFxuXHRcdFx0ICAgIG5wZyA9IHRoaXMuX25vblBvaW50R3JvdXAsXG5cdFx0XHQgICAgb3JpZ2luYWxBcnJheSA9IHRydWU7XG5cblx0XHRcdGlmICghdGhpcy5fbWFwKSB7XG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHRtID0gbGF5ZXJzQXJyYXlbaV07XG5cblx0XHRcdFx0XHQvLyBHcm91cCBvZiBsYXllcnMsIGFwcGVuZCBjaGlsZHJlbiB0byBsYXllcnNBcnJheSBhbmQgc2tpcC5cblx0XHRcdFx0XHRpZiAobSBpbnN0YW5jZW9mIEwuTGF5ZXJHcm91cCkge1xuXHRcdFx0XHRcdFx0aWYgKG9yaWdpbmFsQXJyYXkpIHtcblx0XHRcdFx0XHRcdFx0bGF5ZXJzQXJyYXkgPSBsYXllcnNBcnJheS5zbGljZSgpO1xuXHRcdFx0XHRcdFx0XHRvcmlnaW5hbEFycmF5ID0gZmFsc2U7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR0aGlzLl9leHRyYWN0Tm9uR3JvdXBMYXllcnMobSwgbGF5ZXJzQXJyYXkpO1xuXHRcdFx0XHRcdFx0bCA9IGxheWVyc0FycmF5Lmxlbmd0aDtcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHRoaXMuX2FycmF5U3BsaWNlKHRoaXMuX25lZWRzQ2x1c3RlcmluZywgbSk7XG5cdFx0XHRcdFx0bnBnLnJlbW92ZUxheWVyKG0pO1xuXHRcdFx0XHRcdGlmICh0aGlzLmhhc0xheWVyKG0pKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9uZWVkc1JlbW92aW5nLnB1c2goeyBsYXllcjogbSwgbGF0bG5nOiBtLl9sYXRsbmcgfSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRoaXMuZmlyZSgnbGF5ZXJyZW1vdmUnLCB7IGxheWVyOiBtIH0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGhpcy5fdW5zcGlkZXJmeSkge1xuXHRcdFx0XHR0aGlzLl91bnNwaWRlcmZ5KCk7XG5cblx0XHRcdFx0Ly8gV29yayBvbiBhIGNvcHkgb2YgdGhlIGFycmF5LCBzbyB0aGF0IG5leHQgbG9vcCBpcyBub3QgYWZmZWN0ZWQuXG5cdFx0XHRcdHZhciBsYXllcnNBcnJheTIgPSBsYXllcnNBcnJheS5zbGljZSgpLFxuXHRcdFx0XHQgICAgbDIgPSBsO1xuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgbDI7IGkrKykge1xuXHRcdFx0XHRcdG0gPSBsYXllcnNBcnJheTJbaV07XG5cblx0XHRcdFx0XHQvLyBHcm91cCBvZiBsYXllcnMsIGFwcGVuZCBjaGlsZHJlbiB0byBsYXllcnNBcnJheSBhbmQgc2tpcC5cblx0XHRcdFx0XHRpZiAobSBpbnN0YW5jZW9mIEwuTGF5ZXJHcm91cCkge1xuXHRcdFx0XHRcdFx0dGhpcy5fZXh0cmFjdE5vbkdyb3VwTGF5ZXJzKG0sIGxheWVyc0FycmF5Mik7XG5cdFx0XHRcdFx0XHRsMiA9IGxheWVyc0FycmF5Mi5sZW5ndGg7XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR0aGlzLl91bnNwaWRlcmZ5TGF5ZXIobSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRtID0gbGF5ZXJzQXJyYXlbaV07XG5cblx0XHRcdFx0Ly8gR3JvdXAgb2YgbGF5ZXJzLCBhcHBlbmQgY2hpbGRyZW4gdG8gbGF5ZXJzQXJyYXkgYW5kIHNraXAuXG5cdFx0XHRcdGlmIChtIGluc3RhbmNlb2YgTC5MYXllckdyb3VwKSB7XG5cdFx0XHRcdFx0aWYgKG9yaWdpbmFsQXJyYXkpIHtcblx0XHRcdFx0XHRcdGxheWVyc0FycmF5ID0gbGF5ZXJzQXJyYXkuc2xpY2UoKTtcblx0XHRcdFx0XHRcdG9yaWdpbmFsQXJyYXkgPSBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5fZXh0cmFjdE5vbkdyb3VwTGF5ZXJzKG0sIGxheWVyc0FycmF5KTtcblx0XHRcdFx0XHRsID0gbGF5ZXJzQXJyYXkubGVuZ3RoO1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCFtLl9fcGFyZW50KSB7XG5cdFx0XHRcdFx0bnBnLnJlbW92ZUxheWVyKG0pO1xuXHRcdFx0XHRcdHRoaXMuZmlyZSgnbGF5ZXJyZW1vdmUnLCB7IGxheWVyOiBtIH0pO1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy5fcmVtb3ZlTGF5ZXIobSwgdHJ1ZSwgdHJ1ZSk7XG5cdFx0XHRcdHRoaXMuZmlyZSgnbGF5ZXJyZW1vdmUnLCB7IGxheWVyOiBtIH0pO1xuXG5cdFx0XHRcdGlmIChmZy5oYXNMYXllcihtKSkge1xuXHRcdFx0XHRcdGZnLnJlbW92ZUxheWVyKG0pO1xuXHRcdFx0XHRcdGlmIChtLmNsdXN0ZXJTaG93KSB7XG5cdFx0XHRcdFx0XHRtLmNsdXN0ZXJTaG93KCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlZnJlc2ggYm91bmRzIGFuZCB3ZWlnaHRlZCBwb3NpdGlvbnMuXG5cdFx0XHR0aGlzLl90b3BDbHVzdGVyTGV2ZWwuX3JlY2FsY3VsYXRlQm91bmRzKCk7XG5cblx0XHRcdHRoaXMuX3JlZnJlc2hDbHVzdGVyc0ljb25zKCk7XG5cblx0XHRcdC8vRml4IHVwIHRoZSBjbHVzdGVycyBhbmQgbWFya2VycyBvbiB0aGUgbWFwXG5cdFx0XHR0aGlzLl90b3BDbHVzdGVyTGV2ZWwuX3JlY3Vyc2l2ZWx5QWRkQ2hpbGRyZW5Ub01hcChudWxsLCB0aGlzLl96b29tLCB0aGlzLl9jdXJyZW50U2hvd25Cb3VuZHMpO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9LFxuXG5cdFx0Ly9SZW1vdmVzIGFsbCBsYXllcnMgZnJvbSB0aGUgTWFya2VyQ2x1c3Rlckdyb3VwXG5cdFx0Y2xlYXJMYXllcnM6IGZ1bmN0aW9uICgpIHtcblx0XHRcdC8vTmVlZCBvdXIgb3duIHNwZWNpYWwgaW1wbGVtZW50YXRpb24gYXMgdGhlIExheWVyR3JvdXAgb25lIGRvZXNuJ3Qgd29yayBmb3IgdXNcblxuXHRcdFx0Ly9JZiB3ZSBhcmVuJ3Qgb24gdGhlIG1hcCAoeWV0KSwgYmxvdyBhd2F5IHRoZSBtYXJrZXJzIHdlIGtub3cgb2Zcblx0XHRcdGlmICghdGhpcy5fbWFwKSB7XG5cdFx0XHRcdHRoaXMuX25lZWRzQ2x1c3RlcmluZyA9IFtdO1xuXHRcdFx0XHR0aGlzLl9uZWVkc1JlbW92aW5nID0gW107XG5cdFx0XHRcdGRlbGV0ZSB0aGlzLl9ncmlkQ2x1c3RlcnM7XG5cdFx0XHRcdGRlbGV0ZSB0aGlzLl9ncmlkVW5jbHVzdGVyZWQ7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0aGlzLl9ub2FuaW1hdGlvblVuc3BpZGVyZnkpIHtcblx0XHRcdFx0dGhpcy5fbm9hbmltYXRpb25VbnNwaWRlcmZ5KCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vUmVtb3ZlIGFsbCB0aGUgdmlzaWJsZSBsYXllcnNcblx0XHRcdHRoaXMuX2ZlYXR1cmVHcm91cC5jbGVhckxheWVycygpO1xuXHRcdFx0dGhpcy5fbm9uUG9pbnRHcm91cC5jbGVhckxheWVycygpO1xuXG5cdFx0XHR0aGlzLmVhY2hMYXllcihmdW5jdGlvbiAobWFya2VyKSB7XG5cdFx0XHRcdG1hcmtlci5vZmYodGhpcy5fY2hpbGRNYXJrZXJFdmVudEhhbmRsZXJzLCB0aGlzKTtcblx0XHRcdFx0ZGVsZXRlIG1hcmtlci5fX3BhcmVudDtcblx0XHRcdH0sIHRoaXMpO1xuXG5cdFx0XHRpZiAodGhpcy5fbWFwKSB7XG5cdFx0XHRcdC8vUmVzZXQgX3RvcENsdXN0ZXJMZXZlbCBhbmQgdGhlIERpc3RhbmNlR3JpZHNcblx0XHRcdFx0dGhpcy5fZ2VuZXJhdGVJbml0aWFsQ2x1c3RlcnMoKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fSxcblxuXHRcdC8vT3ZlcnJpZGUgRmVhdHVyZUdyb3VwLmdldEJvdW5kcyBhcyBpdCBkb2Vzbid0IHdvcmtcblx0XHRnZXRCb3VuZHM6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBib3VuZHMgPSBuZXcgTC5MYXRMbmdCb3VuZHMoKTtcblxuXHRcdFx0aWYgKHRoaXMuX3RvcENsdXN0ZXJMZXZlbCkge1xuXHRcdFx0XHRib3VuZHMuZXh0ZW5kKHRoaXMuX3RvcENsdXN0ZXJMZXZlbC5fYm91bmRzKTtcblx0XHRcdH1cblxuXHRcdFx0Zm9yICh2YXIgaSA9IHRoaXMuX25lZWRzQ2x1c3RlcmluZy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0XHRib3VuZHMuZXh0ZW5kKHRoaXMuX25lZWRzQ2x1c3RlcmluZ1tpXS5nZXRMYXRMbmcoKSk7XG5cdFx0XHR9XG5cblx0XHRcdGJvdW5kcy5leHRlbmQodGhpcy5fbm9uUG9pbnRHcm91cC5nZXRCb3VuZHMoKSk7XG5cblx0XHRcdHJldHVybiBib3VuZHM7XG5cdFx0fSxcblxuXHRcdC8vT3ZlcnJpZGVzIExheWVyR3JvdXAuZWFjaExheWVyXG5cdFx0ZWFjaExheWVyOiBmdW5jdGlvbiAobWV0aG9kLCBjb250ZXh0KSB7XG5cdFx0XHR2YXIgbWFya2VycyA9IHRoaXMuX25lZWRzQ2x1c3RlcmluZy5zbGljZSgpLFxuXHRcdFx0XHRuZWVkc1JlbW92aW5nID0gdGhpcy5fbmVlZHNSZW1vdmluZyxcblx0XHRcdFx0dGhpc05lZWRzUmVtb3ZpbmcsIGksIGo7XG5cblx0XHRcdGlmICh0aGlzLl90b3BDbHVzdGVyTGV2ZWwpIHtcblx0XHRcdFx0dGhpcy5fdG9wQ2x1c3RlckxldmVsLmdldEFsbENoaWxkTWFya2VycyhtYXJrZXJzKTtcblx0XHRcdH1cblxuXHRcdFx0Zm9yIChpID0gbWFya2Vycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0XHR0aGlzTmVlZHNSZW1vdmluZyA9IHRydWU7XG5cblx0XHRcdFx0Zm9yIChqID0gbmVlZHNSZW1vdmluZy5sZW5ndGggLSAxOyBqID49IDA7IGotLSkge1xuXHRcdFx0XHRcdGlmIChuZWVkc1JlbW92aW5nW2pdLmxheWVyID09PSBtYXJrZXJzW2ldKSB7XG5cdFx0XHRcdFx0XHR0aGlzTmVlZHNSZW1vdmluZyA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHRoaXNOZWVkc1JlbW92aW5nKSB7XG5cdFx0XHRcdFx0bWV0aG9kLmNhbGwoY29udGV4dCwgbWFya2Vyc1tpXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fbm9uUG9pbnRHcm91cC5lYWNoTGF5ZXIobWV0aG9kLCBjb250ZXh0KTtcblx0XHR9LFxuXG5cdFx0Ly9PdmVycmlkZXMgTGF5ZXJHcm91cC5nZXRMYXllcnNcblx0XHRnZXRMYXllcnM6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBsYXllcnMgPSBbXTtcblx0XHRcdHRoaXMuZWFjaExheWVyKGZ1bmN0aW9uIChsKSB7XG5cdFx0XHRcdGxheWVycy5wdXNoKGwpO1xuXHRcdFx0fSk7XG5cdFx0XHRyZXR1cm4gbGF5ZXJzO1xuXHRcdH0sXG5cblx0XHQvL092ZXJyaWRlcyBMYXllckdyb3VwLmdldExheWVyLCBXQVJOSU5HOiBSZWFsbHkgYmFkIHBlcmZvcm1hbmNlXG5cdFx0Z2V0TGF5ZXI6IGZ1bmN0aW9uIChpZCkge1xuXHRcdFx0dmFyIHJlc3VsdCA9IG51bGw7XG5cblx0XHRcdGlkID0gcGFyc2VJbnQoaWQsIDEwKTtcblxuXHRcdFx0dGhpcy5lYWNoTGF5ZXIoZnVuY3Rpb24gKGwpIHtcblx0XHRcdFx0aWYgKEwuc3RhbXAobCkgPT09IGlkKSB7XG5cdFx0XHRcdFx0cmVzdWx0ID0gbDtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fSxcblxuXHRcdC8vUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBsYXllciBpcyBpbiB0aGlzIE1hcmtlckNsdXN0ZXJHcm91cFxuXHRcdGhhc0xheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHRcdGlmICghbGF5ZXIpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgaSwgYW5BcnJheSA9IHRoaXMuX25lZWRzQ2x1c3RlcmluZztcblxuXHRcdFx0Zm9yIChpID0gYW5BcnJheS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0XHRpZiAoYW5BcnJheVtpXSA9PT0gbGF5ZXIpIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRhbkFycmF5ID0gdGhpcy5fbmVlZHNSZW1vdmluZztcblx0XHRcdGZvciAoaSA9IGFuQXJyYXkubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdFx0aWYgKGFuQXJyYXlbaV0ubGF5ZXIgPT09IGxheWVyKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiAhIShsYXllci5fX3BhcmVudCAmJiBsYXllci5fX3BhcmVudC5fZ3JvdXAgPT09IHRoaXMpIHx8IHRoaXMuX25vblBvaW50R3JvdXAuaGFzTGF5ZXIobGF5ZXIpO1xuXHRcdH0sXG5cblx0XHQvL1pvb20gZG93biB0byBzaG93IHRoZSBnaXZlbiBsYXllciAoc3BpZGVyZnlpbmcgaWYgbmVjZXNzYXJ5KSB0aGVuIGNhbGxzIHRoZSBjYWxsYmFja1xuXHRcdHpvb21Ub1Nob3dMYXllcjogZnVuY3Rpb24gKGxheWVyLCBjYWxsYmFjaykge1xuXG5cdFx0XHR2YXIgbWFwID0gdGhpcy5fbWFwO1xuXG5cdFx0XHRpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdGNhbGxiYWNrID0gZnVuY3Rpb24gKCkge307XG5cdFx0XHR9XG5cblx0XHRcdHZhciBzaG93TWFya2VyID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHQvLyBBc3N1bWVzIHRoYXQgbWFwLmhhc0xheWVyIGNoZWNrcyBmb3IgZGlyZWN0IGFwcGVhcmFuY2Ugb24gbWFwLCBub3QgcmVjdXJzaXZlbHkgY2FsbGluZ1xuXHRcdFx0XHQvLyBoYXNMYXllciBvbiBMYXllciBHcm91cHMgdGhhdCBhcmUgb24gbWFwICh0eXBpY2FsbHkgbm90IGNhbGxpbmcgdGhpcyBNYXJrZXJDbHVzdGVyR3JvdXAuaGFzTGF5ZXIsIHdoaWNoIHdvdWxkIGFsd2F5cyByZXR1cm4gdHJ1ZSlcblx0XHRcdFx0aWYgKChtYXAuaGFzTGF5ZXIobGF5ZXIpIHx8IG1hcC5oYXNMYXllcihsYXllci5fX3BhcmVudCkpICYmICF0aGlzLl9pblpvb21BbmltYXRpb24pIHtcblx0XHRcdFx0XHR0aGlzLl9tYXAub2ZmKCdtb3ZlZW5kJywgc2hvd01hcmtlciwgdGhpcyk7XG5cdFx0XHRcdFx0dGhpcy5vZmYoJ2FuaW1hdGlvbmVuZCcsIHNob3dNYXJrZXIsIHRoaXMpO1xuXG5cdFx0XHRcdFx0aWYgKG1hcC5oYXNMYXllcihsYXllcikpIHtcblx0XHRcdFx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChsYXllci5fX3BhcmVudC5faWNvbikge1xuXHRcdFx0XHRcdFx0dGhpcy5vbmNlKCdzcGlkZXJmaWVkJywgY2FsbGJhY2ssIHRoaXMpO1xuXHRcdFx0XHRcdFx0bGF5ZXIuX19wYXJlbnQuc3BpZGVyZnkoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRcdGlmIChsYXllci5faWNvbiAmJiB0aGlzLl9tYXAuZ2V0Qm91bmRzKCkuY29udGFpbnMobGF5ZXIuZ2V0TGF0TG5nKCkpKSB7XG5cdFx0XHRcdC8vTGF5ZXIgaXMgdmlzaWJsZSBvbmQgb24gc2NyZWVuLCBpbW1lZGlhdGUgcmV0dXJuXG5cdFx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHR9IGVsc2UgaWYgKGxheWVyLl9fcGFyZW50Ll96b29tIDwgTWF0aC5yb3VuZCh0aGlzLl9tYXAuX3pvb20pKSB7XG5cdFx0XHRcdC8vTGF5ZXIgc2hvdWxkIGJlIHZpc2libGUgYXQgdGhpcyB6b29tIGxldmVsLiBJdCBtdXN0IG5vdCBiZSBvbiBzY3JlZW4gc28ganVzdCBwYW4gb3ZlciB0byBpdFxuXHRcdFx0XHR0aGlzLl9tYXAub24oJ21vdmVlbmQnLCBzaG93TWFya2VyLCB0aGlzKTtcblx0XHRcdFx0dGhpcy5fbWFwLnBhblRvKGxheWVyLmdldExhdExuZygpKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuX21hcC5vbignbW92ZWVuZCcsIHNob3dNYXJrZXIsIHRoaXMpO1xuXHRcdFx0XHR0aGlzLm9uKCdhbmltYXRpb25lbmQnLCBzaG93TWFya2VyLCB0aGlzKTtcblx0XHRcdFx0bGF5ZXIuX19wYXJlbnQuem9vbVRvQm91bmRzKCk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8vT3ZlcnJpZGVzIEZlYXR1cmVHcm91cC5vbkFkZFxuXHRcdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0XHR0aGlzLl9tYXAgPSBtYXA7XG5cdFx0XHR2YXIgaSwgbCwgbGF5ZXI7XG5cblx0XHRcdGlmICghaXNGaW5pdGUodGhpcy5fbWFwLmdldE1heFpvb20oKSkpIHtcblx0XHRcdFx0dGhyb3cgXCJNYXAgaGFzIG5vIG1heFpvb20gc3BlY2lmaWVkXCI7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX2ZlYXR1cmVHcm91cC5hZGRUbyhtYXApO1xuXHRcdFx0dGhpcy5fbm9uUG9pbnRHcm91cC5hZGRUbyhtYXApO1xuXG5cdFx0XHRpZiAoIXRoaXMuX2dyaWRDbHVzdGVycykge1xuXHRcdFx0XHR0aGlzLl9nZW5lcmF0ZUluaXRpYWxDbHVzdGVycygpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9tYXhMYXQgPSBtYXAub3B0aW9ucy5jcnMucHJvamVjdGlvbi5NQVhfTEFUSVRVREU7XG5cblx0XHRcdC8vUmVzdG9yZSBhbGwgdGhlIHBvc2l0aW9ucyBhcyB0aGV5IGFyZSBpbiB0aGUgTUNHIGJlZm9yZSByZW1vdmluZyB0aGVtXG5cdFx0XHRmb3IgKGkgPSAwLCBsID0gdGhpcy5fbmVlZHNSZW1vdmluZy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0bGF5ZXIgPSB0aGlzLl9uZWVkc1JlbW92aW5nW2ldO1xuXHRcdFx0XHRsYXllci5uZXdsYXRsbmcgPSBsYXllci5sYXllci5fbGF0bG5nO1xuXHRcdFx0XHRsYXllci5sYXllci5fbGF0bG5nID0gbGF5ZXIubGF0bG5nO1xuXHRcdFx0fVxuXHRcdFx0Ly9SZW1vdmUgdGhlbSwgdGhlbiByZXN0b3JlIHRoZWlyIG5ldyBwb3NpdGlvbnNcblx0XHRcdGZvciAoaSA9IDAsIGwgPSB0aGlzLl9uZWVkc1JlbW92aW5nLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRsYXllciA9IHRoaXMuX25lZWRzUmVtb3ZpbmdbaV07XG5cdFx0XHRcdHRoaXMuX3JlbW92ZUxheWVyKGxheWVyLmxheWVyLCB0cnVlKTtcblx0XHRcdFx0bGF5ZXIubGF5ZXIuX2xhdGxuZyA9IGxheWVyLm5ld2xhdGxuZztcblx0XHRcdH1cblx0XHRcdHRoaXMuX25lZWRzUmVtb3ZpbmcgPSBbXTtcblxuXHRcdFx0Ly9SZW1lbWJlciB0aGUgY3VycmVudCB6b29tIGxldmVsIGFuZCBib3VuZHNcblx0XHRcdHRoaXMuX3pvb20gPSBNYXRoLnJvdW5kKHRoaXMuX21hcC5fem9vbSk7XG5cdFx0XHR0aGlzLl9jdXJyZW50U2hvd25Cb3VuZHMgPSB0aGlzLl9nZXRFeHBhbmRlZFZpc2libGVCb3VuZHMoKTtcblxuXHRcdFx0dGhpcy5fbWFwLm9uKCd6b29tZW5kJywgdGhpcy5fem9vbUVuZCwgdGhpcyk7XG5cdFx0XHR0aGlzLl9tYXAub24oJ21vdmVlbmQnLCB0aGlzLl9tb3ZlRW5kLCB0aGlzKTtcblxuXHRcdFx0aWYgKHRoaXMuX3NwaWRlcmZpZXJPbkFkZCkgeyAvL1RPRE8gRklYTUU6IE5vdCBzdXJlIGhvdyB0byBoYXZlIHNwaWRlcmZpZXIgYWRkIHNvbWV0aGluZyBvbiBoZXJlIG5pY2VseVxuXHRcdFx0XHR0aGlzLl9zcGlkZXJmaWVyT25BZGQoKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fYmluZEV2ZW50cygpO1xuXG5cdFx0XHQvL0FjdHVhbGx5IGFkZCBvdXIgbWFya2VycyB0byB0aGUgbWFwOlxuXHRcdFx0bCA9IHRoaXMuX25lZWRzQ2x1c3RlcmluZztcblx0XHRcdHRoaXMuX25lZWRzQ2x1c3RlcmluZyA9IFtdO1xuXHRcdFx0dGhpcy5hZGRMYXllcnMobCwgdHJ1ZSk7XG5cdFx0fSxcblxuXHRcdC8vT3ZlcnJpZGVzIEZlYXR1cmVHcm91cC5vblJlbW92ZVxuXHRcdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0XHRtYXAub2ZmKCd6b29tZW5kJywgdGhpcy5fem9vbUVuZCwgdGhpcyk7XG5cdFx0XHRtYXAub2ZmKCdtb3ZlZW5kJywgdGhpcy5fbW92ZUVuZCwgdGhpcyk7XG5cblx0XHRcdHRoaXMuX3VuYmluZEV2ZW50cygpO1xuXG5cdFx0XHQvL0luIGNhc2Ugd2UgYXJlIGluIGEgY2x1c3RlciBhbmltYXRpb25cblx0XHRcdHRoaXMuX21hcC5fbWFwUGFuZS5jbGFzc05hbWUgPSB0aGlzLl9tYXAuX21hcFBhbmUuY2xhc3NOYW1lLnJlcGxhY2UoJyBsZWFmbGV0LWNsdXN0ZXItYW5pbScsICcnKTtcblxuXHRcdFx0aWYgKHRoaXMuX3NwaWRlcmZpZXJPblJlbW92ZSkgeyAvL1RPRE8gRklYTUU6IE5vdCBzdXJlIGhvdyB0byBoYXZlIHNwaWRlcmZpZXIgYWRkIHNvbWV0aGluZyBvbiBoZXJlIG5pY2VseVxuXHRcdFx0XHR0aGlzLl9zcGlkZXJmaWVyT25SZW1vdmUoKTtcblx0XHRcdH1cblxuXHRcdFx0ZGVsZXRlIHRoaXMuX21heExhdDtcblxuXHRcdFx0Ly9DbGVhbiB1cCBhbGwgdGhlIGxheWVycyB3ZSBhZGRlZCB0byB0aGUgbWFwXG5cdFx0XHR0aGlzLl9oaWRlQ292ZXJhZ2UoKTtcblx0XHRcdHRoaXMuX2ZlYXR1cmVHcm91cC5yZW1vdmUoKTtcblx0XHRcdHRoaXMuX25vblBvaW50R3JvdXAucmVtb3ZlKCk7XG5cblx0XHRcdHRoaXMuX2ZlYXR1cmVHcm91cC5jbGVhckxheWVycygpO1xuXG5cdFx0XHR0aGlzLl9tYXAgPSBudWxsO1xuXHRcdH0sXG5cblx0XHRnZXRWaXNpYmxlUGFyZW50OiBmdW5jdGlvbiAobWFya2VyKSB7XG5cdFx0XHR2YXIgdk1hcmtlciA9IG1hcmtlcjtcblx0XHRcdHdoaWxlICh2TWFya2VyICYmICF2TWFya2VyLl9pY29uKSB7XG5cdFx0XHRcdHZNYXJrZXIgPSB2TWFya2VyLl9fcGFyZW50O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHZNYXJrZXIgfHwgbnVsbDtcblx0XHR9LFxuXG5cdFx0Ly9SZW1vdmUgdGhlIGdpdmVuIG9iamVjdCBmcm9tIHRoZSBnaXZlbiBhcnJheVxuXHRcdF9hcnJheVNwbGljZTogZnVuY3Rpb24gKGFuQXJyYXksIG9iaikge1xuXHRcdFx0Zm9yICh2YXIgaSA9IGFuQXJyYXkubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdFx0aWYgKGFuQXJyYXlbaV0gPT09IG9iaikge1xuXHRcdFx0XHRcdGFuQXJyYXkuc3BsaWNlKGksIDEpO1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFJlbW92ZXMgYSBtYXJrZXIgZnJvbSBhbGwgX2dyaWRVbmNsdXN0ZXJlZCB6b29tIGxldmVscywgc3RhcnRpbmcgYXQgdGhlIHN1cHBsaWVkIHpvb20uXG5cdFx0ICogQHBhcmFtIG1hcmtlciB0byBiZSByZW1vdmVkIGZyb20gX2dyaWRVbmNsdXN0ZXJlZC5cblx0XHQgKiBAcGFyYW0geiBpbnRlZ2VyIGJvdHRvbSBzdGFydCB6b29tIGxldmVsIChpbmNsdWRlZClcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdF9yZW1vdmVGcm9tR3JpZFVuY2x1c3RlcmVkOiBmdW5jdGlvbiAobWFya2VyLCB6KSB7XG5cdFx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuXHRcdFx0ICAgIGdyaWRVbmNsdXN0ZXJlZCA9IHRoaXMuX2dyaWRVbmNsdXN0ZXJlZCxcblx0XHRcdFx0bWluWm9vbSA9IE1hdGguZmxvb3IodGhpcy5fbWFwLmdldE1pblpvb20oKSk7XG5cblx0XHRcdGZvciAoOyB6ID49IG1pblpvb207IHotLSkge1xuXHRcdFx0XHRpZiAoIWdyaWRVbmNsdXN0ZXJlZFt6XS5yZW1vdmVPYmplY3QobWFya2VyLCBtYXAucHJvamVjdChtYXJrZXIuZ2V0TGF0TG5nKCksIHopKSkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdF9jaGlsZE1hcmtlckRyYWdTdGFydDogZnVuY3Rpb24gKGUpIHtcblx0XHRcdGUudGFyZ2V0Ll9fZHJhZ1N0YXJ0ID0gZS50YXJnZXQuX2xhdGxuZztcblx0XHR9LFxuXG5cdFx0X2NoaWxkTWFya2VyTW92ZWQ6IGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRpZiAoIXRoaXMuX2lnbm9yZU1vdmUgJiYgIWUudGFyZ2V0Ll9fZHJhZ1N0YXJ0KSB7XG5cdFx0XHRcdHZhciBpc1BvcHVwT3BlbiA9IGUudGFyZ2V0Ll9wb3B1cCAmJiBlLnRhcmdldC5fcG9wdXAuaXNPcGVuKCk7XG5cblx0XHRcdFx0dGhpcy5fbW92ZUNoaWxkKGUudGFyZ2V0LCBlLm9sZExhdExuZywgZS5sYXRsbmcpO1xuXG5cdFx0XHRcdGlmIChpc1BvcHVwT3Blbikge1xuXHRcdFx0XHRcdGUudGFyZ2V0Lm9wZW5Qb3B1cCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdF9tb3ZlQ2hpbGQ6IGZ1bmN0aW9uIChsYXllciwgZnJvbSwgdG8pIHtcblx0XHRcdGxheWVyLl9sYXRsbmcgPSBmcm9tO1xuXHRcdFx0dGhpcy5yZW1vdmVMYXllcihsYXllcik7XG5cblx0XHRcdGxheWVyLl9sYXRsbmcgPSB0bztcblx0XHRcdHRoaXMuYWRkTGF5ZXIobGF5ZXIpO1xuXHRcdH0sXG5cblx0XHRfY2hpbGRNYXJrZXJEcmFnRW5kOiBmdW5jdGlvbiAoZSkge1xuXHRcdFx0dmFyIGRyYWdTdGFydCA9IGUudGFyZ2V0Ll9fZHJhZ1N0YXJ0O1xuXHRcdFx0ZGVsZXRlIGUudGFyZ2V0Ll9fZHJhZ1N0YXJ0O1xuXHRcdFx0aWYgKGRyYWdTdGFydCkge1xuXHRcdFx0XHR0aGlzLl9tb3ZlQ2hpbGQoZS50YXJnZXQsIGRyYWdTdGFydCwgZS50YXJnZXQuX2xhdGxuZyk7XG5cdFx0XHR9XHRcdFxuXHRcdH0sXG5cblxuXHRcdC8vSW50ZXJuYWwgZnVuY3Rpb24gZm9yIHJlbW92aW5nIGEgbWFya2VyIGZyb20gZXZlcnl0aGluZy5cblx0XHQvL2RvbnRVcGRhdGVNYXA6IHNldCB0byB0cnVlIGlmIHlvdSB3aWxsIGhhbmRsZSB1cGRhdGluZyB0aGUgbWFwIG1hbnVhbGx5IChmb3IgYnVsayBmdW5jdGlvbnMpXG5cdFx0X3JlbW92ZUxheWVyOiBmdW5jdGlvbiAobWFya2VyLCByZW1vdmVGcm9tRGlzdGFuY2VHcmlkLCBkb250VXBkYXRlTWFwKSB7XG5cdFx0XHR2YXIgZ3JpZENsdXN0ZXJzID0gdGhpcy5fZ3JpZENsdXN0ZXJzLFxuXHRcdFx0XHRncmlkVW5jbHVzdGVyZWQgPSB0aGlzLl9ncmlkVW5jbHVzdGVyZWQsXG5cdFx0XHRcdGZnID0gdGhpcy5fZmVhdHVyZUdyb3VwLFxuXHRcdFx0XHRtYXAgPSB0aGlzLl9tYXAsXG5cdFx0XHRcdG1pblpvb20gPSBNYXRoLmZsb29yKHRoaXMuX21hcC5nZXRNaW5ab29tKCkpO1xuXG5cdFx0XHQvL1JlbW92ZSB0aGUgbWFya2VyIGZyb20gZGlzdGFuY2UgY2x1c3RlcnMgaXQgbWlnaHQgYmUgaW5cblx0XHRcdGlmIChyZW1vdmVGcm9tRGlzdGFuY2VHcmlkKSB7XG5cdFx0XHRcdHRoaXMuX3JlbW92ZUZyb21HcmlkVW5jbHVzdGVyZWQobWFya2VyLCB0aGlzLl9tYXhab29tKTtcblx0XHRcdH1cblxuXHRcdFx0Ly9Xb3JrIG91ciB3YXkgdXAgdGhlIGNsdXN0ZXJzIHJlbW92aW5nIHRoZW0gYXMgd2UgZ28gaWYgcmVxdWlyZWRcblx0XHRcdHZhciBjbHVzdGVyID0gbWFya2VyLl9fcGFyZW50LFxuXHRcdFx0XHRtYXJrZXJzID0gY2x1c3Rlci5fbWFya2Vycyxcblx0XHRcdFx0b3RoZXJNYXJrZXI7XG5cblx0XHRcdC8vUmVtb3ZlIHRoZSBtYXJrZXIgZnJvbSB0aGUgaW1tZWRpYXRlIHBhcmVudHMgbWFya2VyIGxpc3Rcblx0XHRcdHRoaXMuX2FycmF5U3BsaWNlKG1hcmtlcnMsIG1hcmtlcik7XG5cblx0XHRcdHdoaWxlIChjbHVzdGVyKSB7XG5cdFx0XHRcdGNsdXN0ZXIuX2NoaWxkQ291bnQtLTtcblx0XHRcdFx0Y2x1c3Rlci5fYm91bmRzTmVlZFVwZGF0ZSA9IHRydWU7XG5cblx0XHRcdFx0aWYgKGNsdXN0ZXIuX3pvb20gPCBtaW5ab29tKSB7XG5cdFx0XHRcdFx0Ly9Ub3AgbGV2ZWwsIGRvIG5vdGhpbmdcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fSBlbHNlIGlmIChyZW1vdmVGcm9tRGlzdGFuY2VHcmlkICYmIGNsdXN0ZXIuX2NoaWxkQ291bnQgPD0gMSkgeyAvL0NsdXN0ZXIgbm8gbG9uZ2VyIHJlcXVpcmVkXG5cdFx0XHRcdFx0Ly9XZSBuZWVkIHRvIHB1c2ggdGhlIG90aGVyIG1hcmtlciB1cCB0byB0aGUgcGFyZW50XG5cdFx0XHRcdFx0b3RoZXJNYXJrZXIgPSBjbHVzdGVyLl9tYXJrZXJzWzBdID09PSBtYXJrZXIgPyBjbHVzdGVyLl9tYXJrZXJzWzFdIDogY2x1c3Rlci5fbWFya2Vyc1swXTtcblxuXHRcdFx0XHRcdC8vVXBkYXRlIGRpc3RhbmNlIGdyaWRcblx0XHRcdFx0XHRncmlkQ2x1c3RlcnNbY2x1c3Rlci5fem9vbV0ucmVtb3ZlT2JqZWN0KGNsdXN0ZXIsIG1hcC5wcm9qZWN0KGNsdXN0ZXIuX2NMYXRMbmcsIGNsdXN0ZXIuX3pvb20pKTtcblx0XHRcdFx0XHRncmlkVW5jbHVzdGVyZWRbY2x1c3Rlci5fem9vbV0uYWRkT2JqZWN0KG90aGVyTWFya2VyLCBtYXAucHJvamVjdChvdGhlck1hcmtlci5nZXRMYXRMbmcoKSwgY2x1c3Rlci5fem9vbSkpO1xuXG5cdFx0XHRcdFx0Ly9Nb3ZlIG90aGVyTWFya2VyIHVwIHRvIHBhcmVudFxuXHRcdFx0XHRcdHRoaXMuX2FycmF5U3BsaWNlKGNsdXN0ZXIuX19wYXJlbnQuX2NoaWxkQ2x1c3RlcnMsIGNsdXN0ZXIpO1xuXHRcdFx0XHRcdGNsdXN0ZXIuX19wYXJlbnQuX21hcmtlcnMucHVzaChvdGhlck1hcmtlcik7XG5cdFx0XHRcdFx0b3RoZXJNYXJrZXIuX19wYXJlbnQgPSBjbHVzdGVyLl9fcGFyZW50O1xuXG5cdFx0XHRcdFx0aWYgKGNsdXN0ZXIuX2ljb24pIHtcblx0XHRcdFx0XHRcdC8vQ2x1c3RlciBpcyBjdXJyZW50bHkgb24gdGhlIG1hcCwgbmVlZCB0byBwdXQgdGhlIG1hcmtlciBvbiB0aGUgbWFwIGluc3RlYWRcblx0XHRcdFx0XHRcdGZnLnJlbW92ZUxheWVyKGNsdXN0ZXIpO1xuXHRcdFx0XHRcdFx0aWYgKCFkb250VXBkYXRlTWFwKSB7XG5cdFx0XHRcdFx0XHRcdGZnLmFkZExheWVyKG90aGVyTWFya2VyKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y2x1c3Rlci5faWNvbk5lZWRzVXBkYXRlID0gdHJ1ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNsdXN0ZXIgPSBjbHVzdGVyLl9fcGFyZW50O1xuXHRcdFx0fVxuXG5cdFx0XHRkZWxldGUgbWFya2VyLl9fcGFyZW50O1xuXHRcdH0sXG5cblx0XHRfaXNPcklzUGFyZW50OiBmdW5jdGlvbiAoZWwsIG9lbCkge1xuXHRcdFx0d2hpbGUgKG9lbCkge1xuXHRcdFx0XHRpZiAoZWwgPT09IG9lbCkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG9lbCA9IG9lbC5wYXJlbnROb2RlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0sXG5cblx0XHQvL092ZXJyaWRlIEwuRXZlbnRlZC5maXJlXG5cdFx0ZmlyZTogZnVuY3Rpb24gKHR5cGUsIGRhdGEsIHByb3BhZ2F0ZSkge1xuXHRcdFx0aWYgKGRhdGEgJiYgZGF0YS5sYXllciBpbnN0YW5jZW9mIEwuTWFya2VyQ2x1c3Rlcikge1xuXHRcdFx0XHQvL1ByZXZlbnQgbXVsdGlwbGUgY2x1c3Rlcm1vdXNlb3Zlci9vZmYgZXZlbnRzIGlmIHRoZSBpY29uIGlzIG1hZGUgdXAgb2Ygc3RhY2tlZCBkaXZzIChEb2Vzbid0IHdvcmsgaW4gaWUgPD0gOCwgbm8gcmVsYXRlZFRhcmdldClcblx0XHRcdFx0aWYgKGRhdGEub3JpZ2luYWxFdmVudCAmJiB0aGlzLl9pc09ySXNQYXJlbnQoZGF0YS5sYXllci5faWNvbiwgZGF0YS5vcmlnaW5hbEV2ZW50LnJlbGF0ZWRUYXJnZXQpKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHR5cGUgPSAnY2x1c3RlcicgKyB0eXBlO1xuXHRcdFx0fVxuXG5cdFx0XHRMLkZlYXR1cmVHcm91cC5wcm90b3R5cGUuZmlyZS5jYWxsKHRoaXMsIHR5cGUsIGRhdGEsIHByb3BhZ2F0ZSk7XG5cdFx0fSxcblxuXHRcdC8vT3ZlcnJpZGUgTC5FdmVudGVkLmxpc3RlbnNcblx0XHRsaXN0ZW5zOiBmdW5jdGlvbiAodHlwZSwgcHJvcGFnYXRlKSB7XG5cdFx0XHRyZXR1cm4gTC5GZWF0dXJlR3JvdXAucHJvdG90eXBlLmxpc3RlbnMuY2FsbCh0aGlzLCB0eXBlLCBwcm9wYWdhdGUpIHx8IEwuRmVhdHVyZUdyb3VwLnByb3RvdHlwZS5saXN0ZW5zLmNhbGwodGhpcywgJ2NsdXN0ZXInICsgdHlwZSwgcHJvcGFnYXRlKTtcblx0XHR9LFxuXG5cdFx0Ly9EZWZhdWx0IGZ1bmN0aW9uYWxpdHlcblx0XHRfZGVmYXVsdEljb25DcmVhdGVGdW5jdGlvbjogZnVuY3Rpb24gKGNsdXN0ZXIpIHtcblx0XHRcdHZhciBjaGlsZENvdW50ID0gY2x1c3Rlci5nZXRDaGlsZENvdW50KCk7XG5cblx0XHRcdHZhciBjID0gJyBtYXJrZXItY2x1c3Rlci0nO1xuXHRcdFx0aWYgKGNoaWxkQ291bnQgPCAxMCkge1xuXHRcdFx0XHRjICs9ICdzbWFsbCc7XG5cdFx0XHR9IGVsc2UgaWYgKGNoaWxkQ291bnQgPCAxMDApIHtcblx0XHRcdFx0YyArPSAnbWVkaXVtJztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGMgKz0gJ2xhcmdlJztcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG5ldyBMLkRpdkljb24oeyBodG1sOiAnPGRpdj48c3Bhbj4nICsgY2hpbGRDb3VudCArICc8L3NwYW4+PC9kaXY+JywgY2xhc3NOYW1lOiAnbWFya2VyLWNsdXN0ZXInICsgYywgaWNvblNpemU6IG5ldyBMLlBvaW50KDQwLCA0MCkgfSk7XG5cdFx0fSxcblxuXHRcdF9iaW5kRXZlbnRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuXHRcdFx0ICAgIHNwaWRlcmZ5T25NYXhab29tID0gdGhpcy5vcHRpb25zLnNwaWRlcmZ5T25NYXhab29tLFxuXHRcdFx0ICAgIHNob3dDb3ZlcmFnZU9uSG92ZXIgPSB0aGlzLm9wdGlvbnMuc2hvd0NvdmVyYWdlT25Ib3Zlcixcblx0XHRcdCAgICB6b29tVG9Cb3VuZHNPbkNsaWNrID0gdGhpcy5vcHRpb25zLnpvb21Ub0JvdW5kc09uQ2xpY2s7XG5cblx0XHRcdC8vWm9vbSBvbiBjbHVzdGVyIGNsaWNrIG9yIHNwaWRlcmZ5IGlmIHdlIGFyZSBhdCB0aGUgbG93ZXN0IGxldmVsXG5cdFx0XHRpZiAoc3BpZGVyZnlPbk1heFpvb20gfHwgem9vbVRvQm91bmRzT25DbGljaykge1xuXHRcdFx0XHR0aGlzLm9uKCdjbHVzdGVyY2xpY2snLCB0aGlzLl96b29tT3JTcGlkZXJmeSwgdGhpcyk7XG5cdFx0XHR9XG5cblx0XHRcdC8vU2hvdyBjb252ZXggaHVsbCAoYm91bmRhcnkpIHBvbHlnb24gb24gbW91c2Ugb3ZlclxuXHRcdFx0aWYgKHNob3dDb3ZlcmFnZU9uSG92ZXIpIHtcblx0XHRcdFx0dGhpcy5vbignY2x1c3Rlcm1vdXNlb3ZlcicsIHRoaXMuX3Nob3dDb3ZlcmFnZSwgdGhpcyk7XG5cdFx0XHRcdHRoaXMub24oJ2NsdXN0ZXJtb3VzZW91dCcsIHRoaXMuX2hpZGVDb3ZlcmFnZSwgdGhpcyk7XG5cdFx0XHRcdG1hcC5vbignem9vbWVuZCcsIHRoaXMuX2hpZGVDb3ZlcmFnZSwgdGhpcyk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdF96b29tT3JTcGlkZXJmeTogZnVuY3Rpb24gKGUpIHtcblx0XHRcdHZhciBjbHVzdGVyID0gZS5sYXllcixcblx0XHRcdCAgICBib3R0b21DbHVzdGVyID0gY2x1c3RlcjtcblxuXHRcdFx0d2hpbGUgKGJvdHRvbUNsdXN0ZXIuX2NoaWxkQ2x1c3RlcnMubGVuZ3RoID09PSAxKSB7XG5cdFx0XHRcdGJvdHRvbUNsdXN0ZXIgPSBib3R0b21DbHVzdGVyLl9jaGlsZENsdXN0ZXJzWzBdO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoYm90dG9tQ2x1c3Rlci5fem9vbSA9PT0gdGhpcy5fbWF4Wm9vbSAmJlxuXHRcdFx0XHRib3R0b21DbHVzdGVyLl9jaGlsZENvdW50ID09PSBjbHVzdGVyLl9jaGlsZENvdW50ICYmXG5cdFx0XHRcdHRoaXMub3B0aW9ucy5zcGlkZXJmeU9uTWF4Wm9vbSkge1xuXG5cdFx0XHRcdC8vIEFsbCBjaGlsZCBtYXJrZXJzIGFyZSBjb250YWluZWQgaW4gYSBzaW5nbGUgY2x1c3RlciBmcm9tIHRoaXMuX21heFpvb20gdG8gdGhpcyBjbHVzdGVyLlxuXHRcdFx0XHRjbHVzdGVyLnNwaWRlcmZ5KCk7XG5cdFx0XHR9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy56b29tVG9Cb3VuZHNPbkNsaWNrKSB7XG5cdFx0XHRcdGNsdXN0ZXIuem9vbVRvQm91bmRzKCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZvY3VzIHRoZSBtYXAgYWdhaW4gZm9yIGtleWJvYXJkIHVzZXJzLlxuXHRcdFx0aWYgKGUub3JpZ2luYWxFdmVudCAmJiBlLm9yaWdpbmFsRXZlbnQua2V5Q29kZSA9PT0gMTMpIHtcblx0XHRcdFx0dGhpcy5fbWFwLl9jb250YWluZXIuZm9jdXMoKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0X3Nob3dDb3ZlcmFnZTogZnVuY3Rpb24gKGUpIHtcblx0XHRcdHZhciBtYXAgPSB0aGlzLl9tYXA7XG5cdFx0XHRpZiAodGhpcy5faW5ab29tQW5pbWF0aW9uKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLl9zaG93blBvbHlnb24pIHtcblx0XHRcdFx0bWFwLnJlbW92ZUxheWVyKHRoaXMuX3Nob3duUG9seWdvbik7XG5cdFx0XHR9XG5cdFx0XHRpZiAoZS5sYXllci5nZXRDaGlsZENvdW50KCkgPiAyICYmIGUubGF5ZXIgIT09IHRoaXMuX3NwaWRlcmZpZWQpIHtcblx0XHRcdFx0dGhpcy5fc2hvd25Qb2x5Z29uID0gbmV3IEwuUG9seWdvbihlLmxheWVyLmdldENvbnZleEh1bGwoKSwgdGhpcy5vcHRpb25zLnBvbHlnb25PcHRpb25zKTtcblx0XHRcdFx0bWFwLmFkZExheWVyKHRoaXMuX3Nob3duUG9seWdvbik7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdF9oaWRlQ292ZXJhZ2U6IGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmICh0aGlzLl9zaG93blBvbHlnb24pIHtcblx0XHRcdFx0dGhpcy5fbWFwLnJlbW92ZUxheWVyKHRoaXMuX3Nob3duUG9seWdvbik7XG5cdFx0XHRcdHRoaXMuX3Nob3duUG9seWdvbiA9IG51bGw7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdF91bmJpbmRFdmVudHM6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBzcGlkZXJmeU9uTWF4Wm9vbSA9IHRoaXMub3B0aW9ucy5zcGlkZXJmeU9uTWF4Wm9vbSxcblx0XHRcdFx0c2hvd0NvdmVyYWdlT25Ib3ZlciA9IHRoaXMub3B0aW9ucy5zaG93Q292ZXJhZ2VPbkhvdmVyLFxuXHRcdFx0XHR6b29tVG9Cb3VuZHNPbkNsaWNrID0gdGhpcy5vcHRpb25zLnpvb21Ub0JvdW5kc09uQ2xpY2ssXG5cdFx0XHRcdG1hcCA9IHRoaXMuX21hcDtcblxuXHRcdFx0aWYgKHNwaWRlcmZ5T25NYXhab29tIHx8IHpvb21Ub0JvdW5kc09uQ2xpY2spIHtcblx0XHRcdFx0dGhpcy5vZmYoJ2NsdXN0ZXJjbGljaycsIHRoaXMuX3pvb21PclNwaWRlcmZ5LCB0aGlzKTtcblx0XHRcdH1cblx0XHRcdGlmIChzaG93Q292ZXJhZ2VPbkhvdmVyKSB7XG5cdFx0XHRcdHRoaXMub2ZmKCdjbHVzdGVybW91c2VvdmVyJywgdGhpcy5fc2hvd0NvdmVyYWdlLCB0aGlzKTtcblx0XHRcdFx0dGhpcy5vZmYoJ2NsdXN0ZXJtb3VzZW91dCcsIHRoaXMuX2hpZGVDb3ZlcmFnZSwgdGhpcyk7XG5cdFx0XHRcdG1hcC5vZmYoJ3pvb21lbmQnLCB0aGlzLl9oaWRlQ292ZXJhZ2UsIHRoaXMpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRfem9vbUVuZDogZnVuY3Rpb24gKCkge1xuXHRcdFx0aWYgKCF0aGlzLl9tYXApIHsgLy9NYXkgaGF2ZSBiZWVuIHJlbW92ZWQgZnJvbSB0aGUgbWFwIGJ5IGEgem9vbUVuZCBoYW5kbGVyXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHRoaXMuX21lcmdlU3BsaXRDbHVzdGVycygpO1xuXG5cdFx0XHR0aGlzLl96b29tID0gTWF0aC5yb3VuZCh0aGlzLl9tYXAuX3pvb20pO1xuXHRcdFx0dGhpcy5fY3VycmVudFNob3duQm91bmRzID0gdGhpcy5fZ2V0RXhwYW5kZWRWaXNpYmxlQm91bmRzKCk7XG5cdFx0fSxcblxuXHRcdF9tb3ZlRW5kOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRpZiAodGhpcy5faW5ab29tQW5pbWF0aW9uKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0dmFyIG5ld0JvdW5kcyA9IHRoaXMuX2dldEV4cGFuZGVkVmlzaWJsZUJvdW5kcygpO1xuXG5cdFx0XHR0aGlzLl90b3BDbHVzdGVyTGV2ZWwuX3JlY3Vyc2l2ZWx5UmVtb3ZlQ2hpbGRyZW5Gcm9tTWFwKHRoaXMuX2N1cnJlbnRTaG93bkJvdW5kcywgTWF0aC5mbG9vcih0aGlzLl9tYXAuZ2V0TWluWm9vbSgpKSwgdGhpcy5fem9vbSwgbmV3Qm91bmRzKTtcblx0XHRcdHRoaXMuX3RvcENsdXN0ZXJMZXZlbC5fcmVjdXJzaXZlbHlBZGRDaGlsZHJlblRvTWFwKG51bGwsIE1hdGgucm91bmQodGhpcy5fbWFwLl96b29tKSwgbmV3Qm91bmRzKTtcblxuXHRcdFx0dGhpcy5fY3VycmVudFNob3duQm91bmRzID0gbmV3Qm91bmRzO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH0sXG5cblx0XHRfZ2VuZXJhdGVJbml0aWFsQ2x1c3RlcnM6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBtYXhab29tID0gTWF0aC5jZWlsKHRoaXMuX21hcC5nZXRNYXhab29tKCkpLFxuXHRcdFx0XHRtaW5ab29tID0gTWF0aC5mbG9vcih0aGlzLl9tYXAuZ2V0TWluWm9vbSgpKSxcblx0XHRcdFx0cmFkaXVzID0gdGhpcy5vcHRpb25zLm1heENsdXN0ZXJSYWRpdXMsXG5cdFx0XHRcdHJhZGl1c0ZuID0gcmFkaXVzO1xuXG5cdFx0XHQvL0lmIHdlIGp1c3Qgc2V0IG1heENsdXN0ZXJSYWRpdXMgdG8gYSBzaW5nbGUgbnVtYmVyLCB3ZSBuZWVkIHRvIGNyZWF0ZVxuXHRcdFx0Ly9hIHNpbXBsZSBmdW5jdGlvbiB0byByZXR1cm4gdGhhdCBudW1iZXIuIE90aGVyd2lzZSwgd2UganVzdCBoYXZlIHRvXG5cdFx0XHQvL3VzZSB0aGUgZnVuY3Rpb24gd2UndmUgcGFzc2VkIGluLlxuXHRcdFx0aWYgKHR5cGVvZiByYWRpdXMgIT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHRyYWRpdXNGbiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJhZGl1czsgfTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHRoaXMub3B0aW9ucy5kaXNhYmxlQ2x1c3RlcmluZ0F0Wm9vbSAhPT0gbnVsbCkge1xuXHRcdFx0XHRtYXhab29tID0gdGhpcy5vcHRpb25zLmRpc2FibGVDbHVzdGVyaW5nQXRab29tIC0gMTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX21heFpvb20gPSBtYXhab29tO1xuXHRcdFx0dGhpcy5fZ3JpZENsdXN0ZXJzID0ge307XG5cdFx0XHR0aGlzLl9ncmlkVW5jbHVzdGVyZWQgPSB7fTtcblxuXHRcdFx0Ly9TZXQgdXAgRGlzdGFuY2VHcmlkcyBmb3IgZWFjaCB6b29tXG5cdFx0XHRmb3IgKHZhciB6b29tID0gbWF4Wm9vbTsgem9vbSA+PSBtaW5ab29tOyB6b29tLS0pIHtcblx0XHRcdFx0dGhpcy5fZ3JpZENsdXN0ZXJzW3pvb21dID0gbmV3IEwuRGlzdGFuY2VHcmlkKHJhZGl1c0ZuKHpvb20pKTtcblx0XHRcdFx0dGhpcy5fZ3JpZFVuY2x1c3RlcmVkW3pvb21dID0gbmV3IEwuRGlzdGFuY2VHcmlkKHJhZGl1c0ZuKHpvb20pKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSW5zdGFudGlhdGUgdGhlIGFwcHJvcHJpYXRlIEwuTWFya2VyQ2x1c3RlciBjbGFzcyAoYW5pbWF0ZWQgb3Igbm90KS5cblx0XHRcdHRoaXMuX3RvcENsdXN0ZXJMZXZlbCA9IG5ldyB0aGlzLl9tYXJrZXJDbHVzdGVyKHRoaXMsIG1pblpvb20gLSAxKTtcblx0XHR9LFxuXG5cdFx0Ly9ab29tOiBab29tIHRvIHN0YXJ0IGFkZGluZyBhdCAoUGFzcyB0aGlzLl9tYXhab29tIHRvIHN0YXJ0IGF0IHRoZSBib3R0b20pXG5cdFx0X2FkZExheWVyOiBmdW5jdGlvbiAobGF5ZXIsIHpvb20pIHtcblx0XHRcdHZhciBncmlkQ2x1c3RlcnMgPSB0aGlzLl9ncmlkQ2x1c3RlcnMsXG5cdFx0XHQgICAgZ3JpZFVuY2x1c3RlcmVkID0gdGhpcy5fZ3JpZFVuY2x1c3RlcmVkLFxuXHRcdFx0XHRtaW5ab29tID0gTWF0aC5mbG9vcih0aGlzLl9tYXAuZ2V0TWluWm9vbSgpKSxcblx0XHRcdCAgICBtYXJrZXJQb2ludCwgejtcblxuXHRcdFx0aWYgKHRoaXMub3B0aW9ucy5zaW5nbGVNYXJrZXJNb2RlKSB7XG5cdFx0XHRcdHRoaXMuX292ZXJyaWRlTWFya2VySWNvbihsYXllcik7XG5cdFx0XHR9XG5cblx0XHRcdGxheWVyLm9uKHRoaXMuX2NoaWxkTWFya2VyRXZlbnRIYW5kbGVycywgdGhpcyk7XG5cblx0XHRcdC8vRmluZCB0aGUgbG93ZXN0IHpvb20gbGV2ZWwgdG8gc2xvdCB0aGlzIG9uZSBpblxuXHRcdFx0Zm9yICg7IHpvb20gPj0gbWluWm9vbTsgem9vbS0tKSB7XG5cdFx0XHRcdG1hcmtlclBvaW50ID0gdGhpcy5fbWFwLnByb2plY3QobGF5ZXIuZ2V0TGF0TG5nKCksIHpvb20pOyAvLyBjYWxjdWxhdGUgcGl4ZWwgcG9zaXRpb25cblxuXHRcdFx0XHQvL1RyeSBmaW5kIGEgY2x1c3RlciBjbG9zZSBieVxuXHRcdFx0XHR2YXIgY2xvc2VzdCA9IGdyaWRDbHVzdGVyc1t6b29tXS5nZXROZWFyT2JqZWN0KG1hcmtlclBvaW50KTtcblx0XHRcdFx0aWYgKGNsb3Nlc3QpIHtcblx0XHRcdFx0XHRjbG9zZXN0Ll9hZGRDaGlsZChsYXllcik7XG5cdFx0XHRcdFx0bGF5ZXIuX19wYXJlbnQgPSBjbG9zZXN0O1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vVHJ5IGZpbmQgYSBtYXJrZXIgY2xvc2UgYnkgdG8gZm9ybSBhIG5ldyBjbHVzdGVyIHdpdGhcblx0XHRcdFx0Y2xvc2VzdCA9IGdyaWRVbmNsdXN0ZXJlZFt6b29tXS5nZXROZWFyT2JqZWN0KG1hcmtlclBvaW50KTtcblx0XHRcdFx0aWYgKGNsb3Nlc3QpIHtcblx0XHRcdFx0XHR2YXIgcGFyZW50ID0gY2xvc2VzdC5fX3BhcmVudDtcblx0XHRcdFx0XHRpZiAocGFyZW50KSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9yZW1vdmVMYXllcihjbG9zZXN0LCBmYWxzZSk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly9DcmVhdGUgbmV3IGNsdXN0ZXIgd2l0aCB0aGVzZSAyIGluIGl0XG5cblx0XHRcdFx0XHR2YXIgbmV3Q2x1c3RlciA9IG5ldyB0aGlzLl9tYXJrZXJDbHVzdGVyKHRoaXMsIHpvb20sIGNsb3Nlc3QsIGxheWVyKTtcblx0XHRcdFx0XHRncmlkQ2x1c3RlcnNbem9vbV0uYWRkT2JqZWN0KG5ld0NsdXN0ZXIsIHRoaXMuX21hcC5wcm9qZWN0KG5ld0NsdXN0ZXIuX2NMYXRMbmcsIHpvb20pKTtcblx0XHRcdFx0XHRjbG9zZXN0Ll9fcGFyZW50ID0gbmV3Q2x1c3Rlcjtcblx0XHRcdFx0XHRsYXllci5fX3BhcmVudCA9IG5ld0NsdXN0ZXI7XG5cblx0XHRcdFx0XHQvL0ZpcnN0IGNyZWF0ZSBhbnkgbmV3IGludGVybWVkaWF0ZSBwYXJlbnQgY2x1c3RlcnMgdGhhdCBkb24ndCBleGlzdFxuXHRcdFx0XHRcdHZhciBsYXN0UGFyZW50ID0gbmV3Q2x1c3Rlcjtcblx0XHRcdFx0XHRmb3IgKHogPSB6b29tIC0gMTsgeiA+IHBhcmVudC5fem9vbTsgei0tKSB7XG5cdFx0XHRcdFx0XHRsYXN0UGFyZW50ID0gbmV3IHRoaXMuX21hcmtlckNsdXN0ZXIodGhpcywgeiwgbGFzdFBhcmVudCk7XG5cdFx0XHRcdFx0XHRncmlkQ2x1c3RlcnNbel0uYWRkT2JqZWN0KGxhc3RQYXJlbnQsIHRoaXMuX21hcC5wcm9qZWN0KGNsb3Nlc3QuZ2V0TGF0TG5nKCksIHopKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cGFyZW50Ll9hZGRDaGlsZChsYXN0UGFyZW50KTtcblxuXHRcdFx0XHRcdC8vUmVtb3ZlIGNsb3Nlc3QgZnJvbSB0aGlzIHpvb20gbGV2ZWwgYW5kIGFueSBhYm92ZSB0aGF0IGl0IGlzIGluLCByZXBsYWNlIHdpdGggbmV3Q2x1c3RlclxuXHRcdFx0XHRcdHRoaXMuX3JlbW92ZUZyb21HcmlkVW5jbHVzdGVyZWQoY2xvc2VzdCwgem9vbSk7XG5cblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvL0RpZG4ndCBtYW5hZ2UgdG8gY2x1c3RlciBpbiBhdCB0aGlzIHpvb20sIHJlY29yZCB1cyBhcyBhIG1hcmtlciBoZXJlIGFuZCBjb250aW51ZSB1cHdhcmRzXG5cdFx0XHRcdGdyaWRVbmNsdXN0ZXJlZFt6b29tXS5hZGRPYmplY3QobGF5ZXIsIG1hcmtlclBvaW50KTtcblx0XHRcdH1cblxuXHRcdFx0Ly9EaWRuJ3QgZ2V0IGluIGFueXRoaW5nLCBhZGQgdXMgdG8gdGhlIHRvcFxuXHRcdFx0dGhpcy5fdG9wQ2x1c3RlckxldmVsLl9hZGRDaGlsZChsYXllcik7XG5cdFx0XHRsYXllci5fX3BhcmVudCA9IHRoaXMuX3RvcENsdXN0ZXJMZXZlbDtcblx0XHRcdHJldHVybjtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUmVmcmVzaGVzIHRoZSBpY29uIG9mIGFsbCBcImRpcnR5XCIgdmlzaWJsZSBjbHVzdGVycy5cblx0XHQgKiBOb24tdmlzaWJsZSBcImRpcnR5XCIgY2x1c3RlcnMgd2lsbCBiZSB1cGRhdGVkIHdoZW4gdGhleSBhcmUgYWRkZWQgdG8gdGhlIG1hcC5cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdF9yZWZyZXNoQ2x1c3RlcnNJY29uczogZnVuY3Rpb24gKCkge1xuXHRcdFx0dGhpcy5fZmVhdHVyZUdyb3VwLmVhY2hMYXllcihmdW5jdGlvbiAoYykge1xuXHRcdFx0XHRpZiAoYyBpbnN0YW5jZW9mIEwuTWFya2VyQ2x1c3RlciAmJiBjLl9pY29uTmVlZHNVcGRhdGUpIHtcblx0XHRcdFx0XHRjLl91cGRhdGVJY29uKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0sXG5cblx0XHQvL0VucXVldWUgY29kZSB0byBmaXJlIGFmdGVyIHRoZSBtYXJrZXIgZXhwYW5kL2NvbnRyYWN0IGhhcyBoYXBwZW5lZFxuXHRcdF9lbnF1ZXVlOiBmdW5jdGlvbiAoZm4pIHtcblx0XHRcdHRoaXMuX3F1ZXVlLnB1c2goZm4pO1xuXHRcdFx0aWYgKCF0aGlzLl9xdWV1ZVRpbWVvdXQpIHtcblx0XHRcdFx0dGhpcy5fcXVldWVUaW1lb3V0ID0gc2V0VGltZW91dChMLmJpbmQodGhpcy5fcHJvY2Vzc1F1ZXVlLCB0aGlzKSwgMzAwKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdF9wcm9jZXNzUXVldWU6IGZ1bmN0aW9uICgpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fcXVldWUubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dGhpcy5fcXVldWVbaV0uY2FsbCh0aGlzKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX3F1ZXVlLmxlbmd0aCA9IDA7XG5cdFx0XHRjbGVhclRpbWVvdXQodGhpcy5fcXVldWVUaW1lb3V0KTtcblx0XHRcdHRoaXMuX3F1ZXVlVGltZW91dCA9IG51bGw7XG5cdFx0fSxcblxuXHRcdC8vTWVyZ2UgYW5kIHNwbGl0IGFueSBleGlzdGluZyBjbHVzdGVycyB0aGF0IGFyZSB0b28gYmlnIG9yIHNtYWxsXG5cdFx0X21lcmdlU3BsaXRDbHVzdGVyczogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIG1hcFpvb20gPSBNYXRoLnJvdW5kKHRoaXMuX21hcC5fem9vbSk7XG5cblx0XHRcdC8vSW4gY2FzZSB3ZSBhcmUgc3RhcnRpbmcgdG8gc3BsaXQgYmVmb3JlIHRoZSBhbmltYXRpb24gZmluaXNoZWRcblx0XHRcdHRoaXMuX3Byb2Nlc3NRdWV1ZSgpO1xuXG5cdFx0XHRpZiAodGhpcy5fem9vbSA8IG1hcFpvb20gJiYgdGhpcy5fY3VycmVudFNob3duQm91bmRzLmludGVyc2VjdHModGhpcy5fZ2V0RXhwYW5kZWRWaXNpYmxlQm91bmRzKCkpKSB7IC8vWm9vbSBpbiwgc3BsaXRcblx0XHRcdFx0dGhpcy5fYW5pbWF0aW9uU3RhcnQoKTtcblx0XHRcdFx0Ly9SZW1vdmUgY2x1c3RlcnMgbm93IG9mZiBzY3JlZW5cblx0XHRcdFx0dGhpcy5fdG9wQ2x1c3RlckxldmVsLl9yZWN1cnNpdmVseVJlbW92ZUNoaWxkcmVuRnJvbU1hcCh0aGlzLl9jdXJyZW50U2hvd25Cb3VuZHMsIE1hdGguZmxvb3IodGhpcy5fbWFwLmdldE1pblpvb20oKSksIHRoaXMuX3pvb20sIHRoaXMuX2dldEV4cGFuZGVkVmlzaWJsZUJvdW5kcygpKTtcblxuXHRcdFx0XHR0aGlzLl9hbmltYXRpb25ab29tSW4odGhpcy5fem9vbSwgbWFwWm9vbSk7XG5cblx0XHRcdH0gZWxzZSBpZiAodGhpcy5fem9vbSA+IG1hcFpvb20pIHsgLy9ab29tIG91dCwgbWVyZ2Vcblx0XHRcdFx0dGhpcy5fYW5pbWF0aW9uU3RhcnQoKTtcblxuXHRcdFx0XHR0aGlzLl9hbmltYXRpb25ab29tT3V0KHRoaXMuX3pvb20sIG1hcFpvb20pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5fbW92ZUVuZCgpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvL0dldHMgdGhlIG1hcHMgdmlzaWJsZSBib3VuZHMgZXhwYW5kZWQgaW4gZWFjaCBkaXJlY3Rpb24gYnkgdGhlIHNpemUgb2YgdGhlIHNjcmVlbiAoc28gdGhlIHVzZXIgY2Fubm90IHNlZSBhbiBhcmVhIHdlIGRvIG5vdCBjb3ZlciBpbiBvbmUgcGFuKVxuXHRcdF9nZXRFeHBhbmRlZFZpc2libGVCb3VuZHM6IGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmICghdGhpcy5vcHRpb25zLnJlbW92ZU91dHNpZGVWaXNpYmxlQm91bmRzKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9tYXBCb3VuZHNJbmZpbml0ZTtcblx0XHRcdH0gZWxzZSBpZiAoTC5Ccm93c2VyLm1vYmlsZSkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fY2hlY2tCb3VuZHNNYXhMYXQodGhpcy5fbWFwLmdldEJvdW5kcygpKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXMuX2NoZWNrQm91bmRzTWF4TGF0KHRoaXMuX21hcC5nZXRCb3VuZHMoKS5wYWQoMSkpOyAvLyBQYWRkaW5nIGV4cGFuZHMgdGhlIGJvdW5kcyBieSBpdHMgb3duIGRpbWVuc2lvbnMgYnV0IHNjYWxlZCB3aXRoIHRoZSBnaXZlbiBmYWN0b3IuXG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEV4cGFuZHMgdGhlIGxhdGl0dWRlIHRvIEluZmluaXR5IChvciAtSW5maW5pdHkpIGlmIHRoZSBpbnB1dCBib3VuZHMgcmVhY2ggdGhlIG1hcCBwcm9qZWN0aW9uIG1heGltdW0gZGVmaW5lZCBsYXRpdHVkZVxuXHRcdCAqIChpbiB0aGUgY2FzZSBvZiBXZWIvU3BoZXJpY2FsIE1lcmNhdG9yLCBpdCBpcyA4NS4wNTExMjg3Nzk4IC8gc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1dlYl9NZXJjYXRvciNGb3JtdWxhcykuXG5cdFx0ICogT3RoZXJ3aXNlLCB0aGUgcmVtb3ZlT3V0c2lkZVZpc2libGVCb3VuZHMgb3B0aW9uIHdpbGwgcmVtb3ZlIG1hcmtlcnMgYmV5b25kIHRoYXQgbGltaXQsIHdoZXJlYXMgdGhlIHNhbWUgbWFya2VycyB3aXRob3V0XG5cdFx0ICogdGhpcyBvcHRpb24gKG9yIG91dHNpZGUgTUNHKSB3aWxsIGhhdmUgdGhlaXIgcG9zaXRpb24gZmxvb3JlZCAoY2VpbGVkKSBieSB0aGUgcHJvamVjdGlvbiBhbmQgcmVuZGVyZWQgYXQgdGhhdCBsaW1pdCxcblx0XHQgKiBtYWtpbmcgdGhlIHVzZXIgdGhpbmsgdGhhdCBNQ0cgXCJlYXRzXCIgdGhlbSBhbmQgbmV2ZXIgZGlzcGxheXMgdGhlbSBhZ2Fpbi5cblx0XHQgKiBAcGFyYW0gYm91bmRzIEwuTGF0TG5nQm91bmRzXG5cdFx0ICogQHJldHVybnMge0wuTGF0TG5nQm91bmRzfVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0X2NoZWNrQm91bmRzTWF4TGF0OiBmdW5jdGlvbiAoYm91bmRzKSB7XG5cdFx0XHR2YXIgbWF4TGF0ID0gdGhpcy5fbWF4TGF0O1xuXG5cdFx0XHRpZiAobWF4TGF0ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0aWYgKGJvdW5kcy5nZXROb3J0aCgpID49IG1heExhdCkge1xuXHRcdFx0XHRcdGJvdW5kcy5fbm9ydGhFYXN0LmxhdCA9IEluZmluaXR5O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChib3VuZHMuZ2V0U291dGgoKSA8PSAtbWF4TGF0KSB7XG5cdFx0XHRcdFx0Ym91bmRzLl9zb3V0aFdlc3QubGF0ID0gLUluZmluaXR5O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBib3VuZHM7XG5cdFx0fSxcblxuXHRcdC8vU2hhcmVkIGFuaW1hdGlvbiBjb2RlXG5cdFx0X2FuaW1hdGlvbkFkZExheWVyTm9uQW5pbWF0ZWQ6IGZ1bmN0aW9uIChsYXllciwgbmV3Q2x1c3Rlcikge1xuXHRcdFx0aWYgKG5ld0NsdXN0ZXIgPT09IGxheWVyKSB7XG5cdFx0XHRcdHRoaXMuX2ZlYXR1cmVHcm91cC5hZGRMYXllcihsYXllcik7XG5cdFx0XHR9IGVsc2UgaWYgKG5ld0NsdXN0ZXIuX2NoaWxkQ291bnQgPT09IDIpIHtcblx0XHRcdFx0bmV3Q2x1c3Rlci5fYWRkVG9NYXAoKTtcblxuXHRcdFx0XHR2YXIgbWFya2VycyA9IG5ld0NsdXN0ZXIuZ2V0QWxsQ2hpbGRNYXJrZXJzKCk7XG5cdFx0XHRcdHRoaXMuX2ZlYXR1cmVHcm91cC5yZW1vdmVMYXllcihtYXJrZXJzWzBdKTtcblx0XHRcdFx0dGhpcy5fZmVhdHVyZUdyb3VwLnJlbW92ZUxheWVyKG1hcmtlcnNbMV0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bmV3Q2x1c3Rlci5fdXBkYXRlSWNvbigpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBFeHRyYWN0cyBpbmRpdmlkdWFsIChpLmUuIG5vbi1ncm91cCkgbGF5ZXJzIGZyb20gYSBMYXllciBHcm91cC5cblx0XHQgKiBAcGFyYW0gZ3JvdXAgdG8gZXh0cmFjdCBsYXllcnMgZnJvbS5cblx0XHQgKiBAcGFyYW0gb3V0cHV0IHtBcnJheX0gaW4gd2hpY2ggdG8gc3RvcmUgdGhlIGV4dHJhY3RlZCBsYXllcnMuXG5cdFx0ICogQHJldHVybnMgeyp8QXJyYXl9XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHRfZXh0cmFjdE5vbkdyb3VwTGF5ZXJzOiBmdW5jdGlvbiAoZ3JvdXAsIG91dHB1dCkge1xuXHRcdFx0dmFyIGxheWVycyA9IGdyb3VwLmdldExheWVycygpLFxuXHRcdFx0ICAgIGkgPSAwLFxuXHRcdFx0ICAgIGxheWVyO1xuXG5cdFx0XHRvdXRwdXQgPSBvdXRwdXQgfHwgW107XG5cblx0XHRcdGZvciAoOyBpIDwgbGF5ZXJzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGxheWVyID0gbGF5ZXJzW2ldO1xuXG5cdFx0XHRcdGlmIChsYXllciBpbnN0YW5jZW9mIEwuTGF5ZXJHcm91cCkge1xuXHRcdFx0XHRcdHRoaXMuX2V4dHJhY3ROb25Hcm91cExheWVycyhsYXllciwgb3V0cHV0KTtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdG91dHB1dC5wdXNoKGxheWVyKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG91dHB1dDtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogSW1wbGVtZW50cyB0aGUgc2luZ2xlTWFya2VyTW9kZSBvcHRpb24uXG5cdFx0ICogQHBhcmFtIGxheWVyIE1hcmtlciB0byByZS1zdHlsZSB1c2luZyB0aGUgQ2x1c3RlcnMgaWNvbkNyZWF0ZUZ1bmN0aW9uLlxuXHRcdCAqIEByZXR1cm5zIHtMLkljb259IFRoZSBuZXdseSBjcmVhdGVkIGljb24uXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHRfb3ZlcnJpZGVNYXJrZXJJY29uOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHRcdHZhciBpY29uID0gbGF5ZXIub3B0aW9ucy5pY29uID0gdGhpcy5vcHRpb25zLmljb25DcmVhdGVGdW5jdGlvbih7XG5cdFx0XHRcdGdldENoaWxkQ291bnQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRyZXR1cm4gMTtcblx0XHRcdFx0fSxcblx0XHRcdFx0Z2V0QWxsQ2hpbGRNYXJrZXJzOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0cmV0dXJuIFtsYXllcl07XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHRyZXR1cm4gaWNvbjtcblx0XHR9XG5cdH0pO1xuXG5cdC8vIENvbnN0YW50IGJvdW5kcyB1c2VkIGluIGNhc2Ugb3B0aW9uIFwicmVtb3ZlT3V0c2lkZVZpc2libGVCb3VuZHNcIiBpcyBzZXQgdG8gZmFsc2UuXG5cdEwuTWFya2VyQ2x1c3Rlckdyb3VwLmluY2x1ZGUoe1xuXHRcdF9tYXBCb3VuZHNJbmZpbml0ZTogbmV3IEwuTGF0TG5nQm91bmRzKG5ldyBMLkxhdExuZygtSW5maW5pdHksIC1JbmZpbml0eSksIG5ldyBMLkxhdExuZyhJbmZpbml0eSwgSW5maW5pdHkpKVxuXHR9KTtcblxuXHRMLk1hcmtlckNsdXN0ZXJHcm91cC5pbmNsdWRlKHtcblx0XHRfbm9BbmltYXRpb246IHtcblx0XHRcdC8vTm9uIEFuaW1hdGVkIHZlcnNpb25zIG9mIGV2ZXJ5dGhpbmdcblx0XHRcdF9hbmltYXRpb25TdGFydDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHQvL0RvIG5vdGhpbmcuLi5cblx0XHRcdH0sXG5cdFx0XHRfYW5pbWF0aW9uWm9vbUluOiBmdW5jdGlvbiAocHJldmlvdXNab29tTGV2ZWwsIG5ld1pvb21MZXZlbCkge1xuXHRcdFx0XHR0aGlzLl90b3BDbHVzdGVyTGV2ZWwuX3JlY3Vyc2l2ZWx5UmVtb3ZlQ2hpbGRyZW5Gcm9tTWFwKHRoaXMuX2N1cnJlbnRTaG93bkJvdW5kcywgTWF0aC5mbG9vcih0aGlzLl9tYXAuZ2V0TWluWm9vbSgpKSwgcHJldmlvdXNab29tTGV2ZWwpO1xuXHRcdFx0XHR0aGlzLl90b3BDbHVzdGVyTGV2ZWwuX3JlY3Vyc2l2ZWx5QWRkQ2hpbGRyZW5Ub01hcChudWxsLCBuZXdab29tTGV2ZWwsIHRoaXMuX2dldEV4cGFuZGVkVmlzaWJsZUJvdW5kcygpKTtcblxuXHRcdFx0XHQvL1dlIGRpZG4ndCBhY3R1YWxseSBhbmltYXRlLCBidXQgd2UgdXNlIHRoaXMgZXZlbnQgdG8gbWVhbiBcImNsdXN0ZXJpbmcgYW5pbWF0aW9ucyBoYXZlIGZpbmlzaGVkXCJcblx0XHRcdFx0dGhpcy5maXJlKCdhbmltYXRpb25lbmQnKTtcblx0XHRcdH0sXG5cdFx0XHRfYW5pbWF0aW9uWm9vbU91dDogZnVuY3Rpb24gKHByZXZpb3VzWm9vbUxldmVsLCBuZXdab29tTGV2ZWwpIHtcblx0XHRcdFx0dGhpcy5fdG9wQ2x1c3RlckxldmVsLl9yZWN1cnNpdmVseVJlbW92ZUNoaWxkcmVuRnJvbU1hcCh0aGlzLl9jdXJyZW50U2hvd25Cb3VuZHMsIE1hdGguZmxvb3IodGhpcy5fbWFwLmdldE1pblpvb20oKSksIHByZXZpb3VzWm9vbUxldmVsKTtcblx0XHRcdFx0dGhpcy5fdG9wQ2x1c3RlckxldmVsLl9yZWN1cnNpdmVseUFkZENoaWxkcmVuVG9NYXAobnVsbCwgbmV3Wm9vbUxldmVsLCB0aGlzLl9nZXRFeHBhbmRlZFZpc2libGVCb3VuZHMoKSk7XG5cblx0XHRcdFx0Ly9XZSBkaWRuJ3QgYWN0dWFsbHkgYW5pbWF0ZSwgYnV0IHdlIHVzZSB0aGlzIGV2ZW50IHRvIG1lYW4gXCJjbHVzdGVyaW5nIGFuaW1hdGlvbnMgaGF2ZSBmaW5pc2hlZFwiXG5cdFx0XHRcdHRoaXMuZmlyZSgnYW5pbWF0aW9uZW5kJyk7XG5cdFx0XHR9LFxuXHRcdFx0X2FuaW1hdGlvbkFkZExheWVyOiBmdW5jdGlvbiAobGF5ZXIsIG5ld0NsdXN0ZXIpIHtcblx0XHRcdFx0dGhpcy5fYW5pbWF0aW9uQWRkTGF5ZXJOb25BbmltYXRlZChsYXllciwgbmV3Q2x1c3Rlcik7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdF93aXRoQW5pbWF0aW9uOiB7XG5cdFx0XHQvL0FuaW1hdGVkIHZlcnNpb25zIGhlcmVcblx0XHRcdF9hbmltYXRpb25TdGFydDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR0aGlzLl9tYXAuX21hcFBhbmUuY2xhc3NOYW1lICs9ICcgbGVhZmxldC1jbHVzdGVyLWFuaW0nO1xuXHRcdFx0XHR0aGlzLl9pblpvb21BbmltYXRpb24rKztcblx0XHRcdH0sXG5cblx0XHRcdF9hbmltYXRpb25ab29tSW46IGZ1bmN0aW9uIChwcmV2aW91c1pvb21MZXZlbCwgbmV3Wm9vbUxldmVsKSB7XG5cdFx0XHRcdHZhciBib3VuZHMgPSB0aGlzLl9nZXRFeHBhbmRlZFZpc2libGVCb3VuZHMoKSxcblx0XHRcdFx0ICAgIGZnID0gdGhpcy5fZmVhdHVyZUdyb3VwLFxuXHRcdFx0XHRcdG1pblpvb20gPSBNYXRoLmZsb29yKHRoaXMuX21hcC5nZXRNaW5ab29tKCkpLFxuXHRcdFx0XHQgICAgaTtcblxuXHRcdFx0XHR0aGlzLl9pZ25vcmVNb3ZlID0gdHJ1ZTtcblxuXHRcdFx0XHQvL0FkZCBhbGwgY2hpbGRyZW4gb2YgY3VycmVudCBjbHVzdGVycyB0byBtYXAgYW5kIHJlbW92ZSB0aG9zZSBjbHVzdGVycyBmcm9tIG1hcFxuXHRcdFx0XHR0aGlzLl90b3BDbHVzdGVyTGV2ZWwuX3JlY3Vyc2l2ZWx5KGJvdW5kcywgcHJldmlvdXNab29tTGV2ZWwsIG1pblpvb20sIGZ1bmN0aW9uIChjKSB7XG5cdFx0XHRcdFx0dmFyIHN0YXJ0UG9zID0gYy5fbGF0bG5nLFxuXHRcdFx0XHRcdCAgICBtYXJrZXJzICA9IGMuX21hcmtlcnMsXG5cdFx0XHRcdFx0ICAgIG07XG5cblx0XHRcdFx0XHRpZiAoIWJvdW5kcy5jb250YWlucyhzdGFydFBvcykpIHtcblx0XHRcdFx0XHRcdHN0YXJ0UG9zID0gbnVsbDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoYy5faXNTaW5nbGVQYXJlbnQoKSAmJiBwcmV2aW91c1pvb21MZXZlbCArIDEgPT09IG5ld1pvb21MZXZlbCkgeyAvL0ltbWVkaWF0ZWx5IGFkZCB0aGUgbmV3IGNoaWxkIGFuZCByZW1vdmUgdXNcblx0XHRcdFx0XHRcdGZnLnJlbW92ZUxheWVyKGMpO1xuXHRcdFx0XHRcdFx0Yy5fcmVjdXJzaXZlbHlBZGRDaGlsZHJlblRvTWFwKG51bGwsIG5ld1pvb21MZXZlbCwgYm91bmRzKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Ly9GYWRlIG91dCBvbGQgY2x1c3RlclxuXHRcdFx0XHRcdFx0Yy5jbHVzdGVySGlkZSgpO1xuXHRcdFx0XHRcdFx0Yy5fcmVjdXJzaXZlbHlBZGRDaGlsZHJlblRvTWFwKHN0YXJ0UG9zLCBuZXdab29tTGV2ZWwsIGJvdW5kcyk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly9SZW1vdmUgYWxsIG1hcmtlcnMgdGhhdCBhcmVuJ3QgdmlzaWJsZSBhbnkgbW9yZVxuXHRcdFx0XHRcdC8vVE9ETzogRG8gd2UgYWN0dWFsbHkgbmVlZCB0byBkbyB0aGlzIG9uIHRoZSBoaWdoZXIgbGV2ZWxzIHRvbz9cblx0XHRcdFx0XHRmb3IgKGkgPSBtYXJrZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRcdFx0XHRtID0gbWFya2Vyc1tpXTtcblx0XHRcdFx0XHRcdGlmICghYm91bmRzLmNvbnRhaW5zKG0uX2xhdGxuZykpIHtcblx0XHRcdFx0XHRcdFx0ZmcucmVtb3ZlTGF5ZXIobSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdHRoaXMuX2ZvcmNlTGF5b3V0KCk7XG5cblx0XHRcdFx0Ly9VcGRhdGUgb3BhY2l0aWVzXG5cdFx0XHRcdHRoaXMuX3RvcENsdXN0ZXJMZXZlbC5fcmVjdXJzaXZlbHlCZWNvbWVWaXNpYmxlKGJvdW5kcywgbmV3Wm9vbUxldmVsKTtcblx0XHRcdFx0Ly9UT0RPIE1heWJlPyBVcGRhdGUgbWFya2VycyBpbiBfcmVjdXJzaXZlbHlCZWNvbWVWaXNpYmxlXG5cdFx0XHRcdGZnLmVhY2hMYXllcihmdW5jdGlvbiAobikge1xuXHRcdFx0XHRcdGlmICghKG4gaW5zdGFuY2VvZiBMLk1hcmtlckNsdXN0ZXIpICYmIG4uX2ljb24pIHtcblx0XHRcdFx0XHRcdG4uY2x1c3RlclNob3coKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdC8vdXBkYXRlIHRoZSBwb3NpdGlvbnMgb2YgdGhlIGp1c3QgYWRkZWQgY2x1c3RlcnMvbWFya2Vyc1xuXHRcdFx0XHR0aGlzLl90b3BDbHVzdGVyTGV2ZWwuX3JlY3Vyc2l2ZWx5KGJvdW5kcywgcHJldmlvdXNab29tTGV2ZWwsIG5ld1pvb21MZXZlbCwgZnVuY3Rpb24gKGMpIHtcblx0XHRcdFx0XHRjLl9yZWN1cnNpdmVseVJlc3RvcmVDaGlsZFBvc2l0aW9ucyhuZXdab29tTGV2ZWwpO1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHR0aGlzLl9pZ25vcmVNb3ZlID0gZmFsc2U7XG5cblx0XHRcdFx0Ly9SZW1vdmUgdGhlIG9sZCBjbHVzdGVycyBhbmQgY2xvc2UgdGhlIHpvb20gYW5pbWF0aW9uXG5cdFx0XHRcdHRoaXMuX2VucXVldWUoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdC8vdXBkYXRlIHRoZSBwb3NpdGlvbnMgb2YgdGhlIGp1c3QgYWRkZWQgY2x1c3RlcnMvbWFya2Vyc1xuXHRcdFx0XHRcdHRoaXMuX3RvcENsdXN0ZXJMZXZlbC5fcmVjdXJzaXZlbHkoYm91bmRzLCBwcmV2aW91c1pvb21MZXZlbCwgbWluWm9vbSwgZnVuY3Rpb24gKGMpIHtcblx0XHRcdFx0XHRcdGZnLnJlbW92ZUxheWVyKGMpO1xuXHRcdFx0XHRcdFx0Yy5jbHVzdGVyU2hvdygpO1xuXHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0dGhpcy5fYW5pbWF0aW9uRW5kKCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSxcblxuXHRcdFx0X2FuaW1hdGlvblpvb21PdXQ6IGZ1bmN0aW9uIChwcmV2aW91c1pvb21MZXZlbCwgbmV3Wm9vbUxldmVsKSB7XG5cdFx0XHRcdHRoaXMuX2FuaW1hdGlvblpvb21PdXRTaW5nbGUodGhpcy5fdG9wQ2x1c3RlckxldmVsLCBwcmV2aW91c1pvb21MZXZlbCAtIDEsIG5ld1pvb21MZXZlbCk7XG5cblx0XHRcdFx0Ly9OZWVkIHRvIGFkZCBtYXJrZXJzIGZvciB0aG9zZSB0aGF0IHdlcmVuJ3Qgb24gdGhlIG1hcCBiZWZvcmUgYnV0IGFyZSBub3dcblx0XHRcdFx0dGhpcy5fdG9wQ2x1c3RlckxldmVsLl9yZWN1cnNpdmVseUFkZENoaWxkcmVuVG9NYXAobnVsbCwgbmV3Wm9vbUxldmVsLCB0aGlzLl9nZXRFeHBhbmRlZFZpc2libGVCb3VuZHMoKSk7XG5cdFx0XHRcdC8vUmVtb3ZlIG1hcmtlcnMgdGhhdCB3ZXJlIG9uIHRoZSBtYXAgYmVmb3JlIGJ1dCB3b24ndCBiZSBub3dcblx0XHRcdFx0dGhpcy5fdG9wQ2x1c3RlckxldmVsLl9yZWN1cnNpdmVseVJlbW92ZUNoaWxkcmVuRnJvbU1hcCh0aGlzLl9jdXJyZW50U2hvd25Cb3VuZHMsIE1hdGguZmxvb3IodGhpcy5fbWFwLmdldE1pblpvb20oKSksIHByZXZpb3VzWm9vbUxldmVsLCB0aGlzLl9nZXRFeHBhbmRlZFZpc2libGVCb3VuZHMoKSk7XG5cdFx0XHR9LFxuXG5cdFx0XHRfYW5pbWF0aW9uQWRkTGF5ZXI6IGZ1bmN0aW9uIChsYXllciwgbmV3Q2x1c3Rlcikge1xuXHRcdFx0XHR2YXIgbWUgPSB0aGlzLFxuXHRcdFx0XHQgICAgZmcgPSB0aGlzLl9mZWF0dXJlR3JvdXA7XG5cblx0XHRcdFx0ZmcuYWRkTGF5ZXIobGF5ZXIpO1xuXHRcdFx0XHRpZiAobmV3Q2x1c3RlciAhPT0gbGF5ZXIpIHtcblx0XHRcdFx0XHRpZiAobmV3Q2x1c3Rlci5fY2hpbGRDb3VudCA+IDIpIHsgLy9XYXMgYWxyZWFkeSBhIGNsdXN0ZXJcblxuXHRcdFx0XHRcdFx0bmV3Q2x1c3Rlci5fdXBkYXRlSWNvbigpO1xuXHRcdFx0XHRcdFx0dGhpcy5fZm9yY2VMYXlvdXQoKTtcblx0XHRcdFx0XHRcdHRoaXMuX2FuaW1hdGlvblN0YXJ0KCk7XG5cblx0XHRcdFx0XHRcdGxheWVyLl9zZXRQb3ModGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludChuZXdDbHVzdGVyLmdldExhdExuZygpKSk7XG5cdFx0XHRcdFx0XHRsYXllci5jbHVzdGVySGlkZSgpO1xuXG5cdFx0XHRcdFx0XHR0aGlzLl9lbnF1ZXVlKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdFx0ZmcucmVtb3ZlTGF5ZXIobGF5ZXIpO1xuXHRcdFx0XHRcdFx0XHRsYXllci5jbHVzdGVyU2hvdygpO1xuXG5cdFx0XHRcdFx0XHRcdG1lLl9hbmltYXRpb25FbmQoKTtcblx0XHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHsgLy9KdXN0IGJlY2FtZSBhIGNsdXN0ZXJcblx0XHRcdFx0XHRcdHRoaXMuX2ZvcmNlTGF5b3V0KCk7XG5cblx0XHRcdFx0XHRcdG1lLl9hbmltYXRpb25TdGFydCgpO1xuXHRcdFx0XHRcdFx0bWUuX2FuaW1hdGlvblpvb21PdXRTaW5nbGUobmV3Q2x1c3RlciwgdGhpcy5fbWFwLmdldE1heFpvb20oKSwgdGhpcy5fem9vbSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8vIFByaXZhdGUgbWV0aG9kcyBmb3IgYW5pbWF0ZWQgdmVyc2lvbnMuXG5cdFx0X2FuaW1hdGlvblpvb21PdXRTaW5nbGU6IGZ1bmN0aW9uIChjbHVzdGVyLCBwcmV2aW91c1pvb21MZXZlbCwgbmV3Wm9vbUxldmVsKSB7XG5cdFx0XHR2YXIgYm91bmRzID0gdGhpcy5fZ2V0RXhwYW5kZWRWaXNpYmxlQm91bmRzKCksXG5cdFx0XHRcdG1pblpvb20gPSBNYXRoLmZsb29yKHRoaXMuX21hcC5nZXRNaW5ab29tKCkpO1xuXG5cdFx0XHQvL0FuaW1hdGUgYWxsIG9mIHRoZSBtYXJrZXJzIGluIHRoZSBjbHVzdGVycyB0byBtb3ZlIHRvIHRoZWlyIGNsdXN0ZXIgY2VudGVyIHBvaW50XG5cdFx0XHRjbHVzdGVyLl9yZWN1cnNpdmVseUFuaW1hdGVDaGlsZHJlbkluQW5kQWRkU2VsZlRvTWFwKGJvdW5kcywgbWluWm9vbSwgcHJldmlvdXNab29tTGV2ZWwgKyAxLCBuZXdab29tTGV2ZWwpO1xuXG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXG5cdFx0XHQvL1VwZGF0ZSB0aGUgb3BhY2l0eSAoSWYgd2UgaW1tZWRpYXRlbHkgc2V0IGl0IHRoZXkgd29uJ3QgYW5pbWF0ZSlcblx0XHRcdHRoaXMuX2ZvcmNlTGF5b3V0KCk7XG5cdFx0XHRjbHVzdGVyLl9yZWN1cnNpdmVseUJlY29tZVZpc2libGUoYm91bmRzLCBuZXdab29tTGV2ZWwpO1xuXG5cdFx0XHQvL1RPRE86IE1heWJlIHVzZSB0aGUgdHJhbnNpdGlvbiB0aW1pbmcgc3R1ZmYgdG8gbWFrZSB0aGlzIG1vcmUgcmVsaWFibGVcblx0XHRcdC8vV2hlbiB0aGUgYW5pbWF0aW9ucyBhcmUgZG9uZSwgdGlkeSB1cFxuXHRcdFx0dGhpcy5fZW5xdWV1ZShmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0Ly9UaGlzIGNsdXN0ZXIgc3RvcHBlZCBiZWluZyBhIGNsdXN0ZXIgYmVmb3JlIHRoZSB0aW1lb3V0IGZpcmVkXG5cdFx0XHRcdGlmIChjbHVzdGVyLl9jaGlsZENvdW50ID09PSAxKSB7XG5cdFx0XHRcdFx0dmFyIG0gPSBjbHVzdGVyLl9tYXJrZXJzWzBdO1xuXHRcdFx0XHRcdC8vSWYgd2Ugd2VyZSBpbiBhIGNsdXN0ZXIgYW5pbWF0aW9uIGF0IHRoZSB0aW1lIHRoZW4gdGhlIG9wYWNpdHkgYW5kIHBvc2l0aW9uIG9mIG91ciBjaGlsZCBjb3VsZCBiZSB3cm9uZyBub3csIHNvIGZpeCBpdFxuXHRcdFx0XHRcdHRoaXMuX2lnbm9yZU1vdmUgPSB0cnVlO1xuXHRcdFx0XHRcdG0uc2V0TGF0TG5nKG0uZ2V0TGF0TG5nKCkpO1xuXHRcdFx0XHRcdHRoaXMuX2lnbm9yZU1vdmUgPSBmYWxzZTtcblx0XHRcdFx0XHRpZiAobS5jbHVzdGVyU2hvdykge1xuXHRcdFx0XHRcdFx0bS5jbHVzdGVyU2hvdygpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjbHVzdGVyLl9yZWN1cnNpdmVseShib3VuZHMsIG5ld1pvb21MZXZlbCwgbWluWm9vbSwgZnVuY3Rpb24gKGMpIHtcblx0XHRcdFx0XHRcdGMuX3JlY3Vyc2l2ZWx5UmVtb3ZlQ2hpbGRyZW5Gcm9tTWFwKGJvdW5kcywgbWluWm9vbSwgcHJldmlvdXNab29tTGV2ZWwgKyAxKTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRtZS5fYW5pbWF0aW9uRW5kKCk7XG5cdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0X2FuaW1hdGlvbkVuZDogZnVuY3Rpb24gKCkge1xuXHRcdFx0aWYgKHRoaXMuX21hcCkge1xuXHRcdFx0XHR0aGlzLl9tYXAuX21hcFBhbmUuY2xhc3NOYW1lID0gdGhpcy5fbWFwLl9tYXBQYW5lLmNsYXNzTmFtZS5yZXBsYWNlKCcgbGVhZmxldC1jbHVzdGVyLWFuaW0nLCAnJyk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9pblpvb21BbmltYXRpb24tLTtcblx0XHRcdHRoaXMuZmlyZSgnYW5pbWF0aW9uZW5kJyk7XG5cdFx0fSxcblxuXHRcdC8vRm9yY2UgYSBicm93c2VyIGxheW91dCBvZiBzdHVmZiBpbiB0aGUgbWFwXG5cdFx0Ly8gU2hvdWxkIGFwcGx5IHRoZSBjdXJyZW50IG9wYWNpdHkgYW5kIGxvY2F0aW9uIHRvIGFsbCBlbGVtZW50cyBzbyB3ZSBjYW4gdXBkYXRlIHRoZW0gYWdhaW4gZm9yIGFuIGFuaW1hdGlvblxuXHRcdF9mb3JjZUxheW91dDogZnVuY3Rpb24gKCkge1xuXHRcdFx0Ly9JbiBteSB0ZXN0aW5nIHRoaXMgd29ya3MsIGluZmFjdCBvZmZzZXRXaWR0aCBvZiBhbnkgZWxlbWVudCBzZWVtcyB0byB3b3JrLlxuXHRcdFx0Ly9Db3VsZCBsb29wIGFsbCB0aGlzLl9sYXllcnMgYW5kIGRvIHRoaXMgZm9yIGVhY2ggX2ljb24gaWYgaXQgc3RvcHMgd29ya2luZ1xuXG5cdFx0XHRMLlV0aWwuZmFsc2VGbihkb2N1bWVudC5ib2R5Lm9mZnNldFdpZHRoKTtcblx0XHR9XG5cdH0pO1xuXG5cdEwubWFya2VyQ2x1c3Rlckdyb3VwID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0XHRyZXR1cm4gbmV3IEwuTWFya2VyQ2x1c3Rlckdyb3VwKG9wdGlvbnMpO1xuXHR9O1xuXG5cdHZhciBNYXJrZXJDbHVzdGVyID0gTC5NYXJrZXJDbHVzdGVyID0gTC5NYXJrZXIuZXh0ZW5kKHtcblx0XHRvcHRpb25zOiBMLkljb24ucHJvdG90eXBlLm9wdGlvbnMsXG5cblx0XHRpbml0aWFsaXplOiBmdW5jdGlvbiAoZ3JvdXAsIHpvb20sIGEsIGIpIHtcblxuXHRcdFx0TC5NYXJrZXIucHJvdG90eXBlLmluaXRpYWxpemUuY2FsbCh0aGlzLCBhID8gKGEuX2NMYXRMbmcgfHwgYS5nZXRMYXRMbmcoKSkgOiBuZXcgTC5MYXRMbmcoMCwgMCksXG5cdCAgICAgICAgICAgIHsgaWNvbjogdGhpcywgcGFuZTogZ3JvdXAub3B0aW9ucy5jbHVzdGVyUGFuZSB9KTtcblxuXHRcdFx0dGhpcy5fZ3JvdXAgPSBncm91cDtcblx0XHRcdHRoaXMuX3pvb20gPSB6b29tO1xuXG5cdFx0XHR0aGlzLl9tYXJrZXJzID0gW107XG5cdFx0XHR0aGlzLl9jaGlsZENsdXN0ZXJzID0gW107XG5cdFx0XHR0aGlzLl9jaGlsZENvdW50ID0gMDtcblx0XHRcdHRoaXMuX2ljb25OZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0XHR0aGlzLl9ib3VuZHNOZWVkVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0dGhpcy5fYm91bmRzID0gbmV3IEwuTGF0TG5nQm91bmRzKCk7XG5cblx0XHRcdGlmIChhKSB7XG5cdFx0XHRcdHRoaXMuX2FkZENoaWxkKGEpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGIpIHtcblx0XHRcdFx0dGhpcy5fYWRkQ2hpbGQoYik7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8vUmVjdXJzaXZlbHkgcmV0cmlldmUgYWxsIGNoaWxkIG1hcmtlcnMgb2YgdGhpcyBjbHVzdGVyXG5cdFx0Z2V0QWxsQ2hpbGRNYXJrZXJzOiBmdW5jdGlvbiAoc3RvcmFnZUFycmF5LCBpZ25vcmVEcmFnZ2VkTWFya2VyKSB7XG5cdFx0XHRzdG9yYWdlQXJyYXkgPSBzdG9yYWdlQXJyYXkgfHwgW107XG5cblx0XHRcdGZvciAodmFyIGkgPSB0aGlzLl9jaGlsZENsdXN0ZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRcdHRoaXMuX2NoaWxkQ2x1c3RlcnNbaV0uZ2V0QWxsQ2hpbGRNYXJrZXJzKHN0b3JhZ2VBcnJheSk7XG5cdFx0XHR9XG5cblx0XHRcdGZvciAodmFyIGogPSB0aGlzLl9tYXJrZXJzLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKSB7XG5cdFx0XHRcdGlmIChpZ25vcmVEcmFnZ2VkTWFya2VyICYmIHRoaXMuX21hcmtlcnNbal0uX19kcmFnU3RhcnQpIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRzdG9yYWdlQXJyYXkucHVzaCh0aGlzLl9tYXJrZXJzW2pdKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHN0b3JhZ2VBcnJheTtcblx0XHR9LFxuXG5cdFx0Ly9SZXR1cm5zIHRoZSBjb3VudCBvZiBob3cgbWFueSBjaGlsZCBtYXJrZXJzIHdlIGhhdmVcblx0XHRnZXRDaGlsZENvdW50OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fY2hpbGRDb3VudDtcblx0XHR9LFxuXG5cdFx0Ly9ab29tIHRvIHRoZSBtaW5pbXVtIG9mIHNob3dpbmcgYWxsIG9mIHRoZSBjaGlsZCBtYXJrZXJzLCBvciB0aGUgZXh0ZW50cyBvZiB0aGlzIGNsdXN0ZXJcblx0XHR6b29tVG9Cb3VuZHM6IGZ1bmN0aW9uIChmaXRCb3VuZHNPcHRpb25zKSB7XG5cdFx0XHR2YXIgY2hpbGRDbHVzdGVycyA9IHRoaXMuX2NoaWxkQ2x1c3RlcnMuc2xpY2UoKSxcblx0XHRcdFx0bWFwID0gdGhpcy5fZ3JvdXAuX21hcCxcblx0XHRcdFx0Ym91bmRzWm9vbSA9IG1hcC5nZXRCb3VuZHNab29tKHRoaXMuX2JvdW5kcyksXG5cdFx0XHRcdHpvb20gPSB0aGlzLl96b29tICsgMSxcblx0XHRcdFx0bWFwWm9vbSA9IG1hcC5nZXRab29tKCksXG5cdFx0XHRcdGk7XG5cblx0XHRcdC8vY2FsY3VsYXRlIGhvdyBmYXIgd2UgbmVlZCB0byB6b29tIGRvd24gdG8gc2VlIGFsbCBvZiB0aGUgbWFya2Vyc1xuXHRcdFx0d2hpbGUgKGNoaWxkQ2x1c3RlcnMubGVuZ3RoID4gMCAmJiBib3VuZHNab29tID4gem9vbSkge1xuXHRcdFx0XHR6b29tKys7XG5cdFx0XHRcdHZhciBuZXdDbHVzdGVycyA9IFtdO1xuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgY2hpbGRDbHVzdGVycy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdG5ld0NsdXN0ZXJzID0gbmV3Q2x1c3RlcnMuY29uY2F0KGNoaWxkQ2x1c3RlcnNbaV0uX2NoaWxkQ2x1c3RlcnMpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNoaWxkQ2x1c3RlcnMgPSBuZXdDbHVzdGVycztcblx0XHRcdH1cblxuXHRcdFx0aWYgKGJvdW5kc1pvb20gPiB6b29tKSB7XG5cdFx0XHRcdHRoaXMuX2dyb3VwLl9tYXAuc2V0Vmlldyh0aGlzLl9sYXRsbmcsIHpvb20pO1xuXHRcdFx0fSBlbHNlIGlmIChib3VuZHNab29tIDw9IG1hcFpvb20pIHsgLy9JZiBmaXRCb3VuZHMgd291bGRuJ3Qgem9vbSB1cyBkb3duLCB6b29tIHVzIGRvd24gaW5zdGVhZFxuXHRcdFx0XHR0aGlzLl9ncm91cC5fbWFwLnNldFZpZXcodGhpcy5fbGF0bG5nLCBtYXBab29tICsgMSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLl9ncm91cC5fbWFwLmZpdEJvdW5kcyh0aGlzLl9ib3VuZHMsIGZpdEJvdW5kc09wdGlvbnMpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRnZXRCb3VuZHM6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBib3VuZHMgPSBuZXcgTC5MYXRMbmdCb3VuZHMoKTtcblx0XHRcdGJvdW5kcy5leHRlbmQodGhpcy5fYm91bmRzKTtcblx0XHRcdHJldHVybiBib3VuZHM7XG5cdFx0fSxcblxuXHRcdF91cGRhdGVJY29uOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR0aGlzLl9pY29uTmVlZHNVcGRhdGUgPSB0cnVlO1xuXHRcdFx0aWYgKHRoaXMuX2ljb24pIHtcblx0XHRcdFx0dGhpcy5zZXRJY29uKHRoaXMpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvL0NsdWRnZSBmb3IgSWNvbiwgd2UgcHJldGVuZCB0byBiZSBhbiBpY29uIGZvciBwZXJmb3JtYW5jZVxuXHRcdGNyZWF0ZUljb246IGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmICh0aGlzLl9pY29uTmVlZHNVcGRhdGUpIHtcblx0XHRcdFx0dGhpcy5faWNvbk9iaiA9IHRoaXMuX2dyb3VwLm9wdGlvbnMuaWNvbkNyZWF0ZUZ1bmN0aW9uKHRoaXMpO1xuXHRcdFx0XHR0aGlzLl9pY29uTmVlZHNVcGRhdGUgPSBmYWxzZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzLl9pY29uT2JqLmNyZWF0ZUljb24oKTtcblx0XHR9LFxuXHRcdGNyZWF0ZVNoYWRvdzogZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX2ljb25PYmouY3JlYXRlU2hhZG93KCk7XG5cdFx0fSxcblxuXG5cdFx0X2FkZENoaWxkOiBmdW5jdGlvbiAobmV3MSwgaXNOb3RpZmljYXRpb25Gcm9tQ2hpbGQpIHtcblxuXHRcdFx0dGhpcy5faWNvbk5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0dGhpcy5fYm91bmRzTmVlZFVwZGF0ZSA9IHRydWU7XG5cdFx0XHR0aGlzLl9zZXRDbHVzdGVyQ2VudGVyKG5ldzEpO1xuXG5cdFx0XHRpZiAobmV3MSBpbnN0YW5jZW9mIEwuTWFya2VyQ2x1c3Rlcikge1xuXHRcdFx0XHRpZiAoIWlzTm90aWZpY2F0aW9uRnJvbUNoaWxkKSB7XG5cdFx0XHRcdFx0dGhpcy5fY2hpbGRDbHVzdGVycy5wdXNoKG5ldzEpO1xuXHRcdFx0XHRcdG5ldzEuX19wYXJlbnQgPSB0aGlzO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuX2NoaWxkQ291bnQgKz0gbmV3MS5fY2hpbGRDb3VudDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmICghaXNOb3RpZmljYXRpb25Gcm9tQ2hpbGQpIHtcblx0XHRcdFx0XHR0aGlzLl9tYXJrZXJzLnB1c2gobmV3MSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5fY2hpbGRDb3VudCsrO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGhpcy5fX3BhcmVudCkge1xuXHRcdFx0XHR0aGlzLl9fcGFyZW50Ll9hZGRDaGlsZChuZXcxLCB0cnVlKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogTWFrZXMgc3VyZSB0aGUgY2x1c3RlciBjZW50ZXIgaXMgc2V0LiBJZiBub3QsIHVzZXMgdGhlIGNoaWxkIGNlbnRlciBpZiBpdCBpcyBhIGNsdXN0ZXIsIG9yIHRoZSBtYXJrZXIgcG9zaXRpb24uXG5cdFx0ICogQHBhcmFtIGNoaWxkIEwuTWFya2VyQ2x1c3RlcnxMLk1hcmtlciB0aGF0IHdpbGwgYmUgdXNlZCBhcyBjbHVzdGVyIGNlbnRlciBpZiBub3QgZGVmaW5lZCB5ZXQuXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHRfc2V0Q2x1c3RlckNlbnRlcjogZnVuY3Rpb24gKGNoaWxkKSB7XG5cdFx0XHRpZiAoIXRoaXMuX2NMYXRMbmcpIHtcblx0XHRcdFx0Ly8gd2hlbiBjbHVzdGVyaW5nLCB0YWtlIHBvc2l0aW9uIG9mIHRoZSBmaXJzdCBwb2ludCBhcyB0aGUgY2x1c3RlciBjZW50ZXJcblx0XHRcdFx0dGhpcy5fY0xhdExuZyA9IGNoaWxkLl9jTGF0TG5nIHx8IGNoaWxkLl9sYXRsbmc7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEFzc2lnbnMgaW1wb3NzaWJsZSBib3VuZGluZyB2YWx1ZXMgc28gdGhhdCB0aGUgbmV4dCBleHRlbmQgZW50aXJlbHkgZGV0ZXJtaW5lcyB0aGUgbmV3IGJvdW5kcy5cblx0XHQgKiBUaGlzIG1ldGhvZCBhdm9pZHMgaGF2aW5nIHRvIHRyYXNoIHRoZSBwcmV2aW91cyBMLkxhdExuZ0JvdW5kcyBvYmplY3QgYW5kIHRvIGNyZWF0ZSBhIG5ldyBvbmUsIHdoaWNoIGlzIG11Y2ggc2xvd2VyIGZvciB0aGlzIGNsYXNzLlxuXHRcdCAqIEFzIGxvbmcgYXMgdGhlIGJvdW5kcyBhcmUgbm90IGV4dGVuZGVkLCBtb3N0IG90aGVyIG1ldGhvZHMgd291bGQgcHJvYmFibHkgZmFpbCwgYXMgdGhleSB3b3VsZCB3aXRoIGJvdW5kcyBpbml0aWFsaXplZCBidXQgbm90IGV4dGVuZGVkLlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0X3Jlc2V0Qm91bmRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgYm91bmRzID0gdGhpcy5fYm91bmRzO1xuXG5cdFx0XHRpZiAoYm91bmRzLl9zb3V0aFdlc3QpIHtcblx0XHRcdFx0Ym91bmRzLl9zb3V0aFdlc3QubGF0ID0gSW5maW5pdHk7XG5cdFx0XHRcdGJvdW5kcy5fc291dGhXZXN0LmxuZyA9IEluZmluaXR5O1xuXHRcdFx0fVxuXHRcdFx0aWYgKGJvdW5kcy5fbm9ydGhFYXN0KSB7XG5cdFx0XHRcdGJvdW5kcy5fbm9ydGhFYXN0LmxhdCA9IC1JbmZpbml0eTtcblx0XHRcdFx0Ym91bmRzLl9ub3J0aEVhc3QubG5nID0gLUluZmluaXR5O1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRfcmVjYWxjdWxhdGVCb3VuZHM6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBtYXJrZXJzID0gdGhpcy5fbWFya2Vycyxcblx0XHRcdCAgICBjaGlsZENsdXN0ZXJzID0gdGhpcy5fY2hpbGRDbHVzdGVycyxcblx0XHRcdCAgICBsYXRTdW0gPSAwLFxuXHRcdFx0ICAgIGxuZ1N1bSA9IDAsXG5cdFx0XHQgICAgdG90YWxDb3VudCA9IHRoaXMuX2NoaWxkQ291bnQsXG5cdFx0XHQgICAgaSwgY2hpbGQsIGNoaWxkTGF0TG5nLCBjaGlsZENvdW50O1xuXG5cdFx0XHQvLyBDYXNlIHdoZXJlIGFsbCBtYXJrZXJzIGFyZSByZW1vdmVkIGZyb20gdGhlIG1hcCBhbmQgd2UgYXJlIGxlZnQgd2l0aCBqdXN0IGFuIGVtcHR5IF90b3BDbHVzdGVyTGV2ZWwuXG5cdFx0XHRpZiAodG90YWxDb3VudCA9PT0gMCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlc2V0IHJhdGhlciB0aGFuIGNyZWF0aW5nIGEgbmV3IG9iamVjdCwgZm9yIHBlcmZvcm1hbmNlLlxuXHRcdFx0dGhpcy5fcmVzZXRCb3VuZHMoKTtcblxuXHRcdFx0Ly8gQ2hpbGQgbWFya2Vycy5cblx0XHRcdGZvciAoaSA9IDA7IGkgPCBtYXJrZXJzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGNoaWxkTGF0TG5nID0gbWFya2Vyc1tpXS5fbGF0bG5nO1xuXG5cdFx0XHRcdHRoaXMuX2JvdW5kcy5leHRlbmQoY2hpbGRMYXRMbmcpO1xuXG5cdFx0XHRcdGxhdFN1bSArPSBjaGlsZExhdExuZy5sYXQ7XG5cdFx0XHRcdGxuZ1N1bSArPSBjaGlsZExhdExuZy5sbmc7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENoaWxkIGNsdXN0ZXJzLlxuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGNoaWxkQ2x1c3RlcnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0Y2hpbGQgPSBjaGlsZENsdXN0ZXJzW2ldO1xuXG5cdFx0XHRcdC8vIFJlLWNvbXB1dGUgY2hpbGQgYm91bmRzIGFuZCB3ZWlnaHRlZCBwb3NpdGlvbiBmaXJzdCBpZiBuZWNlc3NhcnkuXG5cdFx0XHRcdGlmIChjaGlsZC5fYm91bmRzTmVlZFVwZGF0ZSkge1xuXHRcdFx0XHRcdGNoaWxkLl9yZWNhbGN1bGF0ZUJvdW5kcygpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy5fYm91bmRzLmV4dGVuZChjaGlsZC5fYm91bmRzKTtcblxuXHRcdFx0XHRjaGlsZExhdExuZyA9IGNoaWxkLl93TGF0TG5nO1xuXHRcdFx0XHRjaGlsZENvdW50ID0gY2hpbGQuX2NoaWxkQ291bnQ7XG5cblx0XHRcdFx0bGF0U3VtICs9IGNoaWxkTGF0TG5nLmxhdCAqIGNoaWxkQ291bnQ7XG5cdFx0XHRcdGxuZ1N1bSArPSBjaGlsZExhdExuZy5sbmcgKiBjaGlsZENvdW50O1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9sYXRsbmcgPSB0aGlzLl93TGF0TG5nID0gbmV3IEwuTGF0TG5nKGxhdFN1bSAvIHRvdGFsQ291bnQsIGxuZ1N1bSAvIHRvdGFsQ291bnQpO1xuXG5cdFx0XHQvLyBSZXNldCBkaXJ0eSBmbGFnLlxuXHRcdFx0dGhpcy5fYm91bmRzTmVlZFVwZGF0ZSA9IGZhbHNlO1xuXHRcdH0sXG5cblx0XHQvL1NldCBvdXIgbWFya2VycyBwb3NpdGlvbiBhcyBnaXZlbiBhbmQgYWRkIGl0IHRvIHRoZSBtYXBcblx0XHRfYWRkVG9NYXA6IGZ1bmN0aW9uIChzdGFydFBvcykge1xuXHRcdFx0aWYgKHN0YXJ0UG9zKSB7XG5cdFx0XHRcdHRoaXMuX2JhY2t1cExhdGxuZyA9IHRoaXMuX2xhdGxuZztcblx0XHRcdFx0dGhpcy5zZXRMYXRMbmcoc3RhcnRQb3MpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fZ3JvdXAuX2ZlYXR1cmVHcm91cC5hZGRMYXllcih0aGlzKTtcblx0XHR9LFxuXG5cdFx0X3JlY3Vyc2l2ZWx5QW5pbWF0ZUNoaWxkcmVuSW46IGZ1bmN0aW9uIChib3VuZHMsIGNlbnRlciwgbWF4Wm9vbSkge1xuXHRcdFx0dGhpcy5fcmVjdXJzaXZlbHkoYm91bmRzLCB0aGlzLl9ncm91cC5fbWFwLmdldE1pblpvb20oKSwgbWF4Wm9vbSAtIDEsXG5cdFx0XHRcdGZ1bmN0aW9uIChjKSB7XG5cdFx0XHRcdFx0dmFyIG1hcmtlcnMgPSBjLl9tYXJrZXJzLFxuXHRcdFx0XHRcdFx0aSwgbTtcblx0XHRcdFx0XHRmb3IgKGkgPSBtYXJrZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRcdFx0XHRtID0gbWFya2Vyc1tpXTtcblxuXHRcdFx0XHRcdFx0Ly9Pbmx5IGRvIGl0IGlmIHRoZSBpY29uIGlzIHN0aWxsIG9uIHRoZSBtYXBcblx0XHRcdFx0XHRcdGlmIChtLl9pY29uKSB7XG5cdFx0XHRcdFx0XHRcdG0uX3NldFBvcyhjZW50ZXIpO1xuXHRcdFx0XHRcdFx0XHRtLmNsdXN0ZXJIaWRlKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRmdW5jdGlvbiAoYykge1xuXHRcdFx0XHRcdHZhciBjaGlsZENsdXN0ZXJzID0gYy5fY2hpbGRDbHVzdGVycyxcblx0XHRcdFx0XHRcdGosIGNtO1xuXHRcdFx0XHRcdGZvciAoaiA9IGNoaWxkQ2x1c3RlcnMubGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pIHtcblx0XHRcdFx0XHRcdGNtID0gY2hpbGRDbHVzdGVyc1tqXTtcblx0XHRcdFx0XHRcdGlmIChjbS5faWNvbikge1xuXHRcdFx0XHRcdFx0XHRjbS5fc2V0UG9zKGNlbnRlcik7XG5cdFx0XHRcdFx0XHRcdGNtLmNsdXN0ZXJIaWRlKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHQpO1xuXHRcdH0sXG5cblx0XHRfcmVjdXJzaXZlbHlBbmltYXRlQ2hpbGRyZW5JbkFuZEFkZFNlbGZUb01hcDogZnVuY3Rpb24gKGJvdW5kcywgbWFwTWluWm9vbSwgcHJldmlvdXNab29tTGV2ZWwsIG5ld1pvb21MZXZlbCkge1xuXHRcdFx0dGhpcy5fcmVjdXJzaXZlbHkoYm91bmRzLCBuZXdab29tTGV2ZWwsIG1hcE1pblpvb20sXG5cdFx0XHRcdGZ1bmN0aW9uIChjKSB7XG5cdFx0XHRcdFx0Yy5fcmVjdXJzaXZlbHlBbmltYXRlQ2hpbGRyZW5Jbihib3VuZHMsIGMuX2dyb3VwLl9tYXAubGF0TG5nVG9MYXllclBvaW50KGMuZ2V0TGF0TG5nKCkpLnJvdW5kKCksIHByZXZpb3VzWm9vbUxldmVsKTtcblxuXHRcdFx0XHRcdC8vVE9ETzogZGVwdGhUb0FuaW1hdGVJbiBhZmZlY3RzIF9pc1NpbmdsZVBhcmVudCwgaWYgdGhlcmUgaXMgYSBtdWx0aXpvb20gd2UgbWF5L21heSBub3QgYmUuXG5cdFx0XHRcdFx0Ly9BcyBhIGhhY2sgd2Ugb25seSBkbyBhIGFuaW1hdGlvbiBmcmVlIHpvb20gb24gYSBzaW5nbGUgbGV2ZWwgem9vbSwgaWYgc29tZW9uZSBkb2VzIG11bHRpcGxlIGxldmVscyB0aGVuIHdlIGFsd2F5cyBhbmltYXRlXG5cdFx0XHRcdFx0aWYgKGMuX2lzU2luZ2xlUGFyZW50KCkgJiYgcHJldmlvdXNab29tTGV2ZWwgLSAxID09PSBuZXdab29tTGV2ZWwpIHtcblx0XHRcdFx0XHRcdGMuY2x1c3RlclNob3coKTtcblx0XHRcdFx0XHRcdGMuX3JlY3Vyc2l2ZWx5UmVtb3ZlQ2hpbGRyZW5Gcm9tTWFwKGJvdW5kcywgbWFwTWluWm9vbSwgcHJldmlvdXNab29tTGV2ZWwpOyAvL0ltbWVkaWF0ZWx5IHJlbW92ZSBvdXIgY2hpbGRyZW4gYXMgd2UgYXJlIHJlcGxhY2luZyB0aGVtLiBUT0RPIHByZXZpb3VzQm91bmRzIG5vdCBib3VuZHNcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Yy5jbHVzdGVySGlkZSgpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGMuX2FkZFRvTWFwKCk7XG5cdFx0XHRcdH1cblx0XHRcdCk7XG5cdFx0fSxcblxuXHRcdF9yZWN1cnNpdmVseUJlY29tZVZpc2libGU6IGZ1bmN0aW9uIChib3VuZHMsIHpvb21MZXZlbCkge1xuXHRcdFx0dGhpcy5fcmVjdXJzaXZlbHkoYm91bmRzLCB0aGlzLl9ncm91cC5fbWFwLmdldE1pblpvb20oKSwgem9vbUxldmVsLCBudWxsLCBmdW5jdGlvbiAoYykge1xuXHRcdFx0XHRjLmNsdXN0ZXJTaG93KCk7XG5cdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0X3JlY3Vyc2l2ZWx5QWRkQ2hpbGRyZW5Ub01hcDogZnVuY3Rpb24gKHN0YXJ0UG9zLCB6b29tTGV2ZWwsIGJvdW5kcykge1xuXHRcdFx0dGhpcy5fcmVjdXJzaXZlbHkoYm91bmRzLCB0aGlzLl9ncm91cC5fbWFwLmdldE1pblpvb20oKSAtIDEsIHpvb21MZXZlbCxcblx0XHRcdFx0ZnVuY3Rpb24gKGMpIHtcblx0XHRcdFx0XHRpZiAoem9vbUxldmVsID09PSBjLl96b29tKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly9BZGQgb3VyIGNoaWxkIG1hcmtlcnMgYXQgc3RhcnRQb3MgKHNvIHRoZXkgY2FuIGJlIGFuaW1hdGVkIG91dClcblx0XHRcdFx0XHRmb3IgKHZhciBpID0gYy5fbWFya2Vycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0XHRcdFx0dmFyIG5tID0gYy5fbWFya2Vyc1tpXTtcblxuXHRcdFx0XHRcdFx0aWYgKCFib3VuZHMuY29udGFpbnMobm0uX2xhdGxuZykpIHtcblx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGlmIChzdGFydFBvcykge1xuXHRcdFx0XHRcdFx0XHRubS5fYmFja3VwTGF0bG5nID0gbm0uZ2V0TGF0TG5nKCk7XG5cblx0XHRcdFx0XHRcdFx0bm0uc2V0TGF0TG5nKHN0YXJ0UG9zKTtcblx0XHRcdFx0XHRcdFx0aWYgKG5tLmNsdXN0ZXJIaWRlKSB7XG5cdFx0XHRcdFx0XHRcdFx0bm0uY2x1c3RlckhpZGUoKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRjLl9ncm91cC5fZmVhdHVyZUdyb3VwLmFkZExheWVyKG5tKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGZ1bmN0aW9uIChjKSB7XG5cdFx0XHRcdFx0Yy5fYWRkVG9NYXAoc3RhcnRQb3MpO1xuXHRcdFx0XHR9XG5cdFx0XHQpO1xuXHRcdH0sXG5cblx0XHRfcmVjdXJzaXZlbHlSZXN0b3JlQ2hpbGRQb3NpdGlvbnM6IGZ1bmN0aW9uICh6b29tTGV2ZWwpIHtcblx0XHRcdC8vRml4IHBvc2l0aW9ucyBvZiBjaGlsZCBtYXJrZXJzXG5cdFx0XHRmb3IgKHZhciBpID0gdGhpcy5fbWFya2Vycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0XHR2YXIgbm0gPSB0aGlzLl9tYXJrZXJzW2ldO1xuXHRcdFx0XHRpZiAobm0uX2JhY2t1cExhdGxuZykge1xuXHRcdFx0XHRcdG5tLnNldExhdExuZyhubS5fYmFja3VwTGF0bG5nKTtcblx0XHRcdFx0XHRkZWxldGUgbm0uX2JhY2t1cExhdGxuZztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoem9vbUxldmVsIC0gMSA9PT0gdGhpcy5fem9vbSkge1xuXHRcdFx0XHQvL1JlcG9zaXRpb24gY2hpbGQgY2x1c3RlcnNcblx0XHRcdFx0Zm9yICh2YXIgaiA9IHRoaXMuX2NoaWxkQ2x1c3RlcnMubGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pIHtcblx0XHRcdFx0XHR0aGlzLl9jaGlsZENsdXN0ZXJzW2pdLl9yZXN0b3JlUG9zaXRpb24oKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Zm9yICh2YXIgayA9IHRoaXMuX2NoaWxkQ2x1c3RlcnMubGVuZ3RoIC0gMTsgayA+PSAwOyBrLS0pIHtcblx0XHRcdFx0XHR0aGlzLl9jaGlsZENsdXN0ZXJzW2tdLl9yZWN1cnNpdmVseVJlc3RvcmVDaGlsZFBvc2l0aW9ucyh6b29tTGV2ZWwpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdF9yZXN0b3JlUG9zaXRpb246IGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmICh0aGlzLl9iYWNrdXBMYXRsbmcpIHtcblx0XHRcdFx0dGhpcy5zZXRMYXRMbmcodGhpcy5fYmFja3VwTGF0bG5nKTtcblx0XHRcdFx0ZGVsZXRlIHRoaXMuX2JhY2t1cExhdGxuZztcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Ly9leGNlcHRCb3VuZHM6IElmIHNldCwgZG9uJ3QgcmVtb3ZlIGFueSBtYXJrZXJzL2NsdXN0ZXJzIGluIGl0XG5cdFx0X3JlY3Vyc2l2ZWx5UmVtb3ZlQ2hpbGRyZW5Gcm9tTWFwOiBmdW5jdGlvbiAocHJldmlvdXNCb3VuZHMsIG1hcE1pblpvb20sIHpvb21MZXZlbCwgZXhjZXB0Qm91bmRzKSB7XG5cdFx0XHR2YXIgbSwgaTtcblx0XHRcdHRoaXMuX3JlY3Vyc2l2ZWx5KHByZXZpb3VzQm91bmRzLCBtYXBNaW5ab29tIC0gMSwgem9vbUxldmVsIC0gMSxcblx0XHRcdFx0ZnVuY3Rpb24gKGMpIHtcblx0XHRcdFx0XHQvL1JlbW92ZSBtYXJrZXJzIGF0IGV2ZXJ5IGxldmVsXG5cdFx0XHRcdFx0Zm9yIChpID0gYy5fbWFya2Vycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0XHRcdFx0bSA9IGMuX21hcmtlcnNbaV07XG5cdFx0XHRcdFx0XHRpZiAoIWV4Y2VwdEJvdW5kcyB8fCAhZXhjZXB0Qm91bmRzLmNvbnRhaW5zKG0uX2xhdGxuZykpIHtcblx0XHRcdFx0XHRcdFx0Yy5fZ3JvdXAuX2ZlYXR1cmVHcm91cC5yZW1vdmVMYXllcihtKTtcblx0XHRcdFx0XHRcdFx0aWYgKG0uY2x1c3RlclNob3cpIHtcblx0XHRcdFx0XHRcdFx0XHRtLmNsdXN0ZXJTaG93KCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGZ1bmN0aW9uIChjKSB7XG5cdFx0XHRcdFx0Ly9SZW1vdmUgY2hpbGQgY2x1c3RlcnMgYXQganVzdCB0aGUgYm90dG9tIGxldmVsXG5cdFx0XHRcdFx0Zm9yIChpID0gYy5fY2hpbGRDbHVzdGVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0XHRcdFx0bSA9IGMuX2NoaWxkQ2x1c3RlcnNbaV07XG5cdFx0XHRcdFx0XHRpZiAoIWV4Y2VwdEJvdW5kcyB8fCAhZXhjZXB0Qm91bmRzLmNvbnRhaW5zKG0uX2xhdGxuZykpIHtcblx0XHRcdFx0XHRcdFx0Yy5fZ3JvdXAuX2ZlYXR1cmVHcm91cC5yZW1vdmVMYXllcihtKTtcblx0XHRcdFx0XHRcdFx0aWYgKG0uY2x1c3RlclNob3cpIHtcblx0XHRcdFx0XHRcdFx0XHRtLmNsdXN0ZXJTaG93KCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdCk7XG5cdFx0fSxcblxuXHRcdC8vUnVuIHRoZSBnaXZlbiBmdW5jdGlvbnMgcmVjdXJzaXZlbHkgdG8gdGhpcyBhbmQgY2hpbGQgY2x1c3RlcnNcblx0XHQvLyBib3VuZHNUb0FwcGx5VG86IGEgTC5MYXRMbmdCb3VuZHMgcmVwcmVzZW50aW5nIHRoZSBib3VuZHMgb2Ygd2hhdCBjbHVzdGVycyB0byByZWN1cnNlIGluIHRvXG5cdFx0Ly8gem9vbUxldmVsVG9TdGFydDogem9vbSBsZXZlbCB0byBzdGFydCBydW5uaW5nIGZ1bmN0aW9ucyAoaW5jbHVzaXZlKVxuXHRcdC8vIHpvb21MZXZlbFRvU3RvcDogem9vbSBsZXZlbCB0byBzdG9wIHJ1bm5pbmcgZnVuY3Rpb25zIChpbmNsdXNpdmUpXG5cdFx0Ly8gcnVuQXRFdmVyeUxldmVsOiBmdW5jdGlvbiB0aGF0IHRha2VzIGFuIEwuTWFya2VyQ2x1c3RlciBhcyBhbiBhcmd1bWVudCB0aGF0IHNob3VsZCBiZSBhcHBsaWVkIG9uIGV2ZXJ5IGxldmVsXG5cdFx0Ly8gcnVuQXRCb3R0b21MZXZlbDogZnVuY3Rpb24gdGhhdCB0YWtlcyBhbiBMLk1hcmtlckNsdXN0ZXIgYXMgYW4gYXJndW1lbnQgdGhhdCBzaG91bGQgYmUgYXBwbGllZCBhdCBvbmx5IHRoZSBib3R0b20gbGV2ZWxcblx0XHRfcmVjdXJzaXZlbHk6IGZ1bmN0aW9uIChib3VuZHNUb0FwcGx5VG8sIHpvb21MZXZlbFRvU3RhcnQsIHpvb21MZXZlbFRvU3RvcCwgcnVuQXRFdmVyeUxldmVsLCBydW5BdEJvdHRvbUxldmVsKSB7XG5cdFx0XHR2YXIgY2hpbGRDbHVzdGVycyA9IHRoaXMuX2NoaWxkQ2x1c3RlcnMsXG5cdFx0XHQgICAgem9vbSA9IHRoaXMuX3pvb20sXG5cdFx0XHQgICAgaSwgYztcblxuXHRcdFx0aWYgKHpvb21MZXZlbFRvU3RhcnQgPD0gem9vbSkge1xuXHRcdFx0XHRpZiAocnVuQXRFdmVyeUxldmVsKSB7XG5cdFx0XHRcdFx0cnVuQXRFdmVyeUxldmVsKHRoaXMpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChydW5BdEJvdHRvbUxldmVsICYmIHpvb20gPT09IHpvb21MZXZlbFRvU3RvcCkge1xuXHRcdFx0XHRcdHJ1bkF0Qm90dG9tTGV2ZWwodGhpcyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKHpvb20gPCB6b29tTGV2ZWxUb1N0YXJ0IHx8IHpvb20gPCB6b29tTGV2ZWxUb1N0b3ApIHtcblx0XHRcdFx0Zm9yIChpID0gY2hpbGRDbHVzdGVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0XHRcdGMgPSBjaGlsZENsdXN0ZXJzW2ldO1xuXHRcdFx0XHRcdGlmIChjLl9ib3VuZHNOZWVkVXBkYXRlKSB7XG5cdFx0XHRcdFx0XHRjLl9yZWNhbGN1bGF0ZUJvdW5kcygpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoYm91bmRzVG9BcHBseVRvLmludGVyc2VjdHMoYy5fYm91bmRzKSkge1xuXHRcdFx0XHRcdFx0Yy5fcmVjdXJzaXZlbHkoYm91bmRzVG9BcHBseVRvLCB6b29tTGV2ZWxUb1N0YXJ0LCB6b29tTGV2ZWxUb1N0b3AsIHJ1bkF0RXZlcnlMZXZlbCwgcnVuQXRCb3R0b21MZXZlbCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8vUmV0dXJucyB0cnVlIGlmIHdlIGFyZSB0aGUgcGFyZW50IG9mIG9ubHkgb25lIGNsdXN0ZXIgYW5kIHRoYXQgY2x1c3RlciBpcyB0aGUgc2FtZSBhcyB1c1xuXHRcdF9pc1NpbmdsZVBhcmVudDogZnVuY3Rpb24gKCkge1xuXHRcdFx0Ly9Eb24ndCBuZWVkIHRvIGNoZWNrIHRoaXMuX21hcmtlcnMgYXMgdGhlIHJlc3Qgd29uJ3Qgd29yayBpZiB0aGVyZSBhcmUgYW55XG5cdFx0XHRyZXR1cm4gdGhpcy5fY2hpbGRDbHVzdGVycy5sZW5ndGggPiAwICYmIHRoaXMuX2NoaWxkQ2x1c3RlcnNbMF0uX2NoaWxkQ291bnQgPT09IHRoaXMuX2NoaWxkQ291bnQ7XG5cdFx0fVxuXHR9KTtcblxuXHQvKlxuXHQqIEV4dGVuZHMgTC5NYXJrZXIgdG8gaW5jbHVkZSB0d28gZXh0cmEgbWV0aG9kczogY2x1c3RlckhpZGUgYW5kIGNsdXN0ZXJTaG93LlxuXHQqIFxuXHQqIFRoZXkgd29yayBhcyBzZXRPcGFjaXR5KDApIGFuZCBzZXRPcGFjaXR5KDEpIHJlc3BlY3RpdmVseSwgYnV0XG5cdCogZG9uJ3Qgb3ZlcndyaXRlIHRoZSBvcHRpb25zLm9wYWNpdHlcblx0KiBcblx0Ki9cblxuXHRMLk1hcmtlci5pbmNsdWRlKHtcblx0XHRjbHVzdGVySGlkZTogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIGJhY2t1cCA9IHRoaXMub3B0aW9ucy5vcGFjaXR5O1xuXHRcdFx0dGhpcy5zZXRPcGFjaXR5KDApO1xuXHRcdFx0dGhpcy5vcHRpb25zLm9wYWNpdHkgPSBiYWNrdXA7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9LFxuXHRcdFxuXHRcdGNsdXN0ZXJTaG93OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5zZXRPcGFjaXR5KHRoaXMub3B0aW9ucy5vcGFjaXR5KTtcblx0XHR9XG5cdH0pO1xuXG5cdEwuRGlzdGFuY2VHcmlkID0gZnVuY3Rpb24gKGNlbGxTaXplKSB7XG5cdFx0dGhpcy5fY2VsbFNpemUgPSBjZWxsU2l6ZTtcblx0XHR0aGlzLl9zcUNlbGxTaXplID0gY2VsbFNpemUgKiBjZWxsU2l6ZTtcblx0XHR0aGlzLl9ncmlkID0ge307XG5cdFx0dGhpcy5fb2JqZWN0UG9pbnQgPSB7IH07XG5cdH07XG5cblx0TC5EaXN0YW5jZUdyaWQucHJvdG90eXBlID0ge1xuXG5cdFx0YWRkT2JqZWN0OiBmdW5jdGlvbiAob2JqLCBwb2ludCkge1xuXHRcdFx0dmFyIHggPSB0aGlzLl9nZXRDb29yZChwb2ludC54KSxcblx0XHRcdCAgICB5ID0gdGhpcy5fZ2V0Q29vcmQocG9pbnQueSksXG5cdFx0XHQgICAgZ3JpZCA9IHRoaXMuX2dyaWQsXG5cdFx0XHQgICAgcm93ID0gZ3JpZFt5XSA9IGdyaWRbeV0gfHwge30sXG5cdFx0XHQgICAgY2VsbCA9IHJvd1t4XSA9IHJvd1t4XSB8fCBbXSxcblx0XHRcdCAgICBzdGFtcCA9IEwuVXRpbC5zdGFtcChvYmopO1xuXG5cdFx0XHR0aGlzLl9vYmplY3RQb2ludFtzdGFtcF0gPSBwb2ludDtcblxuXHRcdFx0Y2VsbC5wdXNoKG9iaik7XG5cdFx0fSxcblxuXHRcdHVwZGF0ZU9iamVjdDogZnVuY3Rpb24gKG9iaiwgcG9pbnQpIHtcblx0XHRcdHRoaXMucmVtb3ZlT2JqZWN0KG9iaik7XG5cdFx0XHR0aGlzLmFkZE9iamVjdChvYmosIHBvaW50KTtcblx0XHR9LFxuXG5cdFx0Ly9SZXR1cm5zIHRydWUgaWYgdGhlIG9iamVjdCB3YXMgZm91bmRcblx0XHRyZW1vdmVPYmplY3Q6IGZ1bmN0aW9uIChvYmosIHBvaW50KSB7XG5cdFx0XHR2YXIgeCA9IHRoaXMuX2dldENvb3JkKHBvaW50LngpLFxuXHRcdFx0ICAgIHkgPSB0aGlzLl9nZXRDb29yZChwb2ludC55KSxcblx0XHRcdCAgICBncmlkID0gdGhpcy5fZ3JpZCxcblx0XHRcdCAgICByb3cgPSBncmlkW3ldID0gZ3JpZFt5XSB8fCB7fSxcblx0XHRcdCAgICBjZWxsID0gcm93W3hdID0gcm93W3hdIHx8IFtdLFxuXHRcdFx0ICAgIGksIGxlbjtcblxuXHRcdFx0ZGVsZXRlIHRoaXMuX29iamVjdFBvaW50W0wuVXRpbC5zdGFtcChvYmopXTtcblxuXHRcdFx0Zm9yIChpID0gMCwgbGVuID0gY2VsbC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRpZiAoY2VsbFtpXSA9PT0gb2JqKSB7XG5cblx0XHRcdFx0XHRjZWxsLnNwbGljZShpLCAxKTtcblxuXHRcdFx0XHRcdGlmIChsZW4gPT09IDEpIHtcblx0XHRcdFx0XHRcdGRlbGV0ZSByb3dbeF07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdH0sXG5cblx0XHRlYWNoT2JqZWN0OiBmdW5jdGlvbiAoZm4sIGNvbnRleHQpIHtcblx0XHRcdHZhciBpLCBqLCBrLCBsZW4sIHJvdywgY2VsbCwgcmVtb3ZlZCxcblx0XHRcdCAgICBncmlkID0gdGhpcy5fZ3JpZDtcblxuXHRcdFx0Zm9yIChpIGluIGdyaWQpIHtcblx0XHRcdFx0cm93ID0gZ3JpZFtpXTtcblxuXHRcdFx0XHRmb3IgKGogaW4gcm93KSB7XG5cdFx0XHRcdFx0Y2VsbCA9IHJvd1tqXTtcblxuXHRcdFx0XHRcdGZvciAoayA9IDAsIGxlbiA9IGNlbGwubGVuZ3RoOyBrIDwgbGVuOyBrKyspIHtcblx0XHRcdFx0XHRcdHJlbW92ZWQgPSBmbi5jYWxsKGNvbnRleHQsIGNlbGxba10pO1xuXHRcdFx0XHRcdFx0aWYgKHJlbW92ZWQpIHtcblx0XHRcdFx0XHRcdFx0ay0tO1xuXHRcdFx0XHRcdFx0XHRsZW4tLTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Z2V0TmVhck9iamVjdDogZnVuY3Rpb24gKHBvaW50KSB7XG5cdFx0XHR2YXIgeCA9IHRoaXMuX2dldENvb3JkKHBvaW50LngpLFxuXHRcdFx0ICAgIHkgPSB0aGlzLl9nZXRDb29yZChwb2ludC55KSxcblx0XHRcdCAgICBpLCBqLCBrLCByb3csIGNlbGwsIGxlbiwgb2JqLCBkaXN0LFxuXHRcdFx0ICAgIG9iamVjdFBvaW50ID0gdGhpcy5fb2JqZWN0UG9pbnQsXG5cdFx0XHQgICAgY2xvc2VzdERpc3RTcSA9IHRoaXMuX3NxQ2VsbFNpemUsXG5cdFx0XHQgICAgY2xvc2VzdCA9IG51bGw7XG5cblx0XHRcdGZvciAoaSA9IHkgLSAxOyBpIDw9IHkgKyAxOyBpKyspIHtcblx0XHRcdFx0cm93ID0gdGhpcy5fZ3JpZFtpXTtcblx0XHRcdFx0aWYgKHJvdykge1xuXG5cdFx0XHRcdFx0Zm9yIChqID0geCAtIDE7IGogPD0geCArIDE7IGorKykge1xuXHRcdFx0XHRcdFx0Y2VsbCA9IHJvd1tqXTtcblx0XHRcdFx0XHRcdGlmIChjZWxsKSB7XG5cblx0XHRcdFx0XHRcdFx0Zm9yIChrID0gMCwgbGVuID0gY2VsbC5sZW5ndGg7IGsgPCBsZW47IGsrKykge1xuXHRcdFx0XHRcdFx0XHRcdG9iaiA9IGNlbGxba107XG5cdFx0XHRcdFx0XHRcdFx0ZGlzdCA9IHRoaXMuX3NxRGlzdChvYmplY3RQb2ludFtMLlV0aWwuc3RhbXAob2JqKV0sIHBvaW50KTtcblx0XHRcdFx0XHRcdFx0XHRpZiAoZGlzdCA8IGNsb3Nlc3REaXN0U3EgfHxcblx0XHRcdFx0XHRcdFx0XHRcdGRpc3QgPD0gY2xvc2VzdERpc3RTcSAmJiBjbG9zZXN0ID09PSBudWxsKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjbG9zZXN0RGlzdFNxID0gZGlzdDtcblx0XHRcdFx0XHRcdFx0XHRcdGNsb3Nlc3QgPSBvYmo7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gY2xvc2VzdDtcblx0XHR9LFxuXG5cdFx0X2dldENvb3JkOiBmdW5jdGlvbiAoeCkge1xuXHRcdFx0dmFyIGNvb3JkID0gTWF0aC5mbG9vcih4IC8gdGhpcy5fY2VsbFNpemUpO1xuXHRcdFx0cmV0dXJuIGlzRmluaXRlKGNvb3JkKSA/IGNvb3JkIDogeDtcblx0XHR9LFxuXG5cdFx0X3NxRGlzdDogZnVuY3Rpb24gKHAsIHAyKSB7XG5cdFx0XHR2YXIgZHggPSBwMi54IC0gcC54LFxuXHRcdFx0ICAgIGR5ID0gcDIueSAtIHAueTtcblx0XHRcdHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcblx0XHR9XG5cdH07XG5cblx0LyogQ29weXJpZ2h0IChjKSAyMDEyIHRoZSBhdXRob3JzIGxpc3RlZCBhdCB0aGUgZm9sbG93aW5nIFVSTCwgYW5kL29yXG5cdHRoZSBhdXRob3JzIG9mIHJlZmVyZW5jZWQgYXJ0aWNsZXMgb3IgaW5jb3Jwb3JhdGVkIGV4dGVybmFsIGNvZGU6XG5cdGh0dHA6Ly9lbi5saXRlcmF0ZXByb2dyYW1zLm9yZy9RdWlja2h1bGxfKEphdmFzY3JpcHQpP2FjdGlvbj1oaXN0b3J5Jm9mZnNldD0yMDEyMDQxMDE3NTI1NlxuXG5cdFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZ1xuXHRhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcblx0XCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG5cdHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcblx0ZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvXG5cdHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0b1xuXHR0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblx0VGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcblx0aW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblx0VEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcblx0RVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG5cdE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC5cblx0SU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTllcblx0Q0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCxcblx0VE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEVcblx0U09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cblx0UmV0cmlldmVkIGZyb206IGh0dHA6Ly9lbi5saXRlcmF0ZXByb2dyYW1zLm9yZy9RdWlja2h1bGxfKEphdmFzY3JpcHQpP29sZGlkPTE4NDM0XG5cdCovXG5cblx0KGZ1bmN0aW9uICgpIHtcblx0XHRMLlF1aWNrSHVsbCA9IHtcblxuXHRcdFx0Lypcblx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBjcHQgYSBwb2ludCB0byBiZSBtZWFzdXJlZCBmcm9tIHRoZSBiYXNlbGluZVxuXHRcdFx0ICogQHBhcmFtIHtBcnJheX0gYmwgdGhlIGJhc2VsaW5lLCBhcyByZXByZXNlbnRlZCBieSBhIHR3by1lbGVtZW50XG5cdFx0XHQgKiAgIGFycmF5IG9mIGxhdGxuZyBvYmplY3RzLlxuXHRcdFx0ICogQHJldHVybnMge051bWJlcn0gYW4gYXBwcm94aW1hdGUgZGlzdGFuY2UgbWVhc3VyZVxuXHRcdFx0ICovXG5cdFx0XHRnZXREaXN0YW50OiBmdW5jdGlvbiAoY3B0LCBibCkge1xuXHRcdFx0XHR2YXIgdlkgPSBibFsxXS5sYXQgLSBibFswXS5sYXQsXG5cdFx0XHRcdFx0dlggPSBibFswXS5sbmcgLSBibFsxXS5sbmc7XG5cdFx0XHRcdHJldHVybiAodlggKiAoY3B0LmxhdCAtIGJsWzBdLmxhdCkgKyB2WSAqIChjcHQubG5nIC0gYmxbMF0ubG5nKSk7XG5cdFx0XHR9LFxuXG5cdFx0XHQvKlxuXHRcdFx0ICogQHBhcmFtIHtBcnJheX0gYmFzZUxpbmUgYSB0d28tZWxlbWVudCBhcnJheSBvZiBsYXRsbmcgb2JqZWN0c1xuXHRcdFx0ICogICByZXByZXNlbnRpbmcgdGhlIGJhc2VsaW5lIHRvIHByb2plY3QgZnJvbVxuXHRcdFx0ICogQHBhcmFtIHtBcnJheX0gbGF0TG5ncyBhbiBhcnJheSBvZiBsYXRsbmcgb2JqZWN0c1xuXHRcdFx0ICogQHJldHVybnMge09iamVjdH0gdGhlIG1heGltdW0gcG9pbnQgYW5kIGFsbCBuZXcgcG9pbnRzIHRvIHN0YXlcblx0XHRcdCAqICAgaW4gY29uc2lkZXJhdGlvbiBmb3IgdGhlIGh1bGwuXG5cdFx0XHQgKi9cblx0XHRcdGZpbmRNb3N0RGlzdGFudFBvaW50RnJvbUJhc2VMaW5lOiBmdW5jdGlvbiAoYmFzZUxpbmUsIGxhdExuZ3MpIHtcblx0XHRcdFx0dmFyIG1heEQgPSAwLFxuXHRcdFx0XHRcdG1heFB0ID0gbnVsbCxcblx0XHRcdFx0XHRuZXdQb2ludHMgPSBbXSxcblx0XHRcdFx0XHRpLCBwdCwgZDtcblxuXHRcdFx0XHRmb3IgKGkgPSBsYXRMbmdzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRcdFx0cHQgPSBsYXRMbmdzW2ldO1xuXHRcdFx0XHRcdGQgPSB0aGlzLmdldERpc3RhbnQocHQsIGJhc2VMaW5lKTtcblxuXHRcdFx0XHRcdGlmIChkID4gMCkge1xuXHRcdFx0XHRcdFx0bmV3UG9pbnRzLnB1c2gocHQpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoZCA+IG1heEQpIHtcblx0XHRcdFx0XHRcdG1heEQgPSBkO1xuXHRcdFx0XHRcdFx0bWF4UHQgPSBwdDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4geyBtYXhQb2ludDogbWF4UHQsIG5ld1BvaW50czogbmV3UG9pbnRzIH07XG5cdFx0XHR9LFxuXG5cblx0XHRcdC8qXG5cdFx0XHQgKiBHaXZlbiBhIGJhc2VsaW5lLCBjb21wdXRlIHRoZSBjb252ZXggaHVsbCBvZiBsYXRMbmdzIGFzIGFuIGFycmF5XG5cdFx0XHQgKiBvZiBsYXRMbmdzLlxuXHRcdFx0ICpcblx0XHRcdCAqIEBwYXJhbSB7QXJyYXl9IGxhdExuZ3Ncblx0XHRcdCAqIEByZXR1cm5zIHtBcnJheX1cblx0XHRcdCAqL1xuXHRcdFx0YnVpbGRDb252ZXhIdWxsOiBmdW5jdGlvbiAoYmFzZUxpbmUsIGxhdExuZ3MpIHtcblx0XHRcdFx0dmFyIGNvbnZleEh1bGxCYXNlTGluZXMgPSBbXSxcblx0XHRcdFx0XHR0ID0gdGhpcy5maW5kTW9zdERpc3RhbnRQb2ludEZyb21CYXNlTGluZShiYXNlTGluZSwgbGF0TG5ncyk7XG5cblx0XHRcdFx0aWYgKHQubWF4UG9pbnQpIHsgLy8gaWYgdGhlcmUgaXMgc3RpbGwgYSBwb2ludCBcIm91dHNpZGVcIiB0aGUgYmFzZSBsaW5lXG5cdFx0XHRcdFx0Y29udmV4SHVsbEJhc2VMaW5lcyA9XG5cdFx0XHRcdFx0XHRjb252ZXhIdWxsQmFzZUxpbmVzLmNvbmNhdChcblx0XHRcdFx0XHRcdFx0dGhpcy5idWlsZENvbnZleEh1bGwoW2Jhc2VMaW5lWzBdLCB0Lm1heFBvaW50XSwgdC5uZXdQb2ludHMpXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdGNvbnZleEh1bGxCYXNlTGluZXMgPVxuXHRcdFx0XHRcdFx0Y29udmV4SHVsbEJhc2VMaW5lcy5jb25jYXQoXG5cdFx0XHRcdFx0XHRcdHRoaXMuYnVpbGRDb252ZXhIdWxsKFt0Lm1heFBvaW50LCBiYXNlTGluZVsxXV0sIHQubmV3UG9pbnRzKVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRyZXR1cm4gY29udmV4SHVsbEJhc2VMaW5lcztcblx0XHRcdFx0fSBlbHNlIHsgIC8vIGlmIHRoZXJlIGlzIG5vIG1vcmUgcG9pbnQgXCJvdXRzaWRlXCIgdGhlIGJhc2UgbGluZSwgdGhlIGN1cnJlbnQgYmFzZSBsaW5lIGlzIHBhcnQgb2YgdGhlIGNvbnZleCBodWxsXG5cdFx0XHRcdFx0cmV0dXJuIFtiYXNlTGluZVswXV07XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdC8qXG5cdFx0XHQgKiBHaXZlbiBhbiBhcnJheSBvZiBsYXRsbmdzLCBjb21wdXRlIGEgY29udmV4IGh1bGwgYXMgYW4gYXJyYXlcblx0XHRcdCAqIG9mIGxhdGxuZ3Ncblx0XHRcdCAqXG5cdFx0XHQgKiBAcGFyYW0ge0FycmF5fSBsYXRMbmdzXG5cdFx0XHQgKiBAcmV0dXJucyB7QXJyYXl9XG5cdFx0XHQgKi9cblx0XHRcdGdldENvbnZleEh1bGw6IGZ1bmN0aW9uIChsYXRMbmdzKSB7XG5cdFx0XHRcdC8vIGZpbmQgZmlyc3QgYmFzZWxpbmVcblx0XHRcdFx0dmFyIG1heExhdCA9IGZhbHNlLCBtaW5MYXQgPSBmYWxzZSxcblx0XHRcdFx0XHRtYXhMbmcgPSBmYWxzZSwgbWluTG5nID0gZmFsc2UsXG5cdFx0XHRcdFx0bWF4TGF0UHQgPSBudWxsLCBtaW5MYXRQdCA9IG51bGwsXG5cdFx0XHRcdFx0bWF4TG5nUHQgPSBudWxsLCBtaW5MbmdQdCA9IG51bGwsXG5cdFx0XHRcdFx0bWF4UHQgPSBudWxsLCBtaW5QdCA9IG51bGwsXG5cdFx0XHRcdFx0aTtcblxuXHRcdFx0XHRmb3IgKGkgPSBsYXRMbmdzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRcdFx0dmFyIHB0ID0gbGF0TG5nc1tpXTtcblx0XHRcdFx0XHRpZiAobWF4TGF0ID09PSBmYWxzZSB8fCBwdC5sYXQgPiBtYXhMYXQpIHtcblx0XHRcdFx0XHRcdG1heExhdFB0ID0gcHQ7XG5cdFx0XHRcdFx0XHRtYXhMYXQgPSBwdC5sYXQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChtaW5MYXQgPT09IGZhbHNlIHx8IHB0LmxhdCA8IG1pbkxhdCkge1xuXHRcdFx0XHRcdFx0bWluTGF0UHQgPSBwdDtcblx0XHRcdFx0XHRcdG1pbkxhdCA9IHB0LmxhdDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKG1heExuZyA9PT0gZmFsc2UgfHwgcHQubG5nID4gbWF4TG5nKSB7XG5cdFx0XHRcdFx0XHRtYXhMbmdQdCA9IHB0O1xuXHRcdFx0XHRcdFx0bWF4TG5nID0gcHQubG5nO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAobWluTG5nID09PSBmYWxzZSB8fCBwdC5sbmcgPCBtaW5MbmcpIHtcblx0XHRcdFx0XHRcdG1pbkxuZ1B0ID0gcHQ7XG5cdFx0XHRcdFx0XHRtaW5MbmcgPSBwdC5sbmc7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAobWluTGF0ICE9PSBtYXhMYXQpIHtcblx0XHRcdFx0XHRtaW5QdCA9IG1pbkxhdFB0O1xuXHRcdFx0XHRcdG1heFB0ID0gbWF4TGF0UHQ7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bWluUHQgPSBtaW5MbmdQdDtcblx0XHRcdFx0XHRtYXhQdCA9IG1heExuZ1B0O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIGNoID0gW10uY29uY2F0KHRoaXMuYnVpbGRDb252ZXhIdWxsKFttaW5QdCwgbWF4UHRdLCBsYXRMbmdzKSxcblx0XHRcdFx0XHRcdFx0XHRcdHRoaXMuYnVpbGRDb252ZXhIdWxsKFttYXhQdCwgbWluUHRdLCBsYXRMbmdzKSk7XG5cdFx0XHRcdHJldHVybiBjaDtcblx0XHRcdH1cblx0XHR9O1xuXHR9KCkpO1xuXG5cdEwuTWFya2VyQ2x1c3Rlci5pbmNsdWRlKHtcblx0XHRnZXRDb252ZXhIdWxsOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgY2hpbGRNYXJrZXJzID0gdGhpcy5nZXRBbGxDaGlsZE1hcmtlcnMoKSxcblx0XHRcdFx0cG9pbnRzID0gW10sXG5cdFx0XHRcdHAsIGk7XG5cblx0XHRcdGZvciAoaSA9IGNoaWxkTWFya2Vycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0XHRwID0gY2hpbGRNYXJrZXJzW2ldLmdldExhdExuZygpO1xuXHRcdFx0XHRwb2ludHMucHVzaChwKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIEwuUXVpY2tIdWxsLmdldENvbnZleEh1bGwocG9pbnRzKTtcblx0XHR9XG5cdH0pO1xuXG5cdC8vVGhpcyBjb2RlIGlzIDEwMCUgYmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL2phd2ovT3ZlcmxhcHBpbmdNYXJrZXJTcGlkZXJmaWVyLUxlYWZsZXRcblx0Ly9IdWdlIHRoYW5rcyB0byBqYXdqIGZvciBpbXBsZW1lbnRpbmcgaXQgZmlyc3QgdG8gbWFrZSBteSBqb2IgZWFzeSA6LSlcblxuXHRMLk1hcmtlckNsdXN0ZXIuaW5jbHVkZSh7XG5cblx0XHRfMlBJOiBNYXRoLlBJICogMixcblx0XHRfY2lyY2xlRm9vdFNlcGFyYXRpb246IDI1LCAvL3JlbGF0ZWQgdG8gY2lyY3VtZmVyZW5jZSBvZiBjaXJjbGVcblx0XHRfY2lyY2xlU3RhcnRBbmdsZTogMCxcblxuXHRcdF9zcGlyYWxGb290U2VwYXJhdGlvbjogIDI4LCAvL3JlbGF0ZWQgdG8gc2l6ZSBvZiBzcGlyYWwgKGV4cGVyaW1lbnQhKVxuXHRcdF9zcGlyYWxMZW5ndGhTdGFydDogMTEsXG5cdFx0X3NwaXJhbExlbmd0aEZhY3RvcjogNSxcblxuXHRcdF9jaXJjbGVTcGlyYWxTd2l0Y2hvdmVyOiA5LCAvL3Nob3cgc3BpcmFsIGluc3RlYWQgb2YgY2lyY2xlIGZyb20gdGhpcyBtYXJrZXIgY291bnQgdXB3YXJkcy5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIDAgLT4gYWx3YXlzIHNwaXJhbDsgSW5maW5pdHkgLT4gYWx3YXlzIGNpcmNsZVxuXG5cdFx0c3BpZGVyZnk6IGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmICh0aGlzLl9ncm91cC5fc3BpZGVyZmllZCA9PT0gdGhpcyB8fCB0aGlzLl9ncm91cC5faW5ab29tQW5pbWF0aW9uKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0dmFyIGNoaWxkTWFya2VycyA9IHRoaXMuZ2V0QWxsQ2hpbGRNYXJrZXJzKG51bGwsIHRydWUpLFxuXHRcdFx0XHRncm91cCA9IHRoaXMuX2dyb3VwLFxuXHRcdFx0XHRtYXAgPSBncm91cC5fbWFwLFxuXHRcdFx0XHRjZW50ZXIgPSBtYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX2xhdGxuZyksXG5cdFx0XHRcdHBvc2l0aW9ucztcblxuXHRcdFx0dGhpcy5fZ3JvdXAuX3Vuc3BpZGVyZnkoKTtcblx0XHRcdHRoaXMuX2dyb3VwLl9zcGlkZXJmaWVkID0gdGhpcztcblxuXHRcdFx0Ly9UT0RPIE1heWJlOiBjaGlsZE1hcmtlcnMgb3JkZXIgYnkgZGlzdGFuY2UgdG8gY2VudGVyXG5cblx0XHRcdGlmICh0aGlzLl9ncm91cC5vcHRpb25zLnNwaWRlcmZ5U2hhcGVQb3NpdGlvbnMpIHtcblx0XHRcdFx0cG9zaXRpb25zID0gdGhpcy5fZ3JvdXAub3B0aW9ucy5zcGlkZXJmeVNoYXBlUG9zaXRpb25zKGNoaWxkTWFya2Vycy5sZW5ndGgsIGNlbnRlcik7XG5cdFx0XHR9IGVsc2UgaWYgKGNoaWxkTWFya2Vycy5sZW5ndGggPj0gdGhpcy5fY2lyY2xlU3BpcmFsU3dpdGNob3Zlcikge1xuXHRcdFx0XHRwb3NpdGlvbnMgPSB0aGlzLl9nZW5lcmF0ZVBvaW50c1NwaXJhbChjaGlsZE1hcmtlcnMubGVuZ3RoLCBjZW50ZXIpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2VudGVyLnkgKz0gMTA7IC8vIE90aGVyd2lzZSBjaXJjbGVzIGxvb2sgd3JvbmcgPT4gaGFjayBmb3Igc3RhbmRhcmQgYmx1ZSBpY29uLCByZW5kZXJzIGRpZmZlcmVudGx5IGZvciBvdGhlciBpY29ucy5cblx0XHRcdFx0cG9zaXRpb25zID0gdGhpcy5fZ2VuZXJhdGVQb2ludHNDaXJjbGUoY2hpbGRNYXJrZXJzLmxlbmd0aCwgY2VudGVyKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fYW5pbWF0aW9uU3BpZGVyZnkoY2hpbGRNYXJrZXJzLCBwb3NpdGlvbnMpO1xuXHRcdH0sXG5cblx0XHR1bnNwaWRlcmZ5OiBmdW5jdGlvbiAoem9vbURldGFpbHMpIHtcblx0XHRcdC8vLyA8cGFyYW0gTmFtZT1cInpvb21EZXRhaWxzXCI+QXJndW1lbnQgZnJvbSB6b29tYW5pbSBpZiBiZWluZyBjYWxsZWQgaW4gYSB6b29tIGFuaW1hdGlvbiBvciBudWxsIG90aGVyd2lzZTwvcGFyYW0+XG5cdFx0XHRpZiAodGhpcy5fZ3JvdXAuX2luWm9vbUFuaW1hdGlvbikge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9hbmltYXRpb25VbnNwaWRlcmZ5KHpvb21EZXRhaWxzKTtcblxuXHRcdFx0dGhpcy5fZ3JvdXAuX3NwaWRlcmZpZWQgPSBudWxsO1xuXHRcdH0sXG5cblx0XHRfZ2VuZXJhdGVQb2ludHNDaXJjbGU6IGZ1bmN0aW9uIChjb3VudCwgY2VudGVyUHQpIHtcblx0XHRcdHZhciBjaXJjdW1mZXJlbmNlID0gdGhpcy5fZ3JvdXAub3B0aW9ucy5zcGlkZXJmeURpc3RhbmNlTXVsdGlwbGllciAqIHRoaXMuX2NpcmNsZUZvb3RTZXBhcmF0aW9uICogKDIgKyBjb3VudCksXG5cdFx0XHRcdGxlZ0xlbmd0aCA9IGNpcmN1bWZlcmVuY2UgLyB0aGlzLl8yUEksICAvL3JhZGl1cyBmcm9tIGNpcmN1bWZlcmVuY2Vcblx0XHRcdFx0YW5nbGVTdGVwID0gdGhpcy5fMlBJIC8gY291bnQsXG5cdFx0XHRcdHJlcyA9IFtdLFxuXHRcdFx0XHRpLCBhbmdsZTtcblxuXHRcdFx0bGVnTGVuZ3RoID0gTWF0aC5tYXgobGVnTGVuZ3RoLCAzNSk7IC8vIE1pbmltdW0gZGlzdGFuY2UgdG8gZ2V0IG91dHNpZGUgdGhlIGNsdXN0ZXIgaWNvbi5cblxuXHRcdFx0cmVzLmxlbmd0aCA9IGNvdW50O1xuXG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgY291bnQ7IGkrKykgeyAvLyBDbG9ja3dpc2UsIGxpa2Ugc3BpcmFsLlxuXHRcdFx0XHRhbmdsZSA9IHRoaXMuX2NpcmNsZVN0YXJ0QW5nbGUgKyBpICogYW5nbGVTdGVwO1xuXHRcdFx0XHRyZXNbaV0gPSBuZXcgTC5Qb2ludChjZW50ZXJQdC54ICsgbGVnTGVuZ3RoICogTWF0aC5jb3MoYW5nbGUpLCBjZW50ZXJQdC55ICsgbGVnTGVuZ3RoICogTWF0aC5zaW4oYW5nbGUpKS5fcm91bmQoKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHJlcztcblx0XHR9LFxuXG5cdFx0X2dlbmVyYXRlUG9pbnRzU3BpcmFsOiBmdW5jdGlvbiAoY291bnQsIGNlbnRlclB0KSB7XG5cdFx0XHR2YXIgc3BpZGVyZnlEaXN0YW5jZU11bHRpcGxpZXIgPSB0aGlzLl9ncm91cC5vcHRpb25zLnNwaWRlcmZ5RGlzdGFuY2VNdWx0aXBsaWVyLFxuXHRcdFx0XHRsZWdMZW5ndGggPSBzcGlkZXJmeURpc3RhbmNlTXVsdGlwbGllciAqIHRoaXMuX3NwaXJhbExlbmd0aFN0YXJ0LFxuXHRcdFx0XHRzZXBhcmF0aW9uID0gc3BpZGVyZnlEaXN0YW5jZU11bHRpcGxpZXIgKiB0aGlzLl9zcGlyYWxGb290U2VwYXJhdGlvbixcblx0XHRcdFx0bGVuZ3RoRmFjdG9yID0gc3BpZGVyZnlEaXN0YW5jZU11bHRpcGxpZXIgKiB0aGlzLl9zcGlyYWxMZW5ndGhGYWN0b3IgKiB0aGlzLl8yUEksXG5cdFx0XHRcdGFuZ2xlID0gMCxcblx0XHRcdFx0cmVzID0gW10sXG5cdFx0XHRcdGk7XG5cblx0XHRcdHJlcy5sZW5ndGggPSBjb3VudDtcblxuXHRcdFx0Ly8gSGlnaGVyIGluZGV4LCBjbG9zZXIgcG9zaXRpb24gdG8gY2x1c3RlciBjZW50ZXIuXG5cdFx0XHRmb3IgKGkgPSBjb3VudDsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdFx0Ly8gU2tpcCB0aGUgZmlyc3QgcG9zaXRpb24sIHNvIHRoYXQgd2UgYXJlIGFscmVhZHkgZmFydGhlciBmcm9tIGNlbnRlciBhbmQgd2UgYXZvaWRcblx0XHRcdFx0Ly8gYmVpbmcgdW5kZXIgdGhlIGRlZmF1bHQgY2x1c3RlciBpY29uIChlc3BlY2lhbGx5IGltcG9ydGFudCBmb3IgQ2lyY2xlIE1hcmtlcnMpLlxuXHRcdFx0XHRpZiAoaSA8IGNvdW50KSB7XG5cdFx0XHRcdFx0cmVzW2ldID0gbmV3IEwuUG9pbnQoY2VudGVyUHQueCArIGxlZ0xlbmd0aCAqIE1hdGguY29zKGFuZ2xlKSwgY2VudGVyUHQueSArIGxlZ0xlbmd0aCAqIE1hdGguc2luKGFuZ2xlKSkuX3JvdW5kKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0YW5nbGUgKz0gc2VwYXJhdGlvbiAvIGxlZ0xlbmd0aCArIGkgKiAwLjAwMDU7XG5cdFx0XHRcdGxlZ0xlbmd0aCArPSBsZW5ndGhGYWN0b3IgLyBhbmdsZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXM7XG5cdFx0fSxcblxuXHRcdF9ub2FuaW1hdGlvblVuc3BpZGVyZnk6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBncm91cCA9IHRoaXMuX2dyb3VwLFxuXHRcdFx0XHRtYXAgPSBncm91cC5fbWFwLFxuXHRcdFx0XHRmZyA9IGdyb3VwLl9mZWF0dXJlR3JvdXAsXG5cdFx0XHRcdGNoaWxkTWFya2VycyA9IHRoaXMuZ2V0QWxsQ2hpbGRNYXJrZXJzKG51bGwsIHRydWUpLFxuXHRcdFx0XHRtLCBpO1xuXG5cdFx0XHRncm91cC5faWdub3JlTW92ZSA9IHRydWU7XG5cblx0XHRcdHRoaXMuc2V0T3BhY2l0eSgxKTtcblx0XHRcdGZvciAoaSA9IGNoaWxkTWFya2Vycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0XHRtID0gY2hpbGRNYXJrZXJzW2ldO1xuXG5cdFx0XHRcdGZnLnJlbW92ZUxheWVyKG0pO1xuXG5cdFx0XHRcdGlmIChtLl9wcmVTcGlkZXJmeUxhdGxuZykge1xuXHRcdFx0XHRcdG0uc2V0TGF0TG5nKG0uX3ByZVNwaWRlcmZ5TGF0bG5nKTtcblx0XHRcdFx0XHRkZWxldGUgbS5fcHJlU3BpZGVyZnlMYXRsbmc7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKG0uc2V0WkluZGV4T2Zmc2V0KSB7XG5cdFx0XHRcdFx0bS5zZXRaSW5kZXhPZmZzZXQoMCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAobS5fc3BpZGVyTGVnKSB7XG5cdFx0XHRcdFx0bWFwLnJlbW92ZUxheWVyKG0uX3NwaWRlckxlZyk7XG5cdFx0XHRcdFx0ZGVsZXRlIG0uX3NwaWRlckxlZztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRncm91cC5maXJlKCd1bnNwaWRlcmZpZWQnLCB7XG5cdFx0XHRcdGNsdXN0ZXI6IHRoaXMsXG5cdFx0XHRcdG1hcmtlcnM6IGNoaWxkTWFya2Vyc1xuXHRcdFx0fSk7XG5cdFx0XHRncm91cC5faWdub3JlTW92ZSA9IGZhbHNlO1xuXHRcdFx0Z3JvdXAuX3NwaWRlcmZpZWQgPSBudWxsO1xuXHRcdH1cblx0fSk7XG5cblx0Ly9Ob24gQW5pbWF0ZWQgdmVyc2lvbnMgb2YgZXZlcnl0aGluZ1xuXHRMLk1hcmtlckNsdXN0ZXJOb25BbmltYXRlZCA9IEwuTWFya2VyQ2x1c3Rlci5leHRlbmQoe1xuXHRcdF9hbmltYXRpb25TcGlkZXJmeTogZnVuY3Rpb24gKGNoaWxkTWFya2VycywgcG9zaXRpb25zKSB7XG5cdFx0XHR2YXIgZ3JvdXAgPSB0aGlzLl9ncm91cCxcblx0XHRcdFx0bWFwID0gZ3JvdXAuX21hcCxcblx0XHRcdFx0ZmcgPSBncm91cC5fZmVhdHVyZUdyb3VwLFxuXHRcdFx0XHRsZWdPcHRpb25zID0gdGhpcy5fZ3JvdXAub3B0aW9ucy5zcGlkZXJMZWdQb2x5bGluZU9wdGlvbnMsXG5cdFx0XHRcdGksIG0sIGxlZywgbmV3UG9zO1xuXG5cdFx0XHRncm91cC5faWdub3JlTW92ZSA9IHRydWU7XG5cblx0XHRcdC8vIFRyYXZlcnNlIGluIGFzY2VuZGluZyBvcmRlciB0byBtYWtlIHN1cmUgdGhhdCBpbm5lciBjaXJjbGVNYXJrZXJzIGFyZSBvbiB0b3Agb2YgZnVydGhlciBsZWdzLiBOb3JtYWwgbWFya2VycyBhcmUgcmUtb3JkZXJlZCBieSBuZXdQb3NpdGlvbi5cblx0XHRcdC8vIFRoZSByZXZlcnNlIG9yZGVyIHRyaWNrIG5vIGxvbmdlciBpbXByb3ZlcyBwZXJmb3JtYW5jZSBvbiBtb2Rlcm4gYnJvd3NlcnMuXG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgY2hpbGRNYXJrZXJzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdG5ld1BvcyA9IG1hcC5sYXllclBvaW50VG9MYXRMbmcocG9zaXRpb25zW2ldKTtcblx0XHRcdFx0bSA9IGNoaWxkTWFya2Vyc1tpXTtcblxuXHRcdFx0XHQvLyBBZGQgdGhlIGxlZyBiZWZvcmUgdGhlIG1hcmtlciwgc28gdGhhdCBpbiBjYXNlIHRoZSBsYXR0ZXIgaXMgYSBjaXJjbGVNYXJrZXIsIHRoZSBsZWcgaXMgYmVoaW5kIGl0LlxuXHRcdFx0XHRsZWcgPSBuZXcgTC5Qb2x5bGluZShbdGhpcy5fbGF0bG5nLCBuZXdQb3NdLCBsZWdPcHRpb25zKTtcblx0XHRcdFx0bWFwLmFkZExheWVyKGxlZyk7XG5cdFx0XHRcdG0uX3NwaWRlckxlZyA9IGxlZztcblxuXHRcdFx0XHQvLyBOb3cgYWRkIHRoZSBtYXJrZXIuXG5cdFx0XHRcdG0uX3ByZVNwaWRlcmZ5TGF0bG5nID0gbS5fbGF0bG5nO1xuXHRcdFx0XHRtLnNldExhdExuZyhuZXdQb3MpO1xuXHRcdFx0XHRpZiAobS5zZXRaSW5kZXhPZmZzZXQpIHtcblx0XHRcdFx0XHRtLnNldFpJbmRleE9mZnNldCgxMDAwMDAwKTsgLy9NYWtlIHRoZXNlIGFwcGVhciBvbiB0b3Agb2YgRVZFUllUSElOR1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZmcuYWRkTGF5ZXIobSk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnNldE9wYWNpdHkoMC4zKTtcblxuXHRcdFx0Z3JvdXAuX2lnbm9yZU1vdmUgPSBmYWxzZTtcblx0XHRcdGdyb3VwLmZpcmUoJ3NwaWRlcmZpZWQnLCB7XG5cdFx0XHRcdGNsdXN0ZXI6IHRoaXMsXG5cdFx0XHRcdG1hcmtlcnM6IGNoaWxkTWFya2Vyc1xuXHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdF9hbmltYXRpb25VbnNwaWRlcmZ5OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR0aGlzLl9ub2FuaW1hdGlvblVuc3BpZGVyZnkoKTtcblx0XHR9XG5cdH0pO1xuXG5cdC8vQW5pbWF0ZWQgdmVyc2lvbnMgaGVyZVxuXHRMLk1hcmtlckNsdXN0ZXIuaW5jbHVkZSh7XG5cblx0XHRfYW5pbWF0aW9uU3BpZGVyZnk6IGZ1bmN0aW9uIChjaGlsZE1hcmtlcnMsIHBvc2l0aW9ucykge1xuXHRcdFx0dmFyIG1lID0gdGhpcyxcblx0XHRcdFx0Z3JvdXAgPSB0aGlzLl9ncm91cCxcblx0XHRcdFx0bWFwID0gZ3JvdXAuX21hcCxcblx0XHRcdFx0ZmcgPSBncm91cC5fZmVhdHVyZUdyb3VwLFxuXHRcdFx0XHR0aGlzTGF5ZXJMYXRMbmcgPSB0aGlzLl9sYXRsbmcsXG5cdFx0XHRcdHRoaXNMYXllclBvcyA9IG1hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpc0xheWVyTGF0TG5nKSxcblx0XHRcdFx0c3ZnID0gTC5QYXRoLlNWRyxcblx0XHRcdFx0bGVnT3B0aW9ucyA9IEwuZXh0ZW5kKHt9LCB0aGlzLl9ncm91cC5vcHRpb25zLnNwaWRlckxlZ1BvbHlsaW5lT3B0aW9ucyksIC8vIENvcHkgdGhlIG9wdGlvbnMgc28gdGhhdCB3ZSBjYW4gbW9kaWZ5IHRoZW0gZm9yIGFuaW1hdGlvbi5cblx0XHRcdFx0ZmluYWxMZWdPcGFjaXR5ID0gbGVnT3B0aW9ucy5vcGFjaXR5LFxuXHRcdFx0XHRpLCBtLCBsZWcsIGxlZ1BhdGgsIGxlZ0xlbmd0aCwgbmV3UG9zO1xuXG5cdFx0XHRpZiAoZmluYWxMZWdPcGFjaXR5ID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0ZmluYWxMZWdPcGFjaXR5ID0gTC5NYXJrZXJDbHVzdGVyR3JvdXAucHJvdG90eXBlLm9wdGlvbnMuc3BpZGVyTGVnUG9seWxpbmVPcHRpb25zLm9wYWNpdHk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChzdmcpIHtcblx0XHRcdFx0Ly8gSWYgdGhlIGluaXRpYWwgb3BhY2l0eSBvZiB0aGUgc3BpZGVyIGxlZyBpcyBub3QgMCB0aGVuIGl0IGFwcGVhcnMgYmVmb3JlIHRoZSBhbmltYXRpb24gc3RhcnRzLlxuXHRcdFx0XHRsZWdPcHRpb25zLm9wYWNpdHkgPSAwO1xuXG5cdFx0XHRcdC8vIEFkZCB0aGUgY2xhc3MgZm9yIENTUyB0cmFuc2l0aW9ucy5cblx0XHRcdFx0bGVnT3B0aW9ucy5jbGFzc05hbWUgPSAobGVnT3B0aW9ucy5jbGFzc05hbWUgfHwgJycpICsgJyBsZWFmbGV0LWNsdXN0ZXItc3BpZGVyLWxlZyc7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBNYWtlIHN1cmUgd2UgaGF2ZSBhIGRlZmluZWQgb3BhY2l0eS5cblx0XHRcdFx0bGVnT3B0aW9ucy5vcGFjaXR5ID0gZmluYWxMZWdPcGFjaXR5O1xuXHRcdFx0fVxuXG5cdFx0XHRncm91cC5faWdub3JlTW92ZSA9IHRydWU7XG5cblx0XHRcdC8vIEFkZCBtYXJrZXJzIGFuZCBzcGlkZXIgbGVncyB0byBtYXAsIGhpZGRlbiBhdCBvdXIgY2VudGVyIHBvaW50LlxuXHRcdFx0Ly8gVHJhdmVyc2UgaW4gYXNjZW5kaW5nIG9yZGVyIHRvIG1ha2Ugc3VyZSB0aGF0IGlubmVyIGNpcmNsZU1hcmtlcnMgYXJlIG9uIHRvcCBvZiBmdXJ0aGVyIGxlZ3MuIE5vcm1hbCBtYXJrZXJzIGFyZSByZS1vcmRlcmVkIGJ5IG5ld1Bvc2l0aW9uLlxuXHRcdFx0Ly8gVGhlIHJldmVyc2Ugb3JkZXIgdHJpY2sgbm8gbG9uZ2VyIGltcHJvdmVzIHBlcmZvcm1hbmNlIG9uIG1vZGVybiBicm93c2Vycy5cblx0XHRcdGZvciAoaSA9IDA7IGkgPCBjaGlsZE1hcmtlcnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0bSA9IGNoaWxkTWFya2Vyc1tpXTtcblxuXHRcdFx0XHRuZXdQb3MgPSBtYXAubGF5ZXJQb2ludFRvTGF0TG5nKHBvc2l0aW9uc1tpXSk7XG5cblx0XHRcdFx0Ly8gQWRkIHRoZSBsZWcgYmVmb3JlIHRoZSBtYXJrZXIsIHNvIHRoYXQgaW4gY2FzZSB0aGUgbGF0dGVyIGlzIGEgY2lyY2xlTWFya2VyLCB0aGUgbGVnIGlzIGJlaGluZCBpdC5cblx0XHRcdFx0bGVnID0gbmV3IEwuUG9seWxpbmUoW3RoaXNMYXllckxhdExuZywgbmV3UG9zXSwgbGVnT3B0aW9ucyk7XG5cdFx0XHRcdG1hcC5hZGRMYXllcihsZWcpO1xuXHRcdFx0XHRtLl9zcGlkZXJMZWcgPSBsZWc7XG5cblx0XHRcdFx0Ly8gRXhwbGFuYXRpb25zOiBodHRwczovL2pha2VhcmNoaWJhbGQuY29tLzIwMTMvYW5pbWF0ZWQtbGluZS1kcmF3aW5nLXN2Zy9cblx0XHRcdFx0Ly8gSW4gb3VyIGNhc2UgdGhlIHRyYW5zaXRpb24gcHJvcGVydHkgaXMgZGVjbGFyZWQgaW4gdGhlIENTUyBmaWxlLlxuXHRcdFx0XHRpZiAoc3ZnKSB7XG5cdFx0XHRcdFx0bGVnUGF0aCA9IGxlZy5fcGF0aDtcblx0XHRcdFx0XHRsZWdMZW5ndGggPSBsZWdQYXRoLmdldFRvdGFsTGVuZ3RoKCkgKyAwLjE7IC8vIE5lZWQgYSBzbWFsbCBleHRyYSBsZW5ndGggdG8gYXZvaWQgcmVtYWluaW5nIGRvdCBpbiBGaXJlZm94LlxuXHRcdFx0XHRcdGxlZ1BhdGguc3R5bGUuc3Ryb2tlRGFzaGFycmF5ID0gbGVnTGVuZ3RoOyAvLyBKdXN0IDEgbGVuZ3RoIGlzIGVub3VnaCwgaXQgd2lsbCBiZSBkdXBsaWNhdGVkLlxuXHRcdFx0XHRcdGxlZ1BhdGguc3R5bGUuc3Ryb2tlRGFzaG9mZnNldCA9IGxlZ0xlbmd0aDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIElmIGl0IGlzIGEgbWFya2VyLCBhZGQgaXQgbm93IGFuZCB3ZSdsbCBhbmltYXRlIGl0IG91dFxuXHRcdFx0XHRpZiAobS5zZXRaSW5kZXhPZmZzZXQpIHtcblx0XHRcdFx0XHRtLnNldFpJbmRleE9mZnNldCgxMDAwMDAwKTsgLy8gTWFrZSBub3JtYWwgbWFya2VycyBhcHBlYXIgb24gdG9wIG9mIEVWRVJZVEhJTkdcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAobS5jbHVzdGVySGlkZSkge1xuXHRcdFx0XHRcdG0uY2x1c3RlckhpZGUoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0Ly8gVmVjdG9ycyBqdXN0IGdldCBpbW1lZGlhdGVseSBhZGRlZFxuXHRcdFx0XHRmZy5hZGRMYXllcihtKTtcblxuXHRcdFx0XHRpZiAobS5fc2V0UG9zKSB7XG5cdFx0XHRcdFx0bS5fc2V0UG9zKHRoaXNMYXllclBvcyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Z3JvdXAuX2ZvcmNlTGF5b3V0KCk7XG5cdFx0XHRncm91cC5fYW5pbWF0aW9uU3RhcnQoKTtcblxuXHRcdFx0Ly8gUmV2ZWFsIG1hcmtlcnMgYW5kIHNwaWRlciBsZWdzLlxuXHRcdFx0Zm9yIChpID0gY2hpbGRNYXJrZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRcdG5ld1BvcyA9IG1hcC5sYXllclBvaW50VG9MYXRMbmcocG9zaXRpb25zW2ldKTtcblx0XHRcdFx0bSA9IGNoaWxkTWFya2Vyc1tpXTtcblxuXHRcdFx0XHQvL01vdmUgbWFya2VyIHRvIG5ldyBwb3NpdGlvblxuXHRcdFx0XHRtLl9wcmVTcGlkZXJmeUxhdGxuZyA9IG0uX2xhdGxuZztcblx0XHRcdFx0bS5zZXRMYXRMbmcobmV3UG9zKTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChtLmNsdXN0ZXJTaG93KSB7XG5cdFx0XHRcdFx0bS5jbHVzdGVyU2hvdygpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQW5pbWF0ZSBsZWcgKGFuaW1hdGlvbiBpcyBhY3R1YWxseSBkZWxlZ2F0ZWQgdG8gQ1NTIHRyYW5zaXRpb24pLlxuXHRcdFx0XHRpZiAoc3ZnKSB7XG5cdFx0XHRcdFx0bGVnID0gbS5fc3BpZGVyTGVnO1xuXHRcdFx0XHRcdGxlZ1BhdGggPSBsZWcuX3BhdGg7XG5cdFx0XHRcdFx0bGVnUGF0aC5zdHlsZS5zdHJva2VEYXNob2Zmc2V0ID0gMDtcblx0XHRcdFx0XHQvL2xlZ1BhdGguc3R5bGUuc3Ryb2tlT3BhY2l0eSA9IGZpbmFsTGVnT3BhY2l0eTtcblx0XHRcdFx0XHRsZWcuc2V0U3R5bGUoe29wYWNpdHk6IGZpbmFsTGVnT3BhY2l0eX0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnNldE9wYWNpdHkoMC4zKTtcblxuXHRcdFx0Z3JvdXAuX2lnbm9yZU1vdmUgPSBmYWxzZTtcblxuXHRcdFx0c2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdGdyb3VwLl9hbmltYXRpb25FbmQoKTtcblx0XHRcdFx0Z3JvdXAuZmlyZSgnc3BpZGVyZmllZCcsIHtcblx0XHRcdFx0XHRjbHVzdGVyOiBtZSxcblx0XHRcdFx0XHRtYXJrZXJzOiBjaGlsZE1hcmtlcnNcblx0XHRcdFx0fSk7XG5cdFx0XHR9LCAyMDApO1xuXHRcdH0sXG5cblx0XHRfYW5pbWF0aW9uVW5zcGlkZXJmeTogZnVuY3Rpb24gKHpvb21EZXRhaWxzKSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzLFxuXHRcdFx0XHRncm91cCA9IHRoaXMuX2dyb3VwLFxuXHRcdFx0XHRtYXAgPSBncm91cC5fbWFwLFxuXHRcdFx0XHRmZyA9IGdyb3VwLl9mZWF0dXJlR3JvdXAsXG5cdFx0XHRcdHRoaXNMYXllclBvcyA9IHpvb21EZXRhaWxzID8gbWFwLl9sYXRMbmdUb05ld0xheWVyUG9pbnQodGhpcy5fbGF0bG5nLCB6b29tRGV0YWlscy56b29tLCB6b29tRGV0YWlscy5jZW50ZXIpIDogbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcpLFxuXHRcdFx0XHRjaGlsZE1hcmtlcnMgPSB0aGlzLmdldEFsbENoaWxkTWFya2VycyhudWxsLCB0cnVlKSxcblx0XHRcdFx0c3ZnID0gTC5QYXRoLlNWRyxcblx0XHRcdFx0bSwgaSwgbGVnLCBsZWdQYXRoLCBsZWdMZW5ndGgsIG5vbkFuaW1hdGFibGU7XG5cblx0XHRcdGdyb3VwLl9pZ25vcmVNb3ZlID0gdHJ1ZTtcblx0XHRcdGdyb3VwLl9hbmltYXRpb25TdGFydCgpO1xuXG5cdFx0XHQvL01ha2UgdXMgdmlzaWJsZSBhbmQgYnJpbmcgdGhlIGNoaWxkIG1hcmtlcnMgYmFjayBpblxuXHRcdFx0dGhpcy5zZXRPcGFjaXR5KDEpO1xuXHRcdFx0Zm9yIChpID0gY2hpbGRNYXJrZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRcdG0gPSBjaGlsZE1hcmtlcnNbaV07XG5cblx0XHRcdFx0Ly9NYXJrZXIgd2FzIGFkZGVkIHRvIHVzIGFmdGVyIHdlIHdlcmUgc3BpZGVyZmllZFxuXHRcdFx0XHRpZiAoIW0uX3ByZVNwaWRlcmZ5TGF0bG5nKSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvL0Nsb3NlIGFueSBwb3B1cCBvbiB0aGUgbWFya2VyIGZpcnN0LCBvdGhlcndpc2Ugc2V0dGluZyB0aGUgbG9jYXRpb24gb2YgdGhlIG1hcmtlciB3aWxsIG1ha2UgdGhlIG1hcCBzY3JvbGxcblx0XHRcdFx0bS5jbG9zZVBvcHVwKCk7XG5cblx0XHRcdFx0Ly9GaXggdXAgdGhlIGxvY2F0aW9uIHRvIHRoZSByZWFsIG9uZVxuXHRcdFx0XHRtLnNldExhdExuZyhtLl9wcmVTcGlkZXJmeUxhdGxuZyk7XG5cdFx0XHRcdGRlbGV0ZSBtLl9wcmVTcGlkZXJmeUxhdGxuZztcblxuXHRcdFx0XHQvL0hhY2sgb3ZlcnJpZGUgdGhlIGxvY2F0aW9uIHRvIGJlIG91ciBjZW50ZXJcblx0XHRcdFx0bm9uQW5pbWF0YWJsZSA9IHRydWU7XG5cdFx0XHRcdGlmIChtLl9zZXRQb3MpIHtcblx0XHRcdFx0XHRtLl9zZXRQb3ModGhpc0xheWVyUG9zKTtcblx0XHRcdFx0XHRub25BbmltYXRhYmxlID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKG0uY2x1c3RlckhpZGUpIHtcblx0XHRcdFx0XHRtLmNsdXN0ZXJIaWRlKCk7XG5cdFx0XHRcdFx0bm9uQW5pbWF0YWJsZSA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChub25BbmltYXRhYmxlKSB7XG5cdFx0XHRcdFx0ZmcucmVtb3ZlTGF5ZXIobSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBbmltYXRlIHRoZSBzcGlkZXIgbGVnIGJhY2sgaW4gKGFuaW1hdGlvbiBpcyBhY3R1YWxseSBkZWxlZ2F0ZWQgdG8gQ1NTIHRyYW5zaXRpb24pLlxuXHRcdFx0XHRpZiAoc3ZnKSB7XG5cdFx0XHRcdFx0bGVnID0gbS5fc3BpZGVyTGVnO1xuXHRcdFx0XHRcdGxlZ1BhdGggPSBsZWcuX3BhdGg7XG5cdFx0XHRcdFx0bGVnTGVuZ3RoID0gbGVnUGF0aC5nZXRUb3RhbExlbmd0aCgpICsgMC4xO1xuXHRcdFx0XHRcdGxlZ1BhdGguc3R5bGUuc3Ryb2tlRGFzaG9mZnNldCA9IGxlZ0xlbmd0aDtcblx0XHRcdFx0XHRsZWcuc2V0U3R5bGUoe29wYWNpdHk6IDB9KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRncm91cC5faWdub3JlTW92ZSA9IGZhbHNlO1xuXG5cdFx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0Ly9JZiB3ZSBoYXZlIG9ubHkgPD0gb25lIGNoaWxkIGxlZnQgdGhlbiB0aGF0IG1hcmtlciB3aWxsIGJlIHNob3duIG9uIHRoZSBtYXAgc28gZG9uJ3QgcmVtb3ZlIGl0IVxuXHRcdFx0XHR2YXIgc3RpbGxUaGVyZUNoaWxkQ291bnQgPSAwO1xuXHRcdFx0XHRmb3IgKGkgPSBjaGlsZE1hcmtlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdFx0XHRtID0gY2hpbGRNYXJrZXJzW2ldO1xuXHRcdFx0XHRcdGlmIChtLl9zcGlkZXJMZWcpIHtcblx0XHRcdFx0XHRcdHN0aWxsVGhlcmVDaGlsZENvdW50Kys7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblxuXHRcdFx0XHRmb3IgKGkgPSBjaGlsZE1hcmtlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdFx0XHRtID0gY2hpbGRNYXJrZXJzW2ldO1xuXG5cdFx0XHRcdFx0aWYgKCFtLl9zcGlkZXJMZWcpIHsgLy9IYXMgYWxyZWFkeSBiZWVuIHVuc3BpZGVyZmllZFxuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKG0uY2x1c3RlclNob3cpIHtcblx0XHRcdFx0XHRcdG0uY2x1c3RlclNob3coKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKG0uc2V0WkluZGV4T2Zmc2V0KSB7XG5cdFx0XHRcdFx0XHRtLnNldFpJbmRleE9mZnNldCgwKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoc3RpbGxUaGVyZUNoaWxkQ291bnQgPiAxKSB7XG5cdFx0XHRcdFx0XHRmZy5yZW1vdmVMYXllcihtKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRtYXAucmVtb3ZlTGF5ZXIobS5fc3BpZGVyTGVnKTtcblx0XHRcdFx0XHRkZWxldGUgbS5fc3BpZGVyTGVnO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGdyb3VwLl9hbmltYXRpb25FbmQoKTtcblx0XHRcdFx0Z3JvdXAuZmlyZSgndW5zcGlkZXJmaWVkJywge1xuXHRcdFx0XHRcdGNsdXN0ZXI6IG1lLFxuXHRcdFx0XHRcdG1hcmtlcnM6IGNoaWxkTWFya2Vyc1xuXHRcdFx0XHR9KTtcblx0XHRcdH0sIDIwMCk7XG5cdFx0fVxuXHR9KTtcblxuXG5cdEwuTWFya2VyQ2x1c3Rlckdyb3VwLmluY2x1ZGUoe1xuXHRcdC8vVGhlIE1hcmtlckNsdXN0ZXIgY3VycmVudGx5IHNwaWRlcmZpZWQgKGlmIGFueSlcblx0XHRfc3BpZGVyZmllZDogbnVsbCxcblxuXHRcdHVuc3BpZGVyZnk6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHRoaXMuX3Vuc3BpZGVyZnkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHR9LFxuXG5cdFx0X3NwaWRlcmZpZXJPbkFkZDogZnVuY3Rpb24gKCkge1xuXHRcdFx0dGhpcy5fbWFwLm9uKCdjbGljaycsIHRoaXMuX3Vuc3BpZGVyZnlXcmFwcGVyLCB0aGlzKTtcblxuXHRcdFx0aWYgKHRoaXMuX21hcC5vcHRpb25zLnpvb21BbmltYXRpb24pIHtcblx0XHRcdFx0dGhpcy5fbWFwLm9uKCd6b29tc3RhcnQnLCB0aGlzLl91bnNwaWRlcmZ5Wm9vbVN0YXJ0LCB0aGlzKTtcblx0XHRcdH1cblx0XHRcdC8vQnJvd3NlcnMgd2l0aG91dCB6b29tQW5pbWF0aW9uIG9yIGEgYmlnIHpvb20gZG9uJ3QgZmlyZSB6b29tc3RhcnRcblx0XHRcdHRoaXMuX21hcC5vbignem9vbWVuZCcsIHRoaXMuX25vYW5pbWF0aW9uVW5zcGlkZXJmeSwgdGhpcyk7XG5cblx0XHRcdGlmICghTC5Ccm93c2VyLnRvdWNoKSB7XG5cdFx0XHRcdHRoaXMuX21hcC5nZXRSZW5kZXJlcih0aGlzKTtcblx0XHRcdFx0Ly9OZWVkcyB0byBoYXBwZW4gaW4gdGhlIHBhZ2Vsb2FkLCBub3QgYWZ0ZXIsIG9yIGFuaW1hdGlvbnMgZG9uJ3Qgd29yayBpbiB3ZWJraXRcblx0XHRcdFx0Ly8gIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvODQ1NTIwMC9zdmctYW5pbWF0ZS13aXRoLWR5bmFtaWNhbGx5LWFkZGVkLWVsZW1lbnRzXG5cdFx0XHRcdC8vRGlzYWJsZSBvbiB0b3VjaCBicm93c2VycyBhcyB0aGUgYW5pbWF0aW9uIG1lc3NlcyB1cCBvbiBhIHRvdWNoIHpvb20gYW5kIGlzbid0IHZlcnkgbm90aWNhYmxlXG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdF9zcGlkZXJmaWVyT25SZW1vdmU6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHRoaXMuX21hcC5vZmYoJ2NsaWNrJywgdGhpcy5fdW5zcGlkZXJmeVdyYXBwZXIsIHRoaXMpO1xuXHRcdFx0dGhpcy5fbWFwLm9mZignem9vbXN0YXJ0JywgdGhpcy5fdW5zcGlkZXJmeVpvb21TdGFydCwgdGhpcyk7XG5cdFx0XHR0aGlzLl9tYXAub2ZmKCd6b29tYW5pbScsIHRoaXMuX3Vuc3BpZGVyZnlab29tQW5pbSwgdGhpcyk7XG5cdFx0XHR0aGlzLl9tYXAub2ZmKCd6b29tZW5kJywgdGhpcy5fbm9hbmltYXRpb25VbnNwaWRlcmZ5LCB0aGlzKTtcblxuXHRcdFx0Ly9FbnN1cmUgdGhhdCBtYXJrZXJzIGFyZSBiYWNrIHdoZXJlIHRoZXkgc2hvdWxkIGJlXG5cdFx0XHQvLyBVc2Ugbm8gYW5pbWF0aW9uIHRvIGF2b2lkIGEgc3RpY2t5IGxlYWZsZXQtY2x1c3Rlci1hbmltIGNsYXNzIG9uIG1hcFBhbmVcblx0XHRcdHRoaXMuX25vYW5pbWF0aW9uVW5zcGlkZXJmeSgpO1xuXHRcdH0sXG5cblx0XHQvL09uIHpvb20gc3RhcnQgd2UgYWRkIGEgem9vbWFuaW0gaGFuZGxlciBzbyB0aGF0IHdlIGFyZSBndWFyYW50ZWVkIHRvIGJlIGxhc3QgKGFmdGVyIG1hcmtlcnMgYXJlIGFuaW1hdGVkKVxuXHRcdC8vVGhpcyBtZWFucyB3ZSBjYW4gZGVmaW5lIHRoZSBhbmltYXRpb24gdGhleSBkbyByYXRoZXIgdGhhbiBNYXJrZXJzIGRvaW5nIGFuIGFuaW1hdGlvbiB0byB0aGVpciBhY3R1YWwgbG9jYXRpb25cblx0XHRfdW5zcGlkZXJmeVpvb21TdGFydDogZnVuY3Rpb24gKCkge1xuXHRcdFx0aWYgKCF0aGlzLl9tYXApIHsgLy9NYXkgaGF2ZSBiZWVuIHJlbW92ZWQgZnJvbSB0aGUgbWFwIGJ5IGEgem9vbUVuZCBoYW5kbGVyXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fbWFwLm9uKCd6b29tYW5pbScsIHRoaXMuX3Vuc3BpZGVyZnlab29tQW5pbSwgdGhpcyk7XG5cdFx0fSxcblxuXHRcdF91bnNwaWRlcmZ5Wm9vbUFuaW06IGZ1bmN0aW9uICh6b29tRGV0YWlscykge1xuXHRcdFx0Ly9XYWl0IHVudGlsIHRoZSBmaXJzdCB6b29tYW5pbSBhZnRlciB0aGUgdXNlciBoYXMgZmluaXNoZWQgdG91Y2gtem9vbWluZyBiZWZvcmUgcnVubmluZyB0aGUgYW5pbWF0aW9uXG5cdFx0XHRpZiAoTC5Eb21VdGlsLmhhc0NsYXNzKHRoaXMuX21hcC5fbWFwUGFuZSwgJ2xlYWZsZXQtdG91Y2hpbmcnKSkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX21hcC5vZmYoJ3pvb21hbmltJywgdGhpcy5fdW5zcGlkZXJmeVpvb21BbmltLCB0aGlzKTtcblx0XHRcdHRoaXMuX3Vuc3BpZGVyZnkoem9vbURldGFpbHMpO1xuXHRcdH0sXG5cblx0XHRfdW5zcGlkZXJmeVdyYXBwZXI6IGZ1bmN0aW9uICgpIHtcblx0XHRcdC8vLyA8c3VtbWFyeT5fdW5zcGlkZXJmeSBidXQgcGFzc2VzIG5vIGFyZ3VtZW50czwvc3VtbWFyeT5cblx0XHRcdHRoaXMuX3Vuc3BpZGVyZnkoKTtcblx0XHR9LFxuXG5cdFx0X3Vuc3BpZGVyZnk6IGZ1bmN0aW9uICh6b29tRGV0YWlscykge1xuXHRcdFx0aWYgKHRoaXMuX3NwaWRlcmZpZWQpIHtcblx0XHRcdFx0dGhpcy5fc3BpZGVyZmllZC51bnNwaWRlcmZ5KHpvb21EZXRhaWxzKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0X25vYW5pbWF0aW9uVW5zcGlkZXJmeTogZnVuY3Rpb24gKCkge1xuXHRcdFx0aWYgKHRoaXMuX3NwaWRlcmZpZWQpIHtcblx0XHRcdFx0dGhpcy5fc3BpZGVyZmllZC5fbm9hbmltYXRpb25VbnNwaWRlcmZ5KCk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8vSWYgdGhlIGdpdmVuIGxheWVyIGlzIGN1cnJlbnRseSBiZWluZyBzcGlkZXJmaWVkIHRoZW4gd2UgdW5zcGlkZXJmeSBpdCBzbyBpdCBpc24ndCBvbiB0aGUgbWFwIGFueW1vcmUgZXRjXG5cdFx0X3Vuc3BpZGVyZnlMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0XHRpZiAobGF5ZXIuX3NwaWRlckxlZykge1xuXHRcdFx0XHR0aGlzLl9mZWF0dXJlR3JvdXAucmVtb3ZlTGF5ZXIobGF5ZXIpO1xuXG5cdFx0XHRcdGlmIChsYXllci5jbHVzdGVyU2hvdykge1xuXHRcdFx0XHRcdGxheWVyLmNsdXN0ZXJTaG93KCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0XHQvL1Bvc2l0aW9uIHdpbGwgYmUgZml4ZWQgdXAgaW1tZWRpYXRlbHkgaW4gX2FuaW1hdGlvblVuc3BpZGVyZnlcblx0XHRcdFx0aWYgKGxheWVyLnNldFpJbmRleE9mZnNldCkge1xuXHRcdFx0XHRcdGxheWVyLnNldFpJbmRleE9mZnNldCgwKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMuX21hcC5yZW1vdmVMYXllcihsYXllci5fc3BpZGVyTGVnKTtcblx0XHRcdFx0ZGVsZXRlIGxheWVyLl9zcGlkZXJMZWc7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcblxuXHQvKipcblx0ICogQWRkcyAxIHB1YmxpYyBtZXRob2QgdG8gTUNHIGFuZCAxIHRvIEwuTWFya2VyIHRvIGZhY2lsaXRhdGUgY2hhbmdpbmdcblx0ICogbWFya2VycycgaWNvbiBvcHRpb25zIGFuZCByZWZyZXNoaW5nIHRoZWlyIGljb24gYW5kIHRoZWlyIHBhcmVudCBjbHVzdGVyc1xuXHQgKiBhY2NvcmRpbmdseSAoY2FzZSB3aGVyZSB0aGVpciBpY29uQ3JlYXRlRnVuY3Rpb24gdXNlcyBkYXRhIG9mIGNoaWxkTWFya2Vyc1xuXHQgKiB0byBtYWtlIHVwIHRoZSBjbHVzdGVyIGljb24pLlxuXHQgKi9cblxuXG5cdEwuTWFya2VyQ2x1c3Rlckdyb3VwLmluY2x1ZGUoe1xuXHRcdC8qKlxuXHRcdCAqIFVwZGF0ZXMgdGhlIGljb24gb2YgYWxsIGNsdXN0ZXJzIHdoaWNoIGFyZSBwYXJlbnRzIG9mIHRoZSBnaXZlbiBtYXJrZXIocykuXG5cdFx0ICogSW4gc2luZ2xlTWFya2VyTW9kZSwgYWxzbyB1cGRhdGVzIHRoZSBnaXZlbiBtYXJrZXIocykgaWNvbi5cblx0XHQgKiBAcGFyYW0gbGF5ZXJzIEwuTWFya2VyQ2x1c3Rlckdyb3VwfEwuTGF5ZXJHcm91cHxBcnJheShMLk1hcmtlcil8TWFwKEwuTWFya2VyKXxcblx0XHQgKiBMLk1hcmtlckNsdXN0ZXJ8TC5NYXJrZXIgKG9wdGlvbmFsKSBsaXN0IG9mIG1hcmtlcnMgKG9yIHNpbmdsZSBtYXJrZXIpIHdob3NlIHBhcmVudFxuXHRcdCAqIGNsdXN0ZXJzIG5lZWQgdG8gYmUgdXBkYXRlZC4gSWYgbm90IHByb3ZpZGVkLCByZXRyaWV2ZXMgYWxsIGNoaWxkIG1hcmtlcnMgb2YgdGhpcy5cblx0XHQgKiBAcmV0dXJucyB7TC5NYXJrZXJDbHVzdGVyR3JvdXB9XG5cdFx0ICovXG5cdFx0cmVmcmVzaENsdXN0ZXJzOiBmdW5jdGlvbiAobGF5ZXJzKSB7XG5cdFx0XHRpZiAoIWxheWVycykge1xuXHRcdFx0XHRsYXllcnMgPSB0aGlzLl90b3BDbHVzdGVyTGV2ZWwuZ2V0QWxsQ2hpbGRNYXJrZXJzKCk7XG5cdFx0XHR9IGVsc2UgaWYgKGxheWVycyBpbnN0YW5jZW9mIEwuTWFya2VyQ2x1c3Rlckdyb3VwKSB7XG5cdFx0XHRcdGxheWVycyA9IGxheWVycy5fdG9wQ2x1c3RlckxldmVsLmdldEFsbENoaWxkTWFya2VycygpO1xuXHRcdFx0fSBlbHNlIGlmIChsYXllcnMgaW5zdGFuY2VvZiBMLkxheWVyR3JvdXApIHtcblx0XHRcdFx0bGF5ZXJzID0gbGF5ZXJzLl9sYXllcnM7XG5cdFx0XHR9IGVsc2UgaWYgKGxheWVycyBpbnN0YW5jZW9mIEwuTWFya2VyQ2x1c3Rlcikge1xuXHRcdFx0XHRsYXllcnMgPSBsYXllcnMuZ2V0QWxsQ2hpbGRNYXJrZXJzKCk7XG5cdFx0XHR9IGVsc2UgaWYgKGxheWVycyBpbnN0YW5jZW9mIEwuTWFya2VyKSB7XG5cdFx0XHRcdGxheWVycyA9IFtsYXllcnNdO1xuXHRcdFx0fSAvLyBlbHNlOiBtdXN0IGJlIGFuIEFycmF5KEwuTWFya2VyKXxNYXAoTC5NYXJrZXIpXG5cdFx0XHR0aGlzLl9mbGFnUGFyZW50c0ljb25zTmVlZFVwZGF0ZShsYXllcnMpO1xuXHRcdFx0dGhpcy5fcmVmcmVzaENsdXN0ZXJzSWNvbnMoKTtcblxuXHRcdFx0Ly8gSW4gY2FzZSBvZiBzaW5nbGVNYXJrZXJNb2RlLCBhbHNvIHJlLWRyYXcgdGhlIG1hcmtlcnMuXG5cdFx0XHRpZiAodGhpcy5vcHRpb25zLnNpbmdsZU1hcmtlck1vZGUpIHtcblx0XHRcdFx0dGhpcy5fcmVmcmVzaFNpbmdsZU1hcmtlck1vZGVNYXJrZXJzKGxheWVycyk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBTaW1wbHkgZmxhZ3MgYWxsIHBhcmVudCBjbHVzdGVycyBvZiB0aGUgZ2l2ZW4gbWFya2VycyBhcyBoYXZpbmcgYSBcImRpcnR5XCIgaWNvbi5cblx0XHQgKiBAcGFyYW0gbGF5ZXJzIEFycmF5KEwuTWFya2VyKXxNYXAoTC5NYXJrZXIpIGxpc3Qgb2YgbWFya2Vycy5cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdF9mbGFnUGFyZW50c0ljb25zTmVlZFVwZGF0ZTogZnVuY3Rpb24gKGxheWVycykge1xuXHRcdFx0dmFyIGlkLCBwYXJlbnQ7XG5cblx0XHRcdC8vIEFzc3VtZXMgbGF5ZXJzIGlzIGFuIEFycmF5IG9yIGFuIE9iamVjdCB3aG9zZSBwcm90b3R5cGUgaXMgbm9uLWVudW1lcmFibGUuXG5cdFx0XHRmb3IgKGlkIGluIGxheWVycykge1xuXHRcdFx0XHQvLyBGbGFnIHBhcmVudCBjbHVzdGVycycgaWNvbiBhcyBcImRpcnR5XCIsIGFsbCB0aGUgd2F5IHVwLlxuXHRcdFx0XHQvLyBEdW1iIHByb2Nlc3MgdGhhdCBmbGFncyBtdWx0aXBsZSB0aW1lcyB1cHBlciBwYXJlbnRzLCBidXQgc3RpbGxcblx0XHRcdFx0Ly8gbXVjaCBtb3JlIGVmZmljaWVudCB0aGFuIHRyeWluZyB0byBiZSBzbWFydCBhbmQgbWFrZSBzaG9ydCBsaXN0cyxcblx0XHRcdFx0Ly8gYXQgbGVhc3QgaW4gdGhlIGNhc2Ugb2YgYSBoaWVyYXJjaHkgZm9sbG93aW5nIGEgcG93ZXIgbGF3OlxuXHRcdFx0XHQvLyBodHRwOi8vanNwZXJmLmNvbS9mbGFnLW5vZGVzLWluLXBvd2VyLWhpZXJhcmNoeS8yXG5cdFx0XHRcdHBhcmVudCA9IGxheWVyc1tpZF0uX19wYXJlbnQ7XG5cdFx0XHRcdHdoaWxlIChwYXJlbnQpIHtcblx0XHRcdFx0XHRwYXJlbnQuX2ljb25OZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0XHRcdFx0cGFyZW50ID0gcGFyZW50Ll9fcGFyZW50O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFJlLWRyYXdzIHRoZSBpY29uIG9mIHRoZSBzdXBwbGllZCBtYXJrZXJzLlxuXHRcdCAqIFRvIGJlIHVzZWQgaW4gc2luZ2xlTWFya2VyTW9kZSBvbmx5LlxuXHRcdCAqIEBwYXJhbSBsYXllcnMgQXJyYXkoTC5NYXJrZXIpfE1hcChMLk1hcmtlcikgbGlzdCBvZiBtYXJrZXJzLlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0X3JlZnJlc2hTaW5nbGVNYXJrZXJNb2RlTWFya2VyczogZnVuY3Rpb24gKGxheWVycykge1xuXHRcdFx0dmFyIGlkLCBsYXllcjtcblxuXHRcdFx0Zm9yIChpZCBpbiBsYXllcnMpIHtcblx0XHRcdFx0bGF5ZXIgPSBsYXllcnNbaWRdO1xuXG5cdFx0XHRcdC8vIE1ha2Ugc3VyZSB3ZSBkbyBub3Qgb3ZlcnJpZGUgbWFya2VycyB0aGF0IGRvIG5vdCBiZWxvbmcgdG8gVEhJUyBncm91cC5cblx0XHRcdFx0aWYgKHRoaXMuaGFzTGF5ZXIobGF5ZXIpKSB7XG5cdFx0XHRcdFx0Ly8gTmVlZCB0byByZS1jcmVhdGUgdGhlIGljb24gZmlyc3QsIHRoZW4gcmUtZHJhdyB0aGUgbWFya2VyLlxuXHRcdFx0XHRcdGxheWVyLnNldEljb24odGhpcy5fb3ZlcnJpZGVNYXJrZXJJY29uKGxheWVyKSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0pO1xuXG5cdEwuTWFya2VyLmluY2x1ZGUoe1xuXHRcdC8qKlxuXHRcdCAqIFVwZGF0ZXMgdGhlIGdpdmVuIG9wdGlvbnMgaW4gdGhlIG1hcmtlcidzIGljb24gYW5kIHJlZnJlc2hlcyB0aGUgbWFya2VyLlxuXHRcdCAqIEBwYXJhbSBvcHRpb25zIG1hcCBvYmplY3Qgb2YgaWNvbiBvcHRpb25zLlxuXHRcdCAqIEBwYXJhbSBkaXJlY3RseVJlZnJlc2hDbHVzdGVycyBib29sZWFuIChvcHRpb25hbCkgdHJ1ZSB0byB0cmlnZ2VyXG5cdFx0ICogTUNHLnJlZnJlc2hDbHVzdGVyc09mKCkgcmlnaHQgYXdheSB3aXRoIHRoaXMgc2luZ2xlIG1hcmtlci5cblx0XHQgKiBAcmV0dXJucyB7TC5NYXJrZXJ9XG5cdFx0ICovXG5cdFx0cmVmcmVzaEljb25PcHRpb25zOiBmdW5jdGlvbiAob3B0aW9ucywgZGlyZWN0bHlSZWZyZXNoQ2x1c3RlcnMpIHtcblx0XHRcdHZhciBpY29uID0gdGhpcy5vcHRpb25zLmljb247XG5cblx0XHRcdEwuc2V0T3B0aW9ucyhpY29uLCBvcHRpb25zKTtcblxuXHRcdFx0dGhpcy5zZXRJY29uKGljb24pO1xuXG5cdFx0XHQvLyBTaG9ydGN1dCB0byByZWZyZXNoIHRoZSBhc3NvY2lhdGVkIE1DRyBjbHVzdGVycyByaWdodCBhd2F5LlxuXHRcdFx0Ly8gVG8gYmUgdXNlZCB3aGVuIHJlZnJlc2hpbmcgYSBzaW5nbGUgbWFya2VyLlxuXHRcdFx0Ly8gT3RoZXJ3aXNlLCBiZXR0ZXIgdXNlIE1DRy5yZWZyZXNoQ2x1c3RlcnMoKSBvbmNlIGF0IHRoZSBlbmQgd2l0aFxuXHRcdFx0Ly8gdGhlIGxpc3Qgb2YgbW9kaWZpZWQgbWFya2Vycy5cblx0XHRcdGlmIChkaXJlY3RseVJlZnJlc2hDbHVzdGVycyAmJiB0aGlzLl9fcGFyZW50KSB7XG5cdFx0XHRcdHRoaXMuX19wYXJlbnQuX2dyb3VwLnJlZnJlc2hDbHVzdGVycyh0aGlzKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHR9KTtcblxuXHRleHBvcnRzLk1hcmtlckNsdXN0ZXIgPSBNYXJrZXJDbHVzdGVyO1xuXHRleHBvcnRzLk1hcmtlckNsdXN0ZXJHcm91cCA9IE1hcmtlckNsdXN0ZXJHcm91cDtcblxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGVhZmxldC5tYXJrZXJjbHVzdGVyLXNyYy5qcy5tYXBcbiIsIi8qKlxuICogRnVzZS5qcyB2Ni40LjYgLSBMaWdodHdlaWdodCBmdXp6eS1zZWFyY2ggKGh0dHA6Ly9mdXNlanMuaW8pXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDIxIEtpcm8gUmlzayAoaHR0cDovL2tpcm8ubWUpXG4gKiBBbGwgUmlnaHRzIFJlc2VydmVkLiBBcGFjaGUgU29mdHdhcmUgTGljZW5zZSAyLjBcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqL1xuXG5mdW5jdGlvbiBpc0FycmF5KHZhbHVlKSB7XG4gIHJldHVybiAhQXJyYXkuaXNBcnJheVxuICAgID8gZ2V0VGFnKHZhbHVlKSA9PT0gJ1tvYmplY3QgQXJyYXldJ1xuICAgIDogQXJyYXkuaXNBcnJheSh2YWx1ZSlcbn1cblxuLy8gQWRhcHRlZCBmcm9tOiBodHRwczovL2dpdGh1Yi5jb20vbG9kYXNoL2xvZGFzaC9ibG9iL21hc3Rlci8uaW50ZXJuYWwvYmFzZVRvU3RyaW5nLmpzXG5jb25zdCBJTkZJTklUWSA9IDEgLyAwO1xuZnVuY3Rpb24gYmFzZVRvU3RyaW5nKHZhbHVlKSB7XG4gIC8vIEV4aXQgZWFybHkgZm9yIHN0cmluZ3MgdG8gYXZvaWQgYSBwZXJmb3JtYW5jZSBoaXQgaW4gc29tZSBlbnZpcm9ubWVudHMuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuICBsZXQgcmVzdWx0ID0gdmFsdWUgKyAnJztcbiAgcmV0dXJuIHJlc3VsdCA9PSAnMCcgJiYgMSAvIHZhbHVlID09IC1JTkZJTklUWSA/ICctMCcgOiByZXN1bHRcbn1cblxuZnVuY3Rpb24gdG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgPyAnJyA6IGJhc2VUb1N0cmluZyh2YWx1ZSlcbn1cblxuZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZydcbn1cblxuZnVuY3Rpb24gaXNOdW1iZXIodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcidcbn1cblxuLy8gQWRhcHRlZCBmcm9tOiBodHRwczovL2dpdGh1Yi5jb20vbG9kYXNoL2xvZGFzaC9ibG9iL21hc3Rlci9pc0Jvb2xlYW4uanNcbmZ1bmN0aW9uIGlzQm9vbGVhbih2YWx1ZSkge1xuICByZXR1cm4gKFxuICAgIHZhbHVlID09PSB0cnVlIHx8XG4gICAgdmFsdWUgPT09IGZhbHNlIHx8XG4gICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgZ2V0VGFnKHZhbHVlKSA9PSAnW29iamVjdCBCb29sZWFuXScpXG4gIClcbn1cblxuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCdcbn1cblxuLy8gQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHZhbHVlKSAmJiB2YWx1ZSAhPT0gbnVsbFxufVxuXG5mdW5jdGlvbiBpc0RlZmluZWQodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGxcbn1cblxuZnVuY3Rpb24gaXNCbGFuayh2YWx1ZSkge1xuICByZXR1cm4gIXZhbHVlLnRyaW0oKS5sZW5ndGhcbn1cblxuLy8gR2V0cyB0aGUgYHRvU3RyaW5nVGFnYCBvZiBgdmFsdWVgLlxuLy8gQWRhcHRlZCBmcm9tOiBodHRwczovL2dpdGh1Yi5jb20vbG9kYXNoL2xvZGFzaC9ibG9iL21hc3Rlci8uaW50ZXJuYWwvZ2V0VGFnLmpzXG5mdW5jdGlvbiBnZXRUYWcodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09IG51bGxcbiAgICA/IHZhbHVlID09PSB1bmRlZmluZWRcbiAgICAgID8gJ1tvYmplY3QgVW5kZWZpbmVkXSdcbiAgICAgIDogJ1tvYmplY3QgTnVsbF0nXG4gICAgOiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpXG59XG5cbmNvbnN0IEVYVEVOREVEX1NFQVJDSF9VTkFWQUlMQUJMRSA9ICdFeHRlbmRlZCBzZWFyY2ggaXMgbm90IGF2YWlsYWJsZSc7XG5cbmNvbnN0IElOQ09SUkVDVF9JTkRFWF9UWVBFID0gXCJJbmNvcnJlY3QgJ2luZGV4JyB0eXBlXCI7XG5cbmNvbnN0IExPR0lDQUxfU0VBUkNIX0lOVkFMSURfUVVFUllfRk9SX0tFWSA9IChrZXkpID0+XG4gIGBJbnZhbGlkIHZhbHVlIGZvciBrZXkgJHtrZXl9YDtcblxuY29uc3QgUEFUVEVSTl9MRU5HVEhfVE9PX0xBUkdFID0gKG1heCkgPT5cbiAgYFBhdHRlcm4gbGVuZ3RoIGV4Y2VlZHMgbWF4IG9mICR7bWF4fS5gO1xuXG5jb25zdCBNSVNTSU5HX0tFWV9QUk9QRVJUWSA9IChuYW1lKSA9PiBgTWlzc2luZyAke25hbWV9IHByb3BlcnR5IGluIGtleWA7XG5cbmNvbnN0IElOVkFMSURfS0VZX1dFSUdIVF9WQUxVRSA9IChrZXkpID0+XG4gIGBQcm9wZXJ0eSAnd2VpZ2h0JyBpbiBrZXkgJyR7a2V5fScgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXJgO1xuXG5jb25zdCBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG5jbGFzcyBLZXlTdG9yZSB7XG4gIGNvbnN0cnVjdG9yKGtleXMpIHtcbiAgICB0aGlzLl9rZXlzID0gW107XG4gICAgdGhpcy5fa2V5TWFwID0ge307XG5cbiAgICBsZXQgdG90YWxXZWlnaHQgPSAwO1xuXG4gICAga2V5cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIGxldCBvYmogPSBjcmVhdGVLZXkoa2V5KTtcblxuICAgICAgdG90YWxXZWlnaHQgKz0gb2JqLndlaWdodDtcblxuICAgICAgdGhpcy5fa2V5cy5wdXNoKG9iaik7XG4gICAgICB0aGlzLl9rZXlNYXBbb2JqLmlkXSA9IG9iajtcblxuICAgICAgdG90YWxXZWlnaHQgKz0gb2JqLndlaWdodDtcbiAgICB9KTtcblxuICAgIC8vIE5vcm1hbGl6ZSB3ZWlnaHRzIHNvIHRoYXQgdGhlaXIgc3VtIGlzIGVxdWFsIHRvIDFcbiAgICB0aGlzLl9rZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAga2V5LndlaWdodCAvPSB0b3RhbFdlaWdodDtcbiAgICB9KTtcbiAgfVxuICBnZXQoa2V5SWQpIHtcbiAgICByZXR1cm4gdGhpcy5fa2V5TWFwW2tleUlkXVxuICB9XG4gIGtleXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2tleXNcbiAgfVxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMuX2tleXMpXG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlS2V5KGtleSkge1xuICBsZXQgcGF0aCA9IG51bGw7XG4gIGxldCBpZCA9IG51bGw7XG4gIGxldCBzcmMgPSBudWxsO1xuICBsZXQgd2VpZ2h0ID0gMTtcblxuICBpZiAoaXNTdHJpbmcoa2V5KSB8fCBpc0FycmF5KGtleSkpIHtcbiAgICBzcmMgPSBrZXk7XG4gICAgcGF0aCA9IGNyZWF0ZUtleVBhdGgoa2V5KTtcbiAgICBpZCA9IGNyZWF0ZUtleUlkKGtleSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKCFoYXNPd24uY2FsbChrZXksICduYW1lJykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihNSVNTSU5HX0tFWV9QUk9QRVJUWSgnbmFtZScpKVxuICAgIH1cblxuICAgIGNvbnN0IG5hbWUgPSBrZXkubmFtZTtcbiAgICBzcmMgPSBuYW1lO1xuXG4gICAgaWYgKGhhc093bi5jYWxsKGtleSwgJ3dlaWdodCcpKSB7XG4gICAgICB3ZWlnaHQgPSBrZXkud2VpZ2h0O1xuXG4gICAgICBpZiAod2VpZ2h0IDw9IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKElOVkFMSURfS0VZX1dFSUdIVF9WQUxVRShuYW1lKSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwYXRoID0gY3JlYXRlS2V5UGF0aChuYW1lKTtcbiAgICBpZCA9IGNyZWF0ZUtleUlkKG5hbWUpO1xuICB9XG5cbiAgcmV0dXJuIHsgcGF0aCwgaWQsIHdlaWdodCwgc3JjIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlS2V5UGF0aChrZXkpIHtcbiAgcmV0dXJuIGlzQXJyYXkoa2V5KSA/IGtleSA6IGtleS5zcGxpdCgnLicpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUtleUlkKGtleSkge1xuICByZXR1cm4gaXNBcnJheShrZXkpID8ga2V5LmpvaW4oJy4nKSA6IGtleVxufVxuXG5mdW5jdGlvbiBnZXQob2JqLCBwYXRoKSB7XG4gIGxldCBsaXN0ID0gW107XG4gIGxldCBhcnIgPSBmYWxzZTtcblxuICBjb25zdCBkZWVwR2V0ID0gKG9iaiwgcGF0aCwgaW5kZXgpID0+IHtcbiAgICBpZiAoIWlzRGVmaW5lZChvYmopKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgaWYgKCFwYXRoW2luZGV4XSkge1xuICAgICAgLy8gSWYgdGhlcmUncyBubyBwYXRoIGxlZnQsIHdlJ3ZlIGFycml2ZWQgYXQgdGhlIG9iamVjdCB3ZSBjYXJlIGFib3V0LlxuICAgICAgbGlzdC5wdXNoKG9iaik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBrZXkgPSBwYXRoW2luZGV4XTtcblxuICAgICAgY29uc3QgdmFsdWUgPSBvYmpba2V5XTtcblxuICAgICAgaWYgKCFpc0RlZmluZWQodmFsdWUpKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyBJZiB3ZSdyZSBhdCB0aGUgbGFzdCB2YWx1ZSBpbiB0aGUgcGF0aCwgYW5kIGlmIGl0J3MgYSBzdHJpbmcvbnVtYmVyL2Jvb2wsXG4gICAgICAvLyBhZGQgaXQgdG8gdGhlIGxpc3RcbiAgICAgIGlmIChcbiAgICAgICAgaW5kZXggPT09IHBhdGgubGVuZ3RoIC0gMSAmJlxuICAgICAgICAoaXNTdHJpbmcodmFsdWUpIHx8IGlzTnVtYmVyKHZhbHVlKSB8fCBpc0Jvb2xlYW4odmFsdWUpKVxuICAgICAgKSB7XG4gICAgICAgIGxpc3QucHVzaCh0b1N0cmluZyh2YWx1ZSkpO1xuICAgICAgfSBlbHNlIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICBhcnIgPSB0cnVlO1xuICAgICAgICAvLyBTZWFyY2ggZWFjaCBpdGVtIGluIHRoZSBhcnJheS5cbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHZhbHVlLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgZGVlcEdldCh2YWx1ZVtpXSwgcGF0aCwgaW5kZXggKyAxKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwYXRoLmxlbmd0aCkge1xuICAgICAgICAvLyBBbiBvYmplY3QuIFJlY3Vyc2UgZnVydGhlci5cbiAgICAgICAgZGVlcEdldCh2YWx1ZSwgcGF0aCwgaW5kZXggKyAxKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHkgKHNpbmNlIHBhdGggdXNlZCB0byBiZSBhIHN0cmluZylcbiAgZGVlcEdldChvYmosIGlzU3RyaW5nKHBhdGgpID8gcGF0aC5zcGxpdCgnLicpIDogcGF0aCwgMCk7XG5cbiAgcmV0dXJuIGFyciA/IGxpc3QgOiBsaXN0WzBdXG59XG5cbmNvbnN0IE1hdGNoT3B0aW9ucyA9IHtcbiAgLy8gV2hldGhlciB0aGUgbWF0Y2hlcyBzaG91bGQgYmUgaW5jbHVkZWQgaW4gdGhlIHJlc3VsdCBzZXQuIFdoZW4gYHRydWVgLCBlYWNoIHJlY29yZCBpbiB0aGUgcmVzdWx0XG4gIC8vIHNldCB3aWxsIGluY2x1ZGUgdGhlIGluZGljZXMgb2YgdGhlIG1hdGNoZWQgY2hhcmFjdGVycy5cbiAgLy8gVGhlc2UgY2FuIGNvbnNlcXVlbnRseSBiZSB1c2VkIGZvciBoaWdobGlnaHRpbmcgcHVycG9zZXMuXG4gIGluY2x1ZGVNYXRjaGVzOiBmYWxzZSxcbiAgLy8gV2hlbiBgdHJ1ZWAsIHRoZSBtYXRjaGluZyBmdW5jdGlvbiB3aWxsIGNvbnRpbnVlIHRvIHRoZSBlbmQgb2YgYSBzZWFyY2ggcGF0dGVybiBldmVuIGlmXG4gIC8vIGEgcGVyZmVjdCBtYXRjaCBoYXMgYWxyZWFkeSBiZWVuIGxvY2F0ZWQgaW4gdGhlIHN0cmluZy5cbiAgZmluZEFsbE1hdGNoZXM6IGZhbHNlLFxuICAvLyBNaW5pbXVtIG51bWJlciBvZiBjaGFyYWN0ZXJzIHRoYXQgbXVzdCBiZSBtYXRjaGVkIGJlZm9yZSBhIHJlc3VsdCBpcyBjb25zaWRlcmVkIGEgbWF0Y2hcbiAgbWluTWF0Y2hDaGFyTGVuZ3RoOiAxXG59O1xuXG5jb25zdCBCYXNpY09wdGlvbnMgPSB7XG4gIC8vIFdoZW4gYHRydWVgLCB0aGUgYWxnb3JpdGhtIGNvbnRpbnVlcyBzZWFyY2hpbmcgdG8gdGhlIGVuZCBvZiB0aGUgaW5wdXQgZXZlbiBpZiBhIHBlcmZlY3RcbiAgLy8gbWF0Y2ggaXMgZm91bmQgYmVmb3JlIHRoZSBlbmQgb2YgdGhlIHNhbWUgaW5wdXQuXG4gIGlzQ2FzZVNlbnNpdGl2ZTogZmFsc2UsXG4gIC8vIFdoZW4gdHJ1ZSwgdGhlIG1hdGNoaW5nIGZ1bmN0aW9uIHdpbGwgY29udGludWUgdG8gdGhlIGVuZCBvZiBhIHNlYXJjaCBwYXR0ZXJuIGV2ZW4gaWZcbiAgaW5jbHVkZVNjb3JlOiBmYWxzZSxcbiAgLy8gTGlzdCBvZiBwcm9wZXJ0aWVzIHRoYXQgd2lsbCBiZSBzZWFyY2hlZC4gVGhpcyBhbHNvIHN1cHBvcnRzIG5lc3RlZCBwcm9wZXJ0aWVzLlxuICBrZXlzOiBbXSxcbiAgLy8gV2hldGhlciB0byBzb3J0IHRoZSByZXN1bHQgbGlzdCwgYnkgc2NvcmVcbiAgc2hvdWxkU29ydDogdHJ1ZSxcbiAgLy8gRGVmYXVsdCBzb3J0IGZ1bmN0aW9uOiBzb3J0IGJ5IGFzY2VuZGluZyBzY29yZSwgYXNjZW5kaW5nIGluZGV4XG4gIHNvcnRGbjogKGEsIGIpID0+XG4gICAgYS5zY29yZSA9PT0gYi5zY29yZSA/IChhLmlkeCA8IGIuaWR4ID8gLTEgOiAxKSA6IGEuc2NvcmUgPCBiLnNjb3JlID8gLTEgOiAxXG59O1xuXG5jb25zdCBGdXp6eU9wdGlvbnMgPSB7XG4gIC8vIEFwcHJveGltYXRlbHkgd2hlcmUgaW4gdGhlIHRleHQgaXMgdGhlIHBhdHRlcm4gZXhwZWN0ZWQgdG8gYmUgZm91bmQ/XG4gIGxvY2F0aW9uOiAwLFxuICAvLyBBdCB3aGF0IHBvaW50IGRvZXMgdGhlIG1hdGNoIGFsZ29yaXRobSBnaXZlIHVwLiBBIHRocmVzaG9sZCBvZiAnMC4wJyByZXF1aXJlcyBhIHBlcmZlY3QgbWF0Y2hcbiAgLy8gKG9mIGJvdGggbGV0dGVycyBhbmQgbG9jYXRpb24pLCBhIHRocmVzaG9sZCBvZiAnMS4wJyB3b3VsZCBtYXRjaCBhbnl0aGluZy5cbiAgdGhyZXNob2xkOiAwLjYsXG4gIC8vIERldGVybWluZXMgaG93IGNsb3NlIHRoZSBtYXRjaCBtdXN0IGJlIHRvIHRoZSBmdXp6eSBsb2NhdGlvbiAoc3BlY2lmaWVkIGFib3ZlKS5cbiAgLy8gQW4gZXhhY3QgbGV0dGVyIG1hdGNoIHdoaWNoIGlzICdkaXN0YW5jZScgY2hhcmFjdGVycyBhd2F5IGZyb20gdGhlIGZ1enp5IGxvY2F0aW9uXG4gIC8vIHdvdWxkIHNjb3JlIGFzIGEgY29tcGxldGUgbWlzbWF0Y2guIEEgZGlzdGFuY2Ugb2YgJzAnIHJlcXVpcmVzIHRoZSBtYXRjaCBiZSBhdFxuICAvLyB0aGUgZXhhY3QgbG9jYXRpb24gc3BlY2lmaWVkLCBhIHRocmVzaG9sZCBvZiAnMTAwMCcgd291bGQgcmVxdWlyZSBhIHBlcmZlY3QgbWF0Y2hcbiAgLy8gdG8gYmUgd2l0aGluIDgwMCBjaGFyYWN0ZXJzIG9mIHRoZSBmdXp6eSBsb2NhdGlvbiB0byBiZSBmb3VuZCB1c2luZyBhIDAuOCB0aHJlc2hvbGQuXG4gIGRpc3RhbmNlOiAxMDBcbn07XG5cbmNvbnN0IEFkdmFuY2VkT3B0aW9ucyA9IHtcbiAgLy8gV2hlbiBgdHJ1ZWAsIGl0IGVuYWJsZXMgdGhlIHVzZSBvZiB1bml4LWxpa2Ugc2VhcmNoIGNvbW1hbmRzXG4gIHVzZUV4dGVuZGVkU2VhcmNoOiBmYWxzZSxcbiAgLy8gVGhlIGdldCBmdW5jdGlvbiB0byB1c2Ugd2hlbiBmZXRjaGluZyBhbiBvYmplY3QncyBwcm9wZXJ0aWVzLlxuICAvLyBUaGUgZGVmYXVsdCB3aWxsIHNlYXJjaCBuZXN0ZWQgcGF0aHMgKmllIGZvby5iYXIuYmF6KlxuICBnZXRGbjogZ2V0LFxuICAvLyBXaGVuIGB0cnVlYCwgc2VhcmNoIHdpbGwgaWdub3JlIGBsb2NhdGlvbmAgYW5kIGBkaXN0YW5jZWAsIHNvIGl0IHdvbid0IG1hdHRlclxuICAvLyB3aGVyZSBpbiB0aGUgc3RyaW5nIHRoZSBwYXR0ZXJuIGFwcGVhcnMuXG4gIC8vIE1vcmUgaW5mbzogaHR0cHM6Ly9mdXNlanMuaW8vY29uY2VwdHMvc2NvcmluZy10aGVvcnkuaHRtbCNmdXp6aW5lc3Mtc2NvcmVcbiAgaWdub3JlTG9jYXRpb246IGZhbHNlLFxuICAvLyBXaGVuIGB0cnVlYCwgdGhlIGNhbGN1bGF0aW9uIGZvciB0aGUgcmVsZXZhbmNlIHNjb3JlICh1c2VkIGZvciBzb3J0aW5nKSB3aWxsXG4gIC8vIGlnbm9yZSB0aGUgZmllbGQtbGVuZ3RoIG5vcm0uXG4gIC8vIE1vcmUgaW5mbzogaHR0cHM6Ly9mdXNlanMuaW8vY29uY2VwdHMvc2NvcmluZy10aGVvcnkuaHRtbCNmaWVsZC1sZW5ndGgtbm9ybVxuICBpZ25vcmVGaWVsZE5vcm06IGZhbHNlXG59O1xuXG52YXIgQ29uZmlnID0ge1xuICAuLi5CYXNpY09wdGlvbnMsXG4gIC4uLk1hdGNoT3B0aW9ucyxcbiAgLi4uRnV6enlPcHRpb25zLFxuICAuLi5BZHZhbmNlZE9wdGlvbnNcbn07XG5cbmNvbnN0IFNQQUNFID0gL1teIF0rL2c7XG5cbi8vIEZpZWxkLWxlbmd0aCBub3JtOiB0aGUgc2hvcnRlciB0aGUgZmllbGQsIHRoZSBoaWdoZXIgdGhlIHdlaWdodC5cbi8vIFNldCB0byAzIGRlY2ltYWxzIHRvIHJlZHVjZSBpbmRleCBzaXplLlxuZnVuY3Rpb24gbm9ybShtYW50aXNzYSA9IDMpIHtcbiAgY29uc3QgY2FjaGUgPSBuZXcgTWFwKCk7XG4gIGNvbnN0IG0gPSBNYXRoLnBvdygxMCwgbWFudGlzc2EpO1xuXG4gIHJldHVybiB7XG4gICAgZ2V0KHZhbHVlKSB7XG4gICAgICBjb25zdCBudW1Ub2tlbnMgPSB2YWx1ZS5tYXRjaChTUEFDRSkubGVuZ3RoO1xuXG4gICAgICBpZiAoY2FjaGUuaGFzKG51bVRva2VucykpIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlLmdldChudW1Ub2tlbnMpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG5vcm0gPSAxIC8gTWF0aC5zcXJ0KG51bVRva2Vucyk7XG5cbiAgICAgIC8vIEluIHBsYWNlIG9mIGB0b0ZpeGVkKG1hbnRpc3NhKWAsIGZvciBmYXN0ZXIgY29tcHV0YXRpb25cbiAgICAgIGNvbnN0IG4gPSBwYXJzZUZsb2F0KE1hdGgucm91bmQobm9ybSAqIG0pIC8gbSk7XG5cbiAgICAgIGNhY2hlLnNldChudW1Ub2tlbnMsIG4pO1xuXG4gICAgICByZXR1cm4gblxuICAgIH0sXG4gICAgY2xlYXIoKSB7XG4gICAgICBjYWNoZS5jbGVhcigpO1xuICAgIH1cbiAgfVxufVxuXG5jbGFzcyBGdXNlSW5kZXgge1xuICBjb25zdHJ1Y3Rvcih7IGdldEZuID0gQ29uZmlnLmdldEZuIH0gPSB7fSkge1xuICAgIHRoaXMubm9ybSA9IG5vcm0oMyk7XG4gICAgdGhpcy5nZXRGbiA9IGdldEZuO1xuICAgIHRoaXMuaXNDcmVhdGVkID0gZmFsc2U7XG5cbiAgICB0aGlzLnNldEluZGV4UmVjb3JkcygpO1xuICB9XG4gIHNldFNvdXJjZXMoZG9jcyA9IFtdKSB7XG4gICAgdGhpcy5kb2NzID0gZG9jcztcbiAgfVxuICBzZXRJbmRleFJlY29yZHMocmVjb3JkcyA9IFtdKSB7XG4gICAgdGhpcy5yZWNvcmRzID0gcmVjb3JkcztcbiAgfVxuICBzZXRLZXlzKGtleXMgPSBbXSkge1xuICAgIHRoaXMua2V5cyA9IGtleXM7XG4gICAgdGhpcy5fa2V5c01hcCA9IHt9O1xuICAgIGtleXMuZm9yRWFjaCgoa2V5LCBpZHgpID0+IHtcbiAgICAgIHRoaXMuX2tleXNNYXBba2V5LmlkXSA9IGlkeDtcbiAgICB9KTtcbiAgfVxuICBjcmVhdGUoKSB7XG4gICAgaWYgKHRoaXMuaXNDcmVhdGVkIHx8ICF0aGlzLmRvY3MubGVuZ3RoKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLmlzQ3JlYXRlZCA9IHRydWU7XG5cbiAgICAvLyBMaXN0IGlzIEFycmF5PFN0cmluZz5cbiAgICBpZiAoaXNTdHJpbmcodGhpcy5kb2NzWzBdKSkge1xuICAgICAgdGhpcy5kb2NzLmZvckVhY2goKGRvYywgZG9jSW5kZXgpID0+IHtcbiAgICAgICAgdGhpcy5fYWRkU3RyaW5nKGRvYywgZG9jSW5kZXgpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIExpc3QgaXMgQXJyYXk8T2JqZWN0PlxuICAgICAgdGhpcy5kb2NzLmZvckVhY2goKGRvYywgZG9jSW5kZXgpID0+IHtcbiAgICAgICAgdGhpcy5fYWRkT2JqZWN0KGRvYywgZG9jSW5kZXgpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5ub3JtLmNsZWFyKCk7XG4gIH1cbiAgLy8gQWRkcyBhIGRvYyB0byB0aGUgZW5kIG9mIHRoZSBpbmRleFxuICBhZGQoZG9jKSB7XG4gICAgY29uc3QgaWR4ID0gdGhpcy5zaXplKCk7XG5cbiAgICBpZiAoaXNTdHJpbmcoZG9jKSkge1xuICAgICAgdGhpcy5fYWRkU3RyaW5nKGRvYywgaWR4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fYWRkT2JqZWN0KGRvYywgaWR4KTtcbiAgICB9XG4gIH1cbiAgLy8gUmVtb3ZlcyB0aGUgZG9jIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXggb2YgdGhlIGluZGV4XG4gIHJlbW92ZUF0KGlkeCkge1xuICAgIHRoaXMucmVjb3Jkcy5zcGxpY2UoaWR4LCAxKTtcblxuICAgIC8vIENoYW5nZSByZWYgaW5kZXggb2YgZXZlcnkgc3Vic3F1ZW50IGRvY1xuICAgIGZvciAobGV0IGkgPSBpZHgsIGxlbiA9IHRoaXMuc2l6ZSgpOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIHRoaXMucmVjb3Jkc1tpXS5pIC09IDE7XG4gICAgfVxuICB9XG4gIGdldFZhbHVlRm9ySXRlbUF0S2V5SWQoaXRlbSwga2V5SWQpIHtcbiAgICByZXR1cm4gaXRlbVt0aGlzLl9rZXlzTWFwW2tleUlkXV1cbiAgfVxuICBzaXplKCkge1xuICAgIHJldHVybiB0aGlzLnJlY29yZHMubGVuZ3RoXG4gIH1cbiAgX2FkZFN0cmluZyhkb2MsIGRvY0luZGV4KSB7XG4gICAgaWYgKCFpc0RlZmluZWQoZG9jKSB8fCBpc0JsYW5rKGRvYykpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGxldCByZWNvcmQgPSB7XG4gICAgICB2OiBkb2MsXG4gICAgICBpOiBkb2NJbmRleCxcbiAgICAgIG46IHRoaXMubm9ybS5nZXQoZG9jKVxuICAgIH07XG5cbiAgICB0aGlzLnJlY29yZHMucHVzaChyZWNvcmQpO1xuICB9XG4gIF9hZGRPYmplY3QoZG9jLCBkb2NJbmRleCkge1xuICAgIGxldCByZWNvcmQgPSB7IGk6IGRvY0luZGV4LCAkOiB7fSB9O1xuXG4gICAgLy8gSXRlcmF0ZSBvdmVyIGV2ZXJ5IGtleSAoaS5lLCBwYXRoKSwgYW5kIGZldGNoIHRoZSB2YWx1ZSBhdCB0aGF0IGtleVxuICAgIHRoaXMua2V5cy5mb3JFYWNoKChrZXksIGtleUluZGV4KSA9PiB7XG4gICAgICAvLyBjb25zb2xlLmxvZyhrZXkpXG4gICAgICBsZXQgdmFsdWUgPSB0aGlzLmdldEZuKGRvYywga2V5LnBhdGgpO1xuXG4gICAgICBpZiAoIWlzRGVmaW5lZCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICBsZXQgc3ViUmVjb3JkcyA9IFtdO1xuICAgICAgICBjb25zdCBzdGFjayA9IFt7IG5lc3RlZEFyckluZGV4OiAtMSwgdmFsdWUgfV07XG5cbiAgICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCkge1xuICAgICAgICAgIGNvbnN0IHsgbmVzdGVkQXJySW5kZXgsIHZhbHVlIH0gPSBzdGFjay5wb3AoKTtcblxuICAgICAgICAgIGlmICghaXNEZWZpbmVkKHZhbHVlKSkge1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaXNTdHJpbmcodmFsdWUpICYmICFpc0JsYW5rKHZhbHVlKSkge1xuICAgICAgICAgICAgbGV0IHN1YlJlY29yZCA9IHtcbiAgICAgICAgICAgICAgdjogdmFsdWUsXG4gICAgICAgICAgICAgIGk6IG5lc3RlZEFyckluZGV4LFxuICAgICAgICAgICAgICBuOiB0aGlzLm5vcm0uZ2V0KHZhbHVlKVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgc3ViUmVjb3Jkcy5wdXNoKHN1YlJlY29yZCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgdmFsdWUuZm9yRWFjaCgoaXRlbSwgaykgPT4ge1xuICAgICAgICAgICAgICBzdGFjay5wdXNoKHtcbiAgICAgICAgICAgICAgICBuZXN0ZWRBcnJJbmRleDogayxcbiAgICAgICAgICAgICAgICB2YWx1ZTogaXRlbVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZWNvcmQuJFtrZXlJbmRleF0gPSBzdWJSZWNvcmRzO1xuICAgICAgfSBlbHNlIGlmICghaXNCbGFuayh2YWx1ZSkpIHtcbiAgICAgICAgbGV0IHN1YlJlY29yZCA9IHtcbiAgICAgICAgICB2OiB2YWx1ZSxcbiAgICAgICAgICBuOiB0aGlzLm5vcm0uZ2V0KHZhbHVlKVxuICAgICAgICB9O1xuXG4gICAgICAgIHJlY29yZC4kW2tleUluZGV4XSA9IHN1YlJlY29yZDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMucmVjb3Jkcy5wdXNoKHJlY29yZCk7XG4gIH1cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBrZXlzOiB0aGlzLmtleXMsXG4gICAgICByZWNvcmRzOiB0aGlzLnJlY29yZHNcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlSW5kZXgoa2V5cywgZG9jcywgeyBnZXRGbiA9IENvbmZpZy5nZXRGbiB9ID0ge30pIHtcbiAgY29uc3QgbXlJbmRleCA9IG5ldyBGdXNlSW5kZXgoeyBnZXRGbiB9KTtcbiAgbXlJbmRleC5zZXRLZXlzKGtleXMubWFwKGNyZWF0ZUtleSkpO1xuICBteUluZGV4LnNldFNvdXJjZXMoZG9jcyk7XG4gIG15SW5kZXguY3JlYXRlKCk7XG4gIHJldHVybiBteUluZGV4XG59XG5cbmZ1bmN0aW9uIHBhcnNlSW5kZXgoZGF0YSwgeyBnZXRGbiA9IENvbmZpZy5nZXRGbiB9ID0ge30pIHtcbiAgY29uc3QgeyBrZXlzLCByZWNvcmRzIH0gPSBkYXRhO1xuICBjb25zdCBteUluZGV4ID0gbmV3IEZ1c2VJbmRleCh7IGdldEZuIH0pO1xuICBteUluZGV4LnNldEtleXMoa2V5cyk7XG4gIG15SW5kZXguc2V0SW5kZXhSZWNvcmRzKHJlY29yZHMpO1xuICByZXR1cm4gbXlJbmRleFxufVxuXG5mdW5jdGlvbiBjb21wdXRlU2NvcmUoXG4gIHBhdHRlcm4sXG4gIHtcbiAgICBlcnJvcnMgPSAwLFxuICAgIGN1cnJlbnRMb2NhdGlvbiA9IDAsXG4gICAgZXhwZWN0ZWRMb2NhdGlvbiA9IDAsXG4gICAgZGlzdGFuY2UgPSBDb25maWcuZGlzdGFuY2UsXG4gICAgaWdub3JlTG9jYXRpb24gPSBDb25maWcuaWdub3JlTG9jYXRpb25cbiAgfSA9IHt9XG4pIHtcbiAgY29uc3QgYWNjdXJhY3kgPSBlcnJvcnMgLyBwYXR0ZXJuLmxlbmd0aDtcblxuICBpZiAoaWdub3JlTG9jYXRpb24pIHtcbiAgICByZXR1cm4gYWNjdXJhY3lcbiAgfVxuXG4gIGNvbnN0IHByb3hpbWl0eSA9IE1hdGguYWJzKGV4cGVjdGVkTG9jYXRpb24gLSBjdXJyZW50TG9jYXRpb24pO1xuXG4gIGlmICghZGlzdGFuY2UpIHtcbiAgICAvLyBEb2RnZSBkaXZpZGUgYnkgemVybyBlcnJvci5cbiAgICByZXR1cm4gcHJveGltaXR5ID8gMS4wIDogYWNjdXJhY3lcbiAgfVxuXG4gIHJldHVybiBhY2N1cmFjeSArIHByb3hpbWl0eSAvIGRpc3RhbmNlXG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRNYXNrVG9JbmRpY2VzKFxuICBtYXRjaG1hc2sgPSBbXSxcbiAgbWluTWF0Y2hDaGFyTGVuZ3RoID0gQ29uZmlnLm1pbk1hdGNoQ2hhckxlbmd0aFxuKSB7XG4gIGxldCBpbmRpY2VzID0gW107XG4gIGxldCBzdGFydCA9IC0xO1xuICBsZXQgZW5kID0gLTE7XG4gIGxldCBpID0gMDtcblxuICBmb3IgKGxldCBsZW4gPSBtYXRjaG1hc2subGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICBsZXQgbWF0Y2ggPSBtYXRjaG1hc2tbaV07XG4gICAgaWYgKG1hdGNoICYmIHN0YXJ0ID09PSAtMSkge1xuICAgICAgc3RhcnQgPSBpO1xuICAgIH0gZWxzZSBpZiAoIW1hdGNoICYmIHN0YXJ0ICE9PSAtMSkge1xuICAgICAgZW5kID0gaSAtIDE7XG4gICAgICBpZiAoZW5kIC0gc3RhcnQgKyAxID49IG1pbk1hdGNoQ2hhckxlbmd0aCkge1xuICAgICAgICBpbmRpY2VzLnB1c2goW3N0YXJ0LCBlbmRdKTtcbiAgICAgIH1cbiAgICAgIHN0YXJ0ID0gLTE7XG4gICAgfVxuICB9XG5cbiAgLy8gKGktMSAtIHN0YXJ0KSArIDEgPT4gaSAtIHN0YXJ0XG4gIGlmIChtYXRjaG1hc2tbaSAtIDFdICYmIGkgLSBzdGFydCA+PSBtaW5NYXRjaENoYXJMZW5ndGgpIHtcbiAgICBpbmRpY2VzLnB1c2goW3N0YXJ0LCBpIC0gMV0pO1xuICB9XG5cbiAgcmV0dXJuIGluZGljZXNcbn1cblxuLy8gTWFjaGluZSB3b3JkIHNpemVcbmNvbnN0IE1BWF9CSVRTID0gMzI7XG5cbmZ1bmN0aW9uIHNlYXJjaChcbiAgdGV4dCxcbiAgcGF0dGVybixcbiAgcGF0dGVybkFscGhhYmV0LFxuICB7XG4gICAgbG9jYXRpb24gPSBDb25maWcubG9jYXRpb24sXG4gICAgZGlzdGFuY2UgPSBDb25maWcuZGlzdGFuY2UsXG4gICAgdGhyZXNob2xkID0gQ29uZmlnLnRocmVzaG9sZCxcbiAgICBmaW5kQWxsTWF0Y2hlcyA9IENvbmZpZy5maW5kQWxsTWF0Y2hlcyxcbiAgICBtaW5NYXRjaENoYXJMZW5ndGggPSBDb25maWcubWluTWF0Y2hDaGFyTGVuZ3RoLFxuICAgIGluY2x1ZGVNYXRjaGVzID0gQ29uZmlnLmluY2x1ZGVNYXRjaGVzLFxuICAgIGlnbm9yZUxvY2F0aW9uID0gQ29uZmlnLmlnbm9yZUxvY2F0aW9uXG4gIH0gPSB7fVxuKSB7XG4gIGlmIChwYXR0ZXJuLmxlbmd0aCA+IE1BWF9CSVRTKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFBBVFRFUk5fTEVOR1RIX1RPT19MQVJHRShNQVhfQklUUykpXG4gIH1cblxuICBjb25zdCBwYXR0ZXJuTGVuID0gcGF0dGVybi5sZW5ndGg7XG4gIC8vIFNldCBzdGFydGluZyBsb2NhdGlvbiBhdCBiZWdpbm5pbmcgdGV4dCBhbmQgaW5pdGlhbGl6ZSB0aGUgYWxwaGFiZXQuXG4gIGNvbnN0IHRleHRMZW4gPSB0ZXh0Lmxlbmd0aDtcbiAgLy8gSGFuZGxlIHRoZSBjYXNlIHdoZW4gbG9jYXRpb24gPiB0ZXh0Lmxlbmd0aFxuICBjb25zdCBleHBlY3RlZExvY2F0aW9uID0gTWF0aC5tYXgoMCwgTWF0aC5taW4obG9jYXRpb24sIHRleHRMZW4pKTtcbiAgLy8gSGlnaGVzdCBzY29yZSBiZXlvbmQgd2hpY2ggd2UgZ2l2ZSB1cC5cbiAgbGV0IGN1cnJlbnRUaHJlc2hvbGQgPSB0aHJlc2hvbGQ7XG4gIC8vIElzIHRoZXJlIGEgbmVhcmJ5IGV4YWN0IG1hdGNoPyAoc3BlZWR1cClcbiAgbGV0IGJlc3RMb2NhdGlvbiA9IGV4cGVjdGVkTG9jYXRpb247XG5cbiAgLy8gUGVyZm9ybWFuY2U6IG9ubHkgY29tcHV0ZXIgbWF0Y2hlcyB3aGVuIHRoZSBtaW5NYXRjaENoYXJMZW5ndGggPiAxXG4gIC8vIE9SIGlmIGBpbmNsdWRlTWF0Y2hlc2AgaXMgdHJ1ZS5cbiAgY29uc3QgY29tcHV0ZU1hdGNoZXMgPSBtaW5NYXRjaENoYXJMZW5ndGggPiAxIHx8IGluY2x1ZGVNYXRjaGVzO1xuICAvLyBBIG1hc2sgb2YgdGhlIG1hdGNoZXMsIHVzZWQgZm9yIGJ1aWxkaW5nIHRoZSBpbmRpY2VzXG4gIGNvbnN0IG1hdGNoTWFzayA9IGNvbXB1dGVNYXRjaGVzID8gQXJyYXkodGV4dExlbikgOiBbXTtcblxuICBsZXQgaW5kZXg7XG5cbiAgLy8gR2V0IGFsbCBleGFjdCBtYXRjaGVzLCBoZXJlIGZvciBzcGVlZCB1cFxuICB3aGlsZSAoKGluZGV4ID0gdGV4dC5pbmRleE9mKHBhdHRlcm4sIGJlc3RMb2NhdGlvbikpID4gLTEpIHtcbiAgICBsZXQgc2NvcmUgPSBjb21wdXRlU2NvcmUocGF0dGVybiwge1xuICAgICAgY3VycmVudExvY2F0aW9uOiBpbmRleCxcbiAgICAgIGV4cGVjdGVkTG9jYXRpb24sXG4gICAgICBkaXN0YW5jZSxcbiAgICAgIGlnbm9yZUxvY2F0aW9uXG4gICAgfSk7XG5cbiAgICBjdXJyZW50VGhyZXNob2xkID0gTWF0aC5taW4oc2NvcmUsIGN1cnJlbnRUaHJlc2hvbGQpO1xuICAgIGJlc3RMb2NhdGlvbiA9IGluZGV4ICsgcGF0dGVybkxlbjtcblxuICAgIGlmIChjb21wdXRlTWF0Y2hlcykge1xuICAgICAgbGV0IGkgPSAwO1xuICAgICAgd2hpbGUgKGkgPCBwYXR0ZXJuTGVuKSB7XG4gICAgICAgIG1hdGNoTWFza1tpbmRleCArIGldID0gMTtcbiAgICAgICAgaSArPSAxO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFJlc2V0IHRoZSBiZXN0IGxvY2F0aW9uXG4gIGJlc3RMb2NhdGlvbiA9IC0xO1xuXG4gIGxldCBsYXN0Qml0QXJyID0gW107XG4gIGxldCBmaW5hbFNjb3JlID0gMTtcbiAgbGV0IGJpbk1heCA9IHBhdHRlcm5MZW4gKyB0ZXh0TGVuO1xuXG4gIGNvbnN0IG1hc2sgPSAxIDw8IChwYXR0ZXJuTGVuIC0gMSk7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXR0ZXJuTGVuOyBpICs9IDEpIHtcbiAgICAvLyBTY2FuIGZvciB0aGUgYmVzdCBtYXRjaDsgZWFjaCBpdGVyYXRpb24gYWxsb3dzIGZvciBvbmUgbW9yZSBlcnJvci5cbiAgICAvLyBSdW4gYSBiaW5hcnkgc2VhcmNoIHRvIGRldGVybWluZSBob3cgZmFyIGZyb20gdGhlIG1hdGNoIGxvY2F0aW9uIHdlIGNhbiBzdHJheVxuICAgIC8vIGF0IHRoaXMgZXJyb3IgbGV2ZWwuXG4gICAgbGV0IGJpbk1pbiA9IDA7XG4gICAgbGV0IGJpbk1pZCA9IGJpbk1heDtcblxuICAgIHdoaWxlIChiaW5NaW4gPCBiaW5NaWQpIHtcbiAgICAgIGNvbnN0IHNjb3JlID0gY29tcHV0ZVNjb3JlKHBhdHRlcm4sIHtcbiAgICAgICAgZXJyb3JzOiBpLFxuICAgICAgICBjdXJyZW50TG9jYXRpb246IGV4cGVjdGVkTG9jYXRpb24gKyBiaW5NaWQsXG4gICAgICAgIGV4cGVjdGVkTG9jYXRpb24sXG4gICAgICAgIGRpc3RhbmNlLFxuICAgICAgICBpZ25vcmVMb2NhdGlvblxuICAgICAgfSk7XG5cbiAgICAgIGlmIChzY29yZSA8PSBjdXJyZW50VGhyZXNob2xkKSB7XG4gICAgICAgIGJpbk1pbiA9IGJpbk1pZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJpbk1heCA9IGJpbk1pZDtcbiAgICAgIH1cblxuICAgICAgYmluTWlkID0gTWF0aC5mbG9vcigoYmluTWF4IC0gYmluTWluKSAvIDIgKyBiaW5NaW4pO1xuICAgIH1cblxuICAgIC8vIFVzZSB0aGUgcmVzdWx0IGZyb20gdGhpcyBpdGVyYXRpb24gYXMgdGhlIG1heGltdW0gZm9yIHRoZSBuZXh0LlxuICAgIGJpbk1heCA9IGJpbk1pZDtcblxuICAgIGxldCBzdGFydCA9IE1hdGgubWF4KDEsIGV4cGVjdGVkTG9jYXRpb24gLSBiaW5NaWQgKyAxKTtcbiAgICBsZXQgZmluaXNoID0gZmluZEFsbE1hdGNoZXNcbiAgICAgID8gdGV4dExlblxuICAgICAgOiBNYXRoLm1pbihleHBlY3RlZExvY2F0aW9uICsgYmluTWlkLCB0ZXh0TGVuKSArIHBhdHRlcm5MZW47XG5cbiAgICAvLyBJbml0aWFsaXplIHRoZSBiaXQgYXJyYXlcbiAgICBsZXQgYml0QXJyID0gQXJyYXkoZmluaXNoICsgMik7XG5cbiAgICBiaXRBcnJbZmluaXNoICsgMV0gPSAoMSA8PCBpKSAtIDE7XG5cbiAgICBmb3IgKGxldCBqID0gZmluaXNoOyBqID49IHN0YXJ0OyBqIC09IDEpIHtcbiAgICAgIGxldCBjdXJyZW50TG9jYXRpb24gPSBqIC0gMTtcbiAgICAgIGxldCBjaGFyTWF0Y2ggPSBwYXR0ZXJuQWxwaGFiZXRbdGV4dC5jaGFyQXQoY3VycmVudExvY2F0aW9uKV07XG5cbiAgICAgIGlmIChjb21wdXRlTWF0Y2hlcykge1xuICAgICAgICAvLyBTcGVlZCB1cDogcXVpY2sgYm9vbCB0byBpbnQgY29udmVyc2lvbiAoaS5lLCBgY2hhck1hdGNoID8gMSA6IDBgKVxuICAgICAgICBtYXRjaE1hc2tbY3VycmVudExvY2F0aW9uXSA9ICshIWNoYXJNYXRjaDtcbiAgICAgIH1cblxuICAgICAgLy8gRmlyc3QgcGFzczogZXhhY3QgbWF0Y2hcbiAgICAgIGJpdEFycltqXSA9ICgoYml0QXJyW2ogKyAxXSA8PCAxKSB8IDEpICYgY2hhck1hdGNoO1xuXG4gICAgICAvLyBTdWJzZXF1ZW50IHBhc3NlczogZnV6enkgbWF0Y2hcbiAgICAgIGlmIChpKSB7XG4gICAgICAgIGJpdEFycltqXSB8PVxuICAgICAgICAgICgobGFzdEJpdEFycltqICsgMV0gfCBsYXN0Qml0QXJyW2pdKSA8PCAxKSB8IDEgfCBsYXN0Qml0QXJyW2ogKyAxXTtcbiAgICAgIH1cblxuICAgICAgaWYgKGJpdEFycltqXSAmIG1hc2spIHtcbiAgICAgICAgZmluYWxTY29yZSA9IGNvbXB1dGVTY29yZShwYXR0ZXJuLCB7XG4gICAgICAgICAgZXJyb3JzOiBpLFxuICAgICAgICAgIGN1cnJlbnRMb2NhdGlvbixcbiAgICAgICAgICBleHBlY3RlZExvY2F0aW9uLFxuICAgICAgICAgIGRpc3RhbmNlLFxuICAgICAgICAgIGlnbm9yZUxvY2F0aW9uXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFRoaXMgbWF0Y2ggd2lsbCBhbG1vc3QgY2VydGFpbmx5IGJlIGJldHRlciB0aGFuIGFueSBleGlzdGluZyBtYXRjaC5cbiAgICAgICAgLy8gQnV0IGNoZWNrIGFueXdheS5cbiAgICAgICAgaWYgKGZpbmFsU2NvcmUgPD0gY3VycmVudFRocmVzaG9sZCkge1xuICAgICAgICAgIC8vIEluZGVlZCBpdCBpc1xuICAgICAgICAgIGN1cnJlbnRUaHJlc2hvbGQgPSBmaW5hbFNjb3JlO1xuICAgICAgICAgIGJlc3RMb2NhdGlvbiA9IGN1cnJlbnRMb2NhdGlvbjtcblxuICAgICAgICAgIC8vIEFscmVhZHkgcGFzc2VkIGBsb2NgLCBkb3duaGlsbCBmcm9tIGhlcmUgb24gaW4uXG4gICAgICAgICAgaWYgKGJlc3RMb2NhdGlvbiA8PSBleHBlY3RlZExvY2F0aW9uKSB7XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFdoZW4gcGFzc2luZyBgYmVzdExvY2F0aW9uYCwgZG9uJ3QgZXhjZWVkIG91ciBjdXJyZW50IGRpc3RhbmNlIGZyb20gYGV4cGVjdGVkTG9jYXRpb25gLlxuICAgICAgICAgIHN0YXJ0ID0gTWF0aC5tYXgoMSwgMiAqIGV4cGVjdGVkTG9jYXRpb24gLSBiZXN0TG9jYXRpb24pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gTm8gaG9wZSBmb3IgYSAoYmV0dGVyKSBtYXRjaCBhdCBncmVhdGVyIGVycm9yIGxldmVscy5cbiAgICBjb25zdCBzY29yZSA9IGNvbXB1dGVTY29yZShwYXR0ZXJuLCB7XG4gICAgICBlcnJvcnM6IGkgKyAxLFxuICAgICAgY3VycmVudExvY2F0aW9uOiBleHBlY3RlZExvY2F0aW9uLFxuICAgICAgZXhwZWN0ZWRMb2NhdGlvbixcbiAgICAgIGRpc3RhbmNlLFxuICAgICAgaWdub3JlTG9jYXRpb25cbiAgICB9KTtcblxuICAgIGlmIChzY29yZSA+IGN1cnJlbnRUaHJlc2hvbGQpIHtcbiAgICAgIGJyZWFrXG4gICAgfVxuXG4gICAgbGFzdEJpdEFyciA9IGJpdEFycjtcbiAgfVxuXG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICBpc01hdGNoOiBiZXN0TG9jYXRpb24gPj0gMCxcbiAgICAvLyBDb3VudCBleGFjdCBtYXRjaGVzICh0aG9zZSB3aXRoIGEgc2NvcmUgb2YgMCkgdG8gYmUgXCJhbG1vc3RcIiBleGFjdFxuICAgIHNjb3JlOiBNYXRoLm1heCgwLjAwMSwgZmluYWxTY29yZSlcbiAgfTtcblxuICBpZiAoY29tcHV0ZU1hdGNoZXMpIHtcbiAgICBjb25zdCBpbmRpY2VzID0gY29udmVydE1hc2tUb0luZGljZXMobWF0Y2hNYXNrLCBtaW5NYXRjaENoYXJMZW5ndGgpO1xuICAgIGlmICghaW5kaWNlcy5sZW5ndGgpIHtcbiAgICAgIHJlc3VsdC5pc01hdGNoID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChpbmNsdWRlTWF0Y2hlcykge1xuICAgICAgcmVzdWx0LmluZGljZXMgPSBpbmRpY2VzO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHRcbn1cblxuZnVuY3Rpb24gY3JlYXRlUGF0dGVybkFscGhhYmV0KHBhdHRlcm4pIHtcbiAgbGV0IG1hc2sgPSB7fTtcblxuICBmb3IgKGxldCBpID0gMCwgbGVuID0gcGF0dGVybi5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgIGNvbnN0IGNoYXIgPSBwYXR0ZXJuLmNoYXJBdChpKTtcbiAgICBtYXNrW2NoYXJdID0gKG1hc2tbY2hhcl0gfHwgMCkgfCAoMSA8PCAobGVuIC0gaSAtIDEpKTtcbiAgfVxuXG4gIHJldHVybiBtYXNrXG59XG5cbmNsYXNzIEJpdGFwU2VhcmNoIHtcbiAgY29uc3RydWN0b3IoXG4gICAgcGF0dGVybixcbiAgICB7XG4gICAgICBsb2NhdGlvbiA9IENvbmZpZy5sb2NhdGlvbixcbiAgICAgIHRocmVzaG9sZCA9IENvbmZpZy50aHJlc2hvbGQsXG4gICAgICBkaXN0YW5jZSA9IENvbmZpZy5kaXN0YW5jZSxcbiAgICAgIGluY2x1ZGVNYXRjaGVzID0gQ29uZmlnLmluY2x1ZGVNYXRjaGVzLFxuICAgICAgZmluZEFsbE1hdGNoZXMgPSBDb25maWcuZmluZEFsbE1hdGNoZXMsXG4gICAgICBtaW5NYXRjaENoYXJMZW5ndGggPSBDb25maWcubWluTWF0Y2hDaGFyTGVuZ3RoLFxuICAgICAgaXNDYXNlU2Vuc2l0aXZlID0gQ29uZmlnLmlzQ2FzZVNlbnNpdGl2ZSxcbiAgICAgIGlnbm9yZUxvY2F0aW9uID0gQ29uZmlnLmlnbm9yZUxvY2F0aW9uXG4gICAgfSA9IHt9XG4gICkge1xuICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgIGxvY2F0aW9uLFxuICAgICAgdGhyZXNob2xkLFxuICAgICAgZGlzdGFuY2UsXG4gICAgICBpbmNsdWRlTWF0Y2hlcyxcbiAgICAgIGZpbmRBbGxNYXRjaGVzLFxuICAgICAgbWluTWF0Y2hDaGFyTGVuZ3RoLFxuICAgICAgaXNDYXNlU2Vuc2l0aXZlLFxuICAgICAgaWdub3JlTG9jYXRpb25cbiAgICB9O1xuXG4gICAgdGhpcy5wYXR0ZXJuID0gaXNDYXNlU2Vuc2l0aXZlID8gcGF0dGVybiA6IHBhdHRlcm4udG9Mb3dlckNhc2UoKTtcblxuICAgIHRoaXMuY2h1bmtzID0gW107XG5cbiAgICBpZiAoIXRoaXMucGF0dGVybi5sZW5ndGgpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IGFkZENodW5rID0gKHBhdHRlcm4sIHN0YXJ0SW5kZXgpID0+IHtcbiAgICAgIHRoaXMuY2h1bmtzLnB1c2goe1xuICAgICAgICBwYXR0ZXJuLFxuICAgICAgICBhbHBoYWJldDogY3JlYXRlUGF0dGVybkFscGhhYmV0KHBhdHRlcm4pLFxuICAgICAgICBzdGFydEluZGV4XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgY29uc3QgbGVuID0gdGhpcy5wYXR0ZXJuLmxlbmd0aDtcblxuICAgIGlmIChsZW4gPiBNQVhfQklUUykge1xuICAgICAgbGV0IGkgPSAwO1xuICAgICAgY29uc3QgcmVtYWluZGVyID0gbGVuICUgTUFYX0JJVFM7XG4gICAgICBjb25zdCBlbmQgPSBsZW4gLSByZW1haW5kZXI7XG5cbiAgICAgIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgICAgIGFkZENodW5rKHRoaXMucGF0dGVybi5zdWJzdHIoaSwgTUFYX0JJVFMpLCBpKTtcbiAgICAgICAgaSArPSBNQVhfQklUUztcbiAgICAgIH1cblxuICAgICAgaWYgKHJlbWFpbmRlcikge1xuICAgICAgICBjb25zdCBzdGFydEluZGV4ID0gbGVuIC0gTUFYX0JJVFM7XG4gICAgICAgIGFkZENodW5rKHRoaXMucGF0dGVybi5zdWJzdHIoc3RhcnRJbmRleCksIHN0YXJ0SW5kZXgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBhZGRDaHVuayh0aGlzLnBhdHRlcm4sIDApO1xuICAgIH1cbiAgfVxuXG4gIHNlYXJjaEluKHRleHQpIHtcbiAgICBjb25zdCB7IGlzQ2FzZVNlbnNpdGl2ZSwgaW5jbHVkZU1hdGNoZXMgfSA9IHRoaXMub3B0aW9ucztcblxuICAgIGlmICghaXNDYXNlU2Vuc2l0aXZlKSB7XG4gICAgICB0ZXh0ID0gdGV4dC50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIC8vIEV4YWN0IG1hdGNoXG4gICAgaWYgKHRoaXMucGF0dGVybiA9PT0gdGV4dCkge1xuICAgICAgbGV0IHJlc3VsdCA9IHtcbiAgICAgICAgaXNNYXRjaDogdHJ1ZSxcbiAgICAgICAgc2NvcmU6IDBcbiAgICAgIH07XG5cbiAgICAgIGlmIChpbmNsdWRlTWF0Y2hlcykge1xuICAgICAgICByZXN1bHQuaW5kaWNlcyA9IFtbMCwgdGV4dC5sZW5ndGggLSAxXV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHRcbiAgICB9XG5cbiAgICAvLyBPdGhlcndpc2UsIHVzZSBCaXRhcCBhbGdvcml0aG1cbiAgICBjb25zdCB7XG4gICAgICBsb2NhdGlvbixcbiAgICAgIGRpc3RhbmNlLFxuICAgICAgdGhyZXNob2xkLFxuICAgICAgZmluZEFsbE1hdGNoZXMsXG4gICAgICBtaW5NYXRjaENoYXJMZW5ndGgsXG4gICAgICBpZ25vcmVMb2NhdGlvblxuICAgIH0gPSB0aGlzLm9wdGlvbnM7XG5cbiAgICBsZXQgYWxsSW5kaWNlcyA9IFtdO1xuICAgIGxldCB0b3RhbFNjb3JlID0gMDtcbiAgICBsZXQgaGFzTWF0Y2hlcyA9IGZhbHNlO1xuXG4gICAgdGhpcy5jaHVua3MuZm9yRWFjaCgoeyBwYXR0ZXJuLCBhbHBoYWJldCwgc3RhcnRJbmRleCB9KSA9PiB7XG4gICAgICBjb25zdCB7IGlzTWF0Y2gsIHNjb3JlLCBpbmRpY2VzIH0gPSBzZWFyY2godGV4dCwgcGF0dGVybiwgYWxwaGFiZXQsIHtcbiAgICAgICAgbG9jYXRpb246IGxvY2F0aW9uICsgc3RhcnRJbmRleCxcbiAgICAgICAgZGlzdGFuY2UsXG4gICAgICAgIHRocmVzaG9sZCxcbiAgICAgICAgZmluZEFsbE1hdGNoZXMsXG4gICAgICAgIG1pbk1hdGNoQ2hhckxlbmd0aCxcbiAgICAgICAgaW5jbHVkZU1hdGNoZXMsXG4gICAgICAgIGlnbm9yZUxvY2F0aW9uXG4gICAgICB9KTtcblxuICAgICAgaWYgKGlzTWF0Y2gpIHtcbiAgICAgICAgaGFzTWF0Y2hlcyA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHRvdGFsU2NvcmUgKz0gc2NvcmU7XG5cbiAgICAgIGlmIChpc01hdGNoICYmIGluZGljZXMpIHtcbiAgICAgICAgYWxsSW5kaWNlcyA9IFsuLi5hbGxJbmRpY2VzLCAuLi5pbmRpY2VzXTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGxldCByZXN1bHQgPSB7XG4gICAgICBpc01hdGNoOiBoYXNNYXRjaGVzLFxuICAgICAgc2NvcmU6IGhhc01hdGNoZXMgPyB0b3RhbFNjb3JlIC8gdGhpcy5jaHVua3MubGVuZ3RoIDogMVxuICAgIH07XG5cbiAgICBpZiAoaGFzTWF0Y2hlcyAmJiBpbmNsdWRlTWF0Y2hlcykge1xuICAgICAgcmVzdWx0LmluZGljZXMgPSBhbGxJbmRpY2VzO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRcbiAgfVxufVxuXG5jbGFzcyBCYXNlTWF0Y2gge1xuICBjb25zdHJ1Y3RvcihwYXR0ZXJuKSB7XG4gICAgdGhpcy5wYXR0ZXJuID0gcGF0dGVybjtcbiAgfVxuICBzdGF0aWMgaXNNdWx0aU1hdGNoKHBhdHRlcm4pIHtcbiAgICByZXR1cm4gZ2V0TWF0Y2gocGF0dGVybiwgdGhpcy5tdWx0aVJlZ2V4KVxuICB9XG4gIHN0YXRpYyBpc1NpbmdsZU1hdGNoKHBhdHRlcm4pIHtcbiAgICByZXR1cm4gZ2V0TWF0Y2gocGF0dGVybiwgdGhpcy5zaW5nbGVSZWdleClcbiAgfVxuICBzZWFyY2goLyp0ZXh0Ki8pIHt9XG59XG5cbmZ1bmN0aW9uIGdldE1hdGNoKHBhdHRlcm4sIGV4cCkge1xuICBjb25zdCBtYXRjaGVzID0gcGF0dGVybi5tYXRjaChleHApO1xuICByZXR1cm4gbWF0Y2hlcyA/IG1hdGNoZXNbMV0gOiBudWxsXG59XG5cbi8vIFRva2VuOiAnZmlsZVxuXG5jbGFzcyBFeGFjdE1hdGNoIGV4dGVuZHMgQmFzZU1hdGNoIHtcbiAgY29uc3RydWN0b3IocGF0dGVybikge1xuICAgIHN1cGVyKHBhdHRlcm4pO1xuICB9XG4gIHN0YXRpYyBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gJ2V4YWN0J1xuICB9XG4gIHN0YXRpYyBnZXQgbXVsdGlSZWdleCgpIHtcbiAgICByZXR1cm4gL149XCIoLiopXCIkL1xuICB9XG4gIHN0YXRpYyBnZXQgc2luZ2xlUmVnZXgoKSB7XG4gICAgcmV0dXJuIC9ePSguKikkL1xuICB9XG4gIHNlYXJjaCh0ZXh0KSB7XG4gICAgY29uc3QgaXNNYXRjaCA9IHRleHQgPT09IHRoaXMucGF0dGVybjtcblxuICAgIHJldHVybiB7XG4gICAgICBpc01hdGNoLFxuICAgICAgc2NvcmU6IGlzTWF0Y2ggPyAwIDogMSxcbiAgICAgIGluZGljZXM6IFswLCB0aGlzLnBhdHRlcm4ubGVuZ3RoIC0gMV1cbiAgICB9XG4gIH1cbn1cblxuLy8gVG9rZW46ICFmaXJlXG5cbmNsYXNzIEludmVyc2VFeGFjdE1hdGNoIGV4dGVuZHMgQmFzZU1hdGNoIHtcbiAgY29uc3RydWN0b3IocGF0dGVybikge1xuICAgIHN1cGVyKHBhdHRlcm4pO1xuICB9XG4gIHN0YXRpYyBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gJ2ludmVyc2UtZXhhY3QnXG4gIH1cbiAgc3RhdGljIGdldCBtdWx0aVJlZ2V4KCkge1xuICAgIHJldHVybiAvXiFcIiguKilcIiQvXG4gIH1cbiAgc3RhdGljIGdldCBzaW5nbGVSZWdleCgpIHtcbiAgICByZXR1cm4gL14hKC4qKSQvXG4gIH1cbiAgc2VhcmNoKHRleHQpIHtcbiAgICBjb25zdCBpbmRleCA9IHRleHQuaW5kZXhPZih0aGlzLnBhdHRlcm4pO1xuICAgIGNvbnN0IGlzTWF0Y2ggPSBpbmRleCA9PT0gLTE7XG5cbiAgICByZXR1cm4ge1xuICAgICAgaXNNYXRjaCxcbiAgICAgIHNjb3JlOiBpc01hdGNoID8gMCA6IDEsXG4gICAgICBpbmRpY2VzOiBbMCwgdGV4dC5sZW5ndGggLSAxXVxuICAgIH1cbiAgfVxufVxuXG4vLyBUb2tlbjogXmZpbGVcblxuY2xhc3MgUHJlZml4RXhhY3RNYXRjaCBleHRlbmRzIEJhc2VNYXRjaCB7XG4gIGNvbnN0cnVjdG9yKHBhdHRlcm4pIHtcbiAgICBzdXBlcihwYXR0ZXJuKTtcbiAgfVxuICBzdGF0aWMgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuICdwcmVmaXgtZXhhY3QnXG4gIH1cbiAgc3RhdGljIGdldCBtdWx0aVJlZ2V4KCkge1xuICAgIHJldHVybiAvXlxcXlwiKC4qKVwiJC9cbiAgfVxuICBzdGF0aWMgZ2V0IHNpbmdsZVJlZ2V4KCkge1xuICAgIHJldHVybiAvXlxcXiguKikkL1xuICB9XG4gIHNlYXJjaCh0ZXh0KSB7XG4gICAgY29uc3QgaXNNYXRjaCA9IHRleHQuc3RhcnRzV2l0aCh0aGlzLnBhdHRlcm4pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGlzTWF0Y2gsXG4gICAgICBzY29yZTogaXNNYXRjaCA/IDAgOiAxLFxuICAgICAgaW5kaWNlczogWzAsIHRoaXMucGF0dGVybi5sZW5ndGggLSAxXVxuICAgIH1cbiAgfVxufVxuXG4vLyBUb2tlbjogIV5maXJlXG5cbmNsYXNzIEludmVyc2VQcmVmaXhFeGFjdE1hdGNoIGV4dGVuZHMgQmFzZU1hdGNoIHtcbiAgY29uc3RydWN0b3IocGF0dGVybikge1xuICAgIHN1cGVyKHBhdHRlcm4pO1xuICB9XG4gIHN0YXRpYyBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gJ2ludmVyc2UtcHJlZml4LWV4YWN0J1xuICB9XG4gIHN0YXRpYyBnZXQgbXVsdGlSZWdleCgpIHtcbiAgICByZXR1cm4gL14hXFxeXCIoLiopXCIkL1xuICB9XG4gIHN0YXRpYyBnZXQgc2luZ2xlUmVnZXgoKSB7XG4gICAgcmV0dXJuIC9eIVxcXiguKikkL1xuICB9XG4gIHNlYXJjaCh0ZXh0KSB7XG4gICAgY29uc3QgaXNNYXRjaCA9ICF0ZXh0LnN0YXJ0c1dpdGgodGhpcy5wYXR0ZXJuKTtcblxuICAgIHJldHVybiB7XG4gICAgICBpc01hdGNoLFxuICAgICAgc2NvcmU6IGlzTWF0Y2ggPyAwIDogMSxcbiAgICAgIGluZGljZXM6IFswLCB0ZXh0Lmxlbmd0aCAtIDFdXG4gICAgfVxuICB9XG59XG5cbi8vIFRva2VuOiAuZmlsZSRcblxuY2xhc3MgU3VmZml4RXhhY3RNYXRjaCBleHRlbmRzIEJhc2VNYXRjaCB7XG4gIGNvbnN0cnVjdG9yKHBhdHRlcm4pIHtcbiAgICBzdXBlcihwYXR0ZXJuKTtcbiAgfVxuICBzdGF0aWMgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuICdzdWZmaXgtZXhhY3QnXG4gIH1cbiAgc3RhdGljIGdldCBtdWx0aVJlZ2V4KCkge1xuICAgIHJldHVybiAvXlwiKC4qKVwiXFwkJC9cbiAgfVxuICBzdGF0aWMgZ2V0IHNpbmdsZVJlZ2V4KCkge1xuICAgIHJldHVybiAvXiguKilcXCQkL1xuICB9XG4gIHNlYXJjaCh0ZXh0KSB7XG4gICAgY29uc3QgaXNNYXRjaCA9IHRleHQuZW5kc1dpdGgodGhpcy5wYXR0ZXJuKTtcblxuICAgIHJldHVybiB7XG4gICAgICBpc01hdGNoLFxuICAgICAgc2NvcmU6IGlzTWF0Y2ggPyAwIDogMSxcbiAgICAgIGluZGljZXM6IFt0ZXh0Lmxlbmd0aCAtIHRoaXMucGF0dGVybi5sZW5ndGgsIHRleHQubGVuZ3RoIC0gMV1cbiAgICB9XG4gIH1cbn1cblxuLy8gVG9rZW46ICEuZmlsZSRcblxuY2xhc3MgSW52ZXJzZVN1ZmZpeEV4YWN0TWF0Y2ggZXh0ZW5kcyBCYXNlTWF0Y2gge1xuICBjb25zdHJ1Y3RvcihwYXR0ZXJuKSB7XG4gICAgc3VwZXIocGF0dGVybik7XG4gIH1cbiAgc3RhdGljIGdldCB0eXBlKCkge1xuICAgIHJldHVybiAnaW52ZXJzZS1zdWZmaXgtZXhhY3QnXG4gIH1cbiAgc3RhdGljIGdldCBtdWx0aVJlZ2V4KCkge1xuICAgIHJldHVybiAvXiFcIiguKilcIlxcJCQvXG4gIH1cbiAgc3RhdGljIGdldCBzaW5nbGVSZWdleCgpIHtcbiAgICByZXR1cm4gL14hKC4qKVxcJCQvXG4gIH1cbiAgc2VhcmNoKHRleHQpIHtcbiAgICBjb25zdCBpc01hdGNoID0gIXRleHQuZW5kc1dpdGgodGhpcy5wYXR0ZXJuKTtcbiAgICByZXR1cm4ge1xuICAgICAgaXNNYXRjaCxcbiAgICAgIHNjb3JlOiBpc01hdGNoID8gMCA6IDEsXG4gICAgICBpbmRpY2VzOiBbMCwgdGV4dC5sZW5ndGggLSAxXVxuICAgIH1cbiAgfVxufVxuXG5jbGFzcyBGdXp6eU1hdGNoIGV4dGVuZHMgQmFzZU1hdGNoIHtcbiAgY29uc3RydWN0b3IoXG4gICAgcGF0dGVybixcbiAgICB7XG4gICAgICBsb2NhdGlvbiA9IENvbmZpZy5sb2NhdGlvbixcbiAgICAgIHRocmVzaG9sZCA9IENvbmZpZy50aHJlc2hvbGQsXG4gICAgICBkaXN0YW5jZSA9IENvbmZpZy5kaXN0YW5jZSxcbiAgICAgIGluY2x1ZGVNYXRjaGVzID0gQ29uZmlnLmluY2x1ZGVNYXRjaGVzLFxuICAgICAgZmluZEFsbE1hdGNoZXMgPSBDb25maWcuZmluZEFsbE1hdGNoZXMsXG4gICAgICBtaW5NYXRjaENoYXJMZW5ndGggPSBDb25maWcubWluTWF0Y2hDaGFyTGVuZ3RoLFxuICAgICAgaXNDYXNlU2Vuc2l0aXZlID0gQ29uZmlnLmlzQ2FzZVNlbnNpdGl2ZSxcbiAgICAgIGlnbm9yZUxvY2F0aW9uID0gQ29uZmlnLmlnbm9yZUxvY2F0aW9uXG4gICAgfSA9IHt9XG4gICkge1xuICAgIHN1cGVyKHBhdHRlcm4pO1xuICAgIHRoaXMuX2JpdGFwU2VhcmNoID0gbmV3IEJpdGFwU2VhcmNoKHBhdHRlcm4sIHtcbiAgICAgIGxvY2F0aW9uLFxuICAgICAgdGhyZXNob2xkLFxuICAgICAgZGlzdGFuY2UsXG4gICAgICBpbmNsdWRlTWF0Y2hlcyxcbiAgICAgIGZpbmRBbGxNYXRjaGVzLFxuICAgICAgbWluTWF0Y2hDaGFyTGVuZ3RoLFxuICAgICAgaXNDYXNlU2Vuc2l0aXZlLFxuICAgICAgaWdub3JlTG9jYXRpb25cbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuICdmdXp6eSdcbiAgfVxuICBzdGF0aWMgZ2V0IG11bHRpUmVnZXgoKSB7XG4gICAgcmV0dXJuIC9eXCIoLiopXCIkL1xuICB9XG4gIHN0YXRpYyBnZXQgc2luZ2xlUmVnZXgoKSB7XG4gICAgcmV0dXJuIC9eKC4qKSQvXG4gIH1cbiAgc2VhcmNoKHRleHQpIHtcbiAgICByZXR1cm4gdGhpcy5fYml0YXBTZWFyY2guc2VhcmNoSW4odGV4dClcbiAgfVxufVxuXG4vLyBUb2tlbjogJ2ZpbGVcblxuY2xhc3MgSW5jbHVkZU1hdGNoIGV4dGVuZHMgQmFzZU1hdGNoIHtcbiAgY29uc3RydWN0b3IocGF0dGVybikge1xuICAgIHN1cGVyKHBhdHRlcm4pO1xuICB9XG4gIHN0YXRpYyBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gJ2luY2x1ZGUnXG4gIH1cbiAgc3RhdGljIGdldCBtdWx0aVJlZ2V4KCkge1xuICAgIHJldHVybiAvXidcIiguKilcIiQvXG4gIH1cbiAgc3RhdGljIGdldCBzaW5nbGVSZWdleCgpIHtcbiAgICByZXR1cm4gL14nKC4qKSQvXG4gIH1cbiAgc2VhcmNoKHRleHQpIHtcbiAgICBsZXQgbG9jYXRpb24gPSAwO1xuICAgIGxldCBpbmRleDtcblxuICAgIGNvbnN0IGluZGljZXMgPSBbXTtcbiAgICBjb25zdCBwYXR0ZXJuTGVuID0gdGhpcy5wYXR0ZXJuLmxlbmd0aDtcblxuICAgIC8vIEdldCBhbGwgZXhhY3QgbWF0Y2hlc1xuICAgIHdoaWxlICgoaW5kZXggPSB0ZXh0LmluZGV4T2YodGhpcy5wYXR0ZXJuLCBsb2NhdGlvbikpID4gLTEpIHtcbiAgICAgIGxvY2F0aW9uID0gaW5kZXggKyBwYXR0ZXJuTGVuO1xuICAgICAgaW5kaWNlcy5wdXNoKFtpbmRleCwgbG9jYXRpb24gLSAxXSk7XG4gICAgfVxuXG4gICAgY29uc3QgaXNNYXRjaCA9ICEhaW5kaWNlcy5sZW5ndGg7XG5cbiAgICByZXR1cm4ge1xuICAgICAgaXNNYXRjaCxcbiAgICAgIHNjb3JlOiBpc01hdGNoID8gMCA6IDEsXG4gICAgICBpbmRpY2VzXG4gICAgfVxuICB9XG59XG5cbi8vIOKdl09yZGVyIGlzIGltcG9ydGFudC4gRE8gTk9UIENIQU5HRS5cbmNvbnN0IHNlYXJjaGVycyA9IFtcbiAgRXhhY3RNYXRjaCxcbiAgSW5jbHVkZU1hdGNoLFxuICBQcmVmaXhFeGFjdE1hdGNoLFxuICBJbnZlcnNlUHJlZml4RXhhY3RNYXRjaCxcbiAgSW52ZXJzZVN1ZmZpeEV4YWN0TWF0Y2gsXG4gIFN1ZmZpeEV4YWN0TWF0Y2gsXG4gIEludmVyc2VFeGFjdE1hdGNoLFxuICBGdXp6eU1hdGNoXG5dO1xuXG5jb25zdCBzZWFyY2hlcnNMZW4gPSBzZWFyY2hlcnMubGVuZ3RoO1xuXG4vLyBSZWdleCB0byBzcGxpdCBieSBzcGFjZXMsIGJ1dCBrZWVwIGFueXRoaW5nIGluIHF1b3RlcyB0b2dldGhlclxuY29uc3QgU1BBQ0VfUkUgPSAvICsoPz0oW15cXFwiXSpcXFwiW15cXFwiXSpcXFwiKSpbXlxcXCJdKiQpLztcbmNvbnN0IE9SX1RPS0VOID0gJ3wnO1xuXG4vLyBSZXR1cm4gYSAyRCBhcnJheSByZXByZXNlbnRhdGlvbiBvZiB0aGUgcXVlcnksIGZvciBzaW1wbGVyIHBhcnNpbmcuXG4vLyBFeGFtcGxlOlxuLy8gXCJeY29yZSBnbyQgfCByYiQgfCBweSQgeHkkXCIgPT4gW1tcIl5jb3JlXCIsIFwiZ28kXCJdLCBbXCJyYiRcIl0sIFtcInB5JFwiLCBcInh5JFwiXV1cbmZ1bmN0aW9uIHBhcnNlUXVlcnkocGF0dGVybiwgb3B0aW9ucyA9IHt9KSB7XG4gIHJldHVybiBwYXR0ZXJuLnNwbGl0KE9SX1RPS0VOKS5tYXAoKGl0ZW0pID0+IHtcbiAgICBsZXQgcXVlcnkgPSBpdGVtXG4gICAgICAudHJpbSgpXG4gICAgICAuc3BsaXQoU1BBQ0VfUkUpXG4gICAgICAuZmlsdGVyKChpdGVtKSA9PiBpdGVtICYmICEhaXRlbS50cmltKCkpO1xuXG4gICAgbGV0IHJlc3VsdHMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gcXVlcnkubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIGNvbnN0IHF1ZXJ5SXRlbSA9IHF1ZXJ5W2ldO1xuXG4gICAgICAvLyAxLiBIYW5kbGUgbXVsdGlwbGUgcXVlcnkgbWF0Y2ggKGkuZSwgb25jZSB0aGF0IGFyZSBxdW90ZWQsIGxpa2UgYFwiaGVsbG8gd29ybGRcImApXG4gICAgICBsZXQgZm91bmQgPSBmYWxzZTtcbiAgICAgIGxldCBpZHggPSAtMTtcbiAgICAgIHdoaWxlICghZm91bmQgJiYgKytpZHggPCBzZWFyY2hlcnNMZW4pIHtcbiAgICAgICAgY29uc3Qgc2VhcmNoZXIgPSBzZWFyY2hlcnNbaWR4XTtcbiAgICAgICAgbGV0IHRva2VuID0gc2VhcmNoZXIuaXNNdWx0aU1hdGNoKHF1ZXJ5SXRlbSk7XG4gICAgICAgIGlmICh0b2tlbikge1xuICAgICAgICAgIHJlc3VsdHMucHVzaChuZXcgc2VhcmNoZXIodG9rZW4sIG9wdGlvbnMpKTtcbiAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZvdW5kKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIDIuIEhhbmRsZSBzaW5nbGUgcXVlcnkgbWF0Y2hlcyAoaS5lLCBvbmNlIHRoYXQgYXJlICpub3QqIHF1b3RlZClcbiAgICAgIGlkeCA9IC0xO1xuICAgICAgd2hpbGUgKCsraWR4IDwgc2VhcmNoZXJzTGVuKSB7XG4gICAgICAgIGNvbnN0IHNlYXJjaGVyID0gc2VhcmNoZXJzW2lkeF07XG4gICAgICAgIGxldCB0b2tlbiA9IHNlYXJjaGVyLmlzU2luZ2xlTWF0Y2gocXVlcnlJdGVtKTtcbiAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgcmVzdWx0cy5wdXNoKG5ldyBzZWFyY2hlcih0b2tlbiwgb3B0aW9ucykpO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0c1xuICB9KVxufVxuXG4vLyBUaGVzZSBleHRlbmRlZCBtYXRjaGVycyBjYW4gcmV0dXJuIGFuIGFycmF5IG9mIG1hdGNoZXMsIGFzIG9wcG9zZWRcbi8vIHRvIGEgc2luZ2wgbWF0Y2hcbmNvbnN0IE11bHRpTWF0Y2hTZXQgPSBuZXcgU2V0KFtGdXp6eU1hdGNoLnR5cGUsIEluY2x1ZGVNYXRjaC50eXBlXSk7XG5cbi8qKlxuICogQ29tbWFuZC1saWtlIHNlYXJjaGluZ1xuICogPT09PT09PT09PT09PT09PT09PT09PVxuICpcbiAqIEdpdmVuIG11bHRpcGxlIHNlYXJjaCB0ZXJtcyBkZWxpbWl0ZWQgYnkgc3BhY2VzLmUuZy4gYF5qc2NyaXB0IC5weXRob24kIHJ1YnkgIWphdmFgLFxuICogc2VhcmNoIGluIGEgZ2l2ZW4gdGV4dC5cbiAqXG4gKiBTZWFyY2ggc3ludGF4OlxuICpcbiAqIHwgVG9rZW4gICAgICAgfCBNYXRjaCB0eXBlICAgICAgICAgICAgICAgICB8IERlc2NyaXB0aW9uICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgLS0tLS0tLS0tLS0gfCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSB8IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIHxcbiAqIHwgYGpzY3JpcHRgICAgfCBmdXp6eS1tYXRjaCAgICAgICAgICAgICAgICB8IEl0ZW1zIHRoYXQgZnV6enkgbWF0Y2ggYGpzY3JpcHRgICAgICAgIHxcbiAqIHwgYD1zY2hlbWVgICAgfCBleGFjdC1tYXRjaCAgICAgICAgICAgICAgICB8IEl0ZW1zIHRoYXQgYXJlIGBzY2hlbWVgICAgICAgICAgICAgICAgIHxcbiAqIHwgYCdweXRob25gICAgfCBpbmNsdWRlLW1hdGNoICAgICAgICAgICAgICB8IEl0ZW1zIHRoYXQgaW5jbHVkZSBgcHl0aG9uYCAgICAgICAgICAgIHxcbiAqIHwgYCFydWJ5YCAgICAgfCBpbnZlcnNlLWV4YWN0LW1hdGNoICAgICAgICB8IEl0ZW1zIHRoYXQgZG8gbm90IGluY2x1ZGUgYHJ1YnlgICAgICAgIHxcbiAqIHwgYF5qYXZhYCAgICAgfCBwcmVmaXgtZXhhY3QtbWF0Y2ggICAgICAgICB8IEl0ZW1zIHRoYXQgc3RhcnQgd2l0aCBgamF2YWAgICAgICAgICAgIHxcbiAqIHwgYCFeZWFybGFuZ2AgfCBpbnZlcnNlLXByZWZpeC1leGFjdC1tYXRjaCB8IEl0ZW1zIHRoYXQgZG8gbm90IHN0YXJ0IHdpdGggYGVhcmxhbmdgIHxcbiAqIHwgYC5qcyRgICAgICAgfCBzdWZmaXgtZXhhY3QtbWF0Y2ggICAgICAgICB8IEl0ZW1zIHRoYXQgZW5kIHdpdGggYC5qc2AgICAgICAgICAgICAgIHxcbiAqIHwgYCEuZ28kYCAgICAgfCBpbnZlcnNlLXN1ZmZpeC1leGFjdC1tYXRjaCB8IEl0ZW1zIHRoYXQgZG8gbm90IGVuZCB3aXRoIGAuZ29gICAgICAgIHxcbiAqXG4gKiBBIHNpbmdsZSBwaXBlIGNoYXJhY3RlciBhY3RzIGFzIGFuIE9SIG9wZXJhdG9yLiBGb3IgZXhhbXBsZSwgdGhlIGZvbGxvd2luZ1xuICogcXVlcnkgbWF0Y2hlcyBlbnRyaWVzIHRoYXQgc3RhcnQgd2l0aCBgY29yZWAgYW5kIGVuZCB3aXRoIGVpdGhlcmBnb2AsIGByYmAsXG4gKiBvcmBweWAuXG4gKlxuICogYGBgXG4gKiBeY29yZSBnbyQgfCByYiQgfCBweSRcbiAqIGBgYFxuICovXG5jbGFzcyBFeHRlbmRlZFNlYXJjaCB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHBhdHRlcm4sXG4gICAge1xuICAgICAgaXNDYXNlU2Vuc2l0aXZlID0gQ29uZmlnLmlzQ2FzZVNlbnNpdGl2ZSxcbiAgICAgIGluY2x1ZGVNYXRjaGVzID0gQ29uZmlnLmluY2x1ZGVNYXRjaGVzLFxuICAgICAgbWluTWF0Y2hDaGFyTGVuZ3RoID0gQ29uZmlnLm1pbk1hdGNoQ2hhckxlbmd0aCxcbiAgICAgIGlnbm9yZUxvY2F0aW9uID0gQ29uZmlnLmlnbm9yZUxvY2F0aW9uLFxuICAgICAgZmluZEFsbE1hdGNoZXMgPSBDb25maWcuZmluZEFsbE1hdGNoZXMsXG4gICAgICBsb2NhdGlvbiA9IENvbmZpZy5sb2NhdGlvbixcbiAgICAgIHRocmVzaG9sZCA9IENvbmZpZy50aHJlc2hvbGQsXG4gICAgICBkaXN0YW5jZSA9IENvbmZpZy5kaXN0YW5jZVxuICAgIH0gPSB7fVxuICApIHtcbiAgICB0aGlzLnF1ZXJ5ID0gbnVsbDtcbiAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICBpc0Nhc2VTZW5zaXRpdmUsXG4gICAgICBpbmNsdWRlTWF0Y2hlcyxcbiAgICAgIG1pbk1hdGNoQ2hhckxlbmd0aCxcbiAgICAgIGZpbmRBbGxNYXRjaGVzLFxuICAgICAgaWdub3JlTG9jYXRpb24sXG4gICAgICBsb2NhdGlvbixcbiAgICAgIHRocmVzaG9sZCxcbiAgICAgIGRpc3RhbmNlXG4gICAgfTtcblxuICAgIHRoaXMucGF0dGVybiA9IGlzQ2FzZVNlbnNpdGl2ZSA/IHBhdHRlcm4gOiBwYXR0ZXJuLnRvTG93ZXJDYXNlKCk7XG4gICAgdGhpcy5xdWVyeSA9IHBhcnNlUXVlcnkodGhpcy5wYXR0ZXJuLCB0aGlzLm9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGNvbmRpdGlvbihfLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMudXNlRXh0ZW5kZWRTZWFyY2hcbiAgfVxuXG4gIHNlYXJjaEluKHRleHQpIHtcbiAgICBjb25zdCBxdWVyeSA9IHRoaXMucXVlcnk7XG5cbiAgICBpZiAoIXF1ZXJ5KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpc01hdGNoOiBmYWxzZSxcbiAgICAgICAgc2NvcmU6IDFcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCB7IGluY2x1ZGVNYXRjaGVzLCBpc0Nhc2VTZW5zaXRpdmUgfSA9IHRoaXMub3B0aW9ucztcblxuICAgIHRleHQgPSBpc0Nhc2VTZW5zaXRpdmUgPyB0ZXh0IDogdGV4dC50b0xvd2VyQ2FzZSgpO1xuXG4gICAgbGV0IG51bU1hdGNoZXMgPSAwO1xuICAgIGxldCBhbGxJbmRpY2VzID0gW107XG4gICAgbGV0IHRvdGFsU2NvcmUgPSAwO1xuXG4gICAgLy8gT1JzXG4gICAgZm9yIChsZXQgaSA9IDAsIHFMZW4gPSBxdWVyeS5sZW5ndGg7IGkgPCBxTGVuOyBpICs9IDEpIHtcbiAgICAgIGNvbnN0IHNlYXJjaGVycyA9IHF1ZXJ5W2ldO1xuXG4gICAgICAvLyBSZXNldCBpbmRpY2VzXG4gICAgICBhbGxJbmRpY2VzLmxlbmd0aCA9IDA7XG4gICAgICBudW1NYXRjaGVzID0gMDtcblxuICAgICAgLy8gQU5Ec1xuICAgICAgZm9yIChsZXQgaiA9IDAsIHBMZW4gPSBzZWFyY2hlcnMubGVuZ3RoOyBqIDwgcExlbjsgaiArPSAxKSB7XG4gICAgICAgIGNvbnN0IHNlYXJjaGVyID0gc2VhcmNoZXJzW2pdO1xuICAgICAgICBjb25zdCB7IGlzTWF0Y2gsIGluZGljZXMsIHNjb3JlIH0gPSBzZWFyY2hlci5zZWFyY2godGV4dCk7XG5cbiAgICAgICAgaWYgKGlzTWF0Y2gpIHtcbiAgICAgICAgICBudW1NYXRjaGVzICs9IDE7XG4gICAgICAgICAgdG90YWxTY29yZSArPSBzY29yZTtcbiAgICAgICAgICBpZiAoaW5jbHVkZU1hdGNoZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBzZWFyY2hlci5jb25zdHJ1Y3Rvci50eXBlO1xuICAgICAgICAgICAgaWYgKE11bHRpTWF0Y2hTZXQuaGFzKHR5cGUpKSB7XG4gICAgICAgICAgICAgIGFsbEluZGljZXMgPSBbLi4uYWxsSW5kaWNlcywgLi4uaW5kaWNlc107XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBhbGxJbmRpY2VzLnB1c2goaW5kaWNlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRvdGFsU2NvcmUgPSAwO1xuICAgICAgICAgIG51bU1hdGNoZXMgPSAwO1xuICAgICAgICAgIGFsbEluZGljZXMubGVuZ3RoID0gMDtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIE9SIGNvbmRpdGlvbiwgc28gaWYgVFJVRSwgcmV0dXJuXG4gICAgICBpZiAobnVtTWF0Y2hlcykge1xuICAgICAgICBsZXQgcmVzdWx0ID0ge1xuICAgICAgICAgIGlzTWF0Y2g6IHRydWUsXG4gICAgICAgICAgc2NvcmU6IHRvdGFsU2NvcmUgLyBudW1NYXRjaGVzXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGluY2x1ZGVNYXRjaGVzKSB7XG4gICAgICAgICAgcmVzdWx0LmluZGljZXMgPSBhbGxJbmRpY2VzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE5vdGhpbmcgd2FzIG1hdGNoZWRcbiAgICByZXR1cm4ge1xuICAgICAgaXNNYXRjaDogZmFsc2UsXG4gICAgICBzY29yZTogMVxuICAgIH1cbiAgfVxufVxuXG5jb25zdCByZWdpc3RlcmVkU2VhcmNoZXJzID0gW107XG5cbmZ1bmN0aW9uIHJlZ2lzdGVyKC4uLmFyZ3MpIHtcbiAgcmVnaXN0ZXJlZFNlYXJjaGVycy5wdXNoKC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVTZWFyY2hlcihwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIGZvciAobGV0IGkgPSAwLCBsZW4gPSByZWdpc3RlcmVkU2VhcmNoZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgbGV0IHNlYXJjaGVyQ2xhc3MgPSByZWdpc3RlcmVkU2VhcmNoZXJzW2ldO1xuICAgIGlmIChzZWFyY2hlckNsYXNzLmNvbmRpdGlvbihwYXR0ZXJuLCBvcHRpb25zKSkge1xuICAgICAgcmV0dXJuIG5ldyBzZWFyY2hlckNsYXNzKHBhdHRlcm4sIG9wdGlvbnMpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ldyBCaXRhcFNlYXJjaChwYXR0ZXJuLCBvcHRpb25zKVxufVxuXG5jb25zdCBMb2dpY2FsT3BlcmF0b3IgPSB7XG4gIEFORDogJyRhbmQnLFxuICBPUjogJyRvcidcbn07XG5cbmNvbnN0IEtleVR5cGUgPSB7XG4gIFBBVEg6ICckcGF0aCcsXG4gIFBBVFRFUk46ICckdmFsJ1xufTtcblxuY29uc3QgaXNFeHByZXNzaW9uID0gKHF1ZXJ5KSA9PlxuICAhIShxdWVyeVtMb2dpY2FsT3BlcmF0b3IuQU5EXSB8fCBxdWVyeVtMb2dpY2FsT3BlcmF0b3IuT1JdKTtcblxuY29uc3QgaXNQYXRoID0gKHF1ZXJ5KSA9PiAhIXF1ZXJ5W0tleVR5cGUuUEFUSF07XG5cbmNvbnN0IGlzTGVhZiA9IChxdWVyeSkgPT5cbiAgIWlzQXJyYXkocXVlcnkpICYmIGlzT2JqZWN0KHF1ZXJ5KSAmJiAhaXNFeHByZXNzaW9uKHF1ZXJ5KTtcblxuY29uc3QgY29udmVydFRvRXhwbGljaXQgPSAocXVlcnkpID0+ICh7XG4gIFtMb2dpY2FsT3BlcmF0b3IuQU5EXTogT2JqZWN0LmtleXMocXVlcnkpLm1hcCgoa2V5KSA9PiAoe1xuICAgIFtrZXldOiBxdWVyeVtrZXldXG4gIH0pKVxufSk7XG5cbi8vIFdoZW4gYGF1dG9gIGlzIGB0cnVlYCwgdGhlIHBhcnNlIGZ1bmN0aW9uIHdpbGwgaW5mZXIgYW5kIGluaXRpYWxpemUgYW5kIGFkZFxuLy8gdGhlIGFwcHJvcHJpYXRlIGBTZWFyY2hlcmAgaW5zdGFuY2VcbmZ1bmN0aW9uIHBhcnNlKHF1ZXJ5LCBvcHRpb25zLCB7IGF1dG8gPSB0cnVlIH0gPSB7fSkge1xuICBjb25zdCBuZXh0ID0gKHF1ZXJ5KSA9PiB7XG4gICAgbGV0IGtleXMgPSBPYmplY3Qua2V5cyhxdWVyeSk7XG5cbiAgICBjb25zdCBpc1F1ZXJ5UGF0aCA9IGlzUGF0aChxdWVyeSk7XG5cbiAgICBpZiAoIWlzUXVlcnlQYXRoICYmIGtleXMubGVuZ3RoID4gMSAmJiAhaXNFeHByZXNzaW9uKHF1ZXJ5KSkge1xuICAgICAgcmV0dXJuIG5leHQoY29udmVydFRvRXhwbGljaXQocXVlcnkpKVxuICAgIH1cblxuICAgIGlmIChpc0xlYWYocXVlcnkpKSB7XG4gICAgICBjb25zdCBrZXkgPSBpc1F1ZXJ5UGF0aCA/IHF1ZXJ5W0tleVR5cGUuUEFUSF0gOiBrZXlzWzBdO1xuXG4gICAgICBjb25zdCBwYXR0ZXJuID0gaXNRdWVyeVBhdGggPyBxdWVyeVtLZXlUeXBlLlBBVFRFUk5dIDogcXVlcnlba2V5XTtcblxuICAgICAgaWYgKCFpc1N0cmluZyhwYXR0ZXJuKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoTE9HSUNBTF9TRUFSQ0hfSU5WQUxJRF9RVUVSWV9GT1JfS0VZKGtleSkpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG9iaiA9IHtcbiAgICAgICAga2V5SWQ6IGNyZWF0ZUtleUlkKGtleSksXG4gICAgICAgIHBhdHRlcm5cbiAgICAgIH07XG5cbiAgICAgIGlmIChhdXRvKSB7XG4gICAgICAgIG9iai5zZWFyY2hlciA9IGNyZWF0ZVNlYXJjaGVyKHBhdHRlcm4sIG9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb2JqXG4gICAgfVxuXG4gICAgbGV0IG5vZGUgPSB7XG4gICAgICBjaGlsZHJlbjogW10sXG4gICAgICBvcGVyYXRvcjoga2V5c1swXVxuICAgIH07XG5cbiAgICBrZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgY29uc3QgdmFsdWUgPSBxdWVyeVtrZXldO1xuXG4gICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgICAgIG5vZGUuY2hpbGRyZW4ucHVzaChuZXh0KGl0ZW0pKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gbm9kZVxuICB9O1xuXG4gIGlmICghaXNFeHByZXNzaW9uKHF1ZXJ5KSkge1xuICAgIHF1ZXJ5ID0gY29udmVydFRvRXhwbGljaXQocXVlcnkpO1xuICB9XG5cbiAgcmV0dXJuIG5leHQocXVlcnkpXG59XG5cbi8vIFByYWN0aWNhbCBzY29yaW5nIGZ1bmN0aW9uXG5mdW5jdGlvbiBjb21wdXRlU2NvcmUkMShcbiAgcmVzdWx0cyxcbiAgeyBpZ25vcmVGaWVsZE5vcm0gPSBDb25maWcuaWdub3JlRmllbGROb3JtIH1cbikge1xuICByZXN1bHRzLmZvckVhY2goKHJlc3VsdCkgPT4ge1xuICAgIGxldCB0b3RhbFNjb3JlID0gMTtcblxuICAgIHJlc3VsdC5tYXRjaGVzLmZvckVhY2goKHsga2V5LCBub3JtLCBzY29yZSB9KSA9PiB7XG4gICAgICBjb25zdCB3ZWlnaHQgPSBrZXkgPyBrZXkud2VpZ2h0IDogbnVsbDtcblxuICAgICAgdG90YWxTY29yZSAqPSBNYXRoLnBvdyhcbiAgICAgICAgc2NvcmUgPT09IDAgJiYgd2VpZ2h0ID8gTnVtYmVyLkVQU0lMT04gOiBzY29yZSxcbiAgICAgICAgKHdlaWdodCB8fCAxKSAqIChpZ25vcmVGaWVsZE5vcm0gPyAxIDogbm9ybSlcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICByZXN1bHQuc2NvcmUgPSB0b3RhbFNjb3JlO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gdHJhbnNmb3JtTWF0Y2hlcyhyZXN1bHQsIGRhdGEpIHtcbiAgY29uc3QgbWF0Y2hlcyA9IHJlc3VsdC5tYXRjaGVzO1xuICBkYXRhLm1hdGNoZXMgPSBbXTtcblxuICBpZiAoIWlzRGVmaW5lZChtYXRjaGVzKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgbWF0Y2hlcy5mb3JFYWNoKChtYXRjaCkgPT4ge1xuICAgIGlmICghaXNEZWZpbmVkKG1hdGNoLmluZGljZXMpIHx8ICFtYXRjaC5pbmRpY2VzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgeyBpbmRpY2VzLCB2YWx1ZSB9ID0gbWF0Y2g7XG5cbiAgICBsZXQgb2JqID0ge1xuICAgICAgaW5kaWNlcyxcbiAgICAgIHZhbHVlXG4gICAgfTtcblxuICAgIGlmIChtYXRjaC5rZXkpIHtcbiAgICAgIG9iai5rZXkgPSBtYXRjaC5rZXkuc3JjO1xuICAgIH1cblxuICAgIGlmIChtYXRjaC5pZHggPiAtMSkge1xuICAgICAgb2JqLnJlZkluZGV4ID0gbWF0Y2guaWR4O1xuICAgIH1cblxuICAgIGRhdGEubWF0Y2hlcy5wdXNoKG9iaik7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1TY29yZShyZXN1bHQsIGRhdGEpIHtcbiAgZGF0YS5zY29yZSA9IHJlc3VsdC5zY29yZTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0KFxuICByZXN1bHRzLFxuICBkb2NzLFxuICB7XG4gICAgaW5jbHVkZU1hdGNoZXMgPSBDb25maWcuaW5jbHVkZU1hdGNoZXMsXG4gICAgaW5jbHVkZVNjb3JlID0gQ29uZmlnLmluY2x1ZGVTY29yZVxuICB9ID0ge31cbikge1xuICBjb25zdCB0cmFuc2Zvcm1lcnMgPSBbXTtcblxuICBpZiAoaW5jbHVkZU1hdGNoZXMpIHRyYW5zZm9ybWVycy5wdXNoKHRyYW5zZm9ybU1hdGNoZXMpO1xuICBpZiAoaW5jbHVkZVNjb3JlKSB0cmFuc2Zvcm1lcnMucHVzaCh0cmFuc2Zvcm1TY29yZSk7XG5cbiAgcmV0dXJuIHJlc3VsdHMubWFwKChyZXN1bHQpID0+IHtcbiAgICBjb25zdCB7IGlkeCB9ID0gcmVzdWx0O1xuXG4gICAgY29uc3QgZGF0YSA9IHtcbiAgICAgIGl0ZW06IGRvY3NbaWR4XSxcbiAgICAgIHJlZkluZGV4OiBpZHhcbiAgICB9O1xuXG4gICAgaWYgKHRyYW5zZm9ybWVycy5sZW5ndGgpIHtcbiAgICAgIHRyYW5zZm9ybWVycy5mb3JFYWNoKCh0cmFuc2Zvcm1lcikgPT4ge1xuICAgICAgICB0cmFuc2Zvcm1lcihyZXN1bHQsIGRhdGEpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGFcbiAgfSlcbn1cblxuY2xhc3MgRnVzZSB7XG4gIGNvbnN0cnVjdG9yKGRvY3MsIG9wdGlvbnMgPSB7fSwgaW5kZXgpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSB7IC4uLkNvbmZpZywgLi4ub3B0aW9ucyB9O1xuXG4gICAgaWYgKFxuICAgICAgdGhpcy5vcHRpb25zLnVzZUV4dGVuZGVkU2VhcmNoICYmXG4gICAgICAhdHJ1ZVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKEVYVEVOREVEX1NFQVJDSF9VTkFWQUlMQUJMRSlcbiAgICB9XG5cbiAgICB0aGlzLl9rZXlTdG9yZSA9IG5ldyBLZXlTdG9yZSh0aGlzLm9wdGlvbnMua2V5cyk7XG5cbiAgICB0aGlzLnNldENvbGxlY3Rpb24oZG9jcywgaW5kZXgpO1xuICB9XG5cbiAgc2V0Q29sbGVjdGlvbihkb2NzLCBpbmRleCkge1xuICAgIHRoaXMuX2RvY3MgPSBkb2NzO1xuXG4gICAgaWYgKGluZGV4ICYmICEoaW5kZXggaW5zdGFuY2VvZiBGdXNlSW5kZXgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoSU5DT1JSRUNUX0lOREVYX1RZUEUpXG4gICAgfVxuXG4gICAgdGhpcy5fbXlJbmRleCA9XG4gICAgICBpbmRleCB8fFxuICAgICAgY3JlYXRlSW5kZXgodGhpcy5vcHRpb25zLmtleXMsIHRoaXMuX2RvY3MsIHtcbiAgICAgICAgZ2V0Rm46IHRoaXMub3B0aW9ucy5nZXRGblxuICAgICAgfSk7XG4gIH1cblxuICBhZGQoZG9jKSB7XG4gICAgaWYgKCFpc0RlZmluZWQoZG9jKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5fZG9jcy5wdXNoKGRvYyk7XG4gICAgdGhpcy5fbXlJbmRleC5hZGQoZG9jKTtcbiAgfVxuXG4gIHJlbW92ZShwcmVkaWNhdGUgPSAoLyogZG9jLCBpZHggKi8pID0+IGZhbHNlKSB7XG4gICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuXG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHRoaXMuX2RvY3MubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIGNvbnN0IGRvYyA9IHRoaXMuX2RvY3NbaV07XG4gICAgICBpZiAocHJlZGljYXRlKGRvYywgaSkpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVBdChpKTtcbiAgICAgICAgaSAtPSAxO1xuICAgICAgICBsZW4gLT0gMTtcblxuICAgICAgICByZXN1bHRzLnB1c2goZG9jKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0c1xuICB9XG5cbiAgcmVtb3ZlQXQoaWR4KSB7XG4gICAgdGhpcy5fZG9jcy5zcGxpY2UoaWR4LCAxKTtcbiAgICB0aGlzLl9teUluZGV4LnJlbW92ZUF0KGlkeCk7XG4gIH1cblxuICBnZXRJbmRleCgpIHtcbiAgICByZXR1cm4gdGhpcy5fbXlJbmRleFxuICB9XG5cbiAgc2VhcmNoKHF1ZXJ5LCB7IGxpbWl0ID0gLTEgfSA9IHt9KSB7XG4gICAgY29uc3Qge1xuICAgICAgaW5jbHVkZU1hdGNoZXMsXG4gICAgICBpbmNsdWRlU2NvcmUsXG4gICAgICBzaG91bGRTb3J0LFxuICAgICAgc29ydEZuLFxuICAgICAgaWdub3JlRmllbGROb3JtXG4gICAgfSA9IHRoaXMub3B0aW9ucztcblxuICAgIGxldCByZXN1bHRzID0gaXNTdHJpbmcocXVlcnkpXG4gICAgICA/IGlzU3RyaW5nKHRoaXMuX2RvY3NbMF0pXG4gICAgICAgID8gdGhpcy5fc2VhcmNoU3RyaW5nTGlzdChxdWVyeSlcbiAgICAgICAgOiB0aGlzLl9zZWFyY2hPYmplY3RMaXN0KHF1ZXJ5KVxuICAgICAgOiB0aGlzLl9zZWFyY2hMb2dpY2FsKHF1ZXJ5KTtcblxuICAgIGNvbXB1dGVTY29yZSQxKHJlc3VsdHMsIHsgaWdub3JlRmllbGROb3JtIH0pO1xuXG4gICAgaWYgKHNob3VsZFNvcnQpIHtcbiAgICAgIHJlc3VsdHMuc29ydChzb3J0Rm4pO1xuICAgIH1cblxuICAgIGlmIChpc051bWJlcihsaW1pdCkgJiYgbGltaXQgPiAtMSkge1xuICAgICAgcmVzdWx0cyA9IHJlc3VsdHMuc2xpY2UoMCwgbGltaXQpO1xuICAgIH1cblxuICAgIHJldHVybiBmb3JtYXQocmVzdWx0cywgdGhpcy5fZG9jcywge1xuICAgICAgaW5jbHVkZU1hdGNoZXMsXG4gICAgICBpbmNsdWRlU2NvcmVcbiAgICB9KVxuICB9XG5cbiAgX3NlYXJjaFN0cmluZ0xpc3QocXVlcnkpIHtcbiAgICBjb25zdCBzZWFyY2hlciA9IGNyZWF0ZVNlYXJjaGVyKHF1ZXJ5LCB0aGlzLm9wdGlvbnMpO1xuICAgIGNvbnN0IHsgcmVjb3JkcyB9ID0gdGhpcy5fbXlJbmRleDtcbiAgICBjb25zdCByZXN1bHRzID0gW107XG5cbiAgICAvLyBJdGVyYXRlIG92ZXIgZXZlcnkgc3RyaW5nIGluIHRoZSBpbmRleFxuICAgIHJlY29yZHMuZm9yRWFjaCgoeyB2OiB0ZXh0LCBpOiBpZHgsIG46IG5vcm0gfSkgPT4ge1xuICAgICAgaWYgKCFpc0RlZmluZWQodGV4dCkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHsgaXNNYXRjaCwgc2NvcmUsIGluZGljZXMgfSA9IHNlYXJjaGVyLnNlYXJjaEluKHRleHQpO1xuXG4gICAgICBpZiAoaXNNYXRjaCkge1xuICAgICAgICByZXN1bHRzLnB1c2goe1xuICAgICAgICAgIGl0ZW06IHRleHQsXG4gICAgICAgICAgaWR4LFxuICAgICAgICAgIG1hdGNoZXM6IFt7IHNjb3JlLCB2YWx1ZTogdGV4dCwgbm9ybSwgaW5kaWNlcyB9XVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiByZXN1bHRzXG4gIH1cblxuICBfc2VhcmNoTG9naWNhbChxdWVyeSkge1xuXG4gICAgY29uc3QgZXhwcmVzc2lvbiA9IHBhcnNlKHF1ZXJ5LCB0aGlzLm9wdGlvbnMpO1xuXG4gICAgY29uc3QgZXZhbHVhdGUgPSAobm9kZSwgaXRlbSwgaWR4KSA9PiB7XG4gICAgICBpZiAoIW5vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgY29uc3QgeyBrZXlJZCwgc2VhcmNoZXIgfSA9IG5vZGU7XG5cbiAgICAgICAgY29uc3QgbWF0Y2hlcyA9IHRoaXMuX2ZpbmRNYXRjaGVzKHtcbiAgICAgICAgICBrZXk6IHRoaXMuX2tleVN0b3JlLmdldChrZXlJZCksXG4gICAgICAgICAgdmFsdWU6IHRoaXMuX215SW5kZXguZ2V0VmFsdWVGb3JJdGVtQXRLZXlJZChpdGVtLCBrZXlJZCksXG4gICAgICAgICAgc2VhcmNoZXJcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKG1hdGNoZXMgJiYgbWF0Y2hlcy5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBpZHgsXG4gICAgICAgICAgICAgIGl0ZW0sXG4gICAgICAgICAgICAgIG1hdGNoZXNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBdXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW11cbiAgICAgIH1cblxuICAgICAgLyplc2xpbnQgaW5kZW50OiBbMiwgMiwge1wiU3dpdGNoQ2FzZVwiOiAxfV0qL1xuICAgICAgc3dpdGNoIChub2RlLm9wZXJhdG9yKSB7XG4gICAgICAgIGNhc2UgTG9naWNhbE9wZXJhdG9yLkFORDoge1xuICAgICAgICAgIGNvbnN0IHJlcyA9IFtdO1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBldmFsdWF0ZShjaGlsZCwgaXRlbSwgaWR4KTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJlcy5wdXNoKC4uLnJlc3VsdCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gW11cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgTG9naWNhbE9wZXJhdG9yLk9SOiB7XG4gICAgICAgICAgY29uc3QgcmVzID0gW107XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGV2YWx1YXRlKGNoaWxkLCBpdGVtLCBpZHgpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmVzLnB1c2goLi4ucmVzdWx0KTtcbiAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IHJlY29yZHMgPSB0aGlzLl9teUluZGV4LnJlY29yZHM7XG4gICAgY29uc3QgcmVzdWx0TWFwID0ge307XG4gICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuXG4gICAgcmVjb3Jkcy5mb3JFYWNoKCh7ICQ6IGl0ZW0sIGk6IGlkeCB9KSA9PiB7XG4gICAgICBpZiAoaXNEZWZpbmVkKGl0ZW0pKSB7XG4gICAgICAgIGxldCBleHBSZXN1bHRzID0gZXZhbHVhdGUoZXhwcmVzc2lvbiwgaXRlbSwgaWR4KTtcblxuICAgICAgICBpZiAoZXhwUmVzdWx0cy5sZW5ndGgpIHtcbiAgICAgICAgICAvLyBEZWR1cGUgd2hlbiBhZGRpbmdcbiAgICAgICAgICBpZiAoIXJlc3VsdE1hcFtpZHhdKSB7XG4gICAgICAgICAgICByZXN1bHRNYXBbaWR4XSA9IHsgaWR4LCBpdGVtLCBtYXRjaGVzOiBbXSB9O1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHJlc3VsdE1hcFtpZHhdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZXhwUmVzdWx0cy5mb3JFYWNoKCh7IG1hdGNoZXMgfSkgPT4ge1xuICAgICAgICAgICAgcmVzdWx0TWFwW2lkeF0ubWF0Y2hlcy5wdXNoKC4uLm1hdGNoZXMpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVzdWx0c1xuICB9XG5cbiAgX3NlYXJjaE9iamVjdExpc3QocXVlcnkpIHtcbiAgICBjb25zdCBzZWFyY2hlciA9IGNyZWF0ZVNlYXJjaGVyKHF1ZXJ5LCB0aGlzLm9wdGlvbnMpO1xuICAgIGNvbnN0IHsga2V5cywgcmVjb3JkcyB9ID0gdGhpcy5fbXlJbmRleDtcbiAgICBjb25zdCByZXN1bHRzID0gW107XG5cbiAgICAvLyBMaXN0IGlzIEFycmF5PE9iamVjdD5cbiAgICByZWNvcmRzLmZvckVhY2goKHsgJDogaXRlbSwgaTogaWR4IH0pID0+IHtcbiAgICAgIGlmICghaXNEZWZpbmVkKGl0ZW0pKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBsZXQgbWF0Y2hlcyA9IFtdO1xuXG4gICAgICAvLyBJdGVyYXRlIG92ZXIgZXZlcnkga2V5IChpLmUsIHBhdGgpLCBhbmQgZmV0Y2ggdGhlIHZhbHVlIGF0IHRoYXQga2V5XG4gICAgICBrZXlzLmZvckVhY2goKGtleSwga2V5SW5kZXgpID0+IHtcbiAgICAgICAgbWF0Y2hlcy5wdXNoKFxuICAgICAgICAgIC4uLnRoaXMuX2ZpbmRNYXRjaGVzKHtcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIHZhbHVlOiBpdGVtW2tleUluZGV4XSxcbiAgICAgICAgICAgIHNlYXJjaGVyXG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAobWF0Y2hlcy5sZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0cy5wdXNoKHtcbiAgICAgICAgICBpZHgsXG4gICAgICAgICAgaXRlbSxcbiAgICAgICAgICBtYXRjaGVzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJlc3VsdHNcbiAgfVxuICBfZmluZE1hdGNoZXMoeyBrZXksIHZhbHVlLCBzZWFyY2hlciB9KSB7XG4gICAgaWYgKCFpc0RlZmluZWQodmFsdWUpKSB7XG4gICAgICByZXR1cm4gW11cbiAgICB9XG5cbiAgICBsZXQgbWF0Y2hlcyA9IFtdO1xuXG4gICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICB2YWx1ZS5mb3JFYWNoKCh7IHY6IHRleHQsIGk6IGlkeCwgbjogbm9ybSB9KSA9PiB7XG4gICAgICAgIGlmICghaXNEZWZpbmVkKHRleHQpKSB7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7IGlzTWF0Y2gsIHNjb3JlLCBpbmRpY2VzIH0gPSBzZWFyY2hlci5zZWFyY2hJbih0ZXh0KTtcblxuICAgICAgICBpZiAoaXNNYXRjaCkge1xuICAgICAgICAgIG1hdGNoZXMucHVzaCh7XG4gICAgICAgICAgICBzY29yZSxcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIHZhbHVlOiB0ZXh0LFxuICAgICAgICAgICAgaWR4LFxuICAgICAgICAgICAgbm9ybSxcbiAgICAgICAgICAgIGluZGljZXNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHsgdjogdGV4dCwgbjogbm9ybSB9ID0gdmFsdWU7XG5cbiAgICAgIGNvbnN0IHsgaXNNYXRjaCwgc2NvcmUsIGluZGljZXMgfSA9IHNlYXJjaGVyLnNlYXJjaEluKHRleHQpO1xuXG4gICAgICBpZiAoaXNNYXRjaCkge1xuICAgICAgICBtYXRjaGVzLnB1c2goeyBzY29yZSwga2V5LCB2YWx1ZTogdGV4dCwgbm9ybSwgaW5kaWNlcyB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWF0Y2hlc1xuICB9XG59XG5cbkZ1c2UudmVyc2lvbiA9ICc2LjQuNic7XG5GdXNlLmNyZWF0ZUluZGV4ID0gY3JlYXRlSW5kZXg7XG5GdXNlLnBhcnNlSW5kZXggPSBwYXJzZUluZGV4O1xuRnVzZS5jb25maWcgPSBDb25maWc7XG5cbntcbiAgRnVzZS5wYXJzZVF1ZXJ5ID0gcGFyc2U7XG59XG5cbntcbiAgcmVnaXN0ZXIoRXh0ZW5kZWRTZWFyY2gpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBGdXNlO1xuIiwiLyogQHByZXNlcnZlXG4gKiBMZWFmbGV0IDEuNy4xLCBhIEpTIGxpYnJhcnkgZm9yIGludGVyYWN0aXZlIG1hcHMuIGh0dHA6Ly9sZWFmbGV0anMuY29tXG4gKiAoYykgMjAxMC0yMDE5IFZsYWRpbWlyIEFnYWZvbmtpbiwgKGMpIDIwMTAtMjAxMSBDbG91ZE1hZGVcbiAqL1xuXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG4gIChmYWN0b3J5KChnbG9iYWwuTCA9IHt9KSkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciB2ZXJzaW9uID0gXCIxLjcuMVwiO1xuXG4gIC8qXHJcbiAgICogQG5hbWVzcGFjZSBVdGlsXHJcbiAgICpcclxuICAgKiBWYXJpb3VzIHV0aWxpdHkgZnVuY3Rpb25zLCB1c2VkIGJ5IExlYWZsZXQgaW50ZXJuYWxseS5cclxuICAgKi9cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGV4dGVuZChkZXN0OiBPYmplY3QsIHNyYz86IE9iamVjdCk6IE9iamVjdFxyXG4gIC8vIE1lcmdlcyB0aGUgcHJvcGVydGllcyBvZiB0aGUgYHNyY2Agb2JqZWN0IChvciBtdWx0aXBsZSBvYmplY3RzKSBpbnRvIGBkZXN0YCBvYmplY3QgYW5kIHJldHVybnMgdGhlIGxhdHRlci4gSGFzIGFuIGBMLmV4dGVuZGAgc2hvcnRjdXQuXHJcbiAgZnVuY3Rpb24gZXh0ZW5kKGRlc3QpIHtcclxuICBcdHZhciBpLCBqLCBsZW4sIHNyYztcclxuXHJcbiAgXHRmb3IgKGogPSAxLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcclxuICBcdFx0c3JjID0gYXJndW1lbnRzW2pdO1xyXG4gIFx0XHRmb3IgKGkgaW4gc3JjKSB7XHJcbiAgXHRcdFx0ZGVzdFtpXSA9IHNyY1tpXTtcclxuICBcdFx0fVxyXG4gIFx0fVxyXG4gIFx0cmV0dXJuIGRlc3Q7XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gY3JlYXRlKHByb3RvOiBPYmplY3QsIHByb3BlcnRpZXM/OiBPYmplY3QpOiBPYmplY3RcclxuICAvLyBDb21wYXRpYmlsaXR5IHBvbHlmaWxsIGZvciBbT2JqZWN0LmNyZWF0ZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2NyZWF0ZSlcclxuICB2YXIgY3JlYXRlID0gT2JqZWN0LmNyZWF0ZSB8fCAoZnVuY3Rpb24gKCkge1xyXG4gIFx0ZnVuY3Rpb24gRigpIHt9XHJcbiAgXHRyZXR1cm4gZnVuY3Rpb24gKHByb3RvKSB7XHJcbiAgXHRcdEYucHJvdG90eXBlID0gcHJvdG87XHJcbiAgXHRcdHJldHVybiBuZXcgRigpO1xyXG4gIFx0fTtcclxuICB9KSgpO1xyXG5cclxuICAvLyBAZnVuY3Rpb24gYmluZChmbjogRnVuY3Rpb24sIOKApik6IEZ1bmN0aW9uXHJcbiAgLy8gUmV0dXJucyBhIG5ldyBmdW5jdGlvbiBib3VuZCB0byB0aGUgYXJndW1lbnRzIHBhc3NlZCwgbGlrZSBbRnVuY3Rpb24ucHJvdG90eXBlLmJpbmRdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0Z1bmN0aW9uL2JpbmQpLlxyXG4gIC8vIEhhcyBhIGBMLmJpbmQoKWAgc2hvcnRjdXQuXHJcbiAgZnVuY3Rpb24gYmluZChmbiwgb2JqKSB7XHJcbiAgXHR2YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XHJcblxyXG4gIFx0aWYgKGZuLmJpbmQpIHtcclxuICBcdFx0cmV0dXJuIGZuLmJpbmQuYXBwbHkoZm4sIHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XHJcbiAgXHR9XHJcblxyXG4gIFx0dmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XHJcblxyXG4gIFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIGZuLmFwcGx5KG9iaiwgYXJncy5sZW5ndGggPyBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpIDogYXJndW1lbnRzKTtcclxuICBcdH07XHJcbiAgfVxyXG5cclxuICAvLyBAcHJvcGVydHkgbGFzdElkOiBOdW1iZXJcclxuICAvLyBMYXN0IHVuaXF1ZSBJRCB1c2VkIGJ5IFtgc3RhbXAoKWBdKCN1dGlsLXN0YW1wKVxyXG4gIHZhciBsYXN0SWQgPSAwO1xyXG5cclxuICAvLyBAZnVuY3Rpb24gc3RhbXAob2JqOiBPYmplY3QpOiBOdW1iZXJcclxuICAvLyBSZXR1cm5zIHRoZSB1bmlxdWUgSUQgb2YgYW4gb2JqZWN0LCBhc3NpZ25pbmcgaXQgb25lIGlmIGl0IGRvZXNuJ3QgaGF2ZSBpdC5cclxuICBmdW5jdGlvbiBzdGFtcChvYmopIHtcclxuICBcdC8qZXNsaW50LWRpc2FibGUgKi9cclxuICBcdG9iai5fbGVhZmxldF9pZCA9IG9iai5fbGVhZmxldF9pZCB8fCArK2xhc3RJZDtcclxuICBcdHJldHVybiBvYmouX2xlYWZsZXRfaWQ7XHJcbiAgXHQvKiBlc2xpbnQtZW5hYmxlICovXHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gdGhyb3R0bGUoZm46IEZ1bmN0aW9uLCB0aW1lOiBOdW1iZXIsIGNvbnRleHQ6IE9iamVjdCk6IEZ1bmN0aW9uXHJcbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHdoaWNoIGV4ZWN1dGVzIGZ1bmN0aW9uIGBmbmAgd2l0aCB0aGUgZ2l2ZW4gc2NvcGUgYGNvbnRleHRgXHJcbiAgLy8gKHNvIHRoYXQgdGhlIGB0aGlzYCBrZXl3b3JkIHJlZmVycyB0byBgY29udGV4dGAgaW5zaWRlIGBmbmAncyBjb2RlKS4gVGhlIGZ1bmN0aW9uXHJcbiAgLy8gYGZuYCB3aWxsIGJlIGNhbGxlZCBubyBtb3JlIHRoYW4gb25lIHRpbWUgcGVyIGdpdmVuIGFtb3VudCBvZiBgdGltZWAuIFRoZSBhcmd1bWVudHNcclxuICAvLyByZWNlaXZlZCBieSB0aGUgYm91bmQgZnVuY3Rpb24gd2lsbCBiZSBhbnkgYXJndW1lbnRzIHBhc3NlZCB3aGVuIGJpbmRpbmcgdGhlXHJcbiAgLy8gZnVuY3Rpb24sIGZvbGxvd2VkIGJ5IGFueSBhcmd1bWVudHMgcGFzc2VkIHdoZW4gaW52b2tpbmcgdGhlIGJvdW5kIGZ1bmN0aW9uLlxyXG4gIC8vIEhhcyBhbiBgTC50aHJvdHRsZWAgc2hvcnRjdXQuXHJcbiAgZnVuY3Rpb24gdGhyb3R0bGUoZm4sIHRpbWUsIGNvbnRleHQpIHtcclxuICBcdHZhciBsb2NrLCBhcmdzLCB3cmFwcGVyRm4sIGxhdGVyO1xyXG5cclxuICBcdGxhdGVyID0gZnVuY3Rpb24gKCkge1xyXG4gIFx0XHQvLyByZXNldCBsb2NrIGFuZCBjYWxsIGlmIHF1ZXVlZFxyXG4gIFx0XHRsb2NrID0gZmFsc2U7XHJcbiAgXHRcdGlmIChhcmdzKSB7XHJcbiAgXHRcdFx0d3JhcHBlckZuLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xyXG4gIFx0XHRcdGFyZ3MgPSBmYWxzZTtcclxuICBcdFx0fVxyXG4gIFx0fTtcclxuXHJcbiAgXHR3cmFwcGVyRm4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdGlmIChsb2NrKSB7XHJcbiAgXHRcdFx0Ly8gY2FsbGVkIHRvbyBzb29uLCBxdWV1ZSB0byBjYWxsIGxhdGVyXHJcbiAgXHRcdFx0YXJncyA9IGFyZ3VtZW50cztcclxuXHJcbiAgXHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0Ly8gY2FsbCBhbmQgbG9jayB1bnRpbCBsYXRlclxyXG4gIFx0XHRcdGZuLmFwcGx5KGNvbnRleHQsIGFyZ3VtZW50cyk7XHJcbiAgXHRcdFx0c2V0VGltZW91dChsYXRlciwgdGltZSk7XHJcbiAgXHRcdFx0bG9jayA9IHRydWU7XHJcbiAgXHRcdH1cclxuICBcdH07XHJcblxyXG4gIFx0cmV0dXJuIHdyYXBwZXJGbjtcclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiB3cmFwTnVtKG51bTogTnVtYmVyLCByYW5nZTogTnVtYmVyW10sIGluY2x1ZGVNYXg/OiBCb29sZWFuKTogTnVtYmVyXHJcbiAgLy8gUmV0dXJucyB0aGUgbnVtYmVyIGBudW1gIG1vZHVsbyBgcmFuZ2VgIGluIHN1Y2ggYSB3YXkgc28gaXQgbGllcyB3aXRoaW5cclxuICAvLyBgcmFuZ2VbMF1gIGFuZCBgcmFuZ2VbMV1gLiBUaGUgcmV0dXJuZWQgdmFsdWUgd2lsbCBiZSBhbHdheXMgc21hbGxlciB0aGFuXHJcbiAgLy8gYHJhbmdlWzFdYCB1bmxlc3MgYGluY2x1ZGVNYXhgIGlzIHNldCB0byBgdHJ1ZWAuXHJcbiAgZnVuY3Rpb24gd3JhcE51bSh4LCByYW5nZSwgaW5jbHVkZU1heCkge1xyXG4gIFx0dmFyIG1heCA9IHJhbmdlWzFdLFxyXG4gIFx0ICAgIG1pbiA9IHJhbmdlWzBdLFxyXG4gIFx0ICAgIGQgPSBtYXggLSBtaW47XHJcbiAgXHRyZXR1cm4geCA9PT0gbWF4ICYmIGluY2x1ZGVNYXggPyB4IDogKCh4IC0gbWluKSAlIGQgKyBkKSAlIGQgKyBtaW47XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gZmFsc2VGbigpOiBGdW5jdGlvblxyXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiB3aGljaCBhbHdheXMgcmV0dXJucyBgZmFsc2VgLlxyXG4gIGZ1bmN0aW9uIGZhbHNlRm4oKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gZm9ybWF0TnVtKG51bTogTnVtYmVyLCBkaWdpdHM/OiBOdW1iZXIpOiBOdW1iZXJcclxuICAvLyBSZXR1cm5zIHRoZSBudW1iZXIgYG51bWAgcm91bmRlZCB0byBgZGlnaXRzYCBkZWNpbWFscywgb3IgdG8gNiBkZWNpbWFscyBieSBkZWZhdWx0LlxyXG4gIGZ1bmN0aW9uIGZvcm1hdE51bShudW0sIGRpZ2l0cykge1xyXG4gIFx0dmFyIHBvdyA9IE1hdGgucG93KDEwLCAoZGlnaXRzID09PSB1bmRlZmluZWQgPyA2IDogZGlnaXRzKSk7XHJcbiAgXHRyZXR1cm4gTWF0aC5yb3VuZChudW0gKiBwb3cpIC8gcG93O1xyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIHRyaW0oc3RyOiBTdHJpbmcpOiBTdHJpbmdcclxuICAvLyBDb21wYXRpYmlsaXR5IHBvbHlmaWxsIGZvciBbU3RyaW5nLnByb3RvdHlwZS50cmltXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvVHJpbSlcclxuICBmdW5jdGlvbiB0cmltKHN0cikge1xyXG4gIFx0cmV0dXJuIHN0ci50cmltID8gc3RyLnRyaW0oKSA6IHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJyk7XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gc3BsaXRXb3JkcyhzdHI6IFN0cmluZyk6IFN0cmluZ1tdXHJcbiAgLy8gVHJpbXMgYW5kIHNwbGl0cyB0aGUgc3RyaW5nIG9uIHdoaXRlc3BhY2UgYW5kIHJldHVybnMgdGhlIGFycmF5IG9mIHBhcnRzLlxyXG4gIGZ1bmN0aW9uIHNwbGl0V29yZHMoc3RyKSB7XHJcbiAgXHRyZXR1cm4gdHJpbShzdHIpLnNwbGl0KC9cXHMrLyk7XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gc2V0T3B0aW9ucyhvYmo6IE9iamVjdCwgb3B0aW9uczogT2JqZWN0KTogT2JqZWN0XHJcbiAgLy8gTWVyZ2VzIHRoZSBnaXZlbiBwcm9wZXJ0aWVzIHRvIHRoZSBgb3B0aW9uc2Agb2YgdGhlIGBvYmpgIG9iamVjdCwgcmV0dXJuaW5nIHRoZSByZXN1bHRpbmcgb3B0aW9ucy4gU2VlIGBDbGFzcyBvcHRpb25zYC4gSGFzIGFuIGBMLnNldE9wdGlvbnNgIHNob3J0Y3V0LlxyXG4gIGZ1bmN0aW9uIHNldE9wdGlvbnMob2JqLCBvcHRpb25zKSB7XHJcbiAgXHRpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosICdvcHRpb25zJykpIHtcclxuICBcdFx0b2JqLm9wdGlvbnMgPSBvYmoub3B0aW9ucyA/IGNyZWF0ZShvYmoub3B0aW9ucykgOiB7fTtcclxuICBcdH1cclxuICBcdGZvciAodmFyIGkgaW4gb3B0aW9ucykge1xyXG4gIFx0XHRvYmoub3B0aW9uc1tpXSA9IG9wdGlvbnNbaV07XHJcbiAgXHR9XHJcbiAgXHRyZXR1cm4gb2JqLm9wdGlvbnM7XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gZ2V0UGFyYW1TdHJpbmcob2JqOiBPYmplY3QsIGV4aXN0aW5nVXJsPzogU3RyaW5nLCB1cHBlcmNhc2U/OiBCb29sZWFuKTogU3RyaW5nXHJcbiAgLy8gQ29udmVydHMgYW4gb2JqZWN0IGludG8gYSBwYXJhbWV0ZXIgVVJMIHN0cmluZywgZS5nLiBge2E6IFwiZm9vXCIsIGI6IFwiYmFyXCJ9YFxyXG4gIC8vIHRyYW5zbGF0ZXMgdG8gYCc/YT1mb28mYj1iYXInYC4gSWYgYGV4aXN0aW5nVXJsYCBpcyBzZXQsIHRoZSBwYXJhbWV0ZXJzIHdpbGxcclxuICAvLyBiZSBhcHBlbmRlZCBhdCB0aGUgZW5kLiBJZiBgdXBwZXJjYXNlYCBpcyBgdHJ1ZWAsIHRoZSBwYXJhbWV0ZXIgbmFtZXMgd2lsbFxyXG4gIC8vIGJlIHVwcGVyY2FzZWQgKGUuZy4gYCc/QT1mb28mQj1iYXInYClcclxuICBmdW5jdGlvbiBnZXRQYXJhbVN0cmluZyhvYmosIGV4aXN0aW5nVXJsLCB1cHBlcmNhc2UpIHtcclxuICBcdHZhciBwYXJhbXMgPSBbXTtcclxuICBcdGZvciAodmFyIGkgaW4gb2JqKSB7XHJcbiAgXHRcdHBhcmFtcy5wdXNoKGVuY29kZVVSSUNvbXBvbmVudCh1cHBlcmNhc2UgPyBpLnRvVXBwZXJDYXNlKCkgOiBpKSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudChvYmpbaV0pKTtcclxuICBcdH1cclxuICBcdHJldHVybiAoKCFleGlzdGluZ1VybCB8fCBleGlzdGluZ1VybC5pbmRleE9mKCc/JykgPT09IC0xKSA/ICc/JyA6ICcmJykgKyBwYXJhbXMuam9pbignJicpO1xyXG4gIH1cclxuXHJcbiAgdmFyIHRlbXBsYXRlUmUgPSAvXFx7ICooW1xcd18tXSspICpcXH0vZztcclxuXHJcbiAgLy8gQGZ1bmN0aW9uIHRlbXBsYXRlKHN0cjogU3RyaW5nLCBkYXRhOiBPYmplY3QpOiBTdHJpbmdcclxuICAvLyBTaW1wbGUgdGVtcGxhdGluZyBmYWNpbGl0eSwgYWNjZXB0cyBhIHRlbXBsYXRlIHN0cmluZyBvZiB0aGUgZm9ybSBgJ0hlbGxvIHthfSwge2J9J2BcclxuICAvLyBhbmQgYSBkYXRhIG9iamVjdCBsaWtlIGB7YTogJ2ZvbycsIGI6ICdiYXInfWAsIHJldHVybnMgZXZhbHVhdGVkIHN0cmluZ1xyXG4gIC8vIGAoJ0hlbGxvIGZvbywgYmFyJylgLiBZb3UgY2FuIGFsc28gc3BlY2lmeSBmdW5jdGlvbnMgaW5zdGVhZCBvZiBzdHJpbmdzIGZvclxyXG4gIC8vIGRhdGEgdmFsdWVzIOKAlCB0aGV5IHdpbGwgYmUgZXZhbHVhdGVkIHBhc3NpbmcgYGRhdGFgIGFzIGFuIGFyZ3VtZW50LlxyXG4gIGZ1bmN0aW9uIHRlbXBsYXRlKHN0ciwgZGF0YSkge1xyXG4gIFx0cmV0dXJuIHN0ci5yZXBsYWNlKHRlbXBsYXRlUmUsIGZ1bmN0aW9uIChzdHIsIGtleSkge1xyXG4gIFx0XHR2YXIgdmFsdWUgPSBkYXRhW2tleV07XHJcblxyXG4gIFx0XHRpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xyXG4gIFx0XHRcdHRocm93IG5ldyBFcnJvcignTm8gdmFsdWUgcHJvdmlkZWQgZm9yIHZhcmlhYmxlICcgKyBzdHIpO1xyXG5cclxuICBcdFx0fSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcclxuICBcdFx0XHR2YWx1ZSA9IHZhbHVlKGRhdGEpO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiB2YWx1ZTtcclxuICBcdH0pO1xyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGlzQXJyYXkob2JqKTogQm9vbGVhblxyXG4gIC8vIENvbXBhdGliaWxpdHkgcG9seWZpbGwgZm9yIFtBcnJheS5pc0FycmF5XShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9pc0FycmF5KVxyXG4gIHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAob2JqKSB7XHJcbiAgXHRyZXR1cm4gKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBBcnJheV0nKTtcclxuICB9O1xyXG5cclxuICAvLyBAZnVuY3Rpb24gaW5kZXhPZihhcnJheTogQXJyYXksIGVsOiBPYmplY3QpOiBOdW1iZXJcclxuICAvLyBDb21wYXRpYmlsaXR5IHBvbHlmaWxsIGZvciBbQXJyYXkucHJvdG90eXBlLmluZGV4T2ZdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2luZGV4T2YpXHJcbiAgZnVuY3Rpb24gaW5kZXhPZihhcnJheSwgZWwpIHtcclxuICBcdGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcclxuICBcdFx0aWYgKGFycmF5W2ldID09PSBlbCkgeyByZXR1cm4gaTsgfVxyXG4gIFx0fVxyXG4gIFx0cmV0dXJuIC0xO1xyXG4gIH1cclxuXHJcbiAgLy8gQHByb3BlcnR5IGVtcHR5SW1hZ2VVcmw6IFN0cmluZ1xyXG4gIC8vIERhdGEgVVJJIHN0cmluZyBjb250YWluaW5nIGEgYmFzZTY0LWVuY29kZWQgZW1wdHkgR0lGIGltYWdlLlxyXG4gIC8vIFVzZWQgYXMgYSBoYWNrIHRvIGZyZWUgbWVtb3J5IGZyb20gdW51c2VkIGltYWdlcyBvbiBXZWJLaXQtcG93ZXJlZFxyXG4gIC8vIG1vYmlsZSBkZXZpY2VzIChieSBzZXR0aW5nIGltYWdlIGBzcmNgIHRvIHRoaXMgc3RyaW5nKS5cclxuICB2YXIgZW1wdHlJbWFnZVVybCA9ICdkYXRhOmltYWdlL2dpZjtiYXNlNjQsUjBsR09EbGhBUUFCQUFEL0FDd0FBQUFBQVFBQkFBQUNBRHM9JztcclxuXHJcbiAgLy8gaW5zcGlyZWQgYnkgaHR0cDovL3BhdWxpcmlzaC5jb20vMjAxMS9yZXF1ZXN0YW5pbWF0aW9uZnJhbWUtZm9yLXNtYXJ0LWFuaW1hdGluZy9cclxuXHJcbiAgZnVuY3Rpb24gZ2V0UHJlZml4ZWQobmFtZSkge1xyXG4gIFx0cmV0dXJuIHdpbmRvd1snd2Via2l0JyArIG5hbWVdIHx8IHdpbmRvd1snbW96JyArIG5hbWVdIHx8IHdpbmRvd1snbXMnICsgbmFtZV07XHJcbiAgfVxyXG5cclxuICB2YXIgbGFzdFRpbWUgPSAwO1xyXG5cclxuICAvLyBmYWxsYmFjayBmb3IgSUUgNy04XHJcbiAgZnVuY3Rpb24gdGltZW91dERlZmVyKGZuKSB7XHJcbiAgXHR2YXIgdGltZSA9ICtuZXcgRGF0ZSgpLFxyXG4gIFx0ICAgIHRpbWVUb0NhbGwgPSBNYXRoLm1heCgwLCAxNiAtICh0aW1lIC0gbGFzdFRpbWUpKTtcclxuXHJcbiAgXHRsYXN0VGltZSA9IHRpbWUgKyB0aW1lVG9DYWxsO1xyXG4gIFx0cmV0dXJuIHdpbmRvdy5zZXRUaW1lb3V0KGZuLCB0aW1lVG9DYWxsKTtcclxuICB9XHJcblxyXG4gIHZhciByZXF1ZXN0Rm4gPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IGdldFByZWZpeGVkKCdSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnKSB8fCB0aW1lb3V0RGVmZXI7XHJcbiAgdmFyIGNhbmNlbEZuID0gd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lIHx8IGdldFByZWZpeGVkKCdDYW5jZWxBbmltYXRpb25GcmFtZScpIHx8XHJcbiAgXHRcdGdldFByZWZpeGVkKCdDYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnKSB8fCBmdW5jdGlvbiAoaWQpIHsgd2luZG93LmNsZWFyVGltZW91dChpZCk7IH07XHJcblxyXG4gIC8vIEBmdW5jdGlvbiByZXF1ZXN0QW5pbUZyYW1lKGZuOiBGdW5jdGlvbiwgY29udGV4dD86IE9iamVjdCwgaW1tZWRpYXRlPzogQm9vbGVhbik6IE51bWJlclxyXG4gIC8vIFNjaGVkdWxlcyBgZm5gIHRvIGJlIGV4ZWN1dGVkIHdoZW4gdGhlIGJyb3dzZXIgcmVwYWludHMuIGBmbmAgaXMgYm91bmQgdG9cclxuICAvLyBgY29udGV4dGAgaWYgZ2l2ZW4uIFdoZW4gYGltbWVkaWF0ZWAgaXMgc2V0LCBgZm5gIGlzIGNhbGxlZCBpbW1lZGlhdGVseSBpZlxyXG4gIC8vIHRoZSBicm93c2VyIGRvZXNuJ3QgaGF2ZSBuYXRpdmUgc3VwcG9ydCBmb3JcclxuICAvLyBbYHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWVgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvd2luZG93L3JlcXVlc3RBbmltYXRpb25GcmFtZSksXHJcbiAgLy8gb3RoZXJ3aXNlIGl0J3MgZGVsYXllZC4gUmV0dXJucyBhIHJlcXVlc3QgSUQgdGhhdCBjYW4gYmUgdXNlZCB0byBjYW5jZWwgdGhlIHJlcXVlc3QuXHJcbiAgZnVuY3Rpb24gcmVxdWVzdEFuaW1GcmFtZShmbiwgY29udGV4dCwgaW1tZWRpYXRlKSB7XHJcbiAgXHRpZiAoaW1tZWRpYXRlICYmIHJlcXVlc3RGbiA9PT0gdGltZW91dERlZmVyKSB7XHJcbiAgXHRcdGZuLmNhbGwoY29udGV4dCk7XHJcbiAgXHR9IGVsc2Uge1xyXG4gIFx0XHRyZXR1cm4gcmVxdWVzdEZuLmNhbGwod2luZG93LCBiaW5kKGZuLCBjb250ZXh0KSk7XHJcbiAgXHR9XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gY2FuY2VsQW5pbUZyYW1lKGlkOiBOdW1iZXIpOiB1bmRlZmluZWRcclxuICAvLyBDYW5jZWxzIGEgcHJldmlvdXMgYHJlcXVlc3RBbmltRnJhbWVgLiBTZWUgYWxzbyBbd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvd2luZG93L2NhbmNlbEFuaW1hdGlvbkZyYW1lKS5cclxuICBmdW5jdGlvbiBjYW5jZWxBbmltRnJhbWUoaWQpIHtcclxuICBcdGlmIChpZCkge1xyXG4gIFx0XHRjYW5jZWxGbi5jYWxsKHdpbmRvdywgaWQpO1xyXG4gIFx0fVxyXG4gIH1cblxuICB2YXIgVXRpbCA9ICh7XG4gICAgZXh0ZW5kOiBleHRlbmQsXG4gICAgY3JlYXRlOiBjcmVhdGUsXG4gICAgYmluZDogYmluZCxcbiAgICBsYXN0SWQ6IGxhc3RJZCxcbiAgICBzdGFtcDogc3RhbXAsXG4gICAgdGhyb3R0bGU6IHRocm90dGxlLFxuICAgIHdyYXBOdW06IHdyYXBOdW0sXG4gICAgZmFsc2VGbjogZmFsc2VGbixcbiAgICBmb3JtYXROdW06IGZvcm1hdE51bSxcbiAgICB0cmltOiB0cmltLFxuICAgIHNwbGl0V29yZHM6IHNwbGl0V29yZHMsXG4gICAgc2V0T3B0aW9uczogc2V0T3B0aW9ucyxcbiAgICBnZXRQYXJhbVN0cmluZzogZ2V0UGFyYW1TdHJpbmcsXG4gICAgdGVtcGxhdGU6IHRlbXBsYXRlLFxuICAgIGlzQXJyYXk6IGlzQXJyYXksXG4gICAgaW5kZXhPZjogaW5kZXhPZixcbiAgICBlbXB0eUltYWdlVXJsOiBlbXB0eUltYWdlVXJsLFxuICAgIHJlcXVlc3RGbjogcmVxdWVzdEZuLFxuICAgIGNhbmNlbEZuOiBjYW5jZWxGbixcbiAgICByZXF1ZXN0QW5pbUZyYW1lOiByZXF1ZXN0QW5pbUZyYW1lLFxuICAgIGNhbmNlbEFuaW1GcmFtZTogY2FuY2VsQW5pbUZyYW1lXG4gIH0pO1xuXG4gIC8vIEBjbGFzcyBDbGFzc1xyXG4gIC8vIEBha2EgTC5DbGFzc1xyXG5cclxuICAvLyBAc2VjdGlvblxyXG4gIC8vIEB1bmluaGVyaXRhYmxlXHJcblxyXG4gIC8vIFRoYW5rcyB0byBKb2huIFJlc2lnIGFuZCBEZWFuIEVkd2FyZHMgZm9yIGluc3BpcmF0aW9uIVxyXG5cclxuICBmdW5jdGlvbiBDbGFzcygpIHt9XHJcblxyXG4gIENsYXNzLmV4dGVuZCA9IGZ1bmN0aW9uIChwcm9wcykge1xyXG5cclxuICBcdC8vIEBmdW5jdGlvbiBleHRlbmQocHJvcHM6IE9iamVjdCk6IEZ1bmN0aW9uXHJcbiAgXHQvLyBbRXh0ZW5kcyB0aGUgY3VycmVudCBjbGFzc10oI2NsYXNzLWluaGVyaXRhbmNlKSBnaXZlbiB0aGUgcHJvcGVydGllcyB0byBiZSBpbmNsdWRlZC5cclxuICBcdC8vIFJldHVybnMgYSBKYXZhc2NyaXB0IGZ1bmN0aW9uIHRoYXQgaXMgYSBjbGFzcyBjb25zdHJ1Y3RvciAodG8gYmUgY2FsbGVkIHdpdGggYG5ld2ApLlxyXG4gIFx0dmFyIE5ld0NsYXNzID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICBcdFx0Ly8gY2FsbCB0aGUgY29uc3RydWN0b3JcclxuICBcdFx0aWYgKHRoaXMuaW5pdGlhbGl6ZSkge1xyXG4gIFx0XHRcdHRoaXMuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHQvLyBjYWxsIGFsbCBjb25zdHJ1Y3RvciBob29rc1xyXG4gIFx0XHR0aGlzLmNhbGxJbml0SG9va3MoKTtcclxuICBcdH07XHJcblxyXG4gIFx0dmFyIHBhcmVudFByb3RvID0gTmV3Q2xhc3MuX19zdXBlcl9fID0gdGhpcy5wcm90b3R5cGU7XHJcblxyXG4gIFx0dmFyIHByb3RvID0gY3JlYXRlKHBhcmVudFByb3RvKTtcclxuICBcdHByb3RvLmNvbnN0cnVjdG9yID0gTmV3Q2xhc3M7XHJcblxyXG4gIFx0TmV3Q2xhc3MucHJvdG90eXBlID0gcHJvdG87XHJcblxyXG4gIFx0Ly8gaW5oZXJpdCBwYXJlbnQncyBzdGF0aWNzXHJcbiAgXHRmb3IgKHZhciBpIGluIHRoaXMpIHtcclxuICBcdFx0aWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLCBpKSAmJiBpICE9PSAncHJvdG90eXBlJyAmJiBpICE9PSAnX19zdXBlcl9fJykge1xyXG4gIFx0XHRcdE5ld0NsYXNzW2ldID0gdGhpc1tpXTtcclxuICBcdFx0fVxyXG4gIFx0fVxyXG5cclxuICBcdC8vIG1peCBzdGF0aWMgcHJvcGVydGllcyBpbnRvIHRoZSBjbGFzc1xyXG4gIFx0aWYgKHByb3BzLnN0YXRpY3MpIHtcclxuICBcdFx0ZXh0ZW5kKE5ld0NsYXNzLCBwcm9wcy5zdGF0aWNzKTtcclxuICBcdFx0ZGVsZXRlIHByb3BzLnN0YXRpY3M7XHJcbiAgXHR9XHJcblxyXG4gIFx0Ly8gbWl4IGluY2x1ZGVzIGludG8gdGhlIHByb3RvdHlwZVxyXG4gIFx0aWYgKHByb3BzLmluY2x1ZGVzKSB7XHJcbiAgXHRcdGNoZWNrRGVwcmVjYXRlZE1peGluRXZlbnRzKHByb3BzLmluY2x1ZGVzKTtcclxuICBcdFx0ZXh0ZW5kLmFwcGx5KG51bGwsIFtwcm90b10uY29uY2F0KHByb3BzLmluY2x1ZGVzKSk7XHJcbiAgXHRcdGRlbGV0ZSBwcm9wcy5pbmNsdWRlcztcclxuICBcdH1cclxuXHJcbiAgXHQvLyBtZXJnZSBvcHRpb25zXHJcbiAgXHRpZiAocHJvdG8ub3B0aW9ucykge1xyXG4gIFx0XHRwcm9wcy5vcHRpb25zID0gZXh0ZW5kKGNyZWF0ZShwcm90by5vcHRpb25zKSwgcHJvcHMub3B0aW9ucyk7XHJcbiAgXHR9XHJcblxyXG4gIFx0Ly8gbWl4IGdpdmVuIHByb3BlcnRpZXMgaW50byB0aGUgcHJvdG90eXBlXHJcbiAgXHRleHRlbmQocHJvdG8sIHByb3BzKTtcclxuXHJcbiAgXHRwcm90by5faW5pdEhvb2tzID0gW107XHJcblxyXG4gIFx0Ly8gYWRkIG1ldGhvZCBmb3IgY2FsbGluZyBhbGwgaG9va3NcclxuICBcdHByb3RvLmNhbGxJbml0SG9va3MgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gIFx0XHRpZiAodGhpcy5faW5pdEhvb2tzQ2FsbGVkKSB7IHJldHVybjsgfVxyXG5cclxuICBcdFx0aWYgKHBhcmVudFByb3RvLmNhbGxJbml0SG9va3MpIHtcclxuICBcdFx0XHRwYXJlbnRQcm90by5jYWxsSW5pdEhvb2tzLmNhbGwodGhpcyk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMuX2luaXRIb29rc0NhbGxlZCA9IHRydWU7XHJcblxyXG4gIFx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gcHJvdG8uX2luaXRIb29rcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gIFx0XHRcdHByb3RvLl9pbml0SG9va3NbaV0uY2FsbCh0aGlzKTtcclxuICBcdFx0fVxyXG4gIFx0fTtcclxuXHJcbiAgXHRyZXR1cm4gTmV3Q2xhc3M7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8vIEBmdW5jdGlvbiBpbmNsdWRlKHByb3BlcnRpZXM6IE9iamVjdCk6IHRoaXNcclxuICAvLyBbSW5jbHVkZXMgYSBtaXhpbl0oI2NsYXNzLWluY2x1ZGVzKSBpbnRvIHRoZSBjdXJyZW50IGNsYXNzLlxyXG4gIENsYXNzLmluY2x1ZGUgPSBmdW5jdGlvbiAocHJvcHMpIHtcclxuICBcdGV4dGVuZCh0aGlzLnByb3RvdHlwZSwgcHJvcHMpO1xyXG4gIFx0cmV0dXJuIHRoaXM7XHJcbiAgfTtcclxuXHJcbiAgLy8gQGZ1bmN0aW9uIG1lcmdlT3B0aW9ucyhvcHRpb25zOiBPYmplY3QpOiB0aGlzXHJcbiAgLy8gW01lcmdlcyBgb3B0aW9uc2BdKCNjbGFzcy1vcHRpb25zKSBpbnRvIHRoZSBkZWZhdWx0cyBvZiB0aGUgY2xhc3MuXHJcbiAgQ2xhc3MubWVyZ2VPcHRpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICBcdGV4dGVuZCh0aGlzLnByb3RvdHlwZS5vcHRpb25zLCBvcHRpb25zKTtcclxuICBcdHJldHVybiB0aGlzO1xyXG4gIH07XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBhZGRJbml0SG9vayhmbjogRnVuY3Rpb24pOiB0aGlzXHJcbiAgLy8gQWRkcyBhIFtjb25zdHJ1Y3RvciBob29rXSgjY2xhc3MtY29uc3RydWN0b3ItaG9va3MpIHRvIHRoZSBjbGFzcy5cclxuICBDbGFzcy5hZGRJbml0SG9vayA9IGZ1bmN0aW9uIChmbikgeyAvLyAoRnVuY3Rpb24pIHx8IChTdHJpbmcsIGFyZ3MuLi4pXHJcbiAgXHR2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XHJcblxyXG4gIFx0dmFyIGluaXQgPSB0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicgPyBmbiA6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dGhpc1tmbl0uYXBwbHkodGhpcywgYXJncyk7XHJcbiAgXHR9O1xyXG5cclxuICBcdHRoaXMucHJvdG90eXBlLl9pbml0SG9va3MgPSB0aGlzLnByb3RvdHlwZS5faW5pdEhvb2tzIHx8IFtdO1xyXG4gIFx0dGhpcy5wcm90b3R5cGUuX2luaXRIb29rcy5wdXNoKGluaXQpO1xyXG4gIFx0cmV0dXJuIHRoaXM7XHJcbiAgfTtcclxuXHJcbiAgZnVuY3Rpb24gY2hlY2tEZXByZWNhdGVkTWl4aW5FdmVudHMoaW5jbHVkZXMpIHtcclxuICBcdGlmICh0eXBlb2YgTCA9PT0gJ3VuZGVmaW5lZCcgfHwgIUwgfHwgIUwuTWl4aW4pIHsgcmV0dXJuOyB9XHJcblxyXG4gIFx0aW5jbHVkZXMgPSBpc0FycmF5KGluY2x1ZGVzKSA/IGluY2x1ZGVzIDogW2luY2x1ZGVzXTtcclxuXHJcbiAgXHRmb3IgKHZhciBpID0gMDsgaSA8IGluY2x1ZGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgXHRcdGlmIChpbmNsdWRlc1tpXSA9PT0gTC5NaXhpbi5FdmVudHMpIHtcclxuICBcdFx0XHRjb25zb2xlLndhcm4oJ0RlcHJlY2F0ZWQgaW5jbHVkZSBvZiBMLk1peGluLkV2ZW50czogJyArXHJcbiAgXHRcdFx0XHQndGhpcyBwcm9wZXJ0eSB3aWxsIGJlIHJlbW92ZWQgaW4gZnV0dXJlIHJlbGVhc2VzLCAnICtcclxuICBcdFx0XHRcdCdwbGVhc2UgaW5oZXJpdCBmcm9tIEwuRXZlbnRlZCBpbnN0ZWFkLicsIG5ldyBFcnJvcigpLnN0YWNrKTtcclxuICBcdFx0fVxyXG4gIFx0fVxyXG4gIH1cblxuICAvKlxyXG4gICAqIEBjbGFzcyBFdmVudGVkXHJcbiAgICogQGFrYSBMLkV2ZW50ZWRcclxuICAgKiBAaW5oZXJpdHMgQ2xhc3NcclxuICAgKlxyXG4gICAqIEEgc2V0IG9mIG1ldGhvZHMgc2hhcmVkIGJldHdlZW4gZXZlbnQtcG93ZXJlZCBjbGFzc2VzIChsaWtlIGBNYXBgIGFuZCBgTWFya2VyYCkuIEdlbmVyYWxseSwgZXZlbnRzIGFsbG93IHlvdSB0byBleGVjdXRlIHNvbWUgZnVuY3Rpb24gd2hlbiBzb21ldGhpbmcgaGFwcGVucyB3aXRoIGFuIG9iamVjdCAoZS5nLiB0aGUgdXNlciBjbGlja3Mgb24gdGhlIG1hcCwgY2F1c2luZyB0aGUgbWFwIHRvIGZpcmUgYCdjbGljaydgIGV2ZW50KS5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICpcclxuICAgKiBgYGBqc1xyXG4gICAqIG1hcC5vbignY2xpY2snLCBmdW5jdGlvbihlKSB7XHJcbiAgICogXHRhbGVydChlLmxhdGxuZyk7XHJcbiAgICogfSApO1xyXG4gICAqIGBgYFxyXG4gICAqXHJcbiAgICogTGVhZmxldCBkZWFscyB3aXRoIGV2ZW50IGxpc3RlbmVycyBieSByZWZlcmVuY2UsIHNvIGlmIHlvdSB3YW50IHRvIGFkZCBhIGxpc3RlbmVyIGFuZCB0aGVuIHJlbW92ZSBpdCwgZGVmaW5lIGl0IGFzIGEgZnVuY3Rpb246XHJcbiAgICpcclxuICAgKiBgYGBqc1xyXG4gICAqIGZ1bmN0aW9uIG9uQ2xpY2soZSkgeyAuLi4gfVxyXG4gICAqXHJcbiAgICogbWFwLm9uKCdjbGljaycsIG9uQ2xpY2spO1xyXG4gICAqIG1hcC5vZmYoJ2NsaWNrJywgb25DbGljayk7XHJcbiAgICogYGBgXHJcbiAgICovXHJcblxyXG4gIHZhciBFdmVudHMgPSB7XHJcbiAgXHQvKiBAbWV0aG9kIG9uKHR5cGU6IFN0cmluZywgZm46IEZ1bmN0aW9uLCBjb250ZXh0PzogT2JqZWN0KTogdGhpc1xyXG4gIFx0ICogQWRkcyBhIGxpc3RlbmVyIGZ1bmN0aW9uIChgZm5gKSB0byBhIHBhcnRpY3VsYXIgZXZlbnQgdHlwZSBvZiB0aGUgb2JqZWN0LiBZb3UgY2FuIG9wdGlvbmFsbHkgc3BlY2lmeSB0aGUgY29udGV4dCBvZiB0aGUgbGlzdGVuZXIgKG9iamVjdCB0aGUgdGhpcyBrZXl3b3JkIHdpbGwgcG9pbnQgdG8pLiBZb3UgY2FuIGFsc28gcGFzcyBzZXZlcmFsIHNwYWNlLXNlcGFyYXRlZCB0eXBlcyAoZS5nLiBgJ2NsaWNrIGRibGNsaWNrJ2ApLlxyXG4gIFx0ICpcclxuICBcdCAqIEBhbHRlcm5hdGl2ZVxyXG4gIFx0ICogQG1ldGhvZCBvbihldmVudE1hcDogT2JqZWN0KTogdGhpc1xyXG4gIFx0ICogQWRkcyBhIHNldCBvZiB0eXBlL2xpc3RlbmVyIHBhaXJzLCBlLmcuIGB7Y2xpY2s6IG9uQ2xpY2ssIG1vdXNlbW92ZTogb25Nb3VzZU1vdmV9YFxyXG4gIFx0ICovXHJcbiAgXHRvbjogZnVuY3Rpb24gKHR5cGVzLCBmbiwgY29udGV4dCkge1xyXG5cclxuICBcdFx0Ly8gdHlwZXMgY2FuIGJlIGEgbWFwIG9mIHR5cGVzL2hhbmRsZXJzXHJcbiAgXHRcdGlmICh0eXBlb2YgdHlwZXMgPT09ICdvYmplY3QnKSB7XHJcbiAgXHRcdFx0Zm9yICh2YXIgdHlwZSBpbiB0eXBlcykge1xyXG4gIFx0XHRcdFx0Ly8gd2UgZG9uJ3QgcHJvY2VzcyBzcGFjZS1zZXBhcmF0ZWQgZXZlbnRzIGhlcmUgZm9yIHBlcmZvcm1hbmNlO1xyXG4gIFx0XHRcdFx0Ly8gaXQncyBhIGhvdCBwYXRoIHNpbmNlIExheWVyIHVzZXMgdGhlIG9uKG9iaikgc3ludGF4XHJcbiAgXHRcdFx0XHR0aGlzLl9vbih0eXBlLCB0eXBlc1t0eXBlXSwgZm4pO1xyXG4gIFx0XHRcdH1cclxuXHJcbiAgXHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0Ly8gdHlwZXMgY2FuIGJlIGEgc3RyaW5nIG9mIHNwYWNlLXNlcGFyYXRlZCB3b3Jkc1xyXG4gIFx0XHRcdHR5cGVzID0gc3BsaXRXb3Jkcyh0eXBlcyk7XHJcblxyXG4gIFx0XHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSB0eXBlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gIFx0XHRcdFx0dGhpcy5fb24odHlwZXNbaV0sIGZuLCBjb250ZXh0KTtcclxuICBcdFx0XHR9XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvKiBAbWV0aG9kIG9mZih0eXBlOiBTdHJpbmcsIGZuPzogRnVuY3Rpb24sIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXHJcbiAgXHQgKiBSZW1vdmVzIGEgcHJldmlvdXNseSBhZGRlZCBsaXN0ZW5lciBmdW5jdGlvbi4gSWYgbm8gZnVuY3Rpb24gaXMgc3BlY2lmaWVkLCBpdCB3aWxsIHJlbW92ZSBhbGwgdGhlIGxpc3RlbmVycyBvZiB0aGF0IHBhcnRpY3VsYXIgZXZlbnQgZnJvbSB0aGUgb2JqZWN0LiBOb3RlIHRoYXQgaWYgeW91IHBhc3NlZCBhIGN1c3RvbSBjb250ZXh0IHRvIGBvbmAsIHlvdSBtdXN0IHBhc3MgdGhlIHNhbWUgY29udGV4dCB0byBgb2ZmYCBpbiBvcmRlciB0byByZW1vdmUgdGhlIGxpc3RlbmVyLlxyXG4gIFx0ICpcclxuICBcdCAqIEBhbHRlcm5hdGl2ZVxyXG4gIFx0ICogQG1ldGhvZCBvZmYoZXZlbnRNYXA6IE9iamVjdCk6IHRoaXNcclxuICBcdCAqIFJlbW92ZXMgYSBzZXQgb2YgdHlwZS9saXN0ZW5lciBwYWlycy5cclxuICBcdCAqXHJcbiAgXHQgKiBAYWx0ZXJuYXRpdmVcclxuICBcdCAqIEBtZXRob2Qgb2ZmOiB0aGlzXHJcbiAgXHQgKiBSZW1vdmVzIGFsbCBsaXN0ZW5lcnMgdG8gYWxsIGV2ZW50cyBvbiB0aGUgb2JqZWN0LiBUaGlzIGluY2x1ZGVzIGltcGxpY2l0bHkgYXR0YWNoZWQgZXZlbnRzLlxyXG4gIFx0ICovXHJcbiAgXHRvZmY6IGZ1bmN0aW9uICh0eXBlcywgZm4sIGNvbnRleHQpIHtcclxuXHJcbiAgXHRcdGlmICghdHlwZXMpIHtcclxuICBcdFx0XHQvLyBjbGVhciBhbGwgbGlzdGVuZXJzIGlmIGNhbGxlZCB3aXRob3V0IGFyZ3VtZW50c1xyXG4gIFx0XHRcdGRlbGV0ZSB0aGlzLl9ldmVudHM7XHJcblxyXG4gIFx0XHR9IGVsc2UgaWYgKHR5cGVvZiB0eXBlcyA9PT0gJ29iamVjdCcpIHtcclxuICBcdFx0XHRmb3IgKHZhciB0eXBlIGluIHR5cGVzKSB7XHJcbiAgXHRcdFx0XHR0aGlzLl9vZmYodHlwZSwgdHlwZXNbdHlwZV0sIGZuKTtcclxuICBcdFx0XHR9XHJcblxyXG4gIFx0XHR9IGVsc2Uge1xyXG4gIFx0XHRcdHR5cGVzID0gc3BsaXRXb3Jkcyh0eXBlcyk7XHJcblxyXG4gIFx0XHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSB0eXBlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gIFx0XHRcdFx0dGhpcy5fb2ZmKHR5cGVzW2ldLCBmbiwgY29udGV4dCk7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gYXR0YWNoIGxpc3RlbmVyICh3aXRob3V0IHN5bnRhY3RpYyBzdWdhciBub3cpXHJcbiAgXHRfb246IGZ1bmN0aW9uICh0eXBlLCBmbiwgY29udGV4dCkge1xyXG4gIFx0XHR0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMgfHwge307XHJcblxyXG4gIFx0XHQvKiBnZXQvaW5pdCBsaXN0ZW5lcnMgZm9yIHR5cGUgKi9cclxuICBcdFx0dmFyIHR5cGVMaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbdHlwZV07XHJcbiAgXHRcdGlmICghdHlwZUxpc3RlbmVycykge1xyXG4gIFx0XHRcdHR5cGVMaXN0ZW5lcnMgPSBbXTtcclxuICBcdFx0XHR0aGlzLl9ldmVudHNbdHlwZV0gPSB0eXBlTGlzdGVuZXJzO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRpZiAoY29udGV4dCA9PT0gdGhpcykge1xyXG4gIFx0XHRcdC8vIExlc3MgbWVtb3J5IGZvb3RwcmludC5cclxuICBcdFx0XHRjb250ZXh0ID0gdW5kZWZpbmVkO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHZhciBuZXdMaXN0ZW5lciA9IHtmbjogZm4sIGN0eDogY29udGV4dH0sXHJcbiAgXHRcdCAgICBsaXN0ZW5lcnMgPSB0eXBlTGlzdGVuZXJzO1xyXG5cclxuICBcdFx0Ly8gY2hlY2sgaWYgZm4gYWxyZWFkeSB0aGVyZVxyXG4gIFx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgXHRcdFx0aWYgKGxpc3RlbmVyc1tpXS5mbiA9PT0gZm4gJiYgbGlzdGVuZXJzW2ldLmN0eCA9PT0gY29udGV4dCkge1xyXG4gIFx0XHRcdFx0cmV0dXJuO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0fVxyXG5cclxuICBcdFx0bGlzdGVuZXJzLnB1c2gobmV3TGlzdGVuZXIpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfb2ZmOiBmdW5jdGlvbiAodHlwZSwgZm4sIGNvbnRleHQpIHtcclxuICBcdFx0dmFyIGxpc3RlbmVycyxcclxuICBcdFx0ICAgIGksXHJcbiAgXHRcdCAgICBsZW47XHJcblxyXG4gIFx0XHRpZiAoIXRoaXMuX2V2ZW50cykgeyByZXR1cm47IH1cclxuXHJcbiAgXHRcdGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcclxuXHJcbiAgXHRcdGlmICghbGlzdGVuZXJzKSB7XHJcbiAgXHRcdFx0cmV0dXJuO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRpZiAoIWZuKSB7XHJcbiAgXHRcdFx0Ly8gU2V0IGFsbCByZW1vdmVkIGxpc3RlbmVycyB0byBub29wIHNvIHRoZXkgYXJlIG5vdCBjYWxsZWQgaWYgcmVtb3ZlIGhhcHBlbnMgaW4gZmlyZVxyXG4gIFx0XHRcdGZvciAoaSA9IDAsIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gIFx0XHRcdFx0bGlzdGVuZXJzW2ldLmZuID0gZmFsc2VGbjtcclxuICBcdFx0XHR9XHJcbiAgXHRcdFx0Ly8gY2xlYXIgYWxsIGxpc3RlbmVycyBmb3IgYSB0eXBlIGlmIGZ1bmN0aW9uIGlzbid0IHNwZWNpZmllZFxyXG4gIFx0XHRcdGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XHJcbiAgXHRcdFx0cmV0dXJuO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRpZiAoY29udGV4dCA9PT0gdGhpcykge1xyXG4gIFx0XHRcdGNvbnRleHQgPSB1bmRlZmluZWQ7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGlmIChsaXN0ZW5lcnMpIHtcclxuXHJcbiAgXHRcdFx0Ly8gZmluZCBmbiBhbmQgcmVtb3ZlIGl0XHJcbiAgXHRcdFx0Zm9yIChpID0gMCwgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgXHRcdFx0XHR2YXIgbCA9IGxpc3RlbmVyc1tpXTtcclxuICBcdFx0XHRcdGlmIChsLmN0eCAhPT0gY29udGV4dCkgeyBjb250aW51ZTsgfVxyXG4gIFx0XHRcdFx0aWYgKGwuZm4gPT09IGZuKSB7XHJcblxyXG4gIFx0XHRcdFx0XHQvLyBzZXQgdGhlIHJlbW92ZWQgbGlzdGVuZXIgdG8gbm9vcCBzbyB0aGF0J3Mgbm90IGNhbGxlZCBpZiByZW1vdmUgaGFwcGVucyBpbiBmaXJlXHJcbiAgXHRcdFx0XHRcdGwuZm4gPSBmYWxzZUZuO1xyXG5cclxuICBcdFx0XHRcdFx0aWYgKHRoaXMuX2ZpcmluZ0NvdW50KSB7XHJcbiAgXHRcdFx0XHRcdFx0LyogY29weSBhcnJheSBpbiBjYXNlIGV2ZW50cyBhcmUgYmVpbmcgZmlyZWQgKi9cclxuICBcdFx0XHRcdFx0XHR0aGlzLl9ldmVudHNbdHlwZV0gPSBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMuc2xpY2UoKTtcclxuICBcdFx0XHRcdFx0fVxyXG4gIFx0XHRcdFx0XHRsaXN0ZW5lcnMuc3BsaWNlKGksIDEpO1xyXG5cclxuICBcdFx0XHRcdFx0cmV0dXJuO1xyXG4gIFx0XHRcdFx0fVxyXG4gIFx0XHRcdH1cclxuICBcdFx0fVxyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGZpcmUodHlwZTogU3RyaW5nLCBkYXRhPzogT2JqZWN0LCBwcm9wYWdhdGU/OiBCb29sZWFuKTogdGhpc1xyXG4gIFx0Ly8gRmlyZXMgYW4gZXZlbnQgb2YgdGhlIHNwZWNpZmllZCB0eXBlLiBZb3UgY2FuIG9wdGlvbmFsbHkgcHJvdmlkZSBhbiBkYXRhXHJcbiAgXHQvLyBvYmplY3Qg4oCUIHRoZSBmaXJzdCBhcmd1bWVudCBvZiB0aGUgbGlzdGVuZXIgZnVuY3Rpb24gd2lsbCBjb250YWluIGl0c1xyXG4gIFx0Ly8gcHJvcGVydGllcy4gVGhlIGV2ZW50IGNhbiBvcHRpb25hbGx5IGJlIHByb3BhZ2F0ZWQgdG8gZXZlbnQgcGFyZW50cy5cclxuICBcdGZpcmU6IGZ1bmN0aW9uICh0eXBlLCBkYXRhLCBwcm9wYWdhdGUpIHtcclxuICBcdFx0aWYgKCF0aGlzLmxpc3RlbnModHlwZSwgcHJvcGFnYXRlKSkgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuICBcdFx0dmFyIGV2ZW50ID0gZXh0ZW5kKHt9LCBkYXRhLCB7XHJcbiAgXHRcdFx0dHlwZTogdHlwZSxcclxuICBcdFx0XHR0YXJnZXQ6IHRoaXMsXHJcbiAgXHRcdFx0c291cmNlVGFyZ2V0OiBkYXRhICYmIGRhdGEuc291cmNlVGFyZ2V0IHx8IHRoaXNcclxuICBcdFx0fSk7XHJcblxyXG4gIFx0XHRpZiAodGhpcy5fZXZlbnRzKSB7XHJcbiAgXHRcdFx0dmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcclxuXHJcbiAgXHRcdFx0aWYgKGxpc3RlbmVycykge1xyXG4gIFx0XHRcdFx0dGhpcy5fZmlyaW5nQ291bnQgPSAodGhpcy5fZmlyaW5nQ291bnQgKyAxKSB8fCAxO1xyXG4gIFx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gIFx0XHRcdFx0XHR2YXIgbCA9IGxpc3RlbmVyc1tpXTtcclxuICBcdFx0XHRcdFx0bC5mbi5jYWxsKGwuY3R4IHx8IHRoaXMsIGV2ZW50KTtcclxuICBcdFx0XHRcdH1cclxuXHJcbiAgXHRcdFx0XHR0aGlzLl9maXJpbmdDb3VudC0tO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0fVxyXG5cclxuICBcdFx0aWYgKHByb3BhZ2F0ZSkge1xyXG4gIFx0XHRcdC8vIHByb3BhZ2F0ZSB0aGUgZXZlbnQgdG8gcGFyZW50cyAoc2V0IHdpdGggYWRkRXZlbnRQYXJlbnQpXHJcbiAgXHRcdFx0dGhpcy5fcHJvcGFnYXRlRXZlbnQoZXZlbnQpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBsaXN0ZW5zKHR5cGU6IFN0cmluZyk6IEJvb2xlYW5cclxuICBcdC8vIFJldHVybnMgYHRydWVgIGlmIGEgcGFydGljdWxhciBldmVudCB0eXBlIGhhcyBhbnkgbGlzdGVuZXJzIGF0dGFjaGVkIHRvIGl0LlxyXG4gIFx0bGlzdGVuczogZnVuY3Rpb24gKHR5cGUsIHByb3BhZ2F0ZSkge1xyXG4gIFx0XHR2YXIgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzICYmIHRoaXMuX2V2ZW50c1t0eXBlXTtcclxuICBcdFx0aWYgKGxpc3RlbmVycyAmJiBsaXN0ZW5lcnMubGVuZ3RoKSB7IHJldHVybiB0cnVlOyB9XHJcblxyXG4gIFx0XHRpZiAocHJvcGFnYXRlKSB7XHJcbiAgXHRcdFx0Ly8gYWxzbyBjaGVjayBwYXJlbnRzIGZvciBsaXN0ZW5lcnMgaWYgZXZlbnQgcHJvcGFnYXRlc1xyXG4gIFx0XHRcdGZvciAodmFyIGlkIGluIHRoaXMuX2V2ZW50UGFyZW50cykge1xyXG4gIFx0XHRcdFx0aWYgKHRoaXMuX2V2ZW50UGFyZW50c1tpZF0ubGlzdGVucyh0eXBlLCBwcm9wYWdhdGUpKSB7IHJldHVybiB0cnVlOyB9XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiBmYWxzZTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBvbmNlKOKApik6IHRoaXNcclxuICBcdC8vIEJlaGF2ZXMgYXMgW2BvbijigKYpYF0oI2V2ZW50ZWQtb24pLCBleGNlcHQgdGhlIGxpc3RlbmVyIHdpbGwgb25seSBnZXQgZmlyZWQgb25jZSBhbmQgdGhlbiByZW1vdmVkLlxyXG4gIFx0b25jZTogZnVuY3Rpb24gKHR5cGVzLCBmbiwgY29udGV4dCkge1xyXG5cclxuICBcdFx0aWYgKHR5cGVvZiB0eXBlcyA9PT0gJ29iamVjdCcpIHtcclxuICBcdFx0XHRmb3IgKHZhciB0eXBlIGluIHR5cGVzKSB7XHJcbiAgXHRcdFx0XHR0aGlzLm9uY2UodHlwZSwgdHlwZXNbdHlwZV0sIGZuKTtcclxuICBcdFx0XHR9XHJcbiAgXHRcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHZhciBoYW5kbGVyID0gYmluZChmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdFx0dGhpc1xyXG4gIFx0XHRcdCAgICAub2ZmKHR5cGVzLCBmbiwgY29udGV4dClcclxuICBcdFx0XHQgICAgLm9mZih0eXBlcywgaGFuZGxlciwgY29udGV4dCk7XHJcbiAgXHRcdH0sIHRoaXMpO1xyXG5cclxuICBcdFx0Ly8gYWRkIGEgbGlzdGVuZXIgdGhhdCdzIGV4ZWN1dGVkIG9uY2UgYW5kIHJlbW92ZWQgYWZ0ZXIgdGhhdFxyXG4gIFx0XHRyZXR1cm4gdGhpc1xyXG4gIFx0XHQgICAgLm9uKHR5cGVzLCBmbiwgY29udGV4dClcclxuICBcdFx0ICAgIC5vbih0eXBlcywgaGFuZGxlciwgY29udGV4dCk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgYWRkRXZlbnRQYXJlbnQob2JqOiBFdmVudGVkKTogdGhpc1xyXG4gIFx0Ly8gQWRkcyBhbiBldmVudCBwYXJlbnQgLSBhbiBgRXZlbnRlZGAgdGhhdCB3aWxsIHJlY2VpdmUgcHJvcGFnYXRlZCBldmVudHNcclxuICBcdGFkZEV2ZW50UGFyZW50OiBmdW5jdGlvbiAob2JqKSB7XHJcbiAgXHRcdHRoaXMuX2V2ZW50UGFyZW50cyA9IHRoaXMuX2V2ZW50UGFyZW50cyB8fCB7fTtcclxuICBcdFx0dGhpcy5fZXZlbnRQYXJlbnRzW3N0YW1wKG9iaildID0gb2JqO1xyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCByZW1vdmVFdmVudFBhcmVudChvYmo6IEV2ZW50ZWQpOiB0aGlzXHJcbiAgXHQvLyBSZW1vdmVzIGFuIGV2ZW50IHBhcmVudCwgc28gaXQgd2lsbCBzdG9wIHJlY2VpdmluZyBwcm9wYWdhdGVkIGV2ZW50c1xyXG4gIFx0cmVtb3ZlRXZlbnRQYXJlbnQ6IGZ1bmN0aW9uIChvYmopIHtcclxuICBcdFx0aWYgKHRoaXMuX2V2ZW50UGFyZW50cykge1xyXG4gIFx0XHRcdGRlbGV0ZSB0aGlzLl9ldmVudFBhcmVudHNbc3RhbXAob2JqKV07XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9wcm9wYWdhdGVFdmVudDogZnVuY3Rpb24gKGUpIHtcclxuICBcdFx0Zm9yICh2YXIgaWQgaW4gdGhpcy5fZXZlbnRQYXJlbnRzKSB7XHJcbiAgXHRcdFx0dGhpcy5fZXZlbnRQYXJlbnRzW2lkXS5maXJlKGUudHlwZSwgZXh0ZW5kKHtcclxuICBcdFx0XHRcdGxheWVyOiBlLnRhcmdldCxcclxuICBcdFx0XHRcdHByb3BhZ2F0ZWRGcm9tOiBlLnRhcmdldFxyXG4gIFx0XHRcdH0sIGUpLCB0cnVlKTtcclxuICBcdFx0fVxyXG4gIFx0fVxyXG4gIH07XHJcblxyXG4gIC8vIGFsaWFzZXM7IHdlIHNob3VsZCBkaXRjaCB0aG9zZSBldmVudHVhbGx5XHJcblxyXG4gIC8vIEBtZXRob2QgYWRkRXZlbnRMaXN0ZW5lcijigKYpOiB0aGlzXHJcbiAgLy8gQWxpYXMgdG8gW2BvbijigKYpYF0oI2V2ZW50ZWQtb24pXHJcbiAgRXZlbnRzLmFkZEV2ZW50TGlzdGVuZXIgPSBFdmVudHMub247XHJcblxyXG4gIC8vIEBtZXRob2QgcmVtb3ZlRXZlbnRMaXN0ZW5lcijigKYpOiB0aGlzXHJcbiAgLy8gQWxpYXMgdG8gW2BvZmYo4oCmKWBdKCNldmVudGVkLW9mZilcclxuXHJcbiAgLy8gQG1ldGhvZCBjbGVhckFsbEV2ZW50TGlzdGVuZXJzKOKApik6IHRoaXNcclxuICAvLyBBbGlhcyB0byBbYG9mZigpYF0oI2V2ZW50ZWQtb2ZmKVxyXG4gIEV2ZW50cy5yZW1vdmVFdmVudExpc3RlbmVyID0gRXZlbnRzLmNsZWFyQWxsRXZlbnRMaXN0ZW5lcnMgPSBFdmVudHMub2ZmO1xyXG5cclxuICAvLyBAbWV0aG9kIGFkZE9uZVRpbWVFdmVudExpc3RlbmVyKOKApik6IHRoaXNcclxuICAvLyBBbGlhcyB0byBbYG9uY2Uo4oCmKWBdKCNldmVudGVkLW9uY2UpXHJcbiAgRXZlbnRzLmFkZE9uZVRpbWVFdmVudExpc3RlbmVyID0gRXZlbnRzLm9uY2U7XHJcblxyXG4gIC8vIEBtZXRob2QgZmlyZUV2ZW50KOKApik6IHRoaXNcclxuICAvLyBBbGlhcyB0byBbYGZpcmUo4oCmKWBdKCNldmVudGVkLWZpcmUpXHJcbiAgRXZlbnRzLmZpcmVFdmVudCA9IEV2ZW50cy5maXJlO1xyXG5cclxuICAvLyBAbWV0aG9kIGhhc0V2ZW50TGlzdGVuZXJzKOKApik6IEJvb2xlYW5cclxuICAvLyBBbGlhcyB0byBbYGxpc3RlbnMo4oCmKWBdKCNldmVudGVkLWxpc3RlbnMpXHJcbiAgRXZlbnRzLmhhc0V2ZW50TGlzdGVuZXJzID0gRXZlbnRzLmxpc3RlbnM7XHJcblxyXG4gIHZhciBFdmVudGVkID0gQ2xhc3MuZXh0ZW5kKEV2ZW50cyk7XG5cbiAgLypcclxuICAgKiBAY2xhc3MgUG9pbnRcclxuICAgKiBAYWthIEwuUG9pbnRcclxuICAgKlxyXG4gICAqIFJlcHJlc2VudHMgYSBwb2ludCB3aXRoIGB4YCBhbmQgYHlgIGNvb3JkaW5hdGVzIGluIHBpeGVscy5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICpcclxuICAgKiBgYGBqc1xyXG4gICAqIHZhciBwb2ludCA9IEwucG9pbnQoMjAwLCAzMDApO1xyXG4gICAqIGBgYFxyXG4gICAqXHJcbiAgICogQWxsIExlYWZsZXQgbWV0aG9kcyBhbmQgb3B0aW9ucyB0aGF0IGFjY2VwdCBgUG9pbnRgIG9iamVjdHMgYWxzbyBhY2NlcHQgdGhlbSBpbiBhIHNpbXBsZSBBcnJheSBmb3JtICh1bmxlc3Mgbm90ZWQgb3RoZXJ3aXNlKSwgc28gdGhlc2UgbGluZXMgYXJlIGVxdWl2YWxlbnQ6XHJcbiAgICpcclxuICAgKiBgYGBqc1xyXG4gICAqIG1hcC5wYW5CeShbMjAwLCAzMDBdKTtcclxuICAgKiBtYXAucGFuQnkoTC5wb2ludCgyMDAsIDMwMCkpO1xyXG4gICAqIGBgYFxyXG4gICAqXHJcbiAgICogTm90ZSB0aGF0IGBQb2ludGAgZG9lcyBub3QgaW5oZXJpdCBmcm9tIExlYWZsZXQncyBgQ2xhc3NgIG9iamVjdCxcclxuICAgKiB3aGljaCBtZWFucyBuZXcgY2xhc3NlcyBjYW4ndCBpbmhlcml0IGZyb20gaXQsIGFuZCBuZXcgbWV0aG9kc1xyXG4gICAqIGNhbid0IGJlIGFkZGVkIHRvIGl0IHdpdGggdGhlIGBpbmNsdWRlYCBmdW5jdGlvbi5cclxuICAgKi9cclxuXHJcbiAgZnVuY3Rpb24gUG9pbnQoeCwgeSwgcm91bmQpIHtcclxuICBcdC8vIEBwcm9wZXJ0eSB4OiBOdW1iZXI7IFRoZSBgeGAgY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnRcclxuICBcdHRoaXMueCA9IChyb3VuZCA/IE1hdGgucm91bmQoeCkgOiB4KTtcclxuICBcdC8vIEBwcm9wZXJ0eSB5OiBOdW1iZXI7IFRoZSBgeWAgY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnRcclxuICBcdHRoaXMueSA9IChyb3VuZCA/IE1hdGgucm91bmQoeSkgOiB5KTtcclxuICB9XHJcblxyXG4gIHZhciB0cnVuYyA9IE1hdGgudHJ1bmMgfHwgZnVuY3Rpb24gKHYpIHtcclxuICBcdHJldHVybiB2ID4gMCA/IE1hdGguZmxvb3IodikgOiBNYXRoLmNlaWwodik7XHJcbiAgfTtcclxuXHJcbiAgUG9pbnQucHJvdG90eXBlID0ge1xyXG5cclxuICBcdC8vIEBtZXRob2QgY2xvbmUoKTogUG9pbnRcclxuICBcdC8vIFJldHVybnMgYSBjb3B5IG9mIHRoZSBjdXJyZW50IHBvaW50LlxyXG4gIFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIG5ldyBQb2ludCh0aGlzLngsIHRoaXMueSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgYWRkKG90aGVyUG9pbnQ6IFBvaW50KTogUG9pbnRcclxuICBcdC8vIFJldHVybnMgdGhlIHJlc3VsdCBvZiBhZGRpdGlvbiBvZiB0aGUgY3VycmVudCBhbmQgdGhlIGdpdmVuIHBvaW50cy5cclxuICBcdGFkZDogZnVuY3Rpb24gKHBvaW50KSB7XHJcbiAgXHRcdC8vIG5vbi1kZXN0cnVjdGl2ZSwgcmV0dXJucyBhIG5ldyBwb2ludFxyXG4gIFx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpLl9hZGQodG9Qb2ludChwb2ludCkpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfYWRkOiBmdW5jdGlvbiAocG9pbnQpIHtcclxuICBcdFx0Ly8gZGVzdHJ1Y3RpdmUsIHVzZWQgZGlyZWN0bHkgZm9yIHBlcmZvcm1hbmNlIGluIHNpdHVhdGlvbnMgd2hlcmUgaXQncyBzYWZlIHRvIG1vZGlmeSBleGlzdGluZyBwb2ludFxyXG4gIFx0XHR0aGlzLnggKz0gcG9pbnQueDtcclxuICBcdFx0dGhpcy55ICs9IHBvaW50Lnk7XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHN1YnRyYWN0KG90aGVyUG9pbnQ6IFBvaW50KTogUG9pbnRcclxuICBcdC8vIFJldHVybnMgdGhlIHJlc3VsdCBvZiBzdWJ0cmFjdGlvbiBvZiB0aGUgZ2l2ZW4gcG9pbnQgZnJvbSB0aGUgY3VycmVudC5cclxuICBcdHN1YnRyYWN0OiBmdW5jdGlvbiAocG9pbnQpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5fc3VidHJhY3QodG9Qb2ludChwb2ludCkpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfc3VidHJhY3Q6IGZ1bmN0aW9uIChwb2ludCkge1xyXG4gIFx0XHR0aGlzLnggLT0gcG9pbnQueDtcclxuICBcdFx0dGhpcy55IC09IHBvaW50Lnk7XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGRpdmlkZUJ5KG51bTogTnVtYmVyKTogUG9pbnRcclxuICBcdC8vIFJldHVybnMgdGhlIHJlc3VsdCBvZiBkaXZpc2lvbiBvZiB0aGUgY3VycmVudCBwb2ludCBieSB0aGUgZ2l2ZW4gbnVtYmVyLlxyXG4gIFx0ZGl2aWRlQnk6IGZ1bmN0aW9uIChudW0pIHtcclxuICBcdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5fZGl2aWRlQnkobnVtKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X2RpdmlkZUJ5OiBmdW5jdGlvbiAobnVtKSB7XHJcbiAgXHRcdHRoaXMueCAvPSBudW07XHJcbiAgXHRcdHRoaXMueSAvPSBudW07XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIG11bHRpcGx5QnkobnVtOiBOdW1iZXIpOiBQb2ludFxyXG4gIFx0Ly8gUmV0dXJucyB0aGUgcmVzdWx0IG9mIG11bHRpcGxpY2F0aW9uIG9mIHRoZSBjdXJyZW50IHBvaW50IGJ5IHRoZSBnaXZlbiBudW1iZXIuXHJcbiAgXHRtdWx0aXBseUJ5OiBmdW5jdGlvbiAobnVtKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLmNsb25lKCkuX211bHRpcGx5QnkobnVtKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X211bHRpcGx5Qnk6IGZ1bmN0aW9uIChudW0pIHtcclxuICBcdFx0dGhpcy54ICo9IG51bTtcclxuICBcdFx0dGhpcy55ICo9IG51bTtcclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2Qgc2NhbGVCeShzY2FsZTogUG9pbnQpOiBQb2ludFxyXG4gIFx0Ly8gTXVsdGlwbHkgZWFjaCBjb29yZGluYXRlIG9mIHRoZSBjdXJyZW50IHBvaW50IGJ5IGVhY2ggY29vcmRpbmF0ZSBvZlxyXG4gIFx0Ly8gYHNjYWxlYC4gSW4gbGluZWFyIGFsZ2VicmEgdGVybXMsIG11bHRpcGx5IHRoZSBwb2ludCBieSB0aGVcclxuICBcdC8vIFtzY2FsaW5nIG1hdHJpeF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU2NhbGluZ18lMjhnZW9tZXRyeSUyOSNNYXRyaXhfcmVwcmVzZW50YXRpb24pXHJcbiAgXHQvLyBkZWZpbmVkIGJ5IGBzY2FsZWAuXHJcbiAgXHRzY2FsZUJ5OiBmdW5jdGlvbiAocG9pbnQpIHtcclxuICBcdFx0cmV0dXJuIG5ldyBQb2ludCh0aGlzLnggKiBwb2ludC54LCB0aGlzLnkgKiBwb2ludC55KTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCB1bnNjYWxlQnkoc2NhbGU6IFBvaW50KTogUG9pbnRcclxuICBcdC8vIEludmVyc2Ugb2YgYHNjYWxlQnlgLiBEaXZpZGUgZWFjaCBjb29yZGluYXRlIG9mIHRoZSBjdXJyZW50IHBvaW50IGJ5XHJcbiAgXHQvLyBlYWNoIGNvb3JkaW5hdGUgb2YgYHNjYWxlYC5cclxuICBcdHVuc2NhbGVCeTogZnVuY3Rpb24gKHBvaW50KSB7XHJcbiAgXHRcdHJldHVybiBuZXcgUG9pbnQodGhpcy54IC8gcG9pbnQueCwgdGhpcy55IC8gcG9pbnQueSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2Qgcm91bmQoKTogUG9pbnRcclxuICBcdC8vIFJldHVybnMgYSBjb3B5IG9mIHRoZSBjdXJyZW50IHBvaW50IHdpdGggcm91bmRlZCBjb29yZGluYXRlcy5cclxuICBcdHJvdW5kOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLmNsb25lKCkuX3JvdW5kKCk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9yb3VuZDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR0aGlzLnggPSBNYXRoLnJvdW5kKHRoaXMueCk7XHJcbiAgXHRcdHRoaXMueSA9IE1hdGgucm91bmQodGhpcy55KTtcclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZmxvb3IoKTogUG9pbnRcclxuICBcdC8vIFJldHVybnMgYSBjb3B5IG9mIHRoZSBjdXJyZW50IHBvaW50IHdpdGggZmxvb3JlZCBjb29yZGluYXRlcyAocm91bmRlZCBkb3duKS5cclxuICBcdGZsb29yOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLmNsb25lKCkuX2Zsb29yKCk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9mbG9vcjogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR0aGlzLnggPSBNYXRoLmZsb29yKHRoaXMueCk7XHJcbiAgXHRcdHRoaXMueSA9IE1hdGguZmxvb3IodGhpcy55KTtcclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgY2VpbCgpOiBQb2ludFxyXG4gIFx0Ly8gUmV0dXJucyBhIGNvcHkgb2YgdGhlIGN1cnJlbnQgcG9pbnQgd2l0aCBjZWlsZWQgY29vcmRpbmF0ZXMgKHJvdW5kZWQgdXApLlxyXG4gIFx0Y2VpbDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpLl9jZWlsKCk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9jZWlsOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHRoaXMueCA9IE1hdGguY2VpbCh0aGlzLngpO1xyXG4gIFx0XHR0aGlzLnkgPSBNYXRoLmNlaWwodGhpcy55KTtcclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgdHJ1bmMoKTogUG9pbnRcclxuICBcdC8vIFJldHVybnMgYSBjb3B5IG9mIHRoZSBjdXJyZW50IHBvaW50IHdpdGggdHJ1bmNhdGVkIGNvb3JkaW5hdGVzIChyb3VuZGVkIHRvd2FyZHMgemVybykuXHJcbiAgXHR0cnVuYzogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpLl90cnVuYygpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfdHJ1bmM6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dGhpcy54ID0gdHJ1bmModGhpcy54KTtcclxuICBcdFx0dGhpcy55ID0gdHJ1bmModGhpcy55KTtcclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZGlzdGFuY2VUbyhvdGhlclBvaW50OiBQb2ludCk6IE51bWJlclxyXG4gIFx0Ly8gUmV0dXJucyB0aGUgY2FydGVzaWFuIGRpc3RhbmNlIGJldHdlZW4gdGhlIGN1cnJlbnQgYW5kIHRoZSBnaXZlbiBwb2ludHMuXHJcbiAgXHRkaXN0YW5jZVRvOiBmdW5jdGlvbiAocG9pbnQpIHtcclxuICBcdFx0cG9pbnQgPSB0b1BvaW50KHBvaW50KTtcclxuXHJcbiAgXHRcdHZhciB4ID0gcG9pbnQueCAtIHRoaXMueCxcclxuICBcdFx0ICAgIHkgPSBwb2ludC55IC0gdGhpcy55O1xyXG5cclxuICBcdFx0cmV0dXJuIE1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBlcXVhbHMob3RoZXJQb2ludDogUG9pbnQpOiBCb29sZWFuXHJcbiAgXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gcG9pbnQgaGFzIHRoZSBzYW1lIGNvb3JkaW5hdGVzLlxyXG4gIFx0ZXF1YWxzOiBmdW5jdGlvbiAocG9pbnQpIHtcclxuICBcdFx0cG9pbnQgPSB0b1BvaW50KHBvaW50KTtcclxuXHJcbiAgXHRcdHJldHVybiBwb2ludC54ID09PSB0aGlzLnggJiZcclxuICBcdFx0ICAgICAgIHBvaW50LnkgPT09IHRoaXMueTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBjb250YWlucyhvdGhlclBvaW50OiBQb2ludCk6IEJvb2xlYW5cclxuICBcdC8vIFJldHVybnMgYHRydWVgIGlmIGJvdGggY29vcmRpbmF0ZXMgb2YgdGhlIGdpdmVuIHBvaW50IGFyZSBsZXNzIHRoYW4gdGhlIGNvcnJlc3BvbmRpbmcgY3VycmVudCBwb2ludCBjb29yZGluYXRlcyAoaW4gYWJzb2x1dGUgdmFsdWVzKS5cclxuICBcdGNvbnRhaW5zOiBmdW5jdGlvbiAocG9pbnQpIHtcclxuICBcdFx0cG9pbnQgPSB0b1BvaW50KHBvaW50KTtcclxuXHJcbiAgXHRcdHJldHVybiBNYXRoLmFicyhwb2ludC54KSA8PSBNYXRoLmFicyh0aGlzLngpICYmXHJcbiAgXHRcdCAgICAgICBNYXRoLmFicyhwb2ludC55KSA8PSBNYXRoLmFicyh0aGlzLnkpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHRvU3RyaW5nKCk6IFN0cmluZ1xyXG4gIFx0Ly8gUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgcG9pbnQgZm9yIGRlYnVnZ2luZyBwdXJwb3Nlcy5cclxuICBcdHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiAnUG9pbnQoJyArXHJcbiAgXHRcdCAgICAgICAgZm9ybWF0TnVtKHRoaXMueCkgKyAnLCAnICtcclxuICBcdFx0ICAgICAgICBmb3JtYXROdW0odGhpcy55KSArICcpJztcclxuICBcdH1cclxuICB9O1xyXG5cclxuICAvLyBAZmFjdG9yeSBMLnBvaW50KHg6IE51bWJlciwgeTogTnVtYmVyLCByb3VuZD86IEJvb2xlYW4pXHJcbiAgLy8gQ3JlYXRlcyBhIFBvaW50IG9iamVjdCB3aXRoIHRoZSBnaXZlbiBgeGAgYW5kIGB5YCBjb29yZGluYXRlcy4gSWYgb3B0aW9uYWwgYHJvdW5kYCBpcyBzZXQgdG8gdHJ1ZSwgcm91bmRzIHRoZSBgeGAgYW5kIGB5YCB2YWx1ZXMuXHJcblxyXG4gIC8vIEBhbHRlcm5hdGl2ZVxyXG4gIC8vIEBmYWN0b3J5IEwucG9pbnQoY29vcmRzOiBOdW1iZXJbXSlcclxuICAvLyBFeHBlY3RzIGFuIGFycmF5IG9mIHRoZSBmb3JtIGBbeCwgeV1gIGluc3RlYWQuXHJcblxyXG4gIC8vIEBhbHRlcm5hdGl2ZVxyXG4gIC8vIEBmYWN0b3J5IEwucG9pbnQoY29vcmRzOiBPYmplY3QpXHJcbiAgLy8gRXhwZWN0cyBhIHBsYWluIG9iamVjdCBvZiB0aGUgZm9ybSBge3g6IE51bWJlciwgeTogTnVtYmVyfWAgaW5zdGVhZC5cclxuICBmdW5jdGlvbiB0b1BvaW50KHgsIHksIHJvdW5kKSB7XHJcbiAgXHRpZiAoeCBpbnN0YW5jZW9mIFBvaW50KSB7XHJcbiAgXHRcdHJldHVybiB4O1xyXG4gIFx0fVxyXG4gIFx0aWYgKGlzQXJyYXkoeCkpIHtcclxuICBcdFx0cmV0dXJuIG5ldyBQb2ludCh4WzBdLCB4WzFdKTtcclxuICBcdH1cclxuICBcdGlmICh4ID09PSB1bmRlZmluZWQgfHwgeCA9PT0gbnVsbCkge1xyXG4gIFx0XHRyZXR1cm4geDtcclxuICBcdH1cclxuICBcdGlmICh0eXBlb2YgeCA9PT0gJ29iamVjdCcgJiYgJ3gnIGluIHggJiYgJ3knIGluIHgpIHtcclxuICBcdFx0cmV0dXJuIG5ldyBQb2ludCh4LngsIHgueSk7XHJcbiAgXHR9XHJcbiAgXHRyZXR1cm4gbmV3IFBvaW50KHgsIHksIHJvdW5kKTtcclxuICB9XG5cbiAgLypcclxuICAgKiBAY2xhc3MgQm91bmRzXHJcbiAgICogQGFrYSBMLkJvdW5kc1xyXG4gICAqXHJcbiAgICogUmVwcmVzZW50cyBhIHJlY3Rhbmd1bGFyIGFyZWEgaW4gcGl4ZWwgY29vcmRpbmF0ZXMuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqXHJcbiAgICogYGBganNcclxuICAgKiB2YXIgcDEgPSBMLnBvaW50KDEwLCAxMCksXHJcbiAgICogcDIgPSBMLnBvaW50KDQwLCA2MCksXHJcbiAgICogYm91bmRzID0gTC5ib3VuZHMocDEsIHAyKTtcclxuICAgKiBgYGBcclxuICAgKlxyXG4gICAqIEFsbCBMZWFmbGV0IG1ldGhvZHMgdGhhdCBhY2NlcHQgYEJvdW5kc2Agb2JqZWN0cyBhbHNvIGFjY2VwdCB0aGVtIGluIGEgc2ltcGxlIEFycmF5IGZvcm0gKHVubGVzcyBub3RlZCBvdGhlcndpc2UpLCBzbyB0aGUgYm91bmRzIGV4YW1wbGUgYWJvdmUgY2FuIGJlIHBhc3NlZCBsaWtlIHRoaXM6XHJcbiAgICpcclxuICAgKiBgYGBqc1xyXG4gICAqIG90aGVyQm91bmRzLmludGVyc2VjdHMoW1sxMCwgMTBdLCBbNDAsIDYwXV0pO1xyXG4gICAqIGBgYFxyXG4gICAqXHJcbiAgICogTm90ZSB0aGF0IGBCb3VuZHNgIGRvZXMgbm90IGluaGVyaXQgZnJvbSBMZWFmbGV0J3MgYENsYXNzYCBvYmplY3QsXHJcbiAgICogd2hpY2ggbWVhbnMgbmV3IGNsYXNzZXMgY2FuJ3QgaW5oZXJpdCBmcm9tIGl0LCBhbmQgbmV3IG1ldGhvZHNcclxuICAgKiBjYW4ndCBiZSBhZGRlZCB0byBpdCB3aXRoIHRoZSBgaW5jbHVkZWAgZnVuY3Rpb24uXHJcbiAgICovXHJcblxyXG4gIGZ1bmN0aW9uIEJvdW5kcyhhLCBiKSB7XHJcbiAgXHRpZiAoIWEpIHsgcmV0dXJuOyB9XHJcblxyXG4gIFx0dmFyIHBvaW50cyA9IGIgPyBbYSwgYl0gOiBhO1xyXG5cclxuICBcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICBcdFx0dGhpcy5leHRlbmQocG9pbnRzW2ldKTtcclxuICBcdH1cclxuICB9XHJcblxyXG4gIEJvdW5kcy5wcm90b3R5cGUgPSB7XHJcbiAgXHQvLyBAbWV0aG9kIGV4dGVuZChwb2ludDogUG9pbnQpOiB0aGlzXHJcbiAgXHQvLyBFeHRlbmRzIHRoZSBib3VuZHMgdG8gY29udGFpbiB0aGUgZ2l2ZW4gcG9pbnQuXHJcbiAgXHRleHRlbmQ6IGZ1bmN0aW9uIChwb2ludCkgeyAvLyAoUG9pbnQpXHJcbiAgXHRcdHBvaW50ID0gdG9Qb2ludChwb2ludCk7XHJcblxyXG4gIFx0XHQvLyBAcHJvcGVydHkgbWluOiBQb2ludFxyXG4gIFx0XHQvLyBUaGUgdG9wIGxlZnQgY29ybmVyIG9mIHRoZSByZWN0YW5nbGUuXHJcbiAgXHRcdC8vIEBwcm9wZXJ0eSBtYXg6IFBvaW50XHJcbiAgXHRcdC8vIFRoZSBib3R0b20gcmlnaHQgY29ybmVyIG9mIHRoZSByZWN0YW5nbGUuXHJcbiAgXHRcdGlmICghdGhpcy5taW4gJiYgIXRoaXMubWF4KSB7XHJcbiAgXHRcdFx0dGhpcy5taW4gPSBwb2ludC5jbG9uZSgpO1xyXG4gIFx0XHRcdHRoaXMubWF4ID0gcG9pbnQuY2xvbmUoKTtcclxuICBcdFx0fSBlbHNlIHtcclxuICBcdFx0XHR0aGlzLm1pbi54ID0gTWF0aC5taW4ocG9pbnQueCwgdGhpcy5taW4ueCk7XHJcbiAgXHRcdFx0dGhpcy5tYXgueCA9IE1hdGgubWF4KHBvaW50LngsIHRoaXMubWF4LngpO1xyXG4gIFx0XHRcdHRoaXMubWluLnkgPSBNYXRoLm1pbihwb2ludC55LCB0aGlzLm1pbi55KTtcclxuICBcdFx0XHR0aGlzLm1heC55ID0gTWF0aC5tYXgocG9pbnQueSwgdGhpcy5tYXgueSk7XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0Q2VudGVyKHJvdW5kPzogQm9vbGVhbik6IFBvaW50XHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBjZW50ZXIgcG9pbnQgb2YgdGhlIGJvdW5kcy5cclxuICBcdGdldENlbnRlcjogZnVuY3Rpb24gKHJvdW5kKSB7XHJcbiAgXHRcdHJldHVybiBuZXcgUG9pbnQoXHJcbiAgXHRcdCAgICAgICAgKHRoaXMubWluLnggKyB0aGlzLm1heC54KSAvIDIsXHJcbiAgXHRcdCAgICAgICAgKHRoaXMubWluLnkgKyB0aGlzLm1heC55KSAvIDIsIHJvdW5kKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRCb3R0b21MZWZ0KCk6IFBvaW50XHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBib3R0b20tbGVmdCBwb2ludCBvZiB0aGUgYm91bmRzLlxyXG4gIFx0Z2V0Qm90dG9tTGVmdDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gbmV3IFBvaW50KHRoaXMubWluLngsIHRoaXMubWF4LnkpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldFRvcFJpZ2h0KCk6IFBvaW50XHJcbiAgXHQvLyBSZXR1cm5zIHRoZSB0b3AtcmlnaHQgcG9pbnQgb2YgdGhlIGJvdW5kcy5cclxuICBcdGdldFRvcFJpZ2h0OiBmdW5jdGlvbiAoKSB7IC8vIC0+IFBvaW50XHJcbiAgXHRcdHJldHVybiBuZXcgUG9pbnQodGhpcy5tYXgueCwgdGhpcy5taW4ueSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0VG9wTGVmdCgpOiBQb2ludFxyXG4gIFx0Ly8gUmV0dXJucyB0aGUgdG9wLWxlZnQgcG9pbnQgb2YgdGhlIGJvdW5kcyAoaS5lLiBbYHRoaXMubWluYF0oI2JvdW5kcy1taW4pKS5cclxuICBcdGdldFRvcExlZnQ6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMubWluOyAvLyBsZWZ0LCB0b3BcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRCb3R0b21SaWdodCgpOiBQb2ludFxyXG4gIFx0Ly8gUmV0dXJucyB0aGUgYm90dG9tLXJpZ2h0IHBvaW50IG9mIHRoZSBib3VuZHMgKGkuZS4gW2B0aGlzLm1heGBdKCNib3VuZHMtbWF4KSkuXHJcbiAgXHRnZXRCb3R0b21SaWdodDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5tYXg7IC8vIHJpZ2h0LCBib3R0b21cclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRTaXplKCk6IFBvaW50XHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBzaXplIG9mIHRoZSBnaXZlbiBib3VuZHNcclxuICBcdGdldFNpemU6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMubWF4LnN1YnRyYWN0KHRoaXMubWluKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBjb250YWlucyhvdGhlckJvdW5kczogQm91bmRzKTogQm9vbGVhblxyXG4gIFx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBjb250YWlucyB0aGUgZ2l2ZW4gb25lLlxyXG4gIFx0Ly8gQGFsdGVybmF0aXZlXHJcbiAgXHQvLyBAbWV0aG9kIGNvbnRhaW5zKHBvaW50OiBQb2ludCk6IEJvb2xlYW5cclxuICBcdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgY29udGFpbnMgdGhlIGdpdmVuIHBvaW50LlxyXG4gIFx0Y29udGFpbnM6IGZ1bmN0aW9uIChvYmopIHtcclxuICBcdFx0dmFyIG1pbiwgbWF4O1xyXG5cclxuICBcdFx0aWYgKHR5cGVvZiBvYmpbMF0gPT09ICdudW1iZXInIHx8IG9iaiBpbnN0YW5jZW9mIFBvaW50KSB7XHJcbiAgXHRcdFx0b2JqID0gdG9Qb2ludChvYmopO1xyXG4gIFx0XHR9IGVsc2Uge1xyXG4gIFx0XHRcdG9iaiA9IHRvQm91bmRzKG9iaik7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGlmIChvYmogaW5zdGFuY2VvZiBCb3VuZHMpIHtcclxuICBcdFx0XHRtaW4gPSBvYmoubWluO1xyXG4gIFx0XHRcdG1heCA9IG9iai5tYXg7XHJcbiAgXHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0bWluID0gbWF4ID0gb2JqO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZXR1cm4gKG1pbi54ID49IHRoaXMubWluLngpICYmXHJcbiAgXHRcdCAgICAgICAobWF4LnggPD0gdGhpcy5tYXgueCkgJiZcclxuICBcdFx0ICAgICAgIChtaW4ueSA+PSB0aGlzLm1pbi55KSAmJlxyXG4gIFx0XHQgICAgICAgKG1heC55IDw9IHRoaXMubWF4LnkpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGludGVyc2VjdHMob3RoZXJCb3VuZHM6IEJvdW5kcyk6IEJvb2xlYW5cclxuICBcdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgaW50ZXJzZWN0cyB0aGUgZ2l2ZW4gYm91bmRzLiBUd28gYm91bmRzXHJcbiAgXHQvLyBpbnRlcnNlY3QgaWYgdGhleSBoYXZlIGF0IGxlYXN0IG9uZSBwb2ludCBpbiBjb21tb24uXHJcbiAgXHRpbnRlcnNlY3RzOiBmdW5jdGlvbiAoYm91bmRzKSB7IC8vIChCb3VuZHMpIC0+IEJvb2xlYW5cclxuICBcdFx0Ym91bmRzID0gdG9Cb3VuZHMoYm91bmRzKTtcclxuXHJcbiAgXHRcdHZhciBtaW4gPSB0aGlzLm1pbixcclxuICBcdFx0ICAgIG1heCA9IHRoaXMubWF4LFxyXG4gIFx0XHQgICAgbWluMiA9IGJvdW5kcy5taW4sXHJcbiAgXHRcdCAgICBtYXgyID0gYm91bmRzLm1heCxcclxuICBcdFx0ICAgIHhJbnRlcnNlY3RzID0gKG1heDIueCA+PSBtaW4ueCkgJiYgKG1pbjIueCA8PSBtYXgueCksXHJcbiAgXHRcdCAgICB5SW50ZXJzZWN0cyA9IChtYXgyLnkgPj0gbWluLnkpICYmIChtaW4yLnkgPD0gbWF4LnkpO1xyXG5cclxuICBcdFx0cmV0dXJuIHhJbnRlcnNlY3RzICYmIHlJbnRlcnNlY3RzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIG92ZXJsYXBzKG90aGVyQm91bmRzOiBCb3VuZHMpOiBCb29sZWFuXHJcbiAgXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIG92ZXJsYXBzIHRoZSBnaXZlbiBib3VuZHMuIFR3byBib3VuZHNcclxuICBcdC8vIG92ZXJsYXAgaWYgdGhlaXIgaW50ZXJzZWN0aW9uIGlzIGFuIGFyZWEuXHJcbiAgXHRvdmVybGFwczogZnVuY3Rpb24gKGJvdW5kcykgeyAvLyAoQm91bmRzKSAtPiBCb29sZWFuXHJcbiAgXHRcdGJvdW5kcyA9IHRvQm91bmRzKGJvdW5kcyk7XHJcblxyXG4gIFx0XHR2YXIgbWluID0gdGhpcy5taW4sXHJcbiAgXHRcdCAgICBtYXggPSB0aGlzLm1heCxcclxuICBcdFx0ICAgIG1pbjIgPSBib3VuZHMubWluLFxyXG4gIFx0XHQgICAgbWF4MiA9IGJvdW5kcy5tYXgsXHJcbiAgXHRcdCAgICB4T3ZlcmxhcHMgPSAobWF4Mi54ID4gbWluLngpICYmIChtaW4yLnggPCBtYXgueCksXHJcbiAgXHRcdCAgICB5T3ZlcmxhcHMgPSAobWF4Mi55ID4gbWluLnkpICYmIChtaW4yLnkgPCBtYXgueSk7XHJcblxyXG4gIFx0XHRyZXR1cm4geE92ZXJsYXBzICYmIHlPdmVybGFwcztcclxuICBcdH0sXHJcblxyXG4gIFx0aXNWYWxpZDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gISEodGhpcy5taW4gJiYgdGhpcy5tYXgpO1xyXG4gIFx0fVxyXG4gIH07XHJcblxyXG5cclxuICAvLyBAZmFjdG9yeSBMLmJvdW5kcyhjb3JuZXIxOiBQb2ludCwgY29ybmVyMjogUG9pbnQpXHJcbiAgLy8gQ3JlYXRlcyBhIEJvdW5kcyBvYmplY3QgZnJvbSB0d28gY29ybmVycyBjb29yZGluYXRlIHBhaXJzLlxyXG4gIC8vIEBhbHRlcm5hdGl2ZVxyXG4gIC8vIEBmYWN0b3J5IEwuYm91bmRzKHBvaW50czogUG9pbnRbXSlcclxuICAvLyBDcmVhdGVzIGEgQm91bmRzIG9iamVjdCBmcm9tIHRoZSBnaXZlbiBhcnJheSBvZiBwb2ludHMuXHJcbiAgZnVuY3Rpb24gdG9Cb3VuZHMoYSwgYikge1xyXG4gIFx0aWYgKCFhIHx8IGEgaW5zdGFuY2VvZiBCb3VuZHMpIHtcclxuICBcdFx0cmV0dXJuIGE7XHJcbiAgXHR9XHJcbiAgXHRyZXR1cm4gbmV3IEJvdW5kcyhhLCBiKTtcclxuICB9XG5cbiAgLypcclxuICAgKiBAY2xhc3MgTGF0TG5nQm91bmRzXHJcbiAgICogQGFrYSBMLkxhdExuZ0JvdW5kc1xyXG4gICAqXHJcbiAgICogUmVwcmVzZW50cyBhIHJlY3Rhbmd1bGFyIGdlb2dyYXBoaWNhbCBhcmVhIG9uIGEgbWFwLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKlxyXG4gICAqIGBgYGpzXHJcbiAgICogdmFyIGNvcm5lcjEgPSBMLmxhdExuZyg0MC43MTIsIC03NC4yMjcpLFxyXG4gICAqIGNvcm5lcjIgPSBMLmxhdExuZyg0MC43NzQsIC03NC4xMjUpLFxyXG4gICAqIGJvdW5kcyA9IEwubGF0TG5nQm91bmRzKGNvcm5lcjEsIGNvcm5lcjIpO1xyXG4gICAqIGBgYFxyXG4gICAqXHJcbiAgICogQWxsIExlYWZsZXQgbWV0aG9kcyB0aGF0IGFjY2VwdCBMYXRMbmdCb3VuZHMgb2JqZWN0cyBhbHNvIGFjY2VwdCB0aGVtIGluIGEgc2ltcGxlIEFycmF5IGZvcm0gKHVubGVzcyBub3RlZCBvdGhlcndpc2UpLCBzbyB0aGUgYm91bmRzIGV4YW1wbGUgYWJvdmUgY2FuIGJlIHBhc3NlZCBsaWtlIHRoaXM6XHJcbiAgICpcclxuICAgKiBgYGBqc1xyXG4gICAqIG1hcC5maXRCb3VuZHMoW1xyXG4gICAqIFx0WzQwLjcxMiwgLTc0LjIyN10sXHJcbiAgICogXHRbNDAuNzc0LCAtNzQuMTI1XVxyXG4gICAqIF0pO1xyXG4gICAqIGBgYFxyXG4gICAqXHJcbiAgICogQ2F1dGlvbjogaWYgdGhlIGFyZWEgY3Jvc3NlcyB0aGUgYW50aW1lcmlkaWFuIChvZnRlbiBjb25mdXNlZCB3aXRoIHRoZSBJbnRlcm5hdGlvbmFsIERhdGUgTGluZSksIHlvdSBtdXN0IHNwZWNpZnkgY29ybmVycyBfb3V0c2lkZV8gdGhlIFstMTgwLCAxODBdIGRlZ3JlZXMgbG9uZ2l0dWRlIHJhbmdlLlxyXG4gICAqXHJcbiAgICogTm90ZSB0aGF0IGBMYXRMbmdCb3VuZHNgIGRvZXMgbm90IGluaGVyaXQgZnJvbSBMZWFmbGV0J3MgYENsYXNzYCBvYmplY3QsXHJcbiAgICogd2hpY2ggbWVhbnMgbmV3IGNsYXNzZXMgY2FuJ3QgaW5oZXJpdCBmcm9tIGl0LCBhbmQgbmV3IG1ldGhvZHNcclxuICAgKiBjYW4ndCBiZSBhZGRlZCB0byBpdCB3aXRoIHRoZSBgaW5jbHVkZWAgZnVuY3Rpb24uXHJcbiAgICovXHJcblxyXG4gIGZ1bmN0aW9uIExhdExuZ0JvdW5kcyhjb3JuZXIxLCBjb3JuZXIyKSB7IC8vIChMYXRMbmcsIExhdExuZykgb3IgKExhdExuZ1tdKVxyXG4gIFx0aWYgKCFjb3JuZXIxKSB7IHJldHVybjsgfVxyXG5cclxuICBcdHZhciBsYXRsbmdzID0gY29ybmVyMiA/IFtjb3JuZXIxLCBjb3JuZXIyXSA6IGNvcm5lcjE7XHJcblxyXG4gIFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGxhdGxuZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICBcdFx0dGhpcy5leHRlbmQobGF0bG5nc1tpXSk7XHJcbiAgXHR9XHJcbiAgfVxyXG5cclxuICBMYXRMbmdCb3VuZHMucHJvdG90eXBlID0ge1xyXG5cclxuICBcdC8vIEBtZXRob2QgZXh0ZW5kKGxhdGxuZzogTGF0TG5nKTogdGhpc1xyXG4gIFx0Ly8gRXh0ZW5kIHRoZSBib3VuZHMgdG8gY29udGFpbiB0aGUgZ2l2ZW4gcG9pbnRcclxuXHJcbiAgXHQvLyBAYWx0ZXJuYXRpdmVcclxuICBcdC8vIEBtZXRob2QgZXh0ZW5kKG90aGVyQm91bmRzOiBMYXRMbmdCb3VuZHMpOiB0aGlzXHJcbiAgXHQvLyBFeHRlbmQgdGhlIGJvdW5kcyB0byBjb250YWluIHRoZSBnaXZlbiBib3VuZHNcclxuICBcdGV4dGVuZDogZnVuY3Rpb24gKG9iaikge1xyXG4gIFx0XHR2YXIgc3cgPSB0aGlzLl9zb3V0aFdlc3QsXHJcbiAgXHRcdCAgICBuZSA9IHRoaXMuX25vcnRoRWFzdCxcclxuICBcdFx0ICAgIHN3MiwgbmUyO1xyXG5cclxuICBcdFx0aWYgKG9iaiBpbnN0YW5jZW9mIExhdExuZykge1xyXG4gIFx0XHRcdHN3MiA9IG9iajtcclxuICBcdFx0XHRuZTIgPSBvYmo7XHJcblxyXG4gIFx0XHR9IGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIExhdExuZ0JvdW5kcykge1xyXG4gIFx0XHRcdHN3MiA9IG9iai5fc291dGhXZXN0O1xyXG4gIFx0XHRcdG5lMiA9IG9iai5fbm9ydGhFYXN0O1xyXG5cclxuICBcdFx0XHRpZiAoIXN3MiB8fCAhbmUyKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG4gIFx0XHR9IGVsc2Uge1xyXG4gIFx0XHRcdHJldHVybiBvYmogPyB0aGlzLmV4dGVuZCh0b0xhdExuZyhvYmopIHx8IHRvTGF0TG5nQm91bmRzKG9iaikpIDogdGhpcztcclxuICBcdFx0fVxyXG5cclxuICBcdFx0aWYgKCFzdyAmJiAhbmUpIHtcclxuICBcdFx0XHR0aGlzLl9zb3V0aFdlc3QgPSBuZXcgTGF0TG5nKHN3Mi5sYXQsIHN3Mi5sbmcpO1xyXG4gIFx0XHRcdHRoaXMuX25vcnRoRWFzdCA9IG5ldyBMYXRMbmcobmUyLmxhdCwgbmUyLmxuZyk7XHJcbiAgXHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0c3cubGF0ID0gTWF0aC5taW4oc3cyLmxhdCwgc3cubGF0KTtcclxuICBcdFx0XHRzdy5sbmcgPSBNYXRoLm1pbihzdzIubG5nLCBzdy5sbmcpO1xyXG4gIFx0XHRcdG5lLmxhdCA9IE1hdGgubWF4KG5lMi5sYXQsIG5lLmxhdCk7XHJcbiAgXHRcdFx0bmUubG5nID0gTWF0aC5tYXgobmUyLmxuZywgbmUubG5nKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgcGFkKGJ1ZmZlclJhdGlvOiBOdW1iZXIpOiBMYXRMbmdCb3VuZHNcclxuICBcdC8vIFJldHVybnMgYm91bmRzIGNyZWF0ZWQgYnkgZXh0ZW5kaW5nIG9yIHJldHJhY3RpbmcgdGhlIGN1cnJlbnQgYm91bmRzIGJ5IGEgZ2l2ZW4gcmF0aW8gaW4gZWFjaCBkaXJlY3Rpb24uXHJcbiAgXHQvLyBGb3IgZXhhbXBsZSwgYSByYXRpbyBvZiAwLjUgZXh0ZW5kcyB0aGUgYm91bmRzIGJ5IDUwJSBpbiBlYWNoIGRpcmVjdGlvbi5cclxuICBcdC8vIE5lZ2F0aXZlIHZhbHVlcyB3aWxsIHJldHJhY3QgdGhlIGJvdW5kcy5cclxuICBcdHBhZDogZnVuY3Rpb24gKGJ1ZmZlclJhdGlvKSB7XHJcbiAgXHRcdHZhciBzdyA9IHRoaXMuX3NvdXRoV2VzdCxcclxuICBcdFx0ICAgIG5lID0gdGhpcy5fbm9ydGhFYXN0LFxyXG4gIFx0XHQgICAgaGVpZ2h0QnVmZmVyID0gTWF0aC5hYnMoc3cubGF0IC0gbmUubGF0KSAqIGJ1ZmZlclJhdGlvLFxyXG4gIFx0XHQgICAgd2lkdGhCdWZmZXIgPSBNYXRoLmFicyhzdy5sbmcgLSBuZS5sbmcpICogYnVmZmVyUmF0aW87XHJcblxyXG4gIFx0XHRyZXR1cm4gbmV3IExhdExuZ0JvdW5kcyhcclxuICBcdFx0ICAgICAgICBuZXcgTGF0TG5nKHN3LmxhdCAtIGhlaWdodEJ1ZmZlciwgc3cubG5nIC0gd2lkdGhCdWZmZXIpLFxyXG4gIFx0XHQgICAgICAgIG5ldyBMYXRMbmcobmUubGF0ICsgaGVpZ2h0QnVmZmVyLCBuZS5sbmcgKyB3aWR0aEJ1ZmZlcikpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldENlbnRlcigpOiBMYXRMbmdcclxuICBcdC8vIFJldHVybnMgdGhlIGNlbnRlciBwb2ludCBvZiB0aGUgYm91bmRzLlxyXG4gIFx0Z2V0Q2VudGVyOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiBuZXcgTGF0TG5nKFxyXG4gIFx0XHQgICAgICAgICh0aGlzLl9zb3V0aFdlc3QubGF0ICsgdGhpcy5fbm9ydGhFYXN0LmxhdCkgLyAyLFxyXG4gIFx0XHQgICAgICAgICh0aGlzLl9zb3V0aFdlc3QubG5nICsgdGhpcy5fbm9ydGhFYXN0LmxuZykgLyAyKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRTb3V0aFdlc3QoKTogTGF0TG5nXHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBzb3V0aC13ZXN0IHBvaW50IG9mIHRoZSBib3VuZHMuXHJcbiAgXHRnZXRTb3V0aFdlc3Q6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMuX3NvdXRoV2VzdDtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXROb3J0aEVhc3QoKTogTGF0TG5nXHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBub3J0aC1lYXN0IHBvaW50IG9mIHRoZSBib3VuZHMuXHJcbiAgXHRnZXROb3J0aEVhc3Q6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMuX25vcnRoRWFzdDtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXROb3J0aFdlc3QoKTogTGF0TG5nXHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBub3J0aC13ZXN0IHBvaW50IG9mIHRoZSBib3VuZHMuXHJcbiAgXHRnZXROb3J0aFdlc3Q6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIG5ldyBMYXRMbmcodGhpcy5nZXROb3J0aCgpLCB0aGlzLmdldFdlc3QoKSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0U291dGhFYXN0KCk6IExhdExuZ1xyXG4gIFx0Ly8gUmV0dXJucyB0aGUgc291dGgtZWFzdCBwb2ludCBvZiB0aGUgYm91bmRzLlxyXG4gIFx0Z2V0U291dGhFYXN0OiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiBuZXcgTGF0TG5nKHRoaXMuZ2V0U291dGgoKSwgdGhpcy5nZXRFYXN0KCkpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldFdlc3QoKTogTnVtYmVyXHJcbiAgXHQvLyBSZXR1cm5zIHRoZSB3ZXN0IGxvbmdpdHVkZSBvZiB0aGUgYm91bmRzXHJcbiAgXHRnZXRXZXN0OiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLl9zb3V0aFdlc3QubG5nO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldFNvdXRoKCk6IE51bWJlclxyXG4gIFx0Ly8gUmV0dXJucyB0aGUgc291dGggbGF0aXR1ZGUgb2YgdGhlIGJvdW5kc1xyXG4gIFx0Z2V0U291dGg6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMuX3NvdXRoV2VzdC5sYXQ7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0RWFzdCgpOiBOdW1iZXJcclxuICBcdC8vIFJldHVybnMgdGhlIGVhc3QgbG9uZ2l0dWRlIG9mIHRoZSBib3VuZHNcclxuICBcdGdldEVhc3Q6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMuX25vcnRoRWFzdC5sbmc7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0Tm9ydGgoKTogTnVtYmVyXHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBub3J0aCBsYXRpdHVkZSBvZiB0aGUgYm91bmRzXHJcbiAgXHRnZXROb3J0aDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5fbm9ydGhFYXN0LmxhdDtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBjb250YWlucyhvdGhlckJvdW5kczogTGF0TG5nQm91bmRzKTogQm9vbGVhblxyXG4gIFx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBjb250YWlucyB0aGUgZ2l2ZW4gb25lLlxyXG5cclxuICBcdC8vIEBhbHRlcm5hdGl2ZVxyXG4gIFx0Ly8gQG1ldGhvZCBjb250YWlucyAobGF0bG5nOiBMYXRMbmcpOiBCb29sZWFuXHJcbiAgXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIGNvbnRhaW5zIHRoZSBnaXZlbiBwb2ludC5cclxuICBcdGNvbnRhaW5zOiBmdW5jdGlvbiAob2JqKSB7IC8vIChMYXRMbmdCb3VuZHMpIG9yIChMYXRMbmcpIC0+IEJvb2xlYW5cclxuICBcdFx0aWYgKHR5cGVvZiBvYmpbMF0gPT09ICdudW1iZXInIHx8IG9iaiBpbnN0YW5jZW9mIExhdExuZyB8fCAnbGF0JyBpbiBvYmopIHtcclxuICBcdFx0XHRvYmogPSB0b0xhdExuZyhvYmopO1xyXG4gIFx0XHR9IGVsc2Uge1xyXG4gIFx0XHRcdG9iaiA9IHRvTGF0TG5nQm91bmRzKG9iaik7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHZhciBzdyA9IHRoaXMuX3NvdXRoV2VzdCxcclxuICBcdFx0ICAgIG5lID0gdGhpcy5fbm9ydGhFYXN0LFxyXG4gIFx0XHQgICAgc3cyLCBuZTI7XHJcblxyXG4gIFx0XHRpZiAob2JqIGluc3RhbmNlb2YgTGF0TG5nQm91bmRzKSB7XHJcbiAgXHRcdFx0c3cyID0gb2JqLmdldFNvdXRoV2VzdCgpO1xyXG4gIFx0XHRcdG5lMiA9IG9iai5nZXROb3J0aEVhc3QoKTtcclxuICBcdFx0fSBlbHNlIHtcclxuICBcdFx0XHRzdzIgPSBuZTIgPSBvYmo7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHJldHVybiAoc3cyLmxhdCA+PSBzdy5sYXQpICYmIChuZTIubGF0IDw9IG5lLmxhdCkgJiZcclxuICBcdFx0ICAgICAgIChzdzIubG5nID49IHN3LmxuZykgJiYgKG5lMi5sbmcgPD0gbmUubG5nKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBpbnRlcnNlY3RzKG90aGVyQm91bmRzOiBMYXRMbmdCb3VuZHMpOiBCb29sZWFuXHJcbiAgXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIGludGVyc2VjdHMgdGhlIGdpdmVuIGJvdW5kcy4gVHdvIGJvdW5kcyBpbnRlcnNlY3QgaWYgdGhleSBoYXZlIGF0IGxlYXN0IG9uZSBwb2ludCBpbiBjb21tb24uXHJcbiAgXHRpbnRlcnNlY3RzOiBmdW5jdGlvbiAoYm91bmRzKSB7XHJcbiAgXHRcdGJvdW5kcyA9IHRvTGF0TG5nQm91bmRzKGJvdW5kcyk7XHJcblxyXG4gIFx0XHR2YXIgc3cgPSB0aGlzLl9zb3V0aFdlc3QsXHJcbiAgXHRcdCAgICBuZSA9IHRoaXMuX25vcnRoRWFzdCxcclxuICBcdFx0ICAgIHN3MiA9IGJvdW5kcy5nZXRTb3V0aFdlc3QoKSxcclxuICBcdFx0ICAgIG5lMiA9IGJvdW5kcy5nZXROb3J0aEVhc3QoKSxcclxuXHJcbiAgXHRcdCAgICBsYXRJbnRlcnNlY3RzID0gKG5lMi5sYXQgPj0gc3cubGF0KSAmJiAoc3cyLmxhdCA8PSBuZS5sYXQpLFxyXG4gIFx0XHQgICAgbG5nSW50ZXJzZWN0cyA9IChuZTIubG5nID49IHN3LmxuZykgJiYgKHN3Mi5sbmcgPD0gbmUubG5nKTtcclxuXHJcbiAgXHRcdHJldHVybiBsYXRJbnRlcnNlY3RzICYmIGxuZ0ludGVyc2VjdHM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2Qgb3ZlcmxhcHMob3RoZXJCb3VuZHM6IExhdExuZ0JvdW5kcyk6IEJvb2xlYW5cclxuICBcdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgb3ZlcmxhcHMgdGhlIGdpdmVuIGJvdW5kcy4gVHdvIGJvdW5kcyBvdmVybGFwIGlmIHRoZWlyIGludGVyc2VjdGlvbiBpcyBhbiBhcmVhLlxyXG4gIFx0b3ZlcmxhcHM6IGZ1bmN0aW9uIChib3VuZHMpIHtcclxuICBcdFx0Ym91bmRzID0gdG9MYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcbiAgXHRcdHZhciBzdyA9IHRoaXMuX3NvdXRoV2VzdCxcclxuICBcdFx0ICAgIG5lID0gdGhpcy5fbm9ydGhFYXN0LFxyXG4gIFx0XHQgICAgc3cyID0gYm91bmRzLmdldFNvdXRoV2VzdCgpLFxyXG4gIFx0XHQgICAgbmUyID0gYm91bmRzLmdldE5vcnRoRWFzdCgpLFxyXG5cclxuICBcdFx0ICAgIGxhdE92ZXJsYXBzID0gKG5lMi5sYXQgPiBzdy5sYXQpICYmIChzdzIubGF0IDwgbmUubGF0KSxcclxuICBcdFx0ICAgIGxuZ092ZXJsYXBzID0gKG5lMi5sbmcgPiBzdy5sbmcpICYmIChzdzIubG5nIDwgbmUubG5nKTtcclxuXHJcbiAgXHRcdHJldHVybiBsYXRPdmVybGFwcyAmJiBsbmdPdmVybGFwcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCB0b0JCb3hTdHJpbmcoKTogU3RyaW5nXHJcbiAgXHQvLyBSZXR1cm5zIGEgc3RyaW5nIHdpdGggYm91bmRpbmcgYm94IGNvb3JkaW5hdGVzIGluIGEgJ3NvdXRod2VzdF9sbmcsc291dGh3ZXN0X2xhdCxub3J0aGVhc3RfbG5nLG5vcnRoZWFzdF9sYXQnIGZvcm1hdC4gVXNlZnVsIGZvciBzZW5kaW5nIHJlcXVlc3RzIHRvIHdlYiBzZXJ2aWNlcyB0aGF0IHJldHVybiBnZW8gZGF0YS5cclxuICBcdHRvQkJveFN0cmluZzogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gW3RoaXMuZ2V0V2VzdCgpLCB0aGlzLmdldFNvdXRoKCksIHRoaXMuZ2V0RWFzdCgpLCB0aGlzLmdldE5vcnRoKCldLmpvaW4oJywnKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBlcXVhbHMob3RoZXJCb3VuZHM6IExhdExuZ0JvdW5kcywgbWF4TWFyZ2luPzogTnVtYmVyKTogQm9vbGVhblxyXG4gIFx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBpcyBlcXVpdmFsZW50ICh3aXRoaW4gYSBzbWFsbCBtYXJnaW4gb2YgZXJyb3IpIHRvIHRoZSBnaXZlbiBib3VuZHMuIFRoZSBtYXJnaW4gb2YgZXJyb3IgY2FuIGJlIG92ZXJyaWRkZW4gYnkgc2V0dGluZyBgbWF4TWFyZ2luYCB0byBhIHNtYWxsIG51bWJlci5cclxuICBcdGVxdWFsczogZnVuY3Rpb24gKGJvdW5kcywgbWF4TWFyZ2luKSB7XHJcbiAgXHRcdGlmICghYm91bmRzKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cclxuICBcdFx0Ym91bmRzID0gdG9MYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcbiAgXHRcdHJldHVybiB0aGlzLl9zb3V0aFdlc3QuZXF1YWxzKGJvdW5kcy5nZXRTb3V0aFdlc3QoKSwgbWF4TWFyZ2luKSAmJlxyXG4gIFx0XHQgICAgICAgdGhpcy5fbm9ydGhFYXN0LmVxdWFscyhib3VuZHMuZ2V0Tm9ydGhFYXN0KCksIG1heE1hcmdpbik7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgaXNWYWxpZCgpOiBCb29sZWFuXHJcbiAgXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYm91bmRzIGFyZSBwcm9wZXJseSBpbml0aWFsaXplZC5cclxuICBcdGlzVmFsaWQ6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuICEhKHRoaXMuX3NvdXRoV2VzdCAmJiB0aGlzLl9ub3J0aEVhc3QpO1xyXG4gIFx0fVxyXG4gIH07XHJcblxyXG4gIC8vIFRPRE8gSW50ZXJuYXRpb25hbCBkYXRlIGxpbmU/XHJcblxyXG4gIC8vIEBmYWN0b3J5IEwubGF0TG5nQm91bmRzKGNvcm5lcjE6IExhdExuZywgY29ybmVyMjogTGF0TG5nKVxyXG4gIC8vIENyZWF0ZXMgYSBgTGF0TG5nQm91bmRzYCBvYmplY3QgYnkgZGVmaW5pbmcgdHdvIGRpYWdvbmFsbHkgb3Bwb3NpdGUgY29ybmVycyBvZiB0aGUgcmVjdGFuZ2xlLlxyXG5cclxuICAvLyBAYWx0ZXJuYXRpdmVcclxuICAvLyBAZmFjdG9yeSBMLmxhdExuZ0JvdW5kcyhsYXRsbmdzOiBMYXRMbmdbXSlcclxuICAvLyBDcmVhdGVzIGEgYExhdExuZ0JvdW5kc2Agb2JqZWN0IGRlZmluZWQgYnkgdGhlIGdlb2dyYXBoaWNhbCBwb2ludHMgaXQgY29udGFpbnMuIFZlcnkgdXNlZnVsIGZvciB6b29taW5nIHRoZSBtYXAgdG8gZml0IGEgcGFydGljdWxhciBzZXQgb2YgbG9jYXRpb25zIHdpdGggW2BmaXRCb3VuZHNgXSgjbWFwLWZpdGJvdW5kcykuXHJcbiAgZnVuY3Rpb24gdG9MYXRMbmdCb3VuZHMoYSwgYikge1xyXG4gIFx0aWYgKGEgaW5zdGFuY2VvZiBMYXRMbmdCb3VuZHMpIHtcclxuICBcdFx0cmV0dXJuIGE7XHJcbiAgXHR9XHJcbiAgXHRyZXR1cm4gbmV3IExhdExuZ0JvdW5kcyhhLCBiKTtcclxuICB9XG5cbiAgLyogQGNsYXNzIExhdExuZ1xyXG4gICAqIEBha2EgTC5MYXRMbmdcclxuICAgKlxyXG4gICAqIFJlcHJlc2VudHMgYSBnZW9ncmFwaGljYWwgcG9pbnQgd2l0aCBhIGNlcnRhaW4gbGF0aXR1ZGUgYW5kIGxvbmdpdHVkZS5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICpcclxuICAgKiBgYGBcclxuICAgKiB2YXIgbGF0bG5nID0gTC5sYXRMbmcoNTAuNSwgMzAuNSk7XHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBBbGwgTGVhZmxldCBtZXRob2RzIHRoYXQgYWNjZXB0IExhdExuZyBvYmplY3RzIGFsc28gYWNjZXB0IHRoZW0gaW4gYSBzaW1wbGUgQXJyYXkgZm9ybSBhbmQgc2ltcGxlIG9iamVjdCBmb3JtICh1bmxlc3Mgbm90ZWQgb3RoZXJ3aXNlKSwgc28gdGhlc2UgbGluZXMgYXJlIGVxdWl2YWxlbnQ6XHJcbiAgICpcclxuICAgKiBgYGBcclxuICAgKiBtYXAucGFuVG8oWzUwLCAzMF0pO1xyXG4gICAqIG1hcC5wYW5Ubyh7bG9uOiAzMCwgbGF0OiA1MH0pO1xyXG4gICAqIG1hcC5wYW5Ubyh7bGF0OiA1MCwgbG5nOiAzMH0pO1xyXG4gICAqIG1hcC5wYW5UbyhMLmxhdExuZyg1MCwgMzApKTtcclxuICAgKiBgYGBcclxuICAgKlxyXG4gICAqIE5vdGUgdGhhdCBgTGF0TG5nYCBkb2VzIG5vdCBpbmhlcml0IGZyb20gTGVhZmxldCdzIGBDbGFzc2Agb2JqZWN0LFxyXG4gICAqIHdoaWNoIG1lYW5zIG5ldyBjbGFzc2VzIGNhbid0IGluaGVyaXQgZnJvbSBpdCwgYW5kIG5ldyBtZXRob2RzXHJcbiAgICogY2FuJ3QgYmUgYWRkZWQgdG8gaXQgd2l0aCB0aGUgYGluY2x1ZGVgIGZ1bmN0aW9uLlxyXG4gICAqL1xyXG5cclxuICBmdW5jdGlvbiBMYXRMbmcobGF0LCBsbmcsIGFsdCkge1xyXG4gIFx0aWYgKGlzTmFOKGxhdCkgfHwgaXNOYU4obG5nKSkge1xyXG4gIFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgTGF0TG5nIG9iamVjdDogKCcgKyBsYXQgKyAnLCAnICsgbG5nICsgJyknKTtcclxuICBcdH1cclxuXHJcbiAgXHQvLyBAcHJvcGVydHkgbGF0OiBOdW1iZXJcclxuICBcdC8vIExhdGl0dWRlIGluIGRlZ3JlZXNcclxuICBcdHRoaXMubGF0ID0gK2xhdDtcclxuXHJcbiAgXHQvLyBAcHJvcGVydHkgbG5nOiBOdW1iZXJcclxuICBcdC8vIExvbmdpdHVkZSBpbiBkZWdyZWVzXHJcbiAgXHR0aGlzLmxuZyA9ICtsbmc7XHJcblxyXG4gIFx0Ly8gQHByb3BlcnR5IGFsdDogTnVtYmVyXHJcbiAgXHQvLyBBbHRpdHVkZSBpbiBtZXRlcnMgKG9wdGlvbmFsKVxyXG4gIFx0aWYgKGFsdCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgXHRcdHRoaXMuYWx0ID0gK2FsdDtcclxuICBcdH1cclxuICB9XHJcblxyXG4gIExhdExuZy5wcm90b3R5cGUgPSB7XHJcbiAgXHQvLyBAbWV0aG9kIGVxdWFscyhvdGhlckxhdExuZzogTGF0TG5nLCBtYXhNYXJnaW4/OiBOdW1iZXIpOiBCb29sZWFuXHJcbiAgXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gYExhdExuZ2AgcG9pbnQgaXMgYXQgdGhlIHNhbWUgcG9zaXRpb24gKHdpdGhpbiBhIHNtYWxsIG1hcmdpbiBvZiBlcnJvcikuIFRoZSBtYXJnaW4gb2YgZXJyb3IgY2FuIGJlIG92ZXJyaWRkZW4gYnkgc2V0dGluZyBgbWF4TWFyZ2luYCB0byBhIHNtYWxsIG51bWJlci5cclxuICBcdGVxdWFsczogZnVuY3Rpb24gKG9iaiwgbWF4TWFyZ2luKSB7XHJcbiAgXHRcdGlmICghb2JqKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cclxuICBcdFx0b2JqID0gdG9MYXRMbmcob2JqKTtcclxuXHJcbiAgXHRcdHZhciBtYXJnaW4gPSBNYXRoLm1heChcclxuICBcdFx0ICAgICAgICBNYXRoLmFicyh0aGlzLmxhdCAtIG9iai5sYXQpLFxyXG4gIFx0XHQgICAgICAgIE1hdGguYWJzKHRoaXMubG5nIC0gb2JqLmxuZykpO1xyXG5cclxuICBcdFx0cmV0dXJuIG1hcmdpbiA8PSAobWF4TWFyZ2luID09PSB1bmRlZmluZWQgPyAxLjBFLTkgOiBtYXhNYXJnaW4pO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHRvU3RyaW5nKCk6IFN0cmluZ1xyXG4gIFx0Ly8gUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgcG9pbnQgKGZvciBkZWJ1Z2dpbmcgcHVycG9zZXMpLlxyXG4gIFx0dG9TdHJpbmc6IGZ1bmN0aW9uIChwcmVjaXNpb24pIHtcclxuICBcdFx0cmV0dXJuICdMYXRMbmcoJyArXHJcbiAgXHRcdCAgICAgICAgZm9ybWF0TnVtKHRoaXMubGF0LCBwcmVjaXNpb24pICsgJywgJyArXHJcbiAgXHRcdCAgICAgICAgZm9ybWF0TnVtKHRoaXMubG5nLCBwcmVjaXNpb24pICsgJyknO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGRpc3RhbmNlVG8ob3RoZXJMYXRMbmc6IExhdExuZyk6IE51bWJlclxyXG4gIFx0Ly8gUmV0dXJucyB0aGUgZGlzdGFuY2UgKGluIG1ldGVycykgdG8gdGhlIGdpdmVuIGBMYXRMbmdgIGNhbGN1bGF0ZWQgdXNpbmcgdGhlIFtTcGhlcmljYWwgTGF3IG9mIENvc2luZXNdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1NwaGVyaWNhbF9sYXdfb2ZfY29zaW5lcykuXHJcbiAgXHRkaXN0YW5jZVRvOiBmdW5jdGlvbiAob3RoZXIpIHtcclxuICBcdFx0cmV0dXJuIEVhcnRoLmRpc3RhbmNlKHRoaXMsIHRvTGF0TG5nKG90aGVyKSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2Qgd3JhcCgpOiBMYXRMbmdcclxuICBcdC8vIFJldHVybnMgYSBuZXcgYExhdExuZ2Agb2JqZWN0IHdpdGggdGhlIGxvbmdpdHVkZSB3cmFwcGVkIHNvIGl0J3MgYWx3YXlzIGJldHdlZW4gLTE4MCBhbmQgKzE4MCBkZWdyZWVzLlxyXG4gIFx0d3JhcDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gRWFydGgud3JhcExhdExuZyh0aGlzKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCB0b0JvdW5kcyhzaXplSW5NZXRlcnM6IE51bWJlcik6IExhdExuZ0JvdW5kc1xyXG4gIFx0Ly8gUmV0dXJucyBhIG5ldyBgTGF0TG5nQm91bmRzYCBvYmplY3QgaW4gd2hpY2ggZWFjaCBib3VuZGFyeSBpcyBgc2l6ZUluTWV0ZXJzLzJgIG1ldGVycyBhcGFydCBmcm9tIHRoZSBgTGF0TG5nYC5cclxuICBcdHRvQm91bmRzOiBmdW5jdGlvbiAoc2l6ZUluTWV0ZXJzKSB7XHJcbiAgXHRcdHZhciBsYXRBY2N1cmFjeSA9IDE4MCAqIHNpemVJbk1ldGVycyAvIDQwMDc1MDE3LFxyXG4gIFx0XHQgICAgbG5nQWNjdXJhY3kgPSBsYXRBY2N1cmFjeSAvIE1hdGguY29zKChNYXRoLlBJIC8gMTgwKSAqIHRoaXMubGF0KTtcclxuXHJcbiAgXHRcdHJldHVybiB0b0xhdExuZ0JvdW5kcyhcclxuICBcdFx0ICAgICAgICBbdGhpcy5sYXQgLSBsYXRBY2N1cmFjeSwgdGhpcy5sbmcgLSBsbmdBY2N1cmFjeV0sXHJcbiAgXHRcdCAgICAgICAgW3RoaXMubGF0ICsgbGF0QWNjdXJhY3ksIHRoaXMubG5nICsgbG5nQWNjdXJhY3ldKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIG5ldyBMYXRMbmcodGhpcy5sYXQsIHRoaXMubG5nLCB0aGlzLmFsdCk7XHJcbiAgXHR9XHJcbiAgfTtcclxuXHJcblxyXG5cclxuICAvLyBAZmFjdG9yeSBMLmxhdExuZyhsYXRpdHVkZTogTnVtYmVyLCBsb25naXR1ZGU6IE51bWJlciwgYWx0aXR1ZGU/OiBOdW1iZXIpOiBMYXRMbmdcclxuICAvLyBDcmVhdGVzIGFuIG9iamVjdCByZXByZXNlbnRpbmcgYSBnZW9ncmFwaGljYWwgcG9pbnQgd2l0aCB0aGUgZ2l2ZW4gbGF0aXR1ZGUgYW5kIGxvbmdpdHVkZSAoYW5kIG9wdGlvbmFsbHkgYWx0aXR1ZGUpLlxyXG5cclxuICAvLyBAYWx0ZXJuYXRpdmVcclxuICAvLyBAZmFjdG9yeSBMLmxhdExuZyhjb29yZHM6IEFycmF5KTogTGF0TG5nXHJcbiAgLy8gRXhwZWN0cyBhbiBhcnJheSBvZiB0aGUgZm9ybSBgW051bWJlciwgTnVtYmVyXWAgb3IgYFtOdW1iZXIsIE51bWJlciwgTnVtYmVyXWAgaW5zdGVhZC5cclxuXHJcbiAgLy8gQGFsdGVybmF0aXZlXHJcbiAgLy8gQGZhY3RvcnkgTC5sYXRMbmcoY29vcmRzOiBPYmplY3QpOiBMYXRMbmdcclxuICAvLyBFeHBlY3RzIGFuIHBsYWluIG9iamVjdCBvZiB0aGUgZm9ybSBge2xhdDogTnVtYmVyLCBsbmc6IE51bWJlcn1gIG9yIGB7bGF0OiBOdW1iZXIsIGxuZzogTnVtYmVyLCBhbHQ6IE51bWJlcn1gIGluc3RlYWQuXHJcblxyXG4gIGZ1bmN0aW9uIHRvTGF0TG5nKGEsIGIsIGMpIHtcclxuICBcdGlmIChhIGluc3RhbmNlb2YgTGF0TG5nKSB7XHJcbiAgXHRcdHJldHVybiBhO1xyXG4gIFx0fVxyXG4gIFx0aWYgKGlzQXJyYXkoYSkgJiYgdHlwZW9mIGFbMF0gIT09ICdvYmplY3QnKSB7XHJcbiAgXHRcdGlmIChhLmxlbmd0aCA9PT0gMykge1xyXG4gIFx0XHRcdHJldHVybiBuZXcgTGF0TG5nKGFbMF0sIGFbMV0sIGFbMl0pO1xyXG4gIFx0XHR9XHJcbiAgXHRcdGlmIChhLmxlbmd0aCA9PT0gMikge1xyXG4gIFx0XHRcdHJldHVybiBuZXcgTGF0TG5nKGFbMF0sIGFbMV0pO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiBudWxsO1xyXG4gIFx0fVxyXG4gIFx0aWYgKGEgPT09IHVuZGVmaW5lZCB8fCBhID09PSBudWxsKSB7XHJcbiAgXHRcdHJldHVybiBhO1xyXG4gIFx0fVxyXG4gIFx0aWYgKHR5cGVvZiBhID09PSAnb2JqZWN0JyAmJiAnbGF0JyBpbiBhKSB7XHJcbiAgXHRcdHJldHVybiBuZXcgTGF0TG5nKGEubGF0LCAnbG5nJyBpbiBhID8gYS5sbmcgOiBhLmxvbiwgYS5hbHQpO1xyXG4gIFx0fVxyXG4gIFx0aWYgKGIgPT09IHVuZGVmaW5lZCkge1xyXG4gIFx0XHRyZXR1cm4gbnVsbDtcclxuICBcdH1cclxuICBcdHJldHVybiBuZXcgTGF0TG5nKGEsIGIsIGMpO1xyXG4gIH1cblxuICAvKlxyXG4gICAqIEBuYW1lc3BhY2UgQ1JTXHJcbiAgICogQGNycyBMLkNSUy5CYXNlXHJcbiAgICogT2JqZWN0IHRoYXQgZGVmaW5lcyBjb29yZGluYXRlIHJlZmVyZW5jZSBzeXN0ZW1zIGZvciBwcm9qZWN0aW5nXHJcbiAgICogZ2VvZ3JhcGhpY2FsIHBvaW50cyBpbnRvIHBpeGVsIChzY3JlZW4pIGNvb3JkaW5hdGVzIGFuZCBiYWNrIChhbmQgdG9cclxuICAgKiBjb29yZGluYXRlcyBpbiBvdGhlciB1bml0cyBmb3IgW1dNU10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvV2ViX01hcF9TZXJ2aWNlKSBzZXJ2aWNlcykuIFNlZVxyXG4gICAqIFtzcGF0aWFsIHJlZmVyZW5jZSBzeXN0ZW1dKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29vcmRpbmF0ZV9yZWZlcmVuY2Vfc3lzdGVtKS5cclxuICAgKlxyXG4gICAqIExlYWZsZXQgZGVmaW5lcyB0aGUgbW9zdCB1c3VhbCBDUlNzIGJ5IGRlZmF1bHQuIElmIHlvdSB3YW50IHRvIHVzZSBhXHJcbiAgICogQ1JTIG5vdCBkZWZpbmVkIGJ5IGRlZmF1bHQsIHRha2UgYSBsb29rIGF0IHRoZVxyXG4gICAqIFtQcm9qNExlYWZsZXRdKGh0dHBzOi8vZ2l0aHViLmNvbS9rYXJ0ZW5hL1Byb2o0TGVhZmxldCkgcGx1Z2luLlxyXG4gICAqXHJcbiAgICogTm90ZSB0aGF0IHRoZSBDUlMgaW5zdGFuY2VzIGRvIG5vdCBpbmhlcml0IGZyb20gTGVhZmxldCdzIGBDbGFzc2Agb2JqZWN0LFxyXG4gICAqIGFuZCBjYW4ndCBiZSBpbnN0YW50aWF0ZWQuIEFsc28sIG5ldyBjbGFzc2VzIGNhbid0IGluaGVyaXQgZnJvbSB0aGVtLFxyXG4gICAqIGFuZCBtZXRob2RzIGNhbid0IGJlIGFkZGVkIHRvIHRoZW0gd2l0aCB0aGUgYGluY2x1ZGVgIGZ1bmN0aW9uLlxyXG4gICAqL1xyXG5cclxuICB2YXIgQ1JTID0ge1xyXG4gIFx0Ly8gQG1ldGhvZCBsYXRMbmdUb1BvaW50KGxhdGxuZzogTGF0TG5nLCB6b29tOiBOdW1iZXIpOiBQb2ludFxyXG4gIFx0Ly8gUHJvamVjdHMgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGVzIGludG8gcGl4ZWwgY29vcmRpbmF0ZXMgZm9yIGEgZ2l2ZW4gem9vbS5cclxuICBcdGxhdExuZ1RvUG9pbnQ6IGZ1bmN0aW9uIChsYXRsbmcsIHpvb20pIHtcclxuICBcdFx0dmFyIHByb2plY3RlZFBvaW50ID0gdGhpcy5wcm9qZWN0aW9uLnByb2plY3QobGF0bG5nKSxcclxuICBcdFx0ICAgIHNjYWxlID0gdGhpcy5zY2FsZSh6b29tKTtcclxuXHJcbiAgXHRcdHJldHVybiB0aGlzLnRyYW5zZm9ybWF0aW9uLl90cmFuc2Zvcm0ocHJvamVjdGVkUG9pbnQsIHNjYWxlKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBwb2ludFRvTGF0TG5nKHBvaW50OiBQb2ludCwgem9vbTogTnVtYmVyKTogTGF0TG5nXHJcbiAgXHQvLyBUaGUgaW52ZXJzZSBvZiBgbGF0TG5nVG9Qb2ludGAuIFByb2plY3RzIHBpeGVsIGNvb3JkaW5hdGVzIG9uIGEgZ2l2ZW5cclxuICBcdC8vIHpvb20gaW50byBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZXMuXHJcbiAgXHRwb2ludFRvTGF0TG5nOiBmdW5jdGlvbiAocG9pbnQsIHpvb20pIHtcclxuICBcdFx0dmFyIHNjYWxlID0gdGhpcy5zY2FsZSh6b29tKSxcclxuICBcdFx0ICAgIHVudHJhbnNmb3JtZWRQb2ludCA9IHRoaXMudHJhbnNmb3JtYXRpb24udW50cmFuc2Zvcm0ocG9pbnQsIHNjYWxlKTtcclxuXHJcbiAgXHRcdHJldHVybiB0aGlzLnByb2plY3Rpb24udW5wcm9qZWN0KHVudHJhbnNmb3JtZWRQb2ludCk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgcHJvamVjdChsYXRsbmc6IExhdExuZyk6IFBvaW50XHJcbiAgXHQvLyBQcm9qZWN0cyBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZXMgaW50byBjb29yZGluYXRlcyBpbiB1bml0cyBhY2NlcHRlZCBmb3JcclxuICBcdC8vIHRoaXMgQ1JTIChlLmcuIG1ldGVycyBmb3IgRVBTRzozODU3LCBmb3IgcGFzc2luZyBpdCB0byBXTVMgc2VydmljZXMpLlxyXG4gIFx0cHJvamVjdDogZnVuY3Rpb24gKGxhdGxuZykge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5wcm9qZWN0aW9uLnByb2plY3QobGF0bG5nKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCB1bnByb2plY3QocG9pbnQ6IFBvaW50KTogTGF0TG5nXHJcbiAgXHQvLyBHaXZlbiBhIHByb2plY3RlZCBjb29yZGluYXRlIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgTGF0TG5nLlxyXG4gIFx0Ly8gVGhlIGludmVyc2Ugb2YgYHByb2plY3RgLlxyXG4gIFx0dW5wcm9qZWN0OiBmdW5jdGlvbiAocG9pbnQpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMucHJvamVjdGlvbi51bnByb2plY3QocG9pbnQpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHNjYWxlKHpvb206IE51bWJlcik6IE51bWJlclxyXG4gIFx0Ly8gUmV0dXJucyB0aGUgc2NhbGUgdXNlZCB3aGVuIHRyYW5zZm9ybWluZyBwcm9qZWN0ZWQgY29vcmRpbmF0ZXMgaW50b1xyXG4gIFx0Ly8gcGl4ZWwgY29vcmRpbmF0ZXMgZm9yIGEgcGFydGljdWxhciB6b29tLiBGb3IgZXhhbXBsZSwgaXQgcmV0dXJuc1xyXG4gIFx0Ly8gYDI1NiAqIDJeem9vbWAgZm9yIE1lcmNhdG9yLWJhc2VkIENSUy5cclxuICBcdHNjYWxlOiBmdW5jdGlvbiAoem9vbSkge1xyXG4gIFx0XHRyZXR1cm4gMjU2ICogTWF0aC5wb3coMiwgem9vbSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2Qgem9vbShzY2FsZTogTnVtYmVyKTogTnVtYmVyXHJcbiAgXHQvLyBJbnZlcnNlIG9mIGBzY2FsZSgpYCwgcmV0dXJucyB0aGUgem9vbSBsZXZlbCBjb3JyZXNwb25kaW5nIHRvIGEgc2NhbGVcclxuICBcdC8vIGZhY3RvciBvZiBgc2NhbGVgLlxyXG4gIFx0em9vbTogZnVuY3Rpb24gKHNjYWxlKSB7XHJcbiAgXHRcdHJldHVybiBNYXRoLmxvZyhzY2FsZSAvIDI1NikgLyBNYXRoLkxOMjtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRQcm9qZWN0ZWRCb3VuZHMoem9vbTogTnVtYmVyKTogQm91bmRzXHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBwcm9qZWN0aW9uJ3MgYm91bmRzIHNjYWxlZCBhbmQgdHJhbnNmb3JtZWQgZm9yIHRoZSBwcm92aWRlZCBgem9vbWAuXHJcbiAgXHRnZXRQcm9qZWN0ZWRCb3VuZHM6IGZ1bmN0aW9uICh6b29tKSB7XHJcbiAgXHRcdGlmICh0aGlzLmluZmluaXRlKSB7IHJldHVybiBudWxsOyB9XHJcblxyXG4gIFx0XHR2YXIgYiA9IHRoaXMucHJvamVjdGlvbi5ib3VuZHMsXHJcbiAgXHRcdCAgICBzID0gdGhpcy5zY2FsZSh6b29tKSxcclxuICBcdFx0ICAgIG1pbiA9IHRoaXMudHJhbnNmb3JtYXRpb24udHJhbnNmb3JtKGIubWluLCBzKSxcclxuICBcdFx0ICAgIG1heCA9IHRoaXMudHJhbnNmb3JtYXRpb24udHJhbnNmb3JtKGIubWF4LCBzKTtcclxuXHJcbiAgXHRcdHJldHVybiBuZXcgQm91bmRzKG1pbiwgbWF4KTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBkaXN0YW5jZShsYXRsbmcxOiBMYXRMbmcsIGxhdGxuZzI6IExhdExuZyk6IE51bWJlclxyXG4gIFx0Ly8gUmV0dXJucyB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGVzLlxyXG5cclxuICBcdC8vIEBwcm9wZXJ0eSBjb2RlOiBTdHJpbmdcclxuICBcdC8vIFN0YW5kYXJkIGNvZGUgbmFtZSBvZiB0aGUgQ1JTIHBhc3NlZCBpbnRvIFdNUyBzZXJ2aWNlcyAoZS5nLiBgJ0VQU0c6Mzg1NydgKVxyXG4gIFx0Ly9cclxuICBcdC8vIEBwcm9wZXJ0eSB3cmFwTG5nOiBOdW1iZXJbXVxyXG4gIFx0Ly8gQW4gYXJyYXkgb2YgdHdvIG51bWJlcnMgZGVmaW5pbmcgd2hldGhlciB0aGUgbG9uZ2l0dWRlIChob3Jpem9udGFsKSBjb29yZGluYXRlXHJcbiAgXHQvLyBheGlzIHdyYXBzIGFyb3VuZCBhIGdpdmVuIHJhbmdlIGFuZCBob3cuIERlZmF1bHRzIHRvIGBbLTE4MCwgMTgwXWAgaW4gbW9zdFxyXG4gIFx0Ly8gZ2VvZ3JhcGhpY2FsIENSU3MuIElmIGB1bmRlZmluZWRgLCB0aGUgbG9uZ2l0dWRlIGF4aXMgZG9lcyBub3Qgd3JhcCBhcm91bmQuXHJcbiAgXHQvL1xyXG4gIFx0Ly8gQHByb3BlcnR5IHdyYXBMYXQ6IE51bWJlcltdXHJcbiAgXHQvLyBMaWtlIGB3cmFwTG5nYCwgYnV0IGZvciB0aGUgbGF0aXR1ZGUgKHZlcnRpY2FsKSBheGlzLlxyXG5cclxuICBcdC8vIHdyYXBMbmc6IFttaW4sIG1heF0sXHJcbiAgXHQvLyB3cmFwTGF0OiBbbWluLCBtYXhdLFxyXG5cclxuICBcdC8vIEBwcm9wZXJ0eSBpbmZpbml0ZTogQm9vbGVhblxyXG4gIFx0Ly8gSWYgdHJ1ZSwgdGhlIGNvb3JkaW5hdGUgc3BhY2Ugd2lsbCBiZSB1bmJvdW5kZWQgKGluZmluaXRlIGluIGJvdGggYXhlcylcclxuICBcdGluZmluaXRlOiBmYWxzZSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHdyYXBMYXRMbmcobGF0bG5nOiBMYXRMbmcpOiBMYXRMbmdcclxuICBcdC8vIFJldHVybnMgYSBgTGF0TG5nYCB3aGVyZSBsYXQgYW5kIGxuZyBoYXMgYmVlbiB3cmFwcGVkIGFjY29yZGluZyB0byB0aGVcclxuICBcdC8vIENSUydzIGB3cmFwTGF0YCBhbmQgYHdyYXBMbmdgIHByb3BlcnRpZXMsIGlmIHRoZXkgYXJlIG91dHNpZGUgdGhlIENSUydzIGJvdW5kcy5cclxuICBcdHdyYXBMYXRMbmc6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuICBcdFx0dmFyIGxuZyA9IHRoaXMud3JhcExuZyA/IHdyYXBOdW0obGF0bG5nLmxuZywgdGhpcy53cmFwTG5nLCB0cnVlKSA6IGxhdGxuZy5sbmcsXHJcbiAgXHRcdCAgICBsYXQgPSB0aGlzLndyYXBMYXQgPyB3cmFwTnVtKGxhdGxuZy5sYXQsIHRoaXMud3JhcExhdCwgdHJ1ZSkgOiBsYXRsbmcubGF0LFxyXG4gIFx0XHQgICAgYWx0ID0gbGF0bG5nLmFsdDtcclxuXHJcbiAgXHRcdHJldHVybiBuZXcgTGF0TG5nKGxhdCwgbG5nLCBhbHQpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHdyYXBMYXRMbmdCb3VuZHMoYm91bmRzOiBMYXRMbmdCb3VuZHMpOiBMYXRMbmdCb3VuZHNcclxuICBcdC8vIFJldHVybnMgYSBgTGF0TG5nQm91bmRzYCB3aXRoIHRoZSBzYW1lIHNpemUgYXMgdGhlIGdpdmVuIG9uZSwgZW5zdXJpbmdcclxuICBcdC8vIHRoYXQgaXRzIGNlbnRlciBpcyB3aXRoaW4gdGhlIENSUydzIGJvdW5kcy5cclxuICBcdC8vIE9ubHkgYWNjZXB0cyBhY3R1YWwgYEwuTGF0TG5nQm91bmRzYCBpbnN0YW5jZXMsIG5vdCBhcnJheXMuXHJcbiAgXHR3cmFwTGF0TG5nQm91bmRzOiBmdW5jdGlvbiAoYm91bmRzKSB7XHJcbiAgXHRcdHZhciBjZW50ZXIgPSBib3VuZHMuZ2V0Q2VudGVyKCksXHJcbiAgXHRcdCAgICBuZXdDZW50ZXIgPSB0aGlzLndyYXBMYXRMbmcoY2VudGVyKSxcclxuICBcdFx0ICAgIGxhdFNoaWZ0ID0gY2VudGVyLmxhdCAtIG5ld0NlbnRlci5sYXQsXHJcbiAgXHRcdCAgICBsbmdTaGlmdCA9IGNlbnRlci5sbmcgLSBuZXdDZW50ZXIubG5nO1xyXG5cclxuICBcdFx0aWYgKGxhdFNoaWZ0ID09PSAwICYmIGxuZ1NoaWZ0ID09PSAwKSB7XHJcbiAgXHRcdFx0cmV0dXJuIGJvdW5kcztcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dmFyIHN3ID0gYm91bmRzLmdldFNvdXRoV2VzdCgpLFxyXG4gIFx0XHQgICAgbmUgPSBib3VuZHMuZ2V0Tm9ydGhFYXN0KCksXHJcbiAgXHRcdCAgICBuZXdTdyA9IG5ldyBMYXRMbmcoc3cubGF0IC0gbGF0U2hpZnQsIHN3LmxuZyAtIGxuZ1NoaWZ0KSxcclxuICBcdFx0ICAgIG5ld05lID0gbmV3IExhdExuZyhuZS5sYXQgLSBsYXRTaGlmdCwgbmUubG5nIC0gbG5nU2hpZnQpO1xyXG5cclxuICBcdFx0cmV0dXJuIG5ldyBMYXRMbmdCb3VuZHMobmV3U3csIG5ld05lKTtcclxuICBcdH1cclxuICB9O1xuXG4gIC8qXG4gICAqIEBuYW1lc3BhY2UgQ1JTXG4gICAqIEBjcnMgTC5DUlMuRWFydGhcbiAgICpcbiAgICogU2VydmVzIGFzIHRoZSBiYXNlIGZvciBDUlMgdGhhdCBhcmUgZ2xvYmFsIHN1Y2ggdGhhdCB0aGV5IGNvdmVyIHRoZSBlYXJ0aC5cbiAgICogQ2FuIG9ubHkgYmUgdXNlZCBhcyB0aGUgYmFzZSBmb3Igb3RoZXIgQ1JTIGFuZCBjYW5ub3QgYmUgdXNlZCBkaXJlY3RseSxcbiAgICogc2luY2UgaXQgZG9lcyBub3QgaGF2ZSBhIGBjb2RlYCwgYHByb2plY3Rpb25gIG9yIGB0cmFuc2Zvcm1hdGlvbmAuIGBkaXN0YW5jZSgpYCByZXR1cm5zXG4gICAqIG1ldGVycy5cbiAgICovXG5cbiAgdmFyIEVhcnRoID0gZXh0ZW5kKHt9LCBDUlMsIHtcbiAgXHR3cmFwTG5nOiBbLTE4MCwgMTgwXSxcblxuICBcdC8vIE1lYW4gRWFydGggUmFkaXVzLCBhcyByZWNvbW1lbmRlZCBmb3IgdXNlIGJ5XG4gIFx0Ly8gdGhlIEludGVybmF0aW9uYWwgVW5pb24gb2YgR2VvZGVzeSBhbmQgR2VvcGh5c2ljcyxcbiAgXHQvLyBzZWUgaHR0cDovL3Jvc2V0dGFjb2RlLm9yZy93aWtpL0hhdmVyc2luZV9mb3JtdWxhXG4gIFx0UjogNjM3MTAwMCxcblxuICBcdC8vIGRpc3RhbmNlIGJldHdlZW4gdHdvIGdlb2dyYXBoaWNhbCBwb2ludHMgdXNpbmcgc3BoZXJpY2FsIGxhdyBvZiBjb3NpbmVzIGFwcHJveGltYXRpb25cbiAgXHRkaXN0YW5jZTogZnVuY3Rpb24gKGxhdGxuZzEsIGxhdGxuZzIpIHtcbiAgXHRcdHZhciByYWQgPSBNYXRoLlBJIC8gMTgwLFxuICBcdFx0ICAgIGxhdDEgPSBsYXRsbmcxLmxhdCAqIHJhZCxcbiAgXHRcdCAgICBsYXQyID0gbGF0bG5nMi5sYXQgKiByYWQsXG4gIFx0XHQgICAgc2luRExhdCA9IE1hdGguc2luKChsYXRsbmcyLmxhdCAtIGxhdGxuZzEubGF0KSAqIHJhZCAvIDIpLFxuICBcdFx0ICAgIHNpbkRMb24gPSBNYXRoLnNpbigobGF0bG5nMi5sbmcgLSBsYXRsbmcxLmxuZykgKiByYWQgLyAyKSxcbiAgXHRcdCAgICBhID0gc2luRExhdCAqIHNpbkRMYXQgKyBNYXRoLmNvcyhsYXQxKSAqIE1hdGguY29zKGxhdDIpICogc2luRExvbiAqIHNpbkRMb24sXG4gIFx0XHQgICAgYyA9IDIgKiBNYXRoLmF0YW4yKE1hdGguc3FydChhKSwgTWF0aC5zcXJ0KDEgLSBhKSk7XG4gIFx0XHRyZXR1cm4gdGhpcy5SICogYztcbiAgXHR9XG4gIH0pO1xuXG4gIC8qXHJcbiAgICogQG5hbWVzcGFjZSBQcm9qZWN0aW9uXHJcbiAgICogQHByb2plY3Rpb24gTC5Qcm9qZWN0aW9uLlNwaGVyaWNhbE1lcmNhdG9yXHJcbiAgICpcclxuICAgKiBTcGhlcmljYWwgTWVyY2F0b3IgcHJvamVjdGlvbiDigJQgdGhlIG1vc3QgY29tbW9uIHByb2plY3Rpb24gZm9yIG9ubGluZSBtYXBzLFxyXG4gICAqIHVzZWQgYnkgYWxtb3N0IGFsbCBmcmVlIGFuZCBjb21tZXJjaWFsIHRpbGUgcHJvdmlkZXJzLiBBc3N1bWVzIHRoYXQgRWFydGggaXNcclxuICAgKiBhIHNwaGVyZS4gVXNlZCBieSB0aGUgYEVQU0c6Mzg1N2AgQ1JTLlxyXG4gICAqL1xyXG5cclxuICB2YXIgZWFydGhSYWRpdXMgPSA2Mzc4MTM3O1xyXG5cclxuICB2YXIgU3BoZXJpY2FsTWVyY2F0b3IgPSB7XHJcblxyXG4gIFx0UjogZWFydGhSYWRpdXMsXHJcbiAgXHRNQVhfTEFUSVRVREU6IDg1LjA1MTEyODc3OTgsXHJcblxyXG4gIFx0cHJvamVjdDogZnVuY3Rpb24gKGxhdGxuZykge1xyXG4gIFx0XHR2YXIgZCA9IE1hdGguUEkgLyAxODAsXHJcbiAgXHRcdCAgICBtYXggPSB0aGlzLk1BWF9MQVRJVFVERSxcclxuICBcdFx0ICAgIGxhdCA9IE1hdGgubWF4KE1hdGgubWluKG1heCwgbGF0bG5nLmxhdCksIC1tYXgpLFxyXG4gIFx0XHQgICAgc2luID0gTWF0aC5zaW4obGF0ICogZCk7XHJcblxyXG4gIFx0XHRyZXR1cm4gbmV3IFBvaW50KFxyXG4gIFx0XHRcdHRoaXMuUiAqIGxhdGxuZy5sbmcgKiBkLFxyXG4gIFx0XHRcdHRoaXMuUiAqIE1hdGgubG9nKCgxICsgc2luKSAvICgxIC0gc2luKSkgLyAyKTtcclxuICBcdH0sXHJcblxyXG4gIFx0dW5wcm9qZWN0OiBmdW5jdGlvbiAocG9pbnQpIHtcclxuICBcdFx0dmFyIGQgPSAxODAgLyBNYXRoLlBJO1xyXG5cclxuICBcdFx0cmV0dXJuIG5ldyBMYXRMbmcoXHJcbiAgXHRcdFx0KDIgKiBNYXRoLmF0YW4oTWF0aC5leHAocG9pbnQueSAvIHRoaXMuUikpIC0gKE1hdGguUEkgLyAyKSkgKiBkLFxyXG4gIFx0XHRcdHBvaW50LnggKiBkIC8gdGhpcy5SKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ym91bmRzOiAoZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR2YXIgZCA9IGVhcnRoUmFkaXVzICogTWF0aC5QSTtcclxuICBcdFx0cmV0dXJuIG5ldyBCb3VuZHMoWy1kLCAtZF0sIFtkLCBkXSk7XHJcbiAgXHR9KSgpXHJcbiAgfTtcblxuICAvKlxyXG4gICAqIEBjbGFzcyBUcmFuc2Zvcm1hdGlvblxyXG4gICAqIEBha2EgTC5UcmFuc2Zvcm1hdGlvblxyXG4gICAqXHJcbiAgICogUmVwcmVzZW50cyBhbiBhZmZpbmUgdHJhbnNmb3JtYXRpb246IGEgc2V0IG9mIGNvZWZmaWNpZW50cyBgYWAsIGBiYCwgYGNgLCBgZGBcclxuICAgKiBmb3IgdHJhbnNmb3JtaW5nIGEgcG9pbnQgb2YgYSBmb3JtIGAoeCwgeSlgIGludG8gYChhKnggKyBiLCBjKnkgKyBkKWAgYW5kIGRvaW5nXHJcbiAgICogdGhlIHJldmVyc2UuIFVzZWQgYnkgTGVhZmxldCBpbiBpdHMgcHJvamVjdGlvbnMgY29kZS5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICpcclxuICAgKiBgYGBqc1xyXG4gICAqIHZhciB0cmFuc2Zvcm1hdGlvbiA9IEwudHJhbnNmb3JtYXRpb24oMiwgNSwgLTEsIDEwKSxcclxuICAgKiBcdHAgPSBMLnBvaW50KDEsIDIpLFxyXG4gICAqIFx0cDIgPSB0cmFuc2Zvcm1hdGlvbi50cmFuc2Zvcm0ocCksIC8vICBMLnBvaW50KDcsIDgpXHJcbiAgICogXHRwMyA9IHRyYW5zZm9ybWF0aW9uLnVudHJhbnNmb3JtKHAyKTsgLy8gIEwucG9pbnQoMSwgMilcclxuICAgKiBgYGBcclxuICAgKi9cclxuXHJcblxyXG4gIC8vIGZhY3RvcnkgbmV3IEwuVHJhbnNmb3JtYXRpb24oYTogTnVtYmVyLCBiOiBOdW1iZXIsIGM6IE51bWJlciwgZDogTnVtYmVyKVxyXG4gIC8vIENyZWF0ZXMgYSBgVHJhbnNmb3JtYXRpb25gIG9iamVjdCB3aXRoIHRoZSBnaXZlbiBjb2VmZmljaWVudHMuXHJcbiAgZnVuY3Rpb24gVHJhbnNmb3JtYXRpb24oYSwgYiwgYywgZCkge1xyXG4gIFx0aWYgKGlzQXJyYXkoYSkpIHtcclxuICBcdFx0Ly8gdXNlIGFycmF5IHByb3BlcnRpZXNcclxuICBcdFx0dGhpcy5fYSA9IGFbMF07XHJcbiAgXHRcdHRoaXMuX2IgPSBhWzFdO1xyXG4gIFx0XHR0aGlzLl9jID0gYVsyXTtcclxuICBcdFx0dGhpcy5fZCA9IGFbM107XHJcbiAgXHRcdHJldHVybjtcclxuICBcdH1cclxuICBcdHRoaXMuX2EgPSBhO1xyXG4gIFx0dGhpcy5fYiA9IGI7XHJcbiAgXHR0aGlzLl9jID0gYztcclxuICBcdHRoaXMuX2QgPSBkO1xyXG4gIH1cclxuXHJcbiAgVHJhbnNmb3JtYXRpb24ucHJvdG90eXBlID0ge1xyXG4gIFx0Ly8gQG1ldGhvZCB0cmFuc2Zvcm0ocG9pbnQ6IFBvaW50LCBzY2FsZT86IE51bWJlcik6IFBvaW50XHJcbiAgXHQvLyBSZXR1cm5zIGEgdHJhbnNmb3JtZWQgcG9pbnQsIG9wdGlvbmFsbHkgbXVsdGlwbGllZCBieSB0aGUgZ2l2ZW4gc2NhbGUuXHJcbiAgXHQvLyBPbmx5IGFjY2VwdHMgYWN0dWFsIGBMLlBvaW50YCBpbnN0YW5jZXMsIG5vdCBhcnJheXMuXHJcbiAgXHR0cmFuc2Zvcm06IGZ1bmN0aW9uIChwb2ludCwgc2NhbGUpIHsgLy8gKFBvaW50LCBOdW1iZXIpIC0+IFBvaW50XHJcbiAgXHRcdHJldHVybiB0aGlzLl90cmFuc2Zvcm0ocG9pbnQuY2xvbmUoKSwgc2NhbGUpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBkZXN0cnVjdGl2ZSB0cmFuc2Zvcm0gKGZhc3RlcilcclxuICBcdF90cmFuc2Zvcm06IGZ1bmN0aW9uIChwb2ludCwgc2NhbGUpIHtcclxuICBcdFx0c2NhbGUgPSBzY2FsZSB8fCAxO1xyXG4gIFx0XHRwb2ludC54ID0gc2NhbGUgKiAodGhpcy5fYSAqIHBvaW50LnggKyB0aGlzLl9iKTtcclxuICBcdFx0cG9pbnQueSA9IHNjYWxlICogKHRoaXMuX2MgKiBwb2ludC55ICsgdGhpcy5fZCk7XHJcbiAgXHRcdHJldHVybiBwb2ludDtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCB1bnRyYW5zZm9ybShwb2ludDogUG9pbnQsIHNjYWxlPzogTnVtYmVyKTogUG9pbnRcclxuICBcdC8vIFJldHVybnMgdGhlIHJldmVyc2UgdHJhbnNmb3JtYXRpb24gb2YgdGhlIGdpdmVuIHBvaW50LCBvcHRpb25hbGx5IGRpdmlkZWRcclxuICBcdC8vIGJ5IHRoZSBnaXZlbiBzY2FsZS4gT25seSBhY2NlcHRzIGFjdHVhbCBgTC5Qb2ludGAgaW5zdGFuY2VzLCBub3QgYXJyYXlzLlxyXG4gIFx0dW50cmFuc2Zvcm06IGZ1bmN0aW9uIChwb2ludCwgc2NhbGUpIHtcclxuICBcdFx0c2NhbGUgPSBzY2FsZSB8fCAxO1xyXG4gIFx0XHRyZXR1cm4gbmV3IFBvaW50KFxyXG4gIFx0XHQgICAgICAgIChwb2ludC54IC8gc2NhbGUgLSB0aGlzLl9iKSAvIHRoaXMuX2EsXHJcbiAgXHRcdCAgICAgICAgKHBvaW50LnkgLyBzY2FsZSAtIHRoaXMuX2QpIC8gdGhpcy5fYyk7XHJcbiAgXHR9XHJcbiAgfTtcclxuXHJcbiAgLy8gZmFjdG9yeSBMLnRyYW5zZm9ybWF0aW9uKGE6IE51bWJlciwgYjogTnVtYmVyLCBjOiBOdW1iZXIsIGQ6IE51bWJlcilcclxuXHJcbiAgLy8gQGZhY3RvcnkgTC50cmFuc2Zvcm1hdGlvbihhOiBOdW1iZXIsIGI6IE51bWJlciwgYzogTnVtYmVyLCBkOiBOdW1iZXIpXHJcbiAgLy8gSW5zdGFudGlhdGVzIGEgVHJhbnNmb3JtYXRpb24gb2JqZWN0IHdpdGggdGhlIGdpdmVuIGNvZWZmaWNpZW50cy5cclxuXHJcbiAgLy8gQGFsdGVybmF0aXZlXHJcbiAgLy8gQGZhY3RvcnkgTC50cmFuc2Zvcm1hdGlvbihjb2VmZmljaWVudHM6IEFycmF5KTogVHJhbnNmb3JtYXRpb25cclxuICAvLyBFeHBlY3RzIGFuIGNvZWZmaWNpZW50cyBhcnJheSBvZiB0aGUgZm9ybVxyXG4gIC8vIGBbYTogTnVtYmVyLCBiOiBOdW1iZXIsIGM6IE51bWJlciwgZDogTnVtYmVyXWAuXHJcblxyXG4gIGZ1bmN0aW9uIHRvVHJhbnNmb3JtYXRpb24oYSwgYiwgYywgZCkge1xyXG4gIFx0cmV0dXJuIG5ldyBUcmFuc2Zvcm1hdGlvbihhLCBiLCBjLCBkKTtcclxuICB9XG5cbiAgLypcclxuICAgKiBAbmFtZXNwYWNlIENSU1xyXG4gICAqIEBjcnMgTC5DUlMuRVBTRzM4NTdcclxuICAgKlxyXG4gICAqIFRoZSBtb3N0IGNvbW1vbiBDUlMgZm9yIG9ubGluZSBtYXBzLCB1c2VkIGJ5IGFsbW9zdCBhbGwgZnJlZSBhbmQgY29tbWVyY2lhbFxyXG4gICAqIHRpbGUgcHJvdmlkZXJzLiBVc2VzIFNwaGVyaWNhbCBNZXJjYXRvciBwcm9qZWN0aW9uLiBTZXQgaW4gYnkgZGVmYXVsdCBpblxyXG4gICAqIE1hcCdzIGBjcnNgIG9wdGlvbi5cclxuICAgKi9cclxuXHJcbiAgdmFyIEVQU0czODU3ID0gZXh0ZW5kKHt9LCBFYXJ0aCwge1xyXG4gIFx0Y29kZTogJ0VQU0c6Mzg1NycsXHJcbiAgXHRwcm9qZWN0aW9uOiBTcGhlcmljYWxNZXJjYXRvcixcclxuXHJcbiAgXHR0cmFuc2Zvcm1hdGlvbjogKGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dmFyIHNjYWxlID0gMC41IC8gKE1hdGguUEkgKiBTcGhlcmljYWxNZXJjYXRvci5SKTtcclxuICBcdFx0cmV0dXJuIHRvVHJhbnNmb3JtYXRpb24oc2NhbGUsIDAuNSwgLXNjYWxlLCAwLjUpO1xyXG4gIFx0fSgpKVxyXG4gIH0pO1xyXG5cclxuICB2YXIgRVBTRzkwMDkxMyA9IGV4dGVuZCh7fSwgRVBTRzM4NTcsIHtcclxuICBcdGNvZGU6ICdFUFNHOjkwMDkxMydcclxuICB9KTtcblxuICAvLyBAbmFtZXNwYWNlIFNWRzsgQHNlY3Rpb25cbiAgLy8gVGhlcmUgYXJlIHNldmVyYWwgc3RhdGljIGZ1bmN0aW9ucyB3aGljaCBjYW4gYmUgY2FsbGVkIHdpdGhvdXQgaW5zdGFudGlhdGluZyBMLlNWRzpcblxuICAvLyBAZnVuY3Rpb24gY3JlYXRlKG5hbWU6IFN0cmluZyk6IFNWR0VsZW1lbnRcbiAgLy8gUmV0dXJucyBhIGluc3RhbmNlIG9mIFtTVkdFbGVtZW50XShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvU1ZHRWxlbWVudCksXG4gIC8vIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGNsYXNzIG5hbWUgcGFzc2VkLiBGb3IgZXhhbXBsZSwgdXNpbmcgJ2xpbmUnIHdpbGwgcmV0dXJuXG4gIC8vIGFuIGluc3RhbmNlIG9mIFtTVkdMaW5lRWxlbWVudF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL1NWR0xpbmVFbGVtZW50KS5cbiAgZnVuY3Rpb24gc3ZnQ3JlYXRlKG5hbWUpIHtcbiAgXHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsIG5hbWUpO1xuICB9XG5cbiAgLy8gQGZ1bmN0aW9uIHBvaW50c1RvUGF0aChyaW5nczogUG9pbnRbXSwgY2xvc2VkOiBCb29sZWFuKTogU3RyaW5nXG4gIC8vIEdlbmVyYXRlcyBhIFNWRyBwYXRoIHN0cmluZyBmb3IgbXVsdGlwbGUgcmluZ3MsIHdpdGggZWFjaCByaW5nIHR1cm5pbmdcbiAgLy8gaW50byBcIk0uLkwuLkwuLlwiIGluc3RydWN0aW9uc1xuICBmdW5jdGlvbiBwb2ludHNUb1BhdGgocmluZ3MsIGNsb3NlZCkge1xuICBcdHZhciBzdHIgPSAnJyxcbiAgXHRpLCBqLCBsZW4sIGxlbjIsIHBvaW50cywgcDtcblxuICBcdGZvciAoaSA9IDAsIGxlbiA9IHJpbmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gIFx0XHRwb2ludHMgPSByaW5nc1tpXTtcblxuICBcdFx0Zm9yIChqID0gMCwgbGVuMiA9IHBvaW50cy5sZW5ndGg7IGogPCBsZW4yOyBqKyspIHtcbiAgXHRcdFx0cCA9IHBvaW50c1tqXTtcbiAgXHRcdFx0c3RyICs9IChqID8gJ0wnIDogJ00nKSArIHAueCArICcgJyArIHAueTtcbiAgXHRcdH1cblxuICBcdFx0Ly8gY2xvc2VzIHRoZSByaW5nIGZvciBwb2x5Z29uczsgXCJ4XCIgaXMgVk1MIHN5bnRheFxuICBcdFx0c3RyICs9IGNsb3NlZCA/IChzdmcgPyAneicgOiAneCcpIDogJyc7XG4gIFx0fVxuXG4gIFx0Ly8gU1ZHIGNvbXBsYWlucyBhYm91dCBlbXB0eSBwYXRoIHN0cmluZ3NcbiAgXHRyZXR1cm4gc3RyIHx8ICdNMCAwJztcbiAgfVxuXG4gIC8qXHJcbiAgICogQG5hbWVzcGFjZSBCcm93c2VyXHJcbiAgICogQGFrYSBMLkJyb3dzZXJcclxuICAgKlxyXG4gICAqIEEgbmFtZXNwYWNlIHdpdGggc3RhdGljIHByb3BlcnRpZXMgZm9yIGJyb3dzZXIvZmVhdHVyZSBkZXRlY3Rpb24gdXNlZCBieSBMZWFmbGV0IGludGVybmFsbHkuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqXHJcbiAgICogYGBganNcclxuICAgKiBpZiAoTC5Ccm93c2VyLmllbHQ5KSB7XHJcbiAgICogICBhbGVydCgnVXBncmFkZSB5b3VyIGJyb3dzZXIsIGR1ZGUhJyk7XHJcbiAgICogfVxyXG4gICAqIGBgYFxyXG4gICAqL1xyXG5cclxuICB2YXIgc3R5bGUkMSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZTtcclxuXHJcbiAgLy8gQHByb3BlcnR5IGllOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIGFsbCBJbnRlcm5ldCBFeHBsb3JlciB2ZXJzaW9ucyAobm90IEVkZ2UpLlxyXG4gIHZhciBpZSA9ICdBY3RpdmVYT2JqZWN0JyBpbiB3aW5kb3c7XHJcblxyXG4gIC8vIEBwcm9wZXJ0eSBpZWx0OTogQm9vbGVhbjsgYHRydWVgIGZvciBJbnRlcm5ldCBFeHBsb3JlciB2ZXJzaW9ucyBsZXNzIHRoYW4gOS5cclxuICB2YXIgaWVsdDkgPSBpZSAmJiAhZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcjtcclxuXHJcbiAgLy8gQHByb3BlcnR5IGVkZ2U6IEJvb2xlYW47IGB0cnVlYCBmb3IgdGhlIEVkZ2Ugd2ViIGJyb3dzZXIuXHJcbiAgdmFyIGVkZ2UgPSAnbXNMYXVuY2hVcmknIGluIG5hdmlnYXRvciAmJiAhKCdkb2N1bWVudE1vZGUnIGluIGRvY3VtZW50KTtcclxuXHJcbiAgLy8gQHByb3BlcnR5IHdlYmtpdDogQm9vbGVhbjtcclxuICAvLyBgdHJ1ZWAgZm9yIHdlYmtpdC1iYXNlZCBicm93c2VycyBsaWtlIENocm9tZSBhbmQgU2FmYXJpIChpbmNsdWRpbmcgbW9iaWxlIHZlcnNpb25zKS5cclxuICB2YXIgd2Via2l0ID0gdXNlckFnZW50Q29udGFpbnMoJ3dlYmtpdCcpO1xyXG5cclxuICAvLyBAcHJvcGVydHkgYW5kcm9pZDogQm9vbGVhblxyXG4gIC8vIGB0cnVlYCBmb3IgYW55IGJyb3dzZXIgcnVubmluZyBvbiBhbiBBbmRyb2lkIHBsYXRmb3JtLlxyXG4gIHZhciBhbmRyb2lkID0gdXNlckFnZW50Q29udGFpbnMoJ2FuZHJvaWQnKTtcclxuXHJcbiAgLy8gQHByb3BlcnR5IGFuZHJvaWQyMzogQm9vbGVhbjsgYHRydWVgIGZvciBicm93c2VycyBydW5uaW5nIG9uIEFuZHJvaWQgMiBvciBBbmRyb2lkIDMuXHJcbiAgdmFyIGFuZHJvaWQyMyA9IHVzZXJBZ2VudENvbnRhaW5zKCdhbmRyb2lkIDInKSB8fCB1c2VyQWdlbnRDb250YWlucygnYW5kcm9pZCAzJyk7XHJcblxyXG4gIC8qIFNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTc5NjEyNjYgZm9yIGRldGFpbHMgb24gZGV0ZWN0aW5nIHN0b2NrIEFuZHJvaWQgKi9cclxuICB2YXIgd2Via2l0VmVyID0gcGFyc2VJbnQoL1dlYktpdFxcLyhbMC05XSspfCQvLmV4ZWMobmF2aWdhdG9yLnVzZXJBZ2VudClbMV0sIDEwKTsgLy8gYWxzbyBtYXRjaGVzIEFwcGxlV2ViS2l0XHJcbiAgLy8gQHByb3BlcnR5IGFuZHJvaWRTdG9jazogQm9vbGVhbjsgYHRydWVgIGZvciB0aGUgQW5kcm9pZCBzdG9jayBicm93c2VyIChpLmUuIG5vdCBDaHJvbWUpXHJcbiAgdmFyIGFuZHJvaWRTdG9jayA9IGFuZHJvaWQgJiYgdXNlckFnZW50Q29udGFpbnMoJ0dvb2dsZScpICYmIHdlYmtpdFZlciA8IDUzNyAmJiAhKCdBdWRpb05vZGUnIGluIHdpbmRvdyk7XHJcblxyXG4gIC8vIEBwcm9wZXJ0eSBvcGVyYTogQm9vbGVhbjsgYHRydWVgIGZvciB0aGUgT3BlcmEgYnJvd3NlclxyXG4gIHZhciBvcGVyYSA9ICEhd2luZG93Lm9wZXJhO1xyXG5cclxuICAvLyBAcHJvcGVydHkgY2hyb21lOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIHRoZSBDaHJvbWUgYnJvd3Nlci5cclxuICB2YXIgY2hyb21lID0gIWVkZ2UgJiYgdXNlckFnZW50Q29udGFpbnMoJ2Nocm9tZScpO1xyXG5cclxuICAvLyBAcHJvcGVydHkgZ2Vja286IEJvb2xlYW47IGB0cnVlYCBmb3IgZ2Vja28tYmFzZWQgYnJvd3NlcnMgbGlrZSBGaXJlZm94LlxyXG4gIHZhciBnZWNrbyA9IHVzZXJBZ2VudENvbnRhaW5zKCdnZWNrbycpICYmICF3ZWJraXQgJiYgIW9wZXJhICYmICFpZTtcclxuXHJcbiAgLy8gQHByb3BlcnR5IHNhZmFyaTogQm9vbGVhbjsgYHRydWVgIGZvciB0aGUgU2FmYXJpIGJyb3dzZXIuXHJcbiAgdmFyIHNhZmFyaSA9ICFjaHJvbWUgJiYgdXNlckFnZW50Q29udGFpbnMoJ3NhZmFyaScpO1xyXG5cclxuICB2YXIgcGhhbnRvbSA9IHVzZXJBZ2VudENvbnRhaW5zKCdwaGFudG9tJyk7XHJcblxyXG4gIC8vIEBwcm9wZXJ0eSBvcGVyYTEyOiBCb29sZWFuXHJcbiAgLy8gYHRydWVgIGZvciB0aGUgT3BlcmEgYnJvd3NlciBzdXBwb3J0aW5nIENTUyB0cmFuc2Zvcm1zICh2ZXJzaW9uIDEyIG9yIGxhdGVyKS5cclxuICB2YXIgb3BlcmExMiA9ICdPVHJhbnNpdGlvbicgaW4gc3R5bGUkMTtcclxuXHJcbiAgLy8gQHByb3BlcnR5IHdpbjogQm9vbGVhbjsgYHRydWVgIHdoZW4gdGhlIGJyb3dzZXIgaXMgcnVubmluZyBpbiBhIFdpbmRvd3MgcGxhdGZvcm1cclxuICB2YXIgd2luID0gbmF2aWdhdG9yLnBsYXRmb3JtLmluZGV4T2YoJ1dpbicpID09PSAwO1xyXG5cclxuICAvLyBAcHJvcGVydHkgaWUzZDogQm9vbGVhbjsgYHRydWVgIGZvciBhbGwgSW50ZXJuZXQgRXhwbG9yZXIgdmVyc2lvbnMgc3VwcG9ydGluZyBDU1MgdHJhbnNmb3Jtcy5cclxuICB2YXIgaWUzZCA9IGllICYmICgndHJhbnNpdGlvbicgaW4gc3R5bGUkMSk7XHJcblxyXG4gIC8vIEBwcm9wZXJ0eSB3ZWJraXQzZDogQm9vbGVhbjsgYHRydWVgIGZvciB3ZWJraXQtYmFzZWQgYnJvd3NlcnMgc3VwcG9ydGluZyBDU1MgdHJhbnNmb3Jtcy5cclxuICB2YXIgd2Via2l0M2QgPSAoJ1dlYktpdENTU01hdHJpeCcgaW4gd2luZG93KSAmJiAoJ20xMScgaW4gbmV3IHdpbmRvdy5XZWJLaXRDU1NNYXRyaXgoKSkgJiYgIWFuZHJvaWQyMztcclxuXHJcbiAgLy8gQHByb3BlcnR5IGdlY2tvM2Q6IEJvb2xlYW47IGB0cnVlYCBmb3IgZ2Vja28tYmFzZWQgYnJvd3NlcnMgc3VwcG9ydGluZyBDU1MgdHJhbnNmb3Jtcy5cclxuICB2YXIgZ2Vja28zZCA9ICdNb3pQZXJzcGVjdGl2ZScgaW4gc3R5bGUkMTtcclxuXHJcbiAgLy8gQHByb3BlcnR5IGFueTNkOiBCb29sZWFuXHJcbiAgLy8gYHRydWVgIGZvciBhbGwgYnJvd3NlcnMgc3VwcG9ydGluZyBDU1MgdHJhbnNmb3Jtcy5cclxuICB2YXIgYW55M2QgPSAhd2luZG93LkxfRElTQUJMRV8zRCAmJiAoaWUzZCB8fCB3ZWJraXQzZCB8fCBnZWNrbzNkKSAmJiAhb3BlcmExMiAmJiAhcGhhbnRvbTtcclxuXHJcbiAgLy8gQHByb3BlcnR5IG1vYmlsZTogQm9vbGVhbjsgYHRydWVgIGZvciBhbGwgYnJvd3NlcnMgcnVubmluZyBpbiBhIG1vYmlsZSBkZXZpY2UuXHJcbiAgdmFyIG1vYmlsZSA9IHR5cGVvZiBvcmllbnRhdGlvbiAhPT0gJ3VuZGVmaW5lZCcgfHwgdXNlckFnZW50Q29udGFpbnMoJ21vYmlsZScpO1xyXG5cclxuICAvLyBAcHJvcGVydHkgbW9iaWxlV2Via2l0OiBCb29sZWFuOyBgdHJ1ZWAgZm9yIGFsbCB3ZWJraXQtYmFzZWQgYnJvd3NlcnMgaW4gYSBtb2JpbGUgZGV2aWNlLlxyXG4gIHZhciBtb2JpbGVXZWJraXQgPSBtb2JpbGUgJiYgd2Via2l0O1xyXG5cclxuICAvLyBAcHJvcGVydHkgbW9iaWxlV2Via2l0M2Q6IEJvb2xlYW5cclxuICAvLyBgdHJ1ZWAgZm9yIGFsbCB3ZWJraXQtYmFzZWQgYnJvd3NlcnMgaW4gYSBtb2JpbGUgZGV2aWNlIHN1cHBvcnRpbmcgQ1NTIHRyYW5zZm9ybXMuXHJcbiAgdmFyIG1vYmlsZVdlYmtpdDNkID0gbW9iaWxlICYmIHdlYmtpdDNkO1xyXG5cclxuICAvLyBAcHJvcGVydHkgbXNQb2ludGVyOiBCb29sZWFuXHJcbiAgLy8gYHRydWVgIGZvciBicm93c2VycyBpbXBsZW1lbnRpbmcgdGhlIE1pY3Jvc29mdCB0b3VjaCBldmVudHMgbW9kZWwgKG5vdGFibHkgSUUxMCkuXHJcbiAgdmFyIG1zUG9pbnRlciA9ICF3aW5kb3cuUG9pbnRlckV2ZW50ICYmIHdpbmRvdy5NU1BvaW50ZXJFdmVudDtcclxuXHJcbiAgLy8gQHByb3BlcnR5IHBvaW50ZXI6IEJvb2xlYW5cclxuICAvLyBgdHJ1ZWAgZm9yIGFsbCBicm93c2VycyBzdXBwb3J0aW5nIFtwb2ludGVyIGV2ZW50c10oaHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9kbjQzMzI0NCUyOHY9dnMuODUlMjkuYXNweCkuXHJcbiAgdmFyIHBvaW50ZXIgPSAhISh3aW5kb3cuUG9pbnRlckV2ZW50IHx8IG1zUG9pbnRlcik7XHJcblxyXG4gIC8vIEBwcm9wZXJ0eSB0b3VjaDogQm9vbGVhblxyXG4gIC8vIGB0cnVlYCBmb3IgYWxsIGJyb3dzZXJzIHN1cHBvcnRpbmcgW3RvdWNoIGV2ZW50c10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL1RvdWNoX2V2ZW50cykuXHJcbiAgLy8gVGhpcyBkb2VzIG5vdCBuZWNlc3NhcmlseSBtZWFuIHRoYXQgdGhlIGJyb3dzZXIgaXMgcnVubmluZyBpbiBhIGNvbXB1dGVyIHdpdGhcclxuICAvLyBhIHRvdWNoc2NyZWVuLCBpdCBvbmx5IG1lYW5zIHRoYXQgdGhlIGJyb3dzZXIgaXMgY2FwYWJsZSBvZiB1bmRlcnN0YW5kaW5nXHJcbiAgLy8gdG91Y2ggZXZlbnRzLlxyXG4gIHZhciB0b3VjaCA9ICF3aW5kb3cuTF9OT19UT1VDSCAmJiAocG9pbnRlciB8fCAnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cgfHxcclxuICBcdFx0KHdpbmRvdy5Eb2N1bWVudFRvdWNoICYmIGRvY3VtZW50IGluc3RhbmNlb2Ygd2luZG93LkRvY3VtZW50VG91Y2gpKTtcclxuXHJcbiAgLy8gQHByb3BlcnR5IG1vYmlsZU9wZXJhOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIHRoZSBPcGVyYSBicm93c2VyIGluIGEgbW9iaWxlIGRldmljZS5cclxuICB2YXIgbW9iaWxlT3BlcmEgPSBtb2JpbGUgJiYgb3BlcmE7XHJcblxyXG4gIC8vIEBwcm9wZXJ0eSBtb2JpbGVHZWNrbzogQm9vbGVhblxyXG4gIC8vIGB0cnVlYCBmb3IgZ2Vja28tYmFzZWQgYnJvd3NlcnMgcnVubmluZyBpbiBhIG1vYmlsZSBkZXZpY2UuXHJcbiAgdmFyIG1vYmlsZUdlY2tvID0gbW9iaWxlICYmIGdlY2tvO1xyXG5cclxuICAvLyBAcHJvcGVydHkgcmV0aW5hOiBCb29sZWFuXHJcbiAgLy8gYHRydWVgIGZvciBicm93c2VycyBvbiBhIGhpZ2gtcmVzb2x1dGlvbiBcInJldGluYVwiIHNjcmVlbiBvciBvbiBhbnkgc2NyZWVuIHdoZW4gYnJvd3NlcidzIGRpc3BsYXkgem9vbSBpcyBtb3JlIHRoYW4gMTAwJS5cclxuICB2YXIgcmV0aW5hID0gKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8ICh3aW5kb3cuc2NyZWVuLmRldmljZVhEUEkgLyB3aW5kb3cuc2NyZWVuLmxvZ2ljYWxYRFBJKSkgPiAxO1xyXG5cclxuICAvLyBAcHJvcGVydHkgcGFzc2l2ZUV2ZW50czogQm9vbGVhblxyXG4gIC8vIGB0cnVlYCBmb3IgYnJvd3NlcnMgdGhhdCBzdXBwb3J0IHBhc3NpdmUgZXZlbnRzLlxyXG4gIHZhciBwYXNzaXZlRXZlbnRzID0gKGZ1bmN0aW9uICgpIHtcclxuICBcdHZhciBzdXBwb3J0c1Bhc3NpdmVPcHRpb24gPSBmYWxzZTtcclxuICBcdHRyeSB7XHJcbiAgXHRcdHZhciBvcHRzID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAncGFzc2l2ZScsIHtcclxuICBcdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBnZXR0ZXItcmV0dXJuXHJcbiAgXHRcdFx0XHRzdXBwb3J0c1Bhc3NpdmVPcHRpb24gPSB0cnVlO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0fSk7XHJcbiAgXHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0ZXN0UGFzc2l2ZUV2ZW50U3VwcG9ydCcsIGZhbHNlRm4sIG9wdHMpO1xyXG4gIFx0XHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndGVzdFBhc3NpdmVFdmVudFN1cHBvcnQnLCBmYWxzZUZuLCBvcHRzKTtcclxuICBcdH0gY2F0Y2ggKGUpIHtcclxuICBcdFx0Ly8gRXJyb3JzIGNhbiBzYWZlbHkgYmUgaWdub3JlZCBzaW5jZSB0aGlzIGlzIG9ubHkgYSBicm93c2VyIHN1cHBvcnQgdGVzdC5cclxuICBcdH1cclxuICBcdHJldHVybiBzdXBwb3J0c1Bhc3NpdmVPcHRpb247XHJcbiAgfSgpKTtcclxuXHJcbiAgLy8gQHByb3BlcnR5IGNhbnZhczogQm9vbGVhblxyXG4gIC8vIGB0cnVlYCB3aGVuIHRoZSBicm93c2VyIHN1cHBvcnRzIFtgPGNhbnZhcz5gXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvQ2FudmFzX0FQSSkuXHJcbiAgdmFyIGNhbnZhcyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgXHRyZXR1cm4gISFkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKS5nZXRDb250ZXh0O1xyXG4gIH0oKSk7XHJcblxyXG4gIC8vIEBwcm9wZXJ0eSBzdmc6IEJvb2xlYW5cclxuICAvLyBgdHJ1ZWAgd2hlbiB0aGUgYnJvd3NlciBzdXBwb3J0cyBbU1ZHXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9TVkcpLlxyXG4gIHZhciBzdmcgPSAhIShkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMgJiYgc3ZnQ3JlYXRlKCdzdmcnKS5jcmVhdGVTVkdSZWN0KTtcclxuXHJcbiAgLy8gQHByb3BlcnR5IHZtbDogQm9vbGVhblxyXG4gIC8vIGB0cnVlYCBpZiB0aGUgYnJvd3NlciBzdXBwb3J0cyBbVk1MXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9WZWN0b3JfTWFya3VwX0xhbmd1YWdlKS5cclxuICB2YXIgdm1sID0gIXN2ZyAmJiAoZnVuY3Rpb24gKCkge1xyXG4gIFx0dHJ5IHtcclxuICBcdFx0dmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gIFx0XHRkaXYuaW5uZXJIVE1MID0gJzx2OnNoYXBlIGFkaj1cIjFcIi8+JztcclxuXHJcbiAgXHRcdHZhciBzaGFwZSA9IGRpdi5maXJzdENoaWxkO1xyXG4gIFx0XHRzaGFwZS5zdHlsZS5iZWhhdmlvciA9ICd1cmwoI2RlZmF1bHQjVk1MKSc7XHJcblxyXG4gIFx0XHRyZXR1cm4gc2hhcGUgJiYgKHR5cGVvZiBzaGFwZS5hZGogPT09ICdvYmplY3QnKTtcclxuXHJcbiAgXHR9IGNhdGNoIChlKSB7XHJcbiAgXHRcdHJldHVybiBmYWxzZTtcclxuICBcdH1cclxuICB9KCkpO1xyXG5cclxuXHJcbiAgZnVuY3Rpb24gdXNlckFnZW50Q29udGFpbnMoc3RyKSB7XHJcbiAgXHRyZXR1cm4gbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLmluZGV4T2Yoc3RyKSA+PSAwO1xyXG4gIH1cblxuICB2YXIgQnJvd3NlciA9ICh7XG4gICAgaWU6IGllLFxuICAgIGllbHQ5OiBpZWx0OSxcbiAgICBlZGdlOiBlZGdlLFxuICAgIHdlYmtpdDogd2Via2l0LFxuICAgIGFuZHJvaWQ6IGFuZHJvaWQsXG4gICAgYW5kcm9pZDIzOiBhbmRyb2lkMjMsXG4gICAgYW5kcm9pZFN0b2NrOiBhbmRyb2lkU3RvY2ssXG4gICAgb3BlcmE6IG9wZXJhLFxuICAgIGNocm9tZTogY2hyb21lLFxuICAgIGdlY2tvOiBnZWNrbyxcbiAgICBzYWZhcmk6IHNhZmFyaSxcbiAgICBwaGFudG9tOiBwaGFudG9tLFxuICAgIG9wZXJhMTI6IG9wZXJhMTIsXG4gICAgd2luOiB3aW4sXG4gICAgaWUzZDogaWUzZCxcbiAgICB3ZWJraXQzZDogd2Via2l0M2QsXG4gICAgZ2Vja28zZDogZ2Vja28zZCxcbiAgICBhbnkzZDogYW55M2QsXG4gICAgbW9iaWxlOiBtb2JpbGUsXG4gICAgbW9iaWxlV2Via2l0OiBtb2JpbGVXZWJraXQsXG4gICAgbW9iaWxlV2Via2l0M2Q6IG1vYmlsZVdlYmtpdDNkLFxuICAgIG1zUG9pbnRlcjogbXNQb2ludGVyLFxuICAgIHBvaW50ZXI6IHBvaW50ZXIsXG4gICAgdG91Y2g6IHRvdWNoLFxuICAgIG1vYmlsZU9wZXJhOiBtb2JpbGVPcGVyYSxcbiAgICBtb2JpbGVHZWNrbzogbW9iaWxlR2Vja28sXG4gICAgcmV0aW5hOiByZXRpbmEsXG4gICAgcGFzc2l2ZUV2ZW50czogcGFzc2l2ZUV2ZW50cyxcbiAgICBjYW52YXM6IGNhbnZhcyxcbiAgICBzdmc6IHN2ZyxcbiAgICB2bWw6IHZtbFxuICB9KTtcblxuICAvKlxuICAgKiBFeHRlbmRzIEwuRG9tRXZlbnQgdG8gcHJvdmlkZSB0b3VjaCBzdXBwb3J0IGZvciBJbnRlcm5ldCBFeHBsb3JlciBhbmQgV2luZG93cy1iYXNlZCBkZXZpY2VzLlxuICAgKi9cblxuXG4gIHZhciBQT0lOVEVSX0RPV04gPSAgIG1zUG9pbnRlciA/ICdNU1BvaW50ZXJEb3duJyAgIDogJ3BvaW50ZXJkb3duJztcbiAgdmFyIFBPSU5URVJfTU9WRSA9ICAgbXNQb2ludGVyID8gJ01TUG9pbnRlck1vdmUnICAgOiAncG9pbnRlcm1vdmUnO1xuICB2YXIgUE9JTlRFUl9VUCA9ICAgICBtc1BvaW50ZXIgPyAnTVNQb2ludGVyVXAnICAgICA6ICdwb2ludGVydXAnO1xuICB2YXIgUE9JTlRFUl9DQU5DRUwgPSBtc1BvaW50ZXIgPyAnTVNQb2ludGVyQ2FuY2VsJyA6ICdwb2ludGVyY2FuY2VsJztcblxuICB2YXIgX3BvaW50ZXJzID0ge307XG4gIHZhciBfcG9pbnRlckRvY0xpc3RlbmVyID0gZmFsc2U7XG5cbiAgLy8gUHJvdmlkZXMgYSB0b3VjaCBldmVudHMgd3JhcHBlciBmb3IgKG1zKXBvaW50ZXIgZXZlbnRzLlxuICAvLyByZWYgaHR0cDovL3d3dy53My5vcmcvVFIvcG9pbnRlcmV2ZW50cy8gaHR0cHM6Ly93d3cudzMub3JnL0J1Z3MvUHVibGljL3Nob3dfYnVnLmNnaT9pZD0yMjg5MFxuXG4gIGZ1bmN0aW9uIGFkZFBvaW50ZXJMaXN0ZW5lcihvYmosIHR5cGUsIGhhbmRsZXIsIGlkKSB7XG4gIFx0aWYgKHR5cGUgPT09ICd0b3VjaHN0YXJ0Jykge1xuICBcdFx0X2FkZFBvaW50ZXJTdGFydChvYmosIGhhbmRsZXIsIGlkKTtcblxuICBcdH0gZWxzZSBpZiAodHlwZSA9PT0gJ3RvdWNobW92ZScpIHtcbiAgXHRcdF9hZGRQb2ludGVyTW92ZShvYmosIGhhbmRsZXIsIGlkKTtcblxuICBcdH0gZWxzZSBpZiAodHlwZSA9PT0gJ3RvdWNoZW5kJykge1xuICBcdFx0X2FkZFBvaW50ZXJFbmQob2JqLCBoYW5kbGVyLCBpZCk7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHRoaXM7XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVQb2ludGVyTGlzdGVuZXIob2JqLCB0eXBlLCBpZCkge1xuICBcdHZhciBoYW5kbGVyID0gb2JqWydfbGVhZmxldF8nICsgdHlwZSArIGlkXTtcblxuICBcdGlmICh0eXBlID09PSAndG91Y2hzdGFydCcpIHtcbiAgXHRcdG9iai5yZW1vdmVFdmVudExpc3RlbmVyKFBPSU5URVJfRE9XTiwgaGFuZGxlciwgZmFsc2UpO1xuXG4gIFx0fSBlbHNlIGlmICh0eXBlID09PSAndG91Y2htb3ZlJykge1xuICBcdFx0b2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIoUE9JTlRFUl9NT1ZFLCBoYW5kbGVyLCBmYWxzZSk7XG5cbiAgXHR9IGVsc2UgaWYgKHR5cGUgPT09ICd0b3VjaGVuZCcpIHtcbiAgXHRcdG9iai5yZW1vdmVFdmVudExpc3RlbmVyKFBPSU5URVJfVVAsIGhhbmRsZXIsIGZhbHNlKTtcbiAgXHRcdG9iai5yZW1vdmVFdmVudExpc3RlbmVyKFBPSU5URVJfQ0FOQ0VMLCBoYW5kbGVyLCBmYWxzZSk7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHRoaXM7XG4gIH1cblxuICBmdW5jdGlvbiBfYWRkUG9pbnRlclN0YXJ0KG9iaiwgaGFuZGxlciwgaWQpIHtcbiAgXHR2YXIgb25Eb3duID0gYmluZChmdW5jdGlvbiAoZSkge1xuICBcdFx0Ly8gSUUxMCBzcGVjaWZpYzogTXNUb3VjaCBuZWVkcyBwcmV2ZW50RGVmYXVsdC4gU2VlICMyMDAwXG4gIFx0XHRpZiAoZS5NU1BPSU5URVJfVFlQRV9UT1VDSCAmJiBlLnBvaW50ZXJUeXBlID09PSBlLk1TUE9JTlRFUl9UWVBFX1RPVUNIKSB7XG4gIFx0XHRcdHByZXZlbnREZWZhdWx0KGUpO1xuICBcdFx0fVxuXG4gIFx0XHRfaGFuZGxlUG9pbnRlcihlLCBoYW5kbGVyKTtcbiAgXHR9KTtcblxuICBcdG9ialsnX2xlYWZsZXRfdG91Y2hzdGFydCcgKyBpZF0gPSBvbkRvd247XG4gIFx0b2JqLmFkZEV2ZW50TGlzdGVuZXIoUE9JTlRFUl9ET1dOLCBvbkRvd24sIGZhbHNlKTtcblxuICBcdC8vIG5lZWQgdG8ga2VlcCB0cmFjayBvZiB3aGF0IHBvaW50ZXJzIGFuZCBob3cgbWFueSBhcmUgYWN0aXZlIHRvIHByb3ZpZGUgZS50b3VjaGVzIGVtdWxhdGlvblxuICBcdGlmICghX3BvaW50ZXJEb2NMaXN0ZW5lcikge1xuICBcdFx0Ly8gd2UgbGlzdGVuIGRvY3VtZW50IGFzIGFueSBkcmFncyB0aGF0IGVuZCBieSBtb3ZpbmcgdGhlIHRvdWNoIG9mZiB0aGUgc2NyZWVuIGdldCBmaXJlZCB0aGVyZVxuICBcdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihQT0lOVEVSX0RPV04sIF9nbG9iYWxQb2ludGVyRG93biwgdHJ1ZSk7XG4gIFx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFBPSU5URVJfTU9WRSwgX2dsb2JhbFBvaW50ZXJNb3ZlLCB0cnVlKTtcbiAgXHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoUE9JTlRFUl9VUCwgX2dsb2JhbFBvaW50ZXJVcCwgdHJ1ZSk7XG4gIFx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFBPSU5URVJfQ0FOQ0VMLCBfZ2xvYmFsUG9pbnRlclVwLCB0cnVlKTtcblxuICBcdFx0X3BvaW50ZXJEb2NMaXN0ZW5lciA9IHRydWU7XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gX2dsb2JhbFBvaW50ZXJEb3duKGUpIHtcbiAgXHRfcG9pbnRlcnNbZS5wb2ludGVySWRdID0gZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9nbG9iYWxQb2ludGVyTW92ZShlKSB7XG4gIFx0aWYgKF9wb2ludGVyc1tlLnBvaW50ZXJJZF0pIHtcbiAgXHRcdF9wb2ludGVyc1tlLnBvaW50ZXJJZF0gPSBlO1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9nbG9iYWxQb2ludGVyVXAoZSkge1xuICBcdGRlbGV0ZSBfcG9pbnRlcnNbZS5wb2ludGVySWRdO1xuICB9XG5cbiAgZnVuY3Rpb24gX2hhbmRsZVBvaW50ZXIoZSwgaGFuZGxlcikge1xuICBcdGUudG91Y2hlcyA9IFtdO1xuICBcdGZvciAodmFyIGkgaW4gX3BvaW50ZXJzKSB7XG4gIFx0XHRlLnRvdWNoZXMucHVzaChfcG9pbnRlcnNbaV0pO1xuICBcdH1cbiAgXHRlLmNoYW5nZWRUb3VjaGVzID0gW2VdO1xuXG4gIFx0aGFuZGxlcihlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9hZGRQb2ludGVyTW92ZShvYmosIGhhbmRsZXIsIGlkKSB7XG4gIFx0dmFyIG9uTW92ZSA9IGZ1bmN0aW9uIChlKSB7XG4gIFx0XHQvLyBkb24ndCBmaXJlIHRvdWNoIG1vdmVzIHdoZW4gbW91c2UgaXNuJ3QgZG93blxuICBcdFx0aWYgKChlLnBvaW50ZXJUeXBlID09PSAoZS5NU1BPSU5URVJfVFlQRV9NT1VTRSB8fCAnbW91c2UnKSkgJiYgZS5idXR0b25zID09PSAwKSB7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0X2hhbmRsZVBvaW50ZXIoZSwgaGFuZGxlcik7XG4gIFx0fTtcblxuICBcdG9ialsnX2xlYWZsZXRfdG91Y2htb3ZlJyArIGlkXSA9IG9uTW92ZTtcbiAgXHRvYmouYWRkRXZlbnRMaXN0ZW5lcihQT0lOVEVSX01PVkUsIG9uTW92ZSwgZmFsc2UpO1xuICB9XG5cbiAgZnVuY3Rpb24gX2FkZFBvaW50ZXJFbmQob2JqLCBoYW5kbGVyLCBpZCkge1xuICBcdHZhciBvblVwID0gZnVuY3Rpb24gKGUpIHtcbiAgXHRcdF9oYW5kbGVQb2ludGVyKGUsIGhhbmRsZXIpO1xuICBcdH07XG5cbiAgXHRvYmpbJ19sZWFmbGV0X3RvdWNoZW5kJyArIGlkXSA9IG9uVXA7XG4gIFx0b2JqLmFkZEV2ZW50TGlzdGVuZXIoUE9JTlRFUl9VUCwgb25VcCwgZmFsc2UpO1xuICBcdG9iai5hZGRFdmVudExpc3RlbmVyKFBPSU5URVJfQ0FOQ0VMLCBvblVwLCBmYWxzZSk7XG4gIH1cblxuICAvKlxyXG4gICAqIEV4dGVuZHMgdGhlIGV2ZW50IGhhbmRsaW5nIGNvZGUgd2l0aCBkb3VibGUgdGFwIHN1cHBvcnQgZm9yIG1vYmlsZSBicm93c2Vycy5cclxuICAgKi9cclxuXHJcbiAgdmFyIF90b3VjaHN0YXJ0ID0gbXNQb2ludGVyID8gJ01TUG9pbnRlckRvd24nIDogcG9pbnRlciA/ICdwb2ludGVyZG93bicgOiAndG91Y2hzdGFydCc7XHJcbiAgdmFyIF90b3VjaGVuZCA9IG1zUG9pbnRlciA/ICdNU1BvaW50ZXJVcCcgOiBwb2ludGVyID8gJ3BvaW50ZXJ1cCcgOiAndG91Y2hlbmQnO1xyXG4gIHZhciBfcHJlID0gJ19sZWFmbGV0Xyc7XHJcblxyXG4gIC8vIGluc3BpcmVkIGJ5IFplcHRvIHRvdWNoIGNvZGUgYnkgVGhvbWFzIEZ1Y2hzXHJcbiAgZnVuY3Rpb24gYWRkRG91YmxlVGFwTGlzdGVuZXIob2JqLCBoYW5kbGVyLCBpZCkge1xyXG4gIFx0dmFyIGxhc3QsIHRvdWNoJCQxLFxyXG4gIFx0ICAgIGRvdWJsZVRhcCA9IGZhbHNlLFxyXG4gIFx0ICAgIGRlbGF5ID0gMjUwO1xyXG5cclxuICBcdGZ1bmN0aW9uIG9uVG91Y2hTdGFydChlKSB7XHJcblxyXG4gIFx0XHRpZiAocG9pbnRlcikge1xyXG4gIFx0XHRcdGlmICghZS5pc1ByaW1hcnkpIHsgcmV0dXJuOyB9XHJcbiAgXHRcdFx0aWYgKGUucG9pbnRlclR5cGUgPT09ICdtb3VzZScpIHsgcmV0dXJuOyB9IC8vIG1vdXNlIGZpcmVzIG5hdGl2ZSBkYmxjbGlja1xyXG4gIFx0XHR9IGVsc2UgaWYgKGUudG91Y2hlcy5sZW5ndGggPiAxKSB7XHJcbiAgXHRcdFx0cmV0dXJuO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR2YXIgbm93ID0gRGF0ZS5ub3coKSxcclxuICBcdFx0ICAgIGRlbHRhID0gbm93IC0gKGxhc3QgfHwgbm93KTtcclxuXHJcbiAgXHRcdHRvdWNoJCQxID0gZS50b3VjaGVzID8gZS50b3VjaGVzWzBdIDogZTtcclxuICBcdFx0ZG91YmxlVGFwID0gKGRlbHRhID4gMCAmJiBkZWx0YSA8PSBkZWxheSk7XHJcbiAgXHRcdGxhc3QgPSBub3c7XHJcbiAgXHR9XHJcblxyXG4gIFx0ZnVuY3Rpb24gb25Ub3VjaEVuZChlKSB7XHJcbiAgXHRcdGlmIChkb3VibGVUYXAgJiYgIXRvdWNoJCQxLmNhbmNlbEJ1YmJsZSkge1xyXG4gIFx0XHRcdGlmIChwb2ludGVyKSB7XHJcbiAgXHRcdFx0XHRpZiAoZS5wb2ludGVyVHlwZSA9PT0gJ21vdXNlJykgeyByZXR1cm47IH1cclxuICBcdFx0XHRcdC8vIHdvcmsgYXJvdW5kIC50eXBlIGJlaW5nIHJlYWRvbmx5IHdpdGggTVNQb2ludGVyKiBldmVudHNcclxuICBcdFx0XHRcdHZhciBuZXdUb3VjaCA9IHt9LFxyXG4gIFx0XHRcdFx0ICAgIHByb3AsIGk7XHJcblxyXG4gIFx0XHRcdFx0Zm9yIChpIGluIHRvdWNoJCQxKSB7XHJcbiAgXHRcdFx0XHRcdHByb3AgPSB0b3VjaCQkMVtpXTtcclxuICBcdFx0XHRcdFx0bmV3VG91Y2hbaV0gPSBwcm9wICYmIHByb3AuYmluZCA/IHByb3AuYmluZCh0b3VjaCQkMSkgOiBwcm9wO1xyXG4gIFx0XHRcdFx0fVxyXG4gIFx0XHRcdFx0dG91Y2gkJDEgPSBuZXdUb3VjaDtcclxuICBcdFx0XHR9XHJcbiAgXHRcdFx0dG91Y2gkJDEudHlwZSA9ICdkYmxjbGljayc7XHJcbiAgXHRcdFx0dG91Y2gkJDEuYnV0dG9uID0gMDtcclxuICBcdFx0XHRoYW5kbGVyKHRvdWNoJCQxKTtcclxuICBcdFx0XHRsYXN0ID0gbnVsbDtcclxuICBcdFx0fVxyXG4gIFx0fVxyXG5cclxuICBcdG9ialtfcHJlICsgX3RvdWNoc3RhcnQgKyBpZF0gPSBvblRvdWNoU3RhcnQ7XHJcbiAgXHRvYmpbX3ByZSArIF90b3VjaGVuZCArIGlkXSA9IG9uVG91Y2hFbmQ7XHJcbiAgXHRvYmpbX3ByZSArICdkYmxjbGljaycgKyBpZF0gPSBoYW5kbGVyO1xyXG5cclxuICBcdG9iai5hZGRFdmVudExpc3RlbmVyKF90b3VjaHN0YXJ0LCBvblRvdWNoU3RhcnQsIHBhc3NpdmVFdmVudHMgPyB7cGFzc2l2ZTogZmFsc2V9IDogZmFsc2UpO1xyXG4gIFx0b2JqLmFkZEV2ZW50TGlzdGVuZXIoX3RvdWNoZW5kLCBvblRvdWNoRW5kLCBwYXNzaXZlRXZlbnRzID8ge3Bhc3NpdmU6IGZhbHNlfSA6IGZhbHNlKTtcclxuXHJcbiAgXHQvLyBPbiBzb21lIHBsYXRmb3JtcyAobm90YWJseSwgY2hyb21lPDU1IG9uIHdpbjEwICsgdG91Y2hzY3JlZW4gKyBtb3VzZSksXHJcbiAgXHQvLyB0aGUgYnJvd3NlciBkb2Vzbid0IGZpcmUgdG91Y2hlbmQvcG9pbnRlcnVwIGV2ZW50cyBidXQgZG9lcyBmaXJlXHJcbiAgXHQvLyBuYXRpdmUgZGJsY2xpY2tzLiBTZWUgIzQxMjcuXHJcbiAgXHQvLyBFZGdlIDE0IGFsc28gZmlyZXMgbmF0aXZlIGRibGNsaWNrcywgYnV0IG9ubHkgZm9yIHBvaW50ZXJUeXBlIG1vdXNlLCBzZWUgIzUxODAuXHJcbiAgXHRvYmouYWRkRXZlbnRMaXN0ZW5lcignZGJsY2xpY2snLCBoYW5kbGVyLCBmYWxzZSk7XHJcblxyXG4gIFx0cmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiByZW1vdmVEb3VibGVUYXBMaXN0ZW5lcihvYmosIGlkKSB7XHJcbiAgXHR2YXIgdG91Y2hzdGFydCA9IG9ialtfcHJlICsgX3RvdWNoc3RhcnQgKyBpZF0sXHJcbiAgXHQgICAgdG91Y2hlbmQgPSBvYmpbX3ByZSArIF90b3VjaGVuZCArIGlkXSxcclxuICBcdCAgICBkYmxjbGljayA9IG9ialtfcHJlICsgJ2RibGNsaWNrJyArIGlkXTtcclxuXHJcbiAgXHRvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcihfdG91Y2hzdGFydCwgdG91Y2hzdGFydCwgcGFzc2l2ZUV2ZW50cyA/IHtwYXNzaXZlOiBmYWxzZX0gOiBmYWxzZSk7XHJcbiAgXHRvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcihfdG91Y2hlbmQsIHRvdWNoZW5kLCBwYXNzaXZlRXZlbnRzID8ge3Bhc3NpdmU6IGZhbHNlfSA6IGZhbHNlKTtcclxuICBcdG9iai5yZW1vdmVFdmVudExpc3RlbmVyKCdkYmxjbGljaycsIGRibGNsaWNrLCBmYWxzZSk7XHJcblxyXG4gIFx0cmV0dXJuIHRoaXM7XHJcbiAgfVxuXG4gIC8qXHJcbiAgICogQG5hbWVzcGFjZSBEb21VdGlsXHJcbiAgICpcclxuICAgKiBVdGlsaXR5IGZ1bmN0aW9ucyB0byB3b3JrIHdpdGggdGhlIFtET01dKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9Eb2N1bWVudF9PYmplY3RfTW9kZWwpXHJcbiAgICogdHJlZSwgdXNlZCBieSBMZWFmbGV0IGludGVybmFsbHkuXHJcbiAgICpcclxuICAgKiBNb3N0IGZ1bmN0aW9ucyBleHBlY3Rpbmcgb3IgcmV0dXJuaW5nIGEgYEhUTUxFbGVtZW50YCBhbHNvIHdvcmsgZm9yXHJcbiAgICogU1ZHIGVsZW1lbnRzLiBUaGUgb25seSBkaWZmZXJlbmNlIGlzIHRoYXQgY2xhc3NlcyByZWZlciB0byBDU1MgY2xhc3Nlc1xyXG4gICAqIGluIEhUTUwgYW5kIFNWRyBjbGFzc2VzIGluIFNWRy5cclxuICAgKi9cclxuXHJcblxyXG4gIC8vIEBwcm9wZXJ0eSBUUkFOU0ZPUk06IFN0cmluZ1xyXG4gIC8vIFZlbmRvci1wcmVmaXhlZCB0cmFuc2Zvcm0gc3R5bGUgbmFtZSAoZS5nLiBgJ3dlYmtpdFRyYW5zZm9ybSdgIGZvciBXZWJLaXQpLlxyXG4gIHZhciBUUkFOU0ZPUk0gPSB0ZXN0UHJvcChcclxuICBcdFsndHJhbnNmb3JtJywgJ3dlYmtpdFRyYW5zZm9ybScsICdPVHJhbnNmb3JtJywgJ01velRyYW5zZm9ybScsICdtc1RyYW5zZm9ybSddKTtcclxuXHJcbiAgLy8gd2Via2l0VHJhbnNpdGlvbiBjb21lcyBmaXJzdCBiZWNhdXNlIHNvbWUgYnJvd3NlciB2ZXJzaW9ucyB0aGF0IGRyb3AgdmVuZG9yIHByZWZpeCBkb24ndCBkb1xyXG4gIC8vIHRoZSBzYW1lIGZvciB0aGUgdHJhbnNpdGlvbmVuZCBldmVudCwgaW4gcGFydGljdWxhciB0aGUgQW5kcm9pZCA0LjEgc3RvY2sgYnJvd3NlclxyXG5cclxuICAvLyBAcHJvcGVydHkgVFJBTlNJVElPTjogU3RyaW5nXHJcbiAgLy8gVmVuZG9yLXByZWZpeGVkIHRyYW5zaXRpb24gc3R5bGUgbmFtZS5cclxuICB2YXIgVFJBTlNJVElPTiA9IHRlc3RQcm9wKFxyXG4gIFx0Wyd3ZWJraXRUcmFuc2l0aW9uJywgJ3RyYW5zaXRpb24nLCAnT1RyYW5zaXRpb24nLCAnTW96VHJhbnNpdGlvbicsICdtc1RyYW5zaXRpb24nXSk7XHJcblxyXG4gIC8vIEBwcm9wZXJ0eSBUUkFOU0lUSU9OX0VORDogU3RyaW5nXHJcbiAgLy8gVmVuZG9yLXByZWZpeGVkIHRyYW5zaXRpb25lbmQgZXZlbnQgbmFtZS5cclxuICB2YXIgVFJBTlNJVElPTl9FTkQgPVxyXG4gIFx0VFJBTlNJVElPTiA9PT0gJ3dlYmtpdFRyYW5zaXRpb24nIHx8IFRSQU5TSVRJT04gPT09ICdPVHJhbnNpdGlvbicgPyBUUkFOU0lUSU9OICsgJ0VuZCcgOiAndHJhbnNpdGlvbmVuZCc7XHJcblxyXG5cclxuICAvLyBAZnVuY3Rpb24gZ2V0KGlkOiBTdHJpbmd8SFRNTEVsZW1lbnQpOiBIVE1MRWxlbWVudFxyXG4gIC8vIFJldHVybnMgYW4gZWxlbWVudCBnaXZlbiBpdHMgRE9NIGlkLCBvciByZXR1cm5zIHRoZSBlbGVtZW50IGl0c2VsZlxyXG4gIC8vIGlmIGl0IHdhcyBwYXNzZWQgZGlyZWN0bHkuXHJcbiAgZnVuY3Rpb24gZ2V0KGlkKSB7XHJcbiAgXHRyZXR1cm4gdHlwZW9mIGlkID09PSAnc3RyaW5nJyA/IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKSA6IGlkO1xyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGdldFN0eWxlKGVsOiBIVE1MRWxlbWVudCwgc3R5bGVBdHRyaWI6IFN0cmluZyk6IFN0cmluZ1xyXG4gIC8vIFJldHVybnMgdGhlIHZhbHVlIGZvciBhIGNlcnRhaW4gc3R5bGUgYXR0cmlidXRlIG9uIGFuIGVsZW1lbnQsXHJcbiAgLy8gaW5jbHVkaW5nIGNvbXB1dGVkIHZhbHVlcyBvciB2YWx1ZXMgc2V0IHRocm91Z2ggQ1NTLlxyXG4gIGZ1bmN0aW9uIGdldFN0eWxlKGVsLCBzdHlsZSkge1xyXG4gIFx0dmFyIHZhbHVlID0gZWwuc3R5bGVbc3R5bGVdIHx8IChlbC5jdXJyZW50U3R5bGUgJiYgZWwuY3VycmVudFN0eWxlW3N0eWxlXSk7XHJcblxyXG4gIFx0aWYgKCghdmFsdWUgfHwgdmFsdWUgPT09ICdhdXRvJykgJiYgZG9jdW1lbnQuZGVmYXVsdFZpZXcpIHtcclxuICBcdFx0dmFyIGNzcyA9IGRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUoZWwsIG51bGwpO1xyXG4gIFx0XHR2YWx1ZSA9IGNzcyA/IGNzc1tzdHlsZV0gOiBudWxsO1xyXG4gIFx0fVxyXG4gIFx0cmV0dXJuIHZhbHVlID09PSAnYXV0bycgPyBudWxsIDogdmFsdWU7XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gY3JlYXRlKHRhZ05hbWU6IFN0cmluZywgY2xhc3NOYW1lPzogU3RyaW5nLCBjb250YWluZXI/OiBIVE1MRWxlbWVudCk6IEhUTUxFbGVtZW50XHJcbiAgLy8gQ3JlYXRlcyBhbiBIVE1MIGVsZW1lbnQgd2l0aCBgdGFnTmFtZWAsIHNldHMgaXRzIGNsYXNzIHRvIGBjbGFzc05hbWVgLCBhbmQgb3B0aW9uYWxseSBhcHBlbmRzIGl0IHRvIGBjb250YWluZXJgIGVsZW1lbnQuXHJcbiAgZnVuY3Rpb24gY3JlYXRlJDEodGFnTmFtZSwgY2xhc3NOYW1lLCBjb250YWluZXIpIHtcclxuICBcdHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7XHJcbiAgXHRlbC5jbGFzc05hbWUgPSBjbGFzc05hbWUgfHwgJyc7XHJcblxyXG4gIFx0aWYgKGNvbnRhaW5lcikge1xyXG4gIFx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQoZWwpO1xyXG4gIFx0fVxyXG4gIFx0cmV0dXJuIGVsO1xyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIHJlbW92ZShlbDogSFRNTEVsZW1lbnQpXHJcbiAgLy8gUmVtb3ZlcyBgZWxgIGZyb20gaXRzIHBhcmVudCBlbGVtZW50XHJcbiAgZnVuY3Rpb24gcmVtb3ZlKGVsKSB7XHJcbiAgXHR2YXIgcGFyZW50ID0gZWwucGFyZW50Tm9kZTtcclxuICBcdGlmIChwYXJlbnQpIHtcclxuICBcdFx0cGFyZW50LnJlbW92ZUNoaWxkKGVsKTtcclxuICBcdH1cclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBlbXB0eShlbDogSFRNTEVsZW1lbnQpXHJcbiAgLy8gUmVtb3ZlcyBhbGwgb2YgYGVsYCdzIGNoaWxkcmVuIGVsZW1lbnRzIGZyb20gYGVsYFxyXG4gIGZ1bmN0aW9uIGVtcHR5KGVsKSB7XHJcbiAgXHR3aGlsZSAoZWwuZmlyc3RDaGlsZCkge1xyXG4gIFx0XHRlbC5yZW1vdmVDaGlsZChlbC5maXJzdENoaWxkKTtcclxuICBcdH1cclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiB0b0Zyb250KGVsOiBIVE1MRWxlbWVudClcclxuICAvLyBNYWtlcyBgZWxgIHRoZSBsYXN0IGNoaWxkIG9mIGl0cyBwYXJlbnQsIHNvIGl0IHJlbmRlcnMgaW4gZnJvbnQgb2YgdGhlIG90aGVyIGNoaWxkcmVuLlxyXG4gIGZ1bmN0aW9uIHRvRnJvbnQoZWwpIHtcclxuICBcdHZhciBwYXJlbnQgPSBlbC5wYXJlbnROb2RlO1xyXG4gIFx0aWYgKHBhcmVudCAmJiBwYXJlbnQubGFzdENoaWxkICE9PSBlbCkge1xyXG4gIFx0XHRwYXJlbnQuYXBwZW5kQ2hpbGQoZWwpO1xyXG4gIFx0fVxyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIHRvQmFjayhlbDogSFRNTEVsZW1lbnQpXHJcbiAgLy8gTWFrZXMgYGVsYCB0aGUgZmlyc3QgY2hpbGQgb2YgaXRzIHBhcmVudCwgc28gaXQgcmVuZGVycyBiZWhpbmQgdGhlIG90aGVyIGNoaWxkcmVuLlxyXG4gIGZ1bmN0aW9uIHRvQmFjayhlbCkge1xyXG4gIFx0dmFyIHBhcmVudCA9IGVsLnBhcmVudE5vZGU7XHJcbiAgXHRpZiAocGFyZW50ICYmIHBhcmVudC5maXJzdENoaWxkICE9PSBlbCkge1xyXG4gIFx0XHRwYXJlbnQuaW5zZXJ0QmVmb3JlKGVsLCBwYXJlbnQuZmlyc3RDaGlsZCk7XHJcbiAgXHR9XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gaGFzQ2xhc3MoZWw6IEhUTUxFbGVtZW50LCBuYW1lOiBTdHJpbmcpOiBCb29sZWFuXHJcbiAgLy8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVsZW1lbnQncyBjbGFzcyBhdHRyaWJ1dGUgY29udGFpbnMgYG5hbWVgLlxyXG4gIGZ1bmN0aW9uIGhhc0NsYXNzKGVsLCBuYW1lKSB7XHJcbiAgXHRpZiAoZWwuY2xhc3NMaXN0ICE9PSB1bmRlZmluZWQpIHtcclxuICBcdFx0cmV0dXJuIGVsLmNsYXNzTGlzdC5jb250YWlucyhuYW1lKTtcclxuICBcdH1cclxuICBcdHZhciBjbGFzc05hbWUgPSBnZXRDbGFzcyhlbCk7XHJcbiAgXHRyZXR1cm4gY2xhc3NOYW1lLmxlbmd0aCA+IDAgJiYgbmV3IFJlZ0V4cCgnKF58XFxcXHMpJyArIG5hbWUgKyAnKFxcXFxzfCQpJykudGVzdChjbGFzc05hbWUpO1xyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGFkZENsYXNzKGVsOiBIVE1MRWxlbWVudCwgbmFtZTogU3RyaW5nKVxyXG4gIC8vIEFkZHMgYG5hbWVgIHRvIHRoZSBlbGVtZW50J3MgY2xhc3MgYXR0cmlidXRlLlxyXG4gIGZ1bmN0aW9uIGFkZENsYXNzKGVsLCBuYW1lKSB7XHJcbiAgXHRpZiAoZWwuY2xhc3NMaXN0ICE9PSB1bmRlZmluZWQpIHtcclxuICBcdFx0dmFyIGNsYXNzZXMgPSBzcGxpdFdvcmRzKG5hbWUpO1xyXG4gIFx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gY2xhc3Nlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gIFx0XHRcdGVsLmNsYXNzTGlzdC5hZGQoY2xhc3Nlc1tpXSk7XHJcbiAgXHRcdH1cclxuICBcdH0gZWxzZSBpZiAoIWhhc0NsYXNzKGVsLCBuYW1lKSkge1xyXG4gIFx0XHR2YXIgY2xhc3NOYW1lID0gZ2V0Q2xhc3MoZWwpO1xyXG4gIFx0XHRzZXRDbGFzcyhlbCwgKGNsYXNzTmFtZSA/IGNsYXNzTmFtZSArICcgJyA6ICcnKSArIG5hbWUpO1xyXG4gIFx0fVxyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIHJlbW92ZUNsYXNzKGVsOiBIVE1MRWxlbWVudCwgbmFtZTogU3RyaW5nKVxyXG4gIC8vIFJlbW92ZXMgYG5hbWVgIGZyb20gdGhlIGVsZW1lbnQncyBjbGFzcyBhdHRyaWJ1dGUuXHJcbiAgZnVuY3Rpb24gcmVtb3ZlQ2xhc3MoZWwsIG5hbWUpIHtcclxuICBcdGlmIChlbC5jbGFzc0xpc3QgIT09IHVuZGVmaW5lZCkge1xyXG4gIFx0XHRlbC5jbGFzc0xpc3QucmVtb3ZlKG5hbWUpO1xyXG4gIFx0fSBlbHNlIHtcclxuICBcdFx0c2V0Q2xhc3MoZWwsIHRyaW0oKCcgJyArIGdldENsYXNzKGVsKSArICcgJykucmVwbGFjZSgnICcgKyBuYW1lICsgJyAnLCAnICcpKSk7XHJcbiAgXHR9XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gc2V0Q2xhc3MoZWw6IEhUTUxFbGVtZW50LCBuYW1lOiBTdHJpbmcpXHJcbiAgLy8gU2V0cyB0aGUgZWxlbWVudCdzIGNsYXNzLlxyXG4gIGZ1bmN0aW9uIHNldENsYXNzKGVsLCBuYW1lKSB7XHJcbiAgXHRpZiAoZWwuY2xhc3NOYW1lLmJhc2VWYWwgPT09IHVuZGVmaW5lZCkge1xyXG4gIFx0XHRlbC5jbGFzc05hbWUgPSBuYW1lO1xyXG4gIFx0fSBlbHNlIHtcclxuICBcdFx0Ly8gaW4gY2FzZSBvZiBTVkcgZWxlbWVudFxyXG4gIFx0XHRlbC5jbGFzc05hbWUuYmFzZVZhbCA9IG5hbWU7XHJcbiAgXHR9XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gZ2V0Q2xhc3MoZWw6IEhUTUxFbGVtZW50KTogU3RyaW5nXHJcbiAgLy8gUmV0dXJucyB0aGUgZWxlbWVudCdzIGNsYXNzLlxyXG4gIGZ1bmN0aW9uIGdldENsYXNzKGVsKSB7XHJcbiAgXHQvLyBDaGVjayBpZiB0aGUgZWxlbWVudCBpcyBhbiBTVkdFbGVtZW50SW5zdGFuY2UgYW5kIHVzZSB0aGUgY29ycmVzcG9uZGluZ0VsZW1lbnQgaW5zdGVhZFxyXG4gIFx0Ly8gKFJlcXVpcmVkIGZvciBsaW5rZWQgU1ZHIGVsZW1lbnRzIGluIElFMTEuKVxyXG4gIFx0aWYgKGVsLmNvcnJlc3BvbmRpbmdFbGVtZW50KSB7XHJcbiAgXHRcdGVsID0gZWwuY29ycmVzcG9uZGluZ0VsZW1lbnQ7XHJcbiAgXHR9XHJcbiAgXHRyZXR1cm4gZWwuY2xhc3NOYW1lLmJhc2VWYWwgPT09IHVuZGVmaW5lZCA/IGVsLmNsYXNzTmFtZSA6IGVsLmNsYXNzTmFtZS5iYXNlVmFsO1xyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIHNldE9wYWNpdHkoZWw6IEhUTUxFbGVtZW50LCBvcGFjaXR5OiBOdW1iZXIpXHJcbiAgLy8gU2V0IHRoZSBvcGFjaXR5IG9mIGFuIGVsZW1lbnQgKGluY2x1ZGluZyBvbGQgSUUgc3VwcG9ydCkuXHJcbiAgLy8gYG9wYWNpdHlgIG11c3QgYmUgYSBudW1iZXIgZnJvbSBgMGAgdG8gYDFgLlxyXG4gIGZ1bmN0aW9uIHNldE9wYWNpdHkoZWwsIHZhbHVlKSB7XHJcbiAgXHRpZiAoJ29wYWNpdHknIGluIGVsLnN0eWxlKSB7XHJcbiAgXHRcdGVsLnN0eWxlLm9wYWNpdHkgPSB2YWx1ZTtcclxuICBcdH0gZWxzZSBpZiAoJ2ZpbHRlcicgaW4gZWwuc3R5bGUpIHtcclxuICBcdFx0X3NldE9wYWNpdHlJRShlbCwgdmFsdWUpO1xyXG4gIFx0fVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gX3NldE9wYWNpdHlJRShlbCwgdmFsdWUpIHtcclxuICBcdHZhciBmaWx0ZXIgPSBmYWxzZSxcclxuICBcdCAgICBmaWx0ZXJOYW1lID0gJ0RYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0LkFscGhhJztcclxuXHJcbiAgXHQvLyBmaWx0ZXJzIGNvbGxlY3Rpb24gdGhyb3dzIGFuIGVycm9yIGlmIHdlIHRyeSB0byByZXRyaWV2ZSBhIGZpbHRlciB0aGF0IGRvZXNuJ3QgZXhpc3RcclxuICBcdHRyeSB7XHJcbiAgXHRcdGZpbHRlciA9IGVsLmZpbHRlcnMuaXRlbShmaWx0ZXJOYW1lKTtcclxuICBcdH0gY2F0Y2ggKGUpIHtcclxuICBcdFx0Ly8gZG9uJ3Qgc2V0IG9wYWNpdHkgdG8gMSBpZiB3ZSBoYXZlbid0IGFscmVhZHkgc2V0IGFuIG9wYWNpdHksXHJcbiAgXHRcdC8vIGl0IGlzbid0IG5lZWRlZCBhbmQgYnJlYWtzIHRyYW5zcGFyZW50IHBuZ3MuXHJcbiAgXHRcdGlmICh2YWx1ZSA9PT0gMSkgeyByZXR1cm47IH1cclxuICBcdH1cclxuXHJcbiAgXHR2YWx1ZSA9IE1hdGgucm91bmQodmFsdWUgKiAxMDApO1xyXG5cclxuICBcdGlmIChmaWx0ZXIpIHtcclxuICBcdFx0ZmlsdGVyLkVuYWJsZWQgPSAodmFsdWUgIT09IDEwMCk7XHJcbiAgXHRcdGZpbHRlci5PcGFjaXR5ID0gdmFsdWU7XHJcbiAgXHR9IGVsc2Uge1xyXG4gIFx0XHRlbC5zdHlsZS5maWx0ZXIgKz0gJyBwcm9naWQ6JyArIGZpbHRlck5hbWUgKyAnKG9wYWNpdHk9JyArIHZhbHVlICsgJyknO1xyXG4gIFx0fVxyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIHRlc3RQcm9wKHByb3BzOiBTdHJpbmdbXSk6IFN0cmluZ3xmYWxzZVxyXG4gIC8vIEdvZXMgdGhyb3VnaCB0aGUgYXJyYXkgb2Ygc3R5bGUgbmFtZXMgYW5kIHJldHVybnMgdGhlIGZpcnN0IG5hbWVcclxuICAvLyB0aGF0IGlzIGEgdmFsaWQgc3R5bGUgbmFtZSBmb3IgYW4gZWxlbWVudC4gSWYgbm8gc3VjaCBuYW1lIGlzIGZvdW5kLFxyXG4gIC8vIGl0IHJldHVybnMgZmFsc2UuIFVzZWZ1bCBmb3IgdmVuZG9yLXByZWZpeGVkIHN0eWxlcyBsaWtlIGB0cmFuc2Zvcm1gLlxyXG4gIGZ1bmN0aW9uIHRlc3RQcm9wKHByb3BzKSB7XHJcbiAgXHR2YXIgc3R5bGUgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGU7XHJcblxyXG4gIFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xyXG4gIFx0XHRpZiAocHJvcHNbaV0gaW4gc3R5bGUpIHtcclxuICBcdFx0XHRyZXR1cm4gcHJvcHNbaV07XHJcbiAgXHRcdH1cclxuICBcdH1cclxuICBcdHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBzZXRUcmFuc2Zvcm0oZWw6IEhUTUxFbGVtZW50LCBvZmZzZXQ6IFBvaW50LCBzY2FsZT86IE51bWJlcilcclxuICAvLyBSZXNldHMgdGhlIDNEIENTUyB0cmFuc2Zvcm0gb2YgYGVsYCBzbyBpdCBpcyB0cmFuc2xhdGVkIGJ5IGBvZmZzZXRgIHBpeGVsc1xyXG4gIC8vIGFuZCBvcHRpb25hbGx5IHNjYWxlZCBieSBgc2NhbGVgLiBEb2VzIG5vdCBoYXZlIGFuIGVmZmVjdCBpZiB0aGVcclxuICAvLyBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCAzRCBDU1MgdHJhbnNmb3Jtcy5cclxuICBmdW5jdGlvbiBzZXRUcmFuc2Zvcm0oZWwsIG9mZnNldCwgc2NhbGUpIHtcclxuICBcdHZhciBwb3MgPSBvZmZzZXQgfHwgbmV3IFBvaW50KDAsIDApO1xyXG5cclxuICBcdGVsLnN0eWxlW1RSQU5TRk9STV0gPVxyXG4gIFx0XHQoaWUzZCA/XHJcbiAgXHRcdFx0J3RyYW5zbGF0ZSgnICsgcG9zLnggKyAncHgsJyArIHBvcy55ICsgJ3B4KScgOlxyXG4gIFx0XHRcdCd0cmFuc2xhdGUzZCgnICsgcG9zLnggKyAncHgsJyArIHBvcy55ICsgJ3B4LDApJykgK1xyXG4gIFx0XHQoc2NhbGUgPyAnIHNjYWxlKCcgKyBzY2FsZSArICcpJyA6ICcnKTtcclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBzZXRQb3NpdGlvbihlbDogSFRNTEVsZW1lbnQsIHBvc2l0aW9uOiBQb2ludClcclxuICAvLyBTZXRzIHRoZSBwb3NpdGlvbiBvZiBgZWxgIHRvIGNvb3JkaW5hdGVzIHNwZWNpZmllZCBieSBgcG9zaXRpb25gLFxyXG4gIC8vIHVzaW5nIENTUyB0cmFuc2xhdGUgb3IgdG9wL2xlZnQgcG9zaXRpb25pbmcgZGVwZW5kaW5nIG9uIHRoZSBicm93c2VyXHJcbiAgLy8gKHVzZWQgYnkgTGVhZmxldCBpbnRlcm5hbGx5IHRvIHBvc2l0aW9uIGl0cyBsYXllcnMpLlxyXG4gIGZ1bmN0aW9uIHNldFBvc2l0aW9uKGVsLCBwb2ludCkge1xyXG5cclxuICBcdC8qZXNsaW50LWRpc2FibGUgKi9cclxuICBcdGVsLl9sZWFmbGV0X3BvcyA9IHBvaW50O1xyXG4gIFx0LyogZXNsaW50LWVuYWJsZSAqL1xyXG5cclxuICBcdGlmIChhbnkzZCkge1xyXG4gIFx0XHRzZXRUcmFuc2Zvcm0oZWwsIHBvaW50KTtcclxuICBcdH0gZWxzZSB7XHJcbiAgXHRcdGVsLnN0eWxlLmxlZnQgPSBwb2ludC54ICsgJ3B4JztcclxuICBcdFx0ZWwuc3R5bGUudG9wID0gcG9pbnQueSArICdweCc7XHJcbiAgXHR9XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gZ2V0UG9zaXRpb24oZWw6IEhUTUxFbGVtZW50KTogUG9pbnRcclxuICAvLyBSZXR1cm5zIHRoZSBjb29yZGluYXRlcyBvZiBhbiBlbGVtZW50IHByZXZpb3VzbHkgcG9zaXRpb25lZCB3aXRoIHNldFBvc2l0aW9uLlxyXG4gIGZ1bmN0aW9uIGdldFBvc2l0aW9uKGVsKSB7XHJcbiAgXHQvLyB0aGlzIG1ldGhvZCBpcyBvbmx5IHVzZWQgZm9yIGVsZW1lbnRzIHByZXZpb3VzbHkgcG9zaXRpb25lZCB1c2luZyBzZXRQb3NpdGlvbixcclxuICBcdC8vIHNvIGl0J3Mgc2FmZSB0byBjYWNoZSB0aGUgcG9zaXRpb24gZm9yIHBlcmZvcm1hbmNlXHJcblxyXG4gIFx0cmV0dXJuIGVsLl9sZWFmbGV0X3BvcyB8fCBuZXcgUG9pbnQoMCwgMCk7XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gZGlzYWJsZVRleHRTZWxlY3Rpb24oKVxyXG4gIC8vIFByZXZlbnRzIHRoZSB1c2VyIGZyb20gZ2VuZXJhdGluZyBgc2VsZWN0c3RhcnRgIERPTSBldmVudHMsIHVzdWFsbHkgZ2VuZXJhdGVkXHJcbiAgLy8gd2hlbiB0aGUgdXNlciBkcmFncyB0aGUgbW91c2UgdGhyb3VnaCBhIHBhZ2Ugd2l0aCB0ZXh0LiBVc2VkIGludGVybmFsbHlcclxuICAvLyBieSBMZWFmbGV0IHRvIG92ZXJyaWRlIHRoZSBiZWhhdmlvdXIgb2YgYW55IGNsaWNrLWFuZC1kcmFnIGludGVyYWN0aW9uIG9uXHJcbiAgLy8gdGhlIG1hcC4gQWZmZWN0cyBkcmFnIGludGVyYWN0aW9ucyBvbiB0aGUgd2hvbGUgZG9jdW1lbnQuXHJcblxyXG4gIC8vIEBmdW5jdGlvbiBlbmFibGVUZXh0U2VsZWN0aW9uKClcclxuICAvLyBDYW5jZWxzIHRoZSBlZmZlY3RzIG9mIGEgcHJldmlvdXMgW2BMLkRvbVV0aWwuZGlzYWJsZVRleHRTZWxlY3Rpb25gXSgjZG9tdXRpbC1kaXNhYmxldGV4dHNlbGVjdGlvbikuXHJcbiAgdmFyIGRpc2FibGVUZXh0U2VsZWN0aW9uO1xyXG4gIHZhciBlbmFibGVUZXh0U2VsZWN0aW9uO1xyXG4gIHZhciBfdXNlclNlbGVjdDtcclxuICBpZiAoJ29uc2VsZWN0c3RhcnQnIGluIGRvY3VtZW50KSB7XHJcbiAgXHRkaXNhYmxlVGV4dFNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0b24od2luZG93LCAnc2VsZWN0c3RhcnQnLCBwcmV2ZW50RGVmYXVsdCk7XHJcbiAgXHR9O1xyXG4gIFx0ZW5hYmxlVGV4dFNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0b2ZmKHdpbmRvdywgJ3NlbGVjdHN0YXJ0JywgcHJldmVudERlZmF1bHQpO1xyXG4gIFx0fTtcclxuICB9IGVsc2Uge1xyXG4gIFx0dmFyIHVzZXJTZWxlY3RQcm9wZXJ0eSA9IHRlc3RQcm9wKFxyXG4gIFx0XHRbJ3VzZXJTZWxlY3QnLCAnV2Via2l0VXNlclNlbGVjdCcsICdPVXNlclNlbGVjdCcsICdNb3pVc2VyU2VsZWN0JywgJ21zVXNlclNlbGVjdCddKTtcclxuXHJcbiAgXHRkaXNhYmxlVGV4dFNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0aWYgKHVzZXJTZWxlY3RQcm9wZXJ0eSkge1xyXG4gIFx0XHRcdHZhciBzdHlsZSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZTtcclxuICBcdFx0XHRfdXNlclNlbGVjdCA9IHN0eWxlW3VzZXJTZWxlY3RQcm9wZXJ0eV07XHJcbiAgXHRcdFx0c3R5bGVbdXNlclNlbGVjdFByb3BlcnR5XSA9ICdub25lJztcclxuICBcdFx0fVxyXG4gIFx0fTtcclxuICBcdGVuYWJsZVRleHRTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdGlmICh1c2VyU2VsZWN0UHJvcGVydHkpIHtcclxuICBcdFx0XHRkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGVbdXNlclNlbGVjdFByb3BlcnR5XSA9IF91c2VyU2VsZWN0O1xyXG4gIFx0XHRcdF91c2VyU2VsZWN0ID0gdW5kZWZpbmVkO1xyXG4gIFx0XHR9XHJcbiAgXHR9O1xyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGRpc2FibGVJbWFnZURyYWcoKVxyXG4gIC8vIEFzIFtgTC5Eb21VdGlsLmRpc2FibGVUZXh0U2VsZWN0aW9uYF0oI2RvbXV0aWwtZGlzYWJsZXRleHRzZWxlY3Rpb24pLCBidXRcclxuICAvLyBmb3IgYGRyYWdzdGFydGAgRE9NIGV2ZW50cywgdXN1YWxseSBnZW5lcmF0ZWQgd2hlbiB0aGUgdXNlciBkcmFncyBhbiBpbWFnZS5cclxuICBmdW5jdGlvbiBkaXNhYmxlSW1hZ2VEcmFnKCkge1xyXG4gIFx0b24od2luZG93LCAnZHJhZ3N0YXJ0JywgcHJldmVudERlZmF1bHQpO1xyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGVuYWJsZUltYWdlRHJhZygpXHJcbiAgLy8gQ2FuY2VscyB0aGUgZWZmZWN0cyBvZiBhIHByZXZpb3VzIFtgTC5Eb21VdGlsLmRpc2FibGVJbWFnZURyYWdgXSgjZG9tdXRpbC1kaXNhYmxldGV4dHNlbGVjdGlvbikuXHJcbiAgZnVuY3Rpb24gZW5hYmxlSW1hZ2VEcmFnKCkge1xyXG4gIFx0b2ZmKHdpbmRvdywgJ2RyYWdzdGFydCcsIHByZXZlbnREZWZhdWx0KTtcclxuICB9XHJcblxyXG4gIHZhciBfb3V0bGluZUVsZW1lbnQsIF9vdXRsaW5lU3R5bGU7XHJcbiAgLy8gQGZ1bmN0aW9uIHByZXZlbnRPdXRsaW5lKGVsOiBIVE1MRWxlbWVudClcclxuICAvLyBNYWtlcyB0aGUgW291dGxpbmVdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0NTUy9vdXRsaW5lKVxyXG4gIC8vIG9mIHRoZSBlbGVtZW50IGBlbGAgaW52aXNpYmxlLiBVc2VkIGludGVybmFsbHkgYnkgTGVhZmxldCB0byBwcmV2ZW50XHJcbiAgLy8gZm9jdXNhYmxlIGVsZW1lbnRzIGZyb20gZGlzcGxheWluZyBhbiBvdXRsaW5lIHdoZW4gdGhlIHVzZXIgcGVyZm9ybXMgYVxyXG4gIC8vIGRyYWcgaW50ZXJhY3Rpb24gb24gdGhlbS5cclxuICBmdW5jdGlvbiBwcmV2ZW50T3V0bGluZShlbGVtZW50KSB7XHJcbiAgXHR3aGlsZSAoZWxlbWVudC50YWJJbmRleCA9PT0gLTEpIHtcclxuICBcdFx0ZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcclxuICBcdH1cclxuICBcdGlmICghZWxlbWVudC5zdHlsZSkgeyByZXR1cm47IH1cclxuICBcdHJlc3RvcmVPdXRsaW5lKCk7XHJcbiAgXHRfb3V0bGluZUVsZW1lbnQgPSBlbGVtZW50O1xyXG4gIFx0X291dGxpbmVTdHlsZSA9IGVsZW1lbnQuc3R5bGUub3V0bGluZTtcclxuICBcdGVsZW1lbnQuc3R5bGUub3V0bGluZSA9ICdub25lJztcclxuICBcdG9uKHdpbmRvdywgJ2tleWRvd24nLCByZXN0b3JlT3V0bGluZSk7XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gcmVzdG9yZU91dGxpbmUoKVxyXG4gIC8vIENhbmNlbHMgdGhlIGVmZmVjdHMgb2YgYSBwcmV2aW91cyBbYEwuRG9tVXRpbC5wcmV2ZW50T3V0bGluZWBdKCkuXHJcbiAgZnVuY3Rpb24gcmVzdG9yZU91dGxpbmUoKSB7XHJcbiAgXHRpZiAoIV9vdXRsaW5lRWxlbWVudCkgeyByZXR1cm47IH1cclxuICBcdF9vdXRsaW5lRWxlbWVudC5zdHlsZS5vdXRsaW5lID0gX291dGxpbmVTdHlsZTtcclxuICBcdF9vdXRsaW5lRWxlbWVudCA9IHVuZGVmaW5lZDtcclxuICBcdF9vdXRsaW5lU3R5bGUgPSB1bmRlZmluZWQ7XHJcbiAgXHRvZmYod2luZG93LCAna2V5ZG93bicsIHJlc3RvcmVPdXRsaW5lKTtcclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBnZXRTaXplZFBhcmVudE5vZGUoZWw6IEhUTUxFbGVtZW50KTogSFRNTEVsZW1lbnRcclxuICAvLyBGaW5kcyB0aGUgY2xvc2VzdCBwYXJlbnQgbm9kZSB3aGljaCBzaXplICh3aWR0aCBhbmQgaGVpZ2h0KSBpcyBub3QgbnVsbC5cclxuICBmdW5jdGlvbiBnZXRTaXplZFBhcmVudE5vZGUoZWxlbWVudCkge1xyXG4gIFx0ZG8ge1xyXG4gIFx0XHRlbGVtZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xyXG4gIFx0fSB3aGlsZSAoKCFlbGVtZW50Lm9mZnNldFdpZHRoIHx8ICFlbGVtZW50Lm9mZnNldEhlaWdodCkgJiYgZWxlbWVudCAhPT0gZG9jdW1lbnQuYm9keSk7XHJcbiAgXHRyZXR1cm4gZWxlbWVudDtcclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBnZXRTY2FsZShlbDogSFRNTEVsZW1lbnQpOiBPYmplY3RcclxuICAvLyBDb21wdXRlcyB0aGUgQ1NTIHNjYWxlIGN1cnJlbnRseSBhcHBsaWVkIG9uIHRoZSBlbGVtZW50LlxyXG4gIC8vIFJldHVybnMgYW4gb2JqZWN0IHdpdGggYHhgIGFuZCBgeWAgbWVtYmVycyBhcyBob3Jpem9udGFsIGFuZCB2ZXJ0aWNhbCBzY2FsZXMgcmVzcGVjdGl2ZWx5LFxyXG4gIC8vIGFuZCBgYm91bmRpbmdDbGllbnRSZWN0YCBhcyB0aGUgcmVzdWx0IG9mIFtgZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRWxlbWVudC9nZXRCb3VuZGluZ0NsaWVudFJlY3QpLlxyXG4gIGZ1bmN0aW9uIGdldFNjYWxlKGVsZW1lbnQpIHtcclxuICBcdHZhciByZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTsgLy8gUmVhZC1vbmx5IGluIG9sZCBicm93c2Vycy5cclxuXHJcbiAgXHRyZXR1cm4ge1xyXG4gIFx0XHR4OiByZWN0LndpZHRoIC8gZWxlbWVudC5vZmZzZXRXaWR0aCB8fCAxLFxyXG4gIFx0XHR5OiByZWN0LmhlaWdodCAvIGVsZW1lbnQub2Zmc2V0SGVpZ2h0IHx8IDEsXHJcbiAgXHRcdGJvdW5kaW5nQ2xpZW50UmVjdDogcmVjdFxyXG4gIFx0fTtcclxuICB9XG5cbiAgdmFyIERvbVV0aWwgPSAoe1xuICAgIFRSQU5TRk9STTogVFJBTlNGT1JNLFxuICAgIFRSQU5TSVRJT046IFRSQU5TSVRJT04sXG4gICAgVFJBTlNJVElPTl9FTkQ6IFRSQU5TSVRJT05fRU5ELFxuICAgIGdldDogZ2V0LFxuICAgIGdldFN0eWxlOiBnZXRTdHlsZSxcbiAgICBjcmVhdGU6IGNyZWF0ZSQxLFxuICAgIHJlbW92ZTogcmVtb3ZlLFxuICAgIGVtcHR5OiBlbXB0eSxcbiAgICB0b0Zyb250OiB0b0Zyb250LFxuICAgIHRvQmFjazogdG9CYWNrLFxuICAgIGhhc0NsYXNzOiBoYXNDbGFzcyxcbiAgICBhZGRDbGFzczogYWRkQ2xhc3MsXG4gICAgcmVtb3ZlQ2xhc3M6IHJlbW92ZUNsYXNzLFxuICAgIHNldENsYXNzOiBzZXRDbGFzcyxcbiAgICBnZXRDbGFzczogZ2V0Q2xhc3MsXG4gICAgc2V0T3BhY2l0eTogc2V0T3BhY2l0eSxcbiAgICB0ZXN0UHJvcDogdGVzdFByb3AsXG4gICAgc2V0VHJhbnNmb3JtOiBzZXRUcmFuc2Zvcm0sXG4gICAgc2V0UG9zaXRpb246IHNldFBvc2l0aW9uLFxuICAgIGdldFBvc2l0aW9uOiBnZXRQb3NpdGlvbixcbiAgICBkaXNhYmxlVGV4dFNlbGVjdGlvbjogZGlzYWJsZVRleHRTZWxlY3Rpb24sXG4gICAgZW5hYmxlVGV4dFNlbGVjdGlvbjogZW5hYmxlVGV4dFNlbGVjdGlvbixcbiAgICBkaXNhYmxlSW1hZ2VEcmFnOiBkaXNhYmxlSW1hZ2VEcmFnLFxuICAgIGVuYWJsZUltYWdlRHJhZzogZW5hYmxlSW1hZ2VEcmFnLFxuICAgIHByZXZlbnRPdXRsaW5lOiBwcmV2ZW50T3V0bGluZSxcbiAgICByZXN0b3JlT3V0bGluZTogcmVzdG9yZU91dGxpbmUsXG4gICAgZ2V0U2l6ZWRQYXJlbnROb2RlOiBnZXRTaXplZFBhcmVudE5vZGUsXG4gICAgZ2V0U2NhbGU6IGdldFNjYWxlXG4gIH0pO1xuXG4gIC8qXHJcbiAgICogQG5hbWVzcGFjZSBEb21FdmVudFxyXG4gICAqIFV0aWxpdHkgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aCB0aGUgW0RPTSBldmVudHNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9FdmVudCksIHVzZWQgYnkgTGVhZmxldCBpbnRlcm5hbGx5LlxyXG4gICAqL1xyXG5cclxuICAvLyBJbnNwaXJlZCBieSBKb2huIFJlc2lnLCBEZWFuIEVkd2FyZHMgYW5kIFlVSSBhZGRFdmVudCBpbXBsZW1lbnRhdGlvbnMuXHJcblxyXG4gIC8vIEBmdW5jdGlvbiBvbihlbDogSFRNTEVsZW1lbnQsIHR5cGVzOiBTdHJpbmcsIGZuOiBGdW5jdGlvbiwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcclxuICAvLyBBZGRzIGEgbGlzdGVuZXIgZnVuY3Rpb24gKGBmbmApIHRvIGEgcGFydGljdWxhciBET00gZXZlbnQgdHlwZSBvZiB0aGVcclxuICAvLyBlbGVtZW50IGBlbGAuIFlvdSBjYW4gb3B0aW9uYWxseSBzcGVjaWZ5IHRoZSBjb250ZXh0IG9mIHRoZSBsaXN0ZW5lclxyXG4gIC8vIChvYmplY3QgdGhlIGB0aGlzYCBrZXl3b3JkIHdpbGwgcG9pbnQgdG8pLiBZb3UgY2FuIGFsc28gcGFzcyBzZXZlcmFsXHJcbiAgLy8gc3BhY2Utc2VwYXJhdGVkIHR5cGVzIChlLmcuIGAnY2xpY2sgZGJsY2xpY2snYCkuXHJcblxyXG4gIC8vIEBhbHRlcm5hdGl2ZVxyXG4gIC8vIEBmdW5jdGlvbiBvbihlbDogSFRNTEVsZW1lbnQsIGV2ZW50TWFwOiBPYmplY3QsIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXHJcbiAgLy8gQWRkcyBhIHNldCBvZiB0eXBlL2xpc3RlbmVyIHBhaXJzLCBlLmcuIGB7Y2xpY2s6IG9uQ2xpY2ssIG1vdXNlbW92ZTogb25Nb3VzZU1vdmV9YFxyXG4gIGZ1bmN0aW9uIG9uKG9iaiwgdHlwZXMsIGZuLCBjb250ZXh0KSB7XHJcblxyXG4gIFx0aWYgKHR5cGVvZiB0eXBlcyA9PT0gJ29iamVjdCcpIHtcclxuICBcdFx0Zm9yICh2YXIgdHlwZSBpbiB0eXBlcykge1xyXG4gIFx0XHRcdGFkZE9uZShvYmosIHR5cGUsIHR5cGVzW3R5cGVdLCBmbik7XHJcbiAgXHRcdH1cclxuICBcdH0gZWxzZSB7XHJcbiAgXHRcdHR5cGVzID0gc3BsaXRXb3Jkcyh0eXBlcyk7XHJcblxyXG4gIFx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gdHlwZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICBcdFx0XHRhZGRPbmUob2JqLCB0eXBlc1tpXSwgZm4sIGNvbnRleHQpO1xyXG4gIFx0XHR9XHJcbiAgXHR9XHJcblxyXG4gIFx0cmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICB2YXIgZXZlbnRzS2V5ID0gJ19sZWFmbGV0X2V2ZW50cyc7XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBvZmYoZWw6IEhUTUxFbGVtZW50LCB0eXBlczogU3RyaW5nLCBmbjogRnVuY3Rpb24sIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXHJcbiAgLy8gUmVtb3ZlcyBhIHByZXZpb3VzbHkgYWRkZWQgbGlzdGVuZXIgZnVuY3Rpb24uXHJcbiAgLy8gTm90ZSB0aGF0IGlmIHlvdSBwYXNzZWQgYSBjdXN0b20gY29udGV4dCB0byBvbiwgeW91IG11c3QgcGFzcyB0aGUgc2FtZVxyXG4gIC8vIGNvbnRleHQgdG8gYG9mZmAgaW4gb3JkZXIgdG8gcmVtb3ZlIHRoZSBsaXN0ZW5lci5cclxuXHJcbiAgLy8gQGFsdGVybmF0aXZlXHJcbiAgLy8gQGZ1bmN0aW9uIG9mZihlbDogSFRNTEVsZW1lbnQsIGV2ZW50TWFwOiBPYmplY3QsIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXHJcbiAgLy8gUmVtb3ZlcyBhIHNldCBvZiB0eXBlL2xpc3RlbmVyIHBhaXJzLCBlLmcuIGB7Y2xpY2s6IG9uQ2xpY2ssIG1vdXNlbW92ZTogb25Nb3VzZU1vdmV9YFxyXG4gIGZ1bmN0aW9uIG9mZihvYmosIHR5cGVzLCBmbiwgY29udGV4dCkge1xyXG5cclxuICBcdGlmICh0eXBlb2YgdHlwZXMgPT09ICdvYmplY3QnKSB7XHJcbiAgXHRcdGZvciAodmFyIHR5cGUgaW4gdHlwZXMpIHtcclxuICBcdFx0XHRyZW1vdmVPbmUob2JqLCB0eXBlLCB0eXBlc1t0eXBlXSwgZm4pO1xyXG4gIFx0XHR9XHJcbiAgXHR9IGVsc2UgaWYgKHR5cGVzKSB7XHJcbiAgXHRcdHR5cGVzID0gc3BsaXRXb3Jkcyh0eXBlcyk7XHJcblxyXG4gIFx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gdHlwZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICBcdFx0XHRyZW1vdmVPbmUob2JqLCB0eXBlc1tpXSwgZm4sIGNvbnRleHQpO1xyXG4gIFx0XHR9XHJcbiAgXHR9IGVsc2Uge1xyXG4gIFx0XHRmb3IgKHZhciBqIGluIG9ialtldmVudHNLZXldKSB7XHJcbiAgXHRcdFx0cmVtb3ZlT25lKG9iaiwgaiwgb2JqW2V2ZW50c0tleV1bal0pO1xyXG4gIFx0XHR9XHJcbiAgXHRcdGRlbGV0ZSBvYmpbZXZlbnRzS2V5XTtcclxuICBcdH1cclxuXHJcbiAgXHRyZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGJyb3dzZXJGaXJlc05hdGl2ZURibENsaWNrKCkge1xyXG4gIFx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS93M2MvcG9pbnRlcmV2ZW50cy9pc3N1ZXMvMTcxXHJcbiAgXHRpZiAocG9pbnRlcikge1xyXG4gIFx0XHRyZXR1cm4gIShlZGdlIHx8IHNhZmFyaSk7XHJcbiAgXHR9XHJcbiAgfVxyXG5cclxuICB2YXIgbW91c2VTdWJzdCA9IHtcclxuICBcdG1vdXNlZW50ZXI6ICdtb3VzZW92ZXInLFxyXG4gIFx0bW91c2VsZWF2ZTogJ21vdXNlb3V0JyxcclxuICBcdHdoZWVsOiAhKCdvbndoZWVsJyBpbiB3aW5kb3cpICYmICdtb3VzZXdoZWVsJ1xyXG4gIH07XHJcblxyXG4gIGZ1bmN0aW9uIGFkZE9uZShvYmosIHR5cGUsIGZuLCBjb250ZXh0KSB7XHJcbiAgXHR2YXIgaWQgPSB0eXBlICsgc3RhbXAoZm4pICsgKGNvbnRleHQgPyAnXycgKyBzdGFtcChjb250ZXh0KSA6ICcnKTtcclxuXHJcbiAgXHRpZiAob2JqW2V2ZW50c0tleV0gJiYgb2JqW2V2ZW50c0tleV1baWRdKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG4gIFx0dmFyIGhhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xyXG4gIFx0XHRyZXR1cm4gZm4uY2FsbChjb250ZXh0IHx8IG9iaiwgZSB8fCB3aW5kb3cuZXZlbnQpO1xyXG4gIFx0fTtcclxuXHJcbiAgXHR2YXIgb3JpZ2luYWxIYW5kbGVyID0gaGFuZGxlcjtcclxuXHJcbiAgXHRpZiAocG9pbnRlciAmJiB0eXBlLmluZGV4T2YoJ3RvdWNoJykgPT09IDApIHtcclxuICBcdFx0Ly8gTmVlZHMgRG9tRXZlbnQuUG9pbnRlci5qc1xyXG4gIFx0XHRhZGRQb2ludGVyTGlzdGVuZXIob2JqLCB0eXBlLCBoYW5kbGVyLCBpZCk7XHJcblxyXG4gIFx0fSBlbHNlIGlmICh0b3VjaCAmJiAodHlwZSA9PT0gJ2RibGNsaWNrJykgJiYgIWJyb3dzZXJGaXJlc05hdGl2ZURibENsaWNrKCkpIHtcclxuICBcdFx0YWRkRG91YmxlVGFwTGlzdGVuZXIob2JqLCBoYW5kbGVyLCBpZCk7XHJcblxyXG4gIFx0fSBlbHNlIGlmICgnYWRkRXZlbnRMaXN0ZW5lcicgaW4gb2JqKSB7XHJcblxyXG4gIFx0XHRpZiAodHlwZSA9PT0gJ3RvdWNoc3RhcnQnIHx8IHR5cGUgPT09ICd0b3VjaG1vdmUnIHx8IHR5cGUgPT09ICd3aGVlbCcgfHwgIHR5cGUgPT09ICdtb3VzZXdoZWVsJykge1xyXG4gIFx0XHRcdG9iai5hZGRFdmVudExpc3RlbmVyKG1vdXNlU3Vic3RbdHlwZV0gfHwgdHlwZSwgaGFuZGxlciwgcGFzc2l2ZUV2ZW50cyA/IHtwYXNzaXZlOiBmYWxzZX0gOiBmYWxzZSk7XHJcblxyXG4gIFx0XHR9IGVsc2UgaWYgKHR5cGUgPT09ICdtb3VzZWVudGVyJyB8fCB0eXBlID09PSAnbW91c2VsZWF2ZScpIHtcclxuICBcdFx0XHRoYW5kbGVyID0gZnVuY3Rpb24gKGUpIHtcclxuICBcdFx0XHRcdGUgPSBlIHx8IHdpbmRvdy5ldmVudDtcclxuICBcdFx0XHRcdGlmIChpc0V4dGVybmFsVGFyZ2V0KG9iaiwgZSkpIHtcclxuICBcdFx0XHRcdFx0b3JpZ2luYWxIYW5kbGVyKGUpO1xyXG4gIFx0XHRcdFx0fVxyXG4gIFx0XHRcdH07XHJcbiAgXHRcdFx0b2JqLmFkZEV2ZW50TGlzdGVuZXIobW91c2VTdWJzdFt0eXBlXSwgaGFuZGxlciwgZmFsc2UpO1xyXG5cclxuICBcdFx0fSBlbHNlIHtcclxuICBcdFx0XHRvYmouYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBvcmlnaW5hbEhhbmRsZXIsIGZhbHNlKTtcclxuICBcdFx0fVxyXG5cclxuICBcdH0gZWxzZSBpZiAoJ2F0dGFjaEV2ZW50JyBpbiBvYmopIHtcclxuICBcdFx0b2JqLmF0dGFjaEV2ZW50KCdvbicgKyB0eXBlLCBoYW5kbGVyKTtcclxuICBcdH1cclxuXHJcbiAgXHRvYmpbZXZlbnRzS2V5XSA9IG9ialtldmVudHNLZXldIHx8IHt9O1xyXG4gIFx0b2JqW2V2ZW50c0tleV1baWRdID0gaGFuZGxlcjtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHJlbW92ZU9uZShvYmosIHR5cGUsIGZuLCBjb250ZXh0KSB7XHJcblxyXG4gIFx0dmFyIGlkID0gdHlwZSArIHN0YW1wKGZuKSArIChjb250ZXh0ID8gJ18nICsgc3RhbXAoY29udGV4dCkgOiAnJyksXHJcbiAgXHQgICAgaGFuZGxlciA9IG9ialtldmVudHNLZXldICYmIG9ialtldmVudHNLZXldW2lkXTtcclxuXHJcbiAgXHRpZiAoIWhhbmRsZXIpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcbiAgXHRpZiAocG9pbnRlciAmJiB0eXBlLmluZGV4T2YoJ3RvdWNoJykgPT09IDApIHtcclxuICBcdFx0cmVtb3ZlUG9pbnRlckxpc3RlbmVyKG9iaiwgdHlwZSwgaWQpO1xyXG5cclxuICBcdH0gZWxzZSBpZiAodG91Y2ggJiYgKHR5cGUgPT09ICdkYmxjbGljaycpICYmICFicm93c2VyRmlyZXNOYXRpdmVEYmxDbGljaygpKSB7XHJcbiAgXHRcdHJlbW92ZURvdWJsZVRhcExpc3RlbmVyKG9iaiwgaWQpO1xyXG5cclxuICBcdH0gZWxzZSBpZiAoJ3JlbW92ZUV2ZW50TGlzdGVuZXInIGluIG9iaikge1xyXG5cclxuICBcdFx0b2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIobW91c2VTdWJzdFt0eXBlXSB8fCB0eXBlLCBoYW5kbGVyLCBmYWxzZSk7XHJcblxyXG4gIFx0fSBlbHNlIGlmICgnZGV0YWNoRXZlbnQnIGluIG9iaikge1xyXG4gIFx0XHRvYmouZGV0YWNoRXZlbnQoJ29uJyArIHR5cGUsIGhhbmRsZXIpO1xyXG4gIFx0fVxyXG5cclxuICBcdG9ialtldmVudHNLZXldW2lkXSA9IG51bGw7XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gc3RvcFByb3BhZ2F0aW9uKGV2OiBET01FdmVudCk6IHRoaXNcclxuICAvLyBTdG9wIHRoZSBnaXZlbiBldmVudCBmcm9tIHByb3BhZ2F0aW9uIHRvIHBhcmVudCBlbGVtZW50cy4gVXNlZCBpbnNpZGUgdGhlIGxpc3RlbmVyIGZ1bmN0aW9uczpcclxuICAvLyBgYGBqc1xyXG4gIC8vIEwuRG9tRXZlbnQub24oZGl2LCAnY2xpY2snLCBmdW5jdGlvbiAoZXYpIHtcclxuICAvLyBcdEwuRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uKGV2KTtcclxuICAvLyB9KTtcclxuICAvLyBgYGBcclxuICBmdW5jdGlvbiBzdG9wUHJvcGFnYXRpb24oZSkge1xyXG5cclxuICBcdGlmIChlLnN0b3BQcm9wYWdhdGlvbikge1xyXG4gIFx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gIFx0fSBlbHNlIGlmIChlLm9yaWdpbmFsRXZlbnQpIHsgIC8vIEluIGNhc2Ugb2YgTGVhZmxldCBldmVudC5cclxuICBcdFx0ZS5vcmlnaW5hbEV2ZW50Ll9zdG9wcGVkID0gdHJ1ZTtcclxuICBcdH0gZWxzZSB7XHJcbiAgXHRcdGUuY2FuY2VsQnViYmxlID0gdHJ1ZTtcclxuICBcdH1cclxuICBcdHNraXBwZWQoZSk7XHJcblxyXG4gIFx0cmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gZGlzYWJsZVNjcm9sbFByb3BhZ2F0aW9uKGVsOiBIVE1MRWxlbWVudCk6IHRoaXNcclxuICAvLyBBZGRzIGBzdG9wUHJvcGFnYXRpb25gIHRvIHRoZSBlbGVtZW50J3MgYCd3aGVlbCdgIGV2ZW50cyAocGx1cyBicm93c2VyIHZhcmlhbnRzKS5cclxuICBmdW5jdGlvbiBkaXNhYmxlU2Nyb2xsUHJvcGFnYXRpb24oZWwpIHtcclxuICBcdGFkZE9uZShlbCwgJ3doZWVsJywgc3RvcFByb3BhZ2F0aW9uKTtcclxuICBcdHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGRpc2FibGVDbGlja1Byb3BhZ2F0aW9uKGVsOiBIVE1MRWxlbWVudCk6IHRoaXNcclxuICAvLyBBZGRzIGBzdG9wUHJvcGFnYXRpb25gIHRvIHRoZSBlbGVtZW50J3MgYCdjbGljaydgLCBgJ2RvdWJsZWNsaWNrJ2AsXHJcbiAgLy8gYCdtb3VzZWRvd24nYCBhbmQgYCd0b3VjaHN0YXJ0J2AgZXZlbnRzIChwbHVzIGJyb3dzZXIgdmFyaWFudHMpLlxyXG4gIGZ1bmN0aW9uIGRpc2FibGVDbGlja1Byb3BhZ2F0aW9uKGVsKSB7XHJcbiAgXHRvbihlbCwgJ21vdXNlZG93biB0b3VjaHN0YXJ0IGRibGNsaWNrJywgc3RvcFByb3BhZ2F0aW9uKTtcclxuICBcdGFkZE9uZShlbCwgJ2NsaWNrJywgZmFrZVN0b3ApO1xyXG4gIFx0cmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gcHJldmVudERlZmF1bHQoZXY6IERPTUV2ZW50KTogdGhpc1xyXG4gIC8vIFByZXZlbnRzIHRoZSBkZWZhdWx0IGFjdGlvbiBvZiB0aGUgRE9NIEV2ZW50IGBldmAgZnJvbSBoYXBwZW5pbmcgKHN1Y2ggYXNcclxuICAvLyBmb2xsb3dpbmcgYSBsaW5rIGluIHRoZSBocmVmIG9mIHRoZSBhIGVsZW1lbnQsIG9yIGRvaW5nIGEgUE9TVCByZXF1ZXN0XHJcbiAgLy8gd2l0aCBwYWdlIHJlbG9hZCB3aGVuIGEgYDxmb3JtPmAgaXMgc3VibWl0dGVkKS5cclxuICAvLyBVc2UgaXQgaW5zaWRlIGxpc3RlbmVyIGZ1bmN0aW9ucy5cclxuICBmdW5jdGlvbiBwcmV2ZW50RGVmYXVsdChlKSB7XHJcbiAgXHRpZiAoZS5wcmV2ZW50RGVmYXVsdCkge1xyXG4gIFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgXHR9IGVsc2Uge1xyXG4gIFx0XHRlLnJldHVyblZhbHVlID0gZmFsc2U7XHJcbiAgXHR9XHJcbiAgXHRyZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBzdG9wKGV2OiBET01FdmVudCk6IHRoaXNcclxuICAvLyBEb2VzIGBzdG9wUHJvcGFnYXRpb25gIGFuZCBgcHJldmVudERlZmF1bHRgIGF0IHRoZSBzYW1lIHRpbWUuXHJcbiAgZnVuY3Rpb24gc3RvcChlKSB7XHJcbiAgXHRwcmV2ZW50RGVmYXVsdChlKTtcclxuICBcdHN0b3BQcm9wYWdhdGlvbihlKTtcclxuICBcdHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGdldE1vdXNlUG9zaXRpb24oZXY6IERPTUV2ZW50LCBjb250YWluZXI/OiBIVE1MRWxlbWVudCk6IFBvaW50XHJcbiAgLy8gR2V0cyBub3JtYWxpemVkIG1vdXNlIHBvc2l0aW9uIGZyb20gYSBET00gZXZlbnQgcmVsYXRpdmUgdG8gdGhlXHJcbiAgLy8gYGNvbnRhaW5lcmAgKGJvcmRlciBleGNsdWRlZCkgb3IgdG8gdGhlIHdob2xlIHBhZ2UgaWYgbm90IHNwZWNpZmllZC5cclxuICBmdW5jdGlvbiBnZXRNb3VzZVBvc2l0aW9uKGUsIGNvbnRhaW5lcikge1xyXG4gIFx0aWYgKCFjb250YWluZXIpIHtcclxuICBcdFx0cmV0dXJuIG5ldyBQb2ludChlLmNsaWVudFgsIGUuY2xpZW50WSk7XHJcbiAgXHR9XHJcblxyXG4gIFx0dmFyIHNjYWxlID0gZ2V0U2NhbGUoY29udGFpbmVyKSxcclxuICBcdCAgICBvZmZzZXQgPSBzY2FsZS5ib3VuZGluZ0NsaWVudFJlY3Q7IC8vIGxlZnQgYW5kIHRvcCAgdmFsdWVzIGFyZSBpbiBwYWdlIHNjYWxlIChsaWtlIHRoZSBldmVudCBjbGllbnRYL1kpXHJcblxyXG4gIFx0cmV0dXJuIG5ldyBQb2ludChcclxuICBcdFx0Ly8gb2Zmc2V0LmxlZnQvdG9wIHZhbHVlcyBhcmUgaW4gcGFnZSBzY2FsZSAobGlrZSBjbGllbnRYL1kpLFxyXG4gIFx0XHQvLyB3aGVyZWFzIGNsaWVudExlZnQvVG9wIChib3JkZXIgd2lkdGgpIHZhbHVlcyBhcmUgdGhlIG9yaWdpbmFsIHZhbHVlcyAoYmVmb3JlIENTUyBzY2FsZSBhcHBsaWVzKS5cclxuICBcdFx0KGUuY2xpZW50WCAtIG9mZnNldC5sZWZ0KSAvIHNjYWxlLnggLSBjb250YWluZXIuY2xpZW50TGVmdCxcclxuICBcdFx0KGUuY2xpZW50WSAtIG9mZnNldC50b3ApIC8gc2NhbGUueSAtIGNvbnRhaW5lci5jbGllbnRUb3BcclxuICBcdCk7XHJcbiAgfVxyXG5cclxuICAvLyBDaHJvbWUgb24gV2luIHNjcm9sbHMgZG91YmxlIHRoZSBwaXhlbHMgYXMgaW4gb3RoZXIgcGxhdGZvcm1zIChzZWUgIzQ1MzgpLFxyXG4gIC8vIGFuZCBGaXJlZm94IHNjcm9sbHMgZGV2aWNlIHBpeGVscywgbm90IENTUyBwaXhlbHNcclxuICB2YXIgd2hlZWxQeEZhY3RvciA9XHJcbiAgXHQod2luICYmIGNocm9tZSkgPyAyICogd2luZG93LmRldmljZVBpeGVsUmF0aW8gOlxyXG4gIFx0Z2Vja28gPyB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyA6IDE7XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBnZXRXaGVlbERlbHRhKGV2OiBET01FdmVudCk6IE51bWJlclxyXG4gIC8vIEdldHMgbm9ybWFsaXplZCB3aGVlbCBkZWx0YSBmcm9tIGEgd2hlZWwgRE9NIGV2ZW50LCBpbiB2ZXJ0aWNhbFxyXG4gIC8vIHBpeGVscyBzY3JvbGxlZCAobmVnYXRpdmUgaWYgc2Nyb2xsaW5nIGRvd24pLlxyXG4gIC8vIEV2ZW50cyBmcm9tIHBvaW50aW5nIGRldmljZXMgd2l0aG91dCBwcmVjaXNlIHNjcm9sbGluZyBhcmUgbWFwcGVkIHRvXHJcbiAgLy8gYSBiZXN0IGd1ZXNzIG9mIDYwIHBpeGVscy5cclxuICBmdW5jdGlvbiBnZXRXaGVlbERlbHRhKGUpIHtcclxuICBcdHJldHVybiAoZWRnZSkgPyBlLndoZWVsRGVsdGFZIC8gMiA6IC8vIERvbid0IHRydXN0IHdpbmRvdy1nZW9tZXRyeS1iYXNlZCBkZWx0YVxyXG4gIFx0ICAgICAgIChlLmRlbHRhWSAmJiBlLmRlbHRhTW9kZSA9PT0gMCkgPyAtZS5kZWx0YVkgLyB3aGVlbFB4RmFjdG9yIDogLy8gUGl4ZWxzXHJcbiAgXHQgICAgICAgKGUuZGVsdGFZICYmIGUuZGVsdGFNb2RlID09PSAxKSA/IC1lLmRlbHRhWSAqIDIwIDogLy8gTGluZXNcclxuICBcdCAgICAgICAoZS5kZWx0YVkgJiYgZS5kZWx0YU1vZGUgPT09IDIpID8gLWUuZGVsdGFZICogNjAgOiAvLyBQYWdlc1xyXG4gIFx0ICAgICAgIChlLmRlbHRhWCB8fCBlLmRlbHRhWikgPyAwIDpcdC8vIFNraXAgaG9yaXpvbnRhbC9kZXB0aCB3aGVlbCBldmVudHNcclxuICBcdCAgICAgICBlLndoZWVsRGVsdGEgPyAoZS53aGVlbERlbHRhWSB8fCBlLndoZWVsRGVsdGEpIC8gMiA6IC8vIExlZ2FjeSBJRSBwaXhlbHNcclxuICBcdCAgICAgICAoZS5kZXRhaWwgJiYgTWF0aC5hYnMoZS5kZXRhaWwpIDwgMzI3NjUpID8gLWUuZGV0YWlsICogMjAgOiAvLyBMZWdhY3kgTW96IGxpbmVzXHJcbiAgXHQgICAgICAgZS5kZXRhaWwgPyBlLmRldGFpbCAvIC0zMjc2NSAqIDYwIDogLy8gTGVnYWN5IE1veiBwYWdlc1xyXG4gIFx0ICAgICAgIDA7XHJcbiAgfVxyXG5cclxuICB2YXIgc2tpcEV2ZW50cyA9IHt9O1xyXG5cclxuICBmdW5jdGlvbiBmYWtlU3RvcChlKSB7XHJcbiAgXHQvLyBmYWtlcyBzdG9wUHJvcGFnYXRpb24gYnkgc2V0dGluZyBhIHNwZWNpYWwgZXZlbnQgZmxhZywgY2hlY2tlZC9yZXNldCB3aXRoIHNraXBwZWQoZSlcclxuICBcdHNraXBFdmVudHNbZS50eXBlXSA9IHRydWU7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBza2lwcGVkKGUpIHtcclxuICBcdHZhciBldmVudHMgPSBza2lwRXZlbnRzW2UudHlwZV07XHJcbiAgXHQvLyByZXNldCB3aGVuIGNoZWNraW5nLCBhcyBpdCdzIG9ubHkgdXNlZCBpbiBtYXAgY29udGFpbmVyIGFuZCBwcm9wYWdhdGVzIG91dHNpZGUgb2YgdGhlIG1hcFxyXG4gIFx0c2tpcEV2ZW50c1tlLnR5cGVdID0gZmFsc2U7XHJcbiAgXHRyZXR1cm4gZXZlbnRzO1xyXG4gIH1cclxuXHJcbiAgLy8gY2hlY2sgaWYgZWxlbWVudCByZWFsbHkgbGVmdC9lbnRlcmVkIHRoZSBldmVudCB0YXJnZXQgKGZvciBtb3VzZWVudGVyL21vdXNlbGVhdmUpXHJcbiAgZnVuY3Rpb24gaXNFeHRlcm5hbFRhcmdldChlbCwgZSkge1xyXG5cclxuICBcdHZhciByZWxhdGVkID0gZS5yZWxhdGVkVGFyZ2V0O1xyXG5cclxuICBcdGlmICghcmVsYXRlZCkgeyByZXR1cm4gdHJ1ZTsgfVxyXG5cclxuICBcdHRyeSB7XHJcbiAgXHRcdHdoaWxlIChyZWxhdGVkICYmIChyZWxhdGVkICE9PSBlbCkpIHtcclxuICBcdFx0XHRyZWxhdGVkID0gcmVsYXRlZC5wYXJlbnROb2RlO1xyXG4gIFx0XHR9XHJcbiAgXHR9IGNhdGNoIChlcnIpIHtcclxuICBcdFx0cmV0dXJuIGZhbHNlO1xyXG4gIFx0fVxyXG4gIFx0cmV0dXJuIChyZWxhdGVkICE9PSBlbCk7XHJcbiAgfVxuXG4gIHZhciBEb21FdmVudCA9ICh7XG4gICAgb246IG9uLFxuICAgIG9mZjogb2ZmLFxuICAgIHN0b3BQcm9wYWdhdGlvbjogc3RvcFByb3BhZ2F0aW9uLFxuICAgIGRpc2FibGVTY3JvbGxQcm9wYWdhdGlvbjogZGlzYWJsZVNjcm9sbFByb3BhZ2F0aW9uLFxuICAgIGRpc2FibGVDbGlja1Byb3BhZ2F0aW9uOiBkaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbixcbiAgICBwcmV2ZW50RGVmYXVsdDogcHJldmVudERlZmF1bHQsXG4gICAgc3RvcDogc3RvcCxcbiAgICBnZXRNb3VzZVBvc2l0aW9uOiBnZXRNb3VzZVBvc2l0aW9uLFxuICAgIGdldFdoZWVsRGVsdGE6IGdldFdoZWVsRGVsdGEsXG4gICAgZmFrZVN0b3A6IGZha2VTdG9wLFxuICAgIHNraXBwZWQ6IHNraXBwZWQsXG4gICAgaXNFeHRlcm5hbFRhcmdldDogaXNFeHRlcm5hbFRhcmdldCxcbiAgICBhZGRMaXN0ZW5lcjogb24sXG4gICAgcmVtb3ZlTGlzdGVuZXI6IG9mZlxuICB9KTtcblxuICAvKlxuICAgKiBAY2xhc3MgUG9zQW5pbWF0aW9uXG4gICAqIEBha2EgTC5Qb3NBbmltYXRpb25cbiAgICogQGluaGVyaXRzIEV2ZW50ZWRcbiAgICogVXNlZCBpbnRlcm5hbGx5IGZvciBwYW5uaW5nIGFuaW1hdGlvbnMsIHV0aWxpemluZyBDU1MzIFRyYW5zaXRpb25zIGZvciBtb2Rlcm4gYnJvd3NlcnMgYW5kIGEgdGltZXIgZmFsbGJhY2sgZm9yIElFNi05LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiB2YXIgZnggPSBuZXcgTC5Qb3NBbmltYXRpb24oKTtcbiAgICogZngucnVuKGVsLCBbMzAwLCA1MDBdLCAwLjUpO1xuICAgKiBgYGBcbiAgICpcbiAgICogQGNvbnN0cnVjdG9yIEwuUG9zQW5pbWF0aW9uKClcbiAgICogQ3JlYXRlcyBhIGBQb3NBbmltYXRpb25gIG9iamVjdC5cbiAgICpcbiAgICovXG5cbiAgdmFyIFBvc0FuaW1hdGlvbiA9IEV2ZW50ZWQuZXh0ZW5kKHtcblxuICBcdC8vIEBtZXRob2QgcnVuKGVsOiBIVE1MRWxlbWVudCwgbmV3UG9zOiBQb2ludCwgZHVyYXRpb24/OiBOdW1iZXIsIGVhc2VMaW5lYXJpdHk/OiBOdW1iZXIpXG4gIFx0Ly8gUnVuIGFuIGFuaW1hdGlvbiBvZiBhIGdpdmVuIGVsZW1lbnQgdG8gYSBuZXcgcG9zaXRpb24sIG9wdGlvbmFsbHkgc2V0dGluZ1xuICBcdC8vIGR1cmF0aW9uIGluIHNlY29uZHMgKGAwLjI1YCBieSBkZWZhdWx0KSBhbmQgZWFzaW5nIGxpbmVhcml0eSBmYWN0b3IgKDNyZFxuICBcdC8vIGFyZ3VtZW50IG9mIHRoZSBbY3ViaWMgYmV6aWVyIGN1cnZlXShodHRwOi8vY3ViaWMtYmV6aWVyLmNvbS8jMCwwLC41LDEpLFxuICBcdC8vIGAwLjVgIGJ5IGRlZmF1bHQpLlxuICBcdHJ1bjogZnVuY3Rpb24gKGVsLCBuZXdQb3MsIGR1cmF0aW9uLCBlYXNlTGluZWFyaXR5KSB7XG4gIFx0XHR0aGlzLnN0b3AoKTtcblxuICBcdFx0dGhpcy5fZWwgPSBlbDtcbiAgXHRcdHRoaXMuX2luUHJvZ3Jlc3MgPSB0cnVlO1xuICBcdFx0dGhpcy5fZHVyYXRpb24gPSBkdXJhdGlvbiB8fCAwLjI1O1xuICBcdFx0dGhpcy5fZWFzZU91dFBvd2VyID0gMSAvIE1hdGgubWF4KGVhc2VMaW5lYXJpdHkgfHwgMC41LCAwLjIpO1xuXG4gIFx0XHR0aGlzLl9zdGFydFBvcyA9IGdldFBvc2l0aW9uKGVsKTtcbiAgXHRcdHRoaXMuX29mZnNldCA9IG5ld1Bvcy5zdWJ0cmFjdCh0aGlzLl9zdGFydFBvcyk7XG4gIFx0XHR0aGlzLl9zdGFydFRpbWUgPSArbmV3IERhdGUoKTtcblxuICBcdFx0Ly8gQGV2ZW50IHN0YXJ0OiBFdmVudFxuICBcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgYW5pbWF0aW9uIHN0YXJ0c1xuICBcdFx0dGhpcy5maXJlKCdzdGFydCcpO1xuXG4gIFx0XHR0aGlzLl9hbmltYXRlKCk7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2Qgc3RvcCgpXG4gIFx0Ly8gU3RvcHMgdGhlIGFuaW1hdGlvbiAoaWYgY3VycmVudGx5IHJ1bm5pbmcpLlxuICBcdHN0b3A6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICghdGhpcy5faW5Qcm9ncmVzcykgeyByZXR1cm47IH1cblxuICBcdFx0dGhpcy5fc3RlcCh0cnVlKTtcbiAgXHRcdHRoaXMuX2NvbXBsZXRlKCk7XG4gIFx0fSxcblxuICBcdF9hbmltYXRlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHQvLyBhbmltYXRpb24gbG9vcFxuICBcdFx0dGhpcy5fYW5pbUlkID0gcmVxdWVzdEFuaW1GcmFtZSh0aGlzLl9hbmltYXRlLCB0aGlzKTtcbiAgXHRcdHRoaXMuX3N0ZXAoKTtcbiAgXHR9LFxuXG4gIFx0X3N0ZXA6IGZ1bmN0aW9uIChyb3VuZCkge1xuICBcdFx0dmFyIGVsYXBzZWQgPSAoK25ldyBEYXRlKCkpIC0gdGhpcy5fc3RhcnRUaW1lLFxuICBcdFx0ICAgIGR1cmF0aW9uID0gdGhpcy5fZHVyYXRpb24gKiAxMDAwO1xuXG4gIFx0XHRpZiAoZWxhcHNlZCA8IGR1cmF0aW9uKSB7XG4gIFx0XHRcdHRoaXMuX3J1bkZyYW1lKHRoaXMuX2Vhc2VPdXQoZWxhcHNlZCAvIGR1cmF0aW9uKSwgcm91bmQpO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0dGhpcy5fcnVuRnJhbWUoMSk7XG4gIFx0XHRcdHRoaXMuX2NvbXBsZXRlKCk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF9ydW5GcmFtZTogZnVuY3Rpb24gKHByb2dyZXNzLCByb3VuZCkge1xuICBcdFx0dmFyIHBvcyA9IHRoaXMuX3N0YXJ0UG9zLmFkZCh0aGlzLl9vZmZzZXQubXVsdGlwbHlCeShwcm9ncmVzcykpO1xuICBcdFx0aWYgKHJvdW5kKSB7XG4gIFx0XHRcdHBvcy5fcm91bmQoKTtcbiAgXHRcdH1cbiAgXHRcdHNldFBvc2l0aW9uKHRoaXMuX2VsLCBwb3MpO1xuXG4gIFx0XHQvLyBAZXZlbnQgc3RlcDogRXZlbnRcbiAgXHRcdC8vIEZpcmVkIGNvbnRpbnVvdXNseSBkdXJpbmcgdGhlIGFuaW1hdGlvbi5cbiAgXHRcdHRoaXMuZmlyZSgnc3RlcCcpO1xuICBcdH0sXG5cbiAgXHRfY29tcGxldGU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGNhbmNlbEFuaW1GcmFtZSh0aGlzLl9hbmltSWQpO1xuXG4gIFx0XHR0aGlzLl9pblByb2dyZXNzID0gZmFsc2U7XG4gIFx0XHQvLyBAZXZlbnQgZW5kOiBFdmVudFxuICBcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgYW5pbWF0aW9uIGVuZHMuXG4gIFx0XHR0aGlzLmZpcmUoJ2VuZCcpO1xuICBcdH0sXG5cbiAgXHRfZWFzZU91dDogZnVuY3Rpb24gKHQpIHtcbiAgXHRcdHJldHVybiAxIC0gTWF0aC5wb3coMSAtIHQsIHRoaXMuX2Vhc2VPdXRQb3dlcik7XG4gIFx0fVxuICB9KTtcblxuICAvKlxyXG4gICAqIEBjbGFzcyBNYXBcclxuICAgKiBAYWthIEwuTWFwXHJcbiAgICogQGluaGVyaXRzIEV2ZW50ZWRcclxuICAgKlxyXG4gICAqIFRoZSBjZW50cmFsIGNsYXNzIG9mIHRoZSBBUEkg4oCUIGl0IGlzIHVzZWQgdG8gY3JlYXRlIGEgbWFwIG9uIGEgcGFnZSBhbmQgbWFuaXB1bGF0ZSBpdC5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICpcclxuICAgKiBgYGBqc1xyXG4gICAqIC8vIGluaXRpYWxpemUgdGhlIG1hcCBvbiB0aGUgXCJtYXBcIiBkaXYgd2l0aCBhIGdpdmVuIGNlbnRlciBhbmQgem9vbVxyXG4gICAqIHZhciBtYXAgPSBMLm1hcCgnbWFwJywge1xyXG4gICAqIFx0Y2VudGVyOiBbNTEuNTA1LCAtMC4wOV0sXHJcbiAgICogXHR6b29tOiAxM1xyXG4gICAqIH0pO1xyXG4gICAqIGBgYFxyXG4gICAqXHJcbiAgICovXHJcblxyXG4gIHZhciBNYXAgPSBFdmVudGVkLmV4dGVuZCh7XHJcblxyXG4gIFx0b3B0aW9uczoge1xyXG4gIFx0XHQvLyBAc2VjdGlvbiBNYXAgU3RhdGUgT3B0aW9uc1xyXG4gIFx0XHQvLyBAb3B0aW9uIGNyczogQ1JTID0gTC5DUlMuRVBTRzM4NTdcclxuICBcdFx0Ly8gVGhlIFtDb29yZGluYXRlIFJlZmVyZW5jZSBTeXN0ZW1dKCNjcnMpIHRvIHVzZS4gRG9uJ3QgY2hhbmdlIHRoaXMgaWYgeW91J3JlIG5vdFxyXG4gIFx0XHQvLyBzdXJlIHdoYXQgaXQgbWVhbnMuXHJcbiAgXHRcdGNyczogRVBTRzM4NTcsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIGNlbnRlcjogTGF0TG5nID0gdW5kZWZpbmVkXHJcbiAgXHRcdC8vIEluaXRpYWwgZ2VvZ3JhcGhpYyBjZW50ZXIgb2YgdGhlIG1hcFxyXG4gIFx0XHRjZW50ZXI6IHVuZGVmaW5lZCxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gem9vbTogTnVtYmVyID0gdW5kZWZpbmVkXHJcbiAgXHRcdC8vIEluaXRpYWwgbWFwIHpvb20gbGV2ZWxcclxuICBcdFx0em9vbTogdW5kZWZpbmVkLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBtaW5ab29tOiBOdW1iZXIgPSAqXHJcbiAgXHRcdC8vIE1pbmltdW0gem9vbSBsZXZlbCBvZiB0aGUgbWFwLlxyXG4gIFx0XHQvLyBJZiBub3Qgc3BlY2lmaWVkIGFuZCBhdCBsZWFzdCBvbmUgYEdyaWRMYXllcmAgb3IgYFRpbGVMYXllcmAgaXMgaW4gdGhlIG1hcCxcclxuICBcdFx0Ly8gdGhlIGxvd2VzdCBvZiB0aGVpciBgbWluWm9vbWAgb3B0aW9ucyB3aWxsIGJlIHVzZWQgaW5zdGVhZC5cclxuICBcdFx0bWluWm9vbTogdW5kZWZpbmVkLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBtYXhab29tOiBOdW1iZXIgPSAqXHJcbiAgXHRcdC8vIE1heGltdW0gem9vbSBsZXZlbCBvZiB0aGUgbWFwLlxyXG4gIFx0XHQvLyBJZiBub3Qgc3BlY2lmaWVkIGFuZCBhdCBsZWFzdCBvbmUgYEdyaWRMYXllcmAgb3IgYFRpbGVMYXllcmAgaXMgaW4gdGhlIG1hcCxcclxuICBcdFx0Ly8gdGhlIGhpZ2hlc3Qgb2YgdGhlaXIgYG1heFpvb21gIG9wdGlvbnMgd2lsbCBiZSB1c2VkIGluc3RlYWQuXHJcbiAgXHRcdG1heFpvb206IHVuZGVmaW5lZCxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gbGF5ZXJzOiBMYXllcltdID0gW11cclxuICBcdFx0Ly8gQXJyYXkgb2YgbGF5ZXJzIHRoYXQgd2lsbCBiZSBhZGRlZCB0byB0aGUgbWFwIGluaXRpYWxseVxyXG4gIFx0XHRsYXllcnM6IFtdLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBtYXhCb3VuZHM6IExhdExuZ0JvdW5kcyA9IG51bGxcclxuICBcdFx0Ly8gV2hlbiB0aGlzIG9wdGlvbiBpcyBzZXQsIHRoZSBtYXAgcmVzdHJpY3RzIHRoZSB2aWV3IHRvIHRoZSBnaXZlblxyXG4gIFx0XHQvLyBnZW9ncmFwaGljYWwgYm91bmRzLCBib3VuY2luZyB0aGUgdXNlciBiYWNrIGlmIHRoZSB1c2VyIHRyaWVzIHRvIHBhblxyXG4gIFx0XHQvLyBvdXRzaWRlIHRoZSB2aWV3LiBUbyBzZXQgdGhlIHJlc3RyaWN0aW9uIGR5bmFtaWNhbGx5LCB1c2VcclxuICBcdFx0Ly8gW2BzZXRNYXhCb3VuZHNgXSgjbWFwLXNldG1heGJvdW5kcykgbWV0aG9kLlxyXG4gIFx0XHRtYXhCb3VuZHM6IHVuZGVmaW5lZCxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gcmVuZGVyZXI6IFJlbmRlcmVyID0gKlxyXG4gIFx0XHQvLyBUaGUgZGVmYXVsdCBtZXRob2QgZm9yIGRyYXdpbmcgdmVjdG9yIGxheWVycyBvbiB0aGUgbWFwLiBgTC5TVkdgXHJcbiAgXHRcdC8vIG9yIGBMLkNhbnZhc2AgYnkgZGVmYXVsdCBkZXBlbmRpbmcgb24gYnJvd3NlciBzdXBwb3J0LlxyXG4gIFx0XHRyZW5kZXJlcjogdW5kZWZpbmVkLFxyXG5cclxuXHJcbiAgXHRcdC8vIEBzZWN0aW9uIEFuaW1hdGlvbiBPcHRpb25zXHJcbiAgXHRcdC8vIEBvcHRpb24gem9vbUFuaW1hdGlvbjogQm9vbGVhbiA9IHRydWVcclxuICBcdFx0Ly8gV2hldGhlciB0aGUgbWFwIHpvb20gYW5pbWF0aW9uIGlzIGVuYWJsZWQuIEJ5IGRlZmF1bHQgaXQncyBlbmFibGVkXHJcbiAgXHRcdC8vIGluIGFsbCBicm93c2VycyB0aGF0IHN1cHBvcnQgQ1NTMyBUcmFuc2l0aW9ucyBleGNlcHQgQW5kcm9pZC5cclxuICBcdFx0em9vbUFuaW1hdGlvbjogdHJ1ZSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gem9vbUFuaW1hdGlvblRocmVzaG9sZDogTnVtYmVyID0gNFxyXG4gIFx0XHQvLyBXb24ndCBhbmltYXRlIHpvb20gaWYgdGhlIHpvb20gZGlmZmVyZW5jZSBleGNlZWRzIHRoaXMgdmFsdWUuXHJcbiAgXHRcdHpvb21BbmltYXRpb25UaHJlc2hvbGQ6IDQsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIGZhZGVBbmltYXRpb246IEJvb2xlYW4gPSB0cnVlXHJcbiAgXHRcdC8vIFdoZXRoZXIgdGhlIHRpbGUgZmFkZSBhbmltYXRpb24gaXMgZW5hYmxlZC4gQnkgZGVmYXVsdCBpdCdzIGVuYWJsZWRcclxuICBcdFx0Ly8gaW4gYWxsIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBDU1MzIFRyYW5zaXRpb25zIGV4Y2VwdCBBbmRyb2lkLlxyXG4gIFx0XHRmYWRlQW5pbWF0aW9uOiB0cnVlLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBtYXJrZXJab29tQW5pbWF0aW9uOiBCb29sZWFuID0gdHJ1ZVxyXG4gIFx0XHQvLyBXaGV0aGVyIG1hcmtlcnMgYW5pbWF0ZSB0aGVpciB6b29tIHdpdGggdGhlIHpvb20gYW5pbWF0aW9uLCBpZiBkaXNhYmxlZFxyXG4gIFx0XHQvLyB0aGV5IHdpbGwgZGlzYXBwZWFyIGZvciB0aGUgbGVuZ3RoIG9mIHRoZSBhbmltYXRpb24uIEJ5IGRlZmF1bHQgaXQnc1xyXG4gIFx0XHQvLyBlbmFibGVkIGluIGFsbCBicm93c2VycyB0aGF0IHN1cHBvcnQgQ1NTMyBUcmFuc2l0aW9ucyBleGNlcHQgQW5kcm9pZC5cclxuICBcdFx0bWFya2VyWm9vbUFuaW1hdGlvbjogdHJ1ZSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gdHJhbnNmb3JtM0RMaW1pdDogTnVtYmVyID0gMl4yM1xyXG4gIFx0XHQvLyBEZWZpbmVzIHRoZSBtYXhpbXVtIHNpemUgb2YgYSBDU1MgdHJhbnNsYXRpb24gdHJhbnNmb3JtLiBUaGUgZGVmYXVsdFxyXG4gIFx0XHQvLyB2YWx1ZSBzaG91bGQgbm90IGJlIGNoYW5nZWQgdW5sZXNzIGEgd2ViIGJyb3dzZXIgcG9zaXRpb25zIGxheWVycyBpblxyXG4gIFx0XHQvLyB0aGUgd3JvbmcgcGxhY2UgYWZ0ZXIgZG9pbmcgYSBsYXJnZSBgcGFuQnlgLlxyXG4gIFx0XHR0cmFuc2Zvcm0zRExpbWl0OiA4Mzg4NjA4LCAvLyBQcmVjaXNpb24gbGltaXQgb2YgYSAzMi1iaXQgZmxvYXRcclxuXHJcbiAgXHRcdC8vIEBzZWN0aW9uIEludGVyYWN0aW9uIE9wdGlvbnNcclxuICBcdFx0Ly8gQG9wdGlvbiB6b29tU25hcDogTnVtYmVyID0gMVxyXG4gIFx0XHQvLyBGb3JjZXMgdGhlIG1hcCdzIHpvb20gbGV2ZWwgdG8gYWx3YXlzIGJlIGEgbXVsdGlwbGUgb2YgdGhpcywgcGFydGljdWxhcmx5XHJcbiAgXHRcdC8vIHJpZ2h0IGFmdGVyIGEgW2BmaXRCb3VuZHMoKWBdKCNtYXAtZml0Ym91bmRzKSBvciBhIHBpbmNoLXpvb20uXHJcbiAgXHRcdC8vIEJ5IGRlZmF1bHQsIHRoZSB6b29tIGxldmVsIHNuYXBzIHRvIHRoZSBuZWFyZXN0IGludGVnZXI7IGxvd2VyIHZhbHVlc1xyXG4gIFx0XHQvLyAoZS5nLiBgMC41YCBvciBgMC4xYCkgYWxsb3cgZm9yIGdyZWF0ZXIgZ3JhbnVsYXJpdHkuIEEgdmFsdWUgb2YgYDBgXHJcbiAgXHRcdC8vIG1lYW5zIHRoZSB6b29tIGxldmVsIHdpbGwgbm90IGJlIHNuYXBwZWQgYWZ0ZXIgYGZpdEJvdW5kc2Agb3IgYSBwaW5jaC16b29tLlxyXG4gIFx0XHR6b29tU25hcDogMSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gem9vbURlbHRhOiBOdW1iZXIgPSAxXHJcbiAgXHRcdC8vIENvbnRyb2xzIGhvdyBtdWNoIHRoZSBtYXAncyB6b29tIGxldmVsIHdpbGwgY2hhbmdlIGFmdGVyIGFcclxuICBcdFx0Ly8gW2B6b29tSW4oKWBdKCNtYXAtem9vbWluKSwgW2B6b29tT3V0KClgXSgjbWFwLXpvb21vdXQpLCBwcmVzc2luZyBgK2BcclxuICBcdFx0Ly8gb3IgYC1gIG9uIHRoZSBrZXlib2FyZCwgb3IgdXNpbmcgdGhlIFt6b29tIGNvbnRyb2xzXSgjY29udHJvbC16b29tKS5cclxuICBcdFx0Ly8gVmFsdWVzIHNtYWxsZXIgdGhhbiBgMWAgKGUuZy4gYDAuNWApIGFsbG93IGZvciBncmVhdGVyIGdyYW51bGFyaXR5LlxyXG4gIFx0XHR6b29tRGVsdGE6IDEsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIHRyYWNrUmVzaXplOiBCb29sZWFuID0gdHJ1ZVxyXG4gIFx0XHQvLyBXaGV0aGVyIHRoZSBtYXAgYXV0b21hdGljYWxseSBoYW5kbGVzIGJyb3dzZXIgd2luZG93IHJlc2l6ZSB0byB1cGRhdGUgaXRzZWxmLlxyXG4gIFx0XHR0cmFja1Jlc2l6ZTogdHJ1ZVxyXG4gIFx0fSxcclxuXHJcbiAgXHRpbml0aWFsaXplOiBmdW5jdGlvbiAoaWQsIG9wdGlvbnMpIHsgLy8gKEhUTUxFbGVtZW50IG9yIFN0cmluZywgT2JqZWN0KVxyXG4gIFx0XHRvcHRpb25zID0gc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcbiAgXHRcdC8vIE1ha2Ugc3VyZSB0byBhc3NpZ24gaW50ZXJuYWwgZmxhZ3MgYXQgdGhlIGJlZ2lubmluZyxcclxuICBcdFx0Ly8gdG8gYXZvaWQgaW5jb25zaXN0ZW50IHN0YXRlIGluIHNvbWUgZWRnZSBjYXNlcy5cclxuICBcdFx0dGhpcy5faGFuZGxlcnMgPSBbXTtcclxuICBcdFx0dGhpcy5fbGF5ZXJzID0ge307XHJcbiAgXHRcdHRoaXMuX3pvb21Cb3VuZExheWVycyA9IHt9O1xyXG4gIFx0XHR0aGlzLl9zaXplQ2hhbmdlZCA9IHRydWU7XHJcblxyXG4gIFx0XHR0aGlzLl9pbml0Q29udGFpbmVyKGlkKTtcclxuICBcdFx0dGhpcy5faW5pdExheW91dCgpO1xyXG5cclxuICBcdFx0Ly8gaGFjayBmb3IgaHR0cHM6Ly9naXRodWIuY29tL0xlYWZsZXQvTGVhZmxldC9pc3N1ZXMvMTk4MFxyXG4gIFx0XHR0aGlzLl9vblJlc2l6ZSA9IGJpbmQodGhpcy5fb25SZXNpemUsIHRoaXMpO1xyXG5cclxuICBcdFx0dGhpcy5faW5pdEV2ZW50cygpO1xyXG5cclxuICBcdFx0aWYgKG9wdGlvbnMubWF4Qm91bmRzKSB7XHJcbiAgXHRcdFx0dGhpcy5zZXRNYXhCb3VuZHMob3B0aW9ucy5tYXhCb3VuZHMpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRpZiAob3B0aW9ucy56b29tICE9PSB1bmRlZmluZWQpIHtcclxuICBcdFx0XHR0aGlzLl96b29tID0gdGhpcy5fbGltaXRab29tKG9wdGlvbnMuem9vbSk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGlmIChvcHRpb25zLmNlbnRlciAmJiBvcHRpb25zLnpvb20gIT09IHVuZGVmaW5lZCkge1xyXG4gIFx0XHRcdHRoaXMuc2V0Vmlldyh0b0xhdExuZyhvcHRpb25zLmNlbnRlciksIG9wdGlvbnMuem9vbSwge3Jlc2V0OiB0cnVlfSk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMuY2FsbEluaXRIb29rcygpO1xyXG5cclxuICBcdFx0Ly8gZG9uJ3QgYW5pbWF0ZSBvbiBicm93c2VycyB3aXRob3V0IGhhcmR3YXJlLWFjY2VsZXJhdGVkIHRyYW5zaXRpb25zIG9yIG9sZCBBbmRyb2lkL09wZXJhXHJcbiAgXHRcdHRoaXMuX3pvb21BbmltYXRlZCA9IFRSQU5TSVRJT04gJiYgYW55M2QgJiYgIW1vYmlsZU9wZXJhICYmXHJcbiAgXHRcdFx0XHR0aGlzLm9wdGlvbnMuem9vbUFuaW1hdGlvbjtcclxuXHJcbiAgXHRcdC8vIHpvb20gdHJhbnNpdGlvbnMgcnVuIHdpdGggdGhlIHNhbWUgZHVyYXRpb24gZm9yIGFsbCBsYXllcnMsIHNvIGlmIG9uZSBvZiB0cmFuc2l0aW9uZW5kIGV2ZW50c1xyXG4gIFx0XHQvLyBoYXBwZW5zIGFmdGVyIHN0YXJ0aW5nIHpvb20gYW5pbWF0aW9uIChwcm9wYWdhdGluZyB0byB0aGUgbWFwIHBhbmUpLCB3ZSBrbm93IHRoYXQgaXQgZW5kZWQgZ2xvYmFsbHlcclxuICBcdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xyXG4gIFx0XHRcdHRoaXMuX2NyZWF0ZUFuaW1Qcm94eSgpO1xyXG4gIFx0XHRcdG9uKHRoaXMuX3Byb3h5LCBUUkFOU0lUSU9OX0VORCwgdGhpcy5fY2F0Y2hUcmFuc2l0aW9uRW5kLCB0aGlzKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dGhpcy5fYWRkTGF5ZXJzKHRoaXMub3B0aW9ucy5sYXllcnMpO1xyXG4gIFx0fSxcclxuXHJcblxyXG4gIFx0Ly8gQHNlY3Rpb24gTWV0aG9kcyBmb3IgbW9kaWZ5aW5nIG1hcCBzdGF0ZVxyXG5cclxuICBcdC8vIEBtZXRob2Qgc2V0VmlldyhjZW50ZXI6IExhdExuZywgem9vbTogTnVtYmVyLCBvcHRpb25zPzogWm9vbS9wYW4gb3B0aW9ucyk6IHRoaXNcclxuICBcdC8vIFNldHMgdGhlIHZpZXcgb2YgdGhlIG1hcCAoZ2VvZ3JhcGhpY2FsIGNlbnRlciBhbmQgem9vbSkgd2l0aCB0aGUgZ2l2ZW5cclxuICBcdC8vIGFuaW1hdGlvbiBvcHRpb25zLlxyXG4gIFx0c2V0VmlldzogZnVuY3Rpb24gKGNlbnRlciwgem9vbSwgb3B0aW9ucykge1xyXG5cclxuICBcdFx0em9vbSA9IHpvb20gPT09IHVuZGVmaW5lZCA/IHRoaXMuX3pvb20gOiB0aGlzLl9saW1pdFpvb20oem9vbSk7XHJcbiAgXHRcdGNlbnRlciA9IHRoaXMuX2xpbWl0Q2VudGVyKHRvTGF0TG5nKGNlbnRlciksIHpvb20sIHRoaXMub3B0aW9ucy5tYXhCb3VuZHMpO1xyXG4gIFx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHJcbiAgXHRcdHRoaXMuX3N0b3AoKTtcclxuXHJcbiAgXHRcdGlmICh0aGlzLl9sb2FkZWQgJiYgIW9wdGlvbnMucmVzZXQgJiYgb3B0aW9ucyAhPT0gdHJ1ZSkge1xyXG5cclxuICBcdFx0XHRpZiAob3B0aW9ucy5hbmltYXRlICE9PSB1bmRlZmluZWQpIHtcclxuICBcdFx0XHRcdG9wdGlvbnMuem9vbSA9IGV4dGVuZCh7YW5pbWF0ZTogb3B0aW9ucy5hbmltYXRlfSwgb3B0aW9ucy56b29tKTtcclxuICBcdFx0XHRcdG9wdGlvbnMucGFuID0gZXh0ZW5kKHthbmltYXRlOiBvcHRpb25zLmFuaW1hdGUsIGR1cmF0aW9uOiBvcHRpb25zLmR1cmF0aW9ufSwgb3B0aW9ucy5wYW4pO1xyXG4gIFx0XHRcdH1cclxuXHJcbiAgXHRcdFx0Ly8gdHJ5IGFuaW1hdGluZyBwYW4gb3Igem9vbVxyXG4gIFx0XHRcdHZhciBtb3ZlZCA9ICh0aGlzLl96b29tICE9PSB6b29tKSA/XHJcbiAgXHRcdFx0XHR0aGlzLl90cnlBbmltYXRlZFpvb20gJiYgdGhpcy5fdHJ5QW5pbWF0ZWRab29tKGNlbnRlciwgem9vbSwgb3B0aW9ucy56b29tKSA6XHJcbiAgXHRcdFx0XHR0aGlzLl90cnlBbmltYXRlZFBhbihjZW50ZXIsIG9wdGlvbnMucGFuKTtcclxuXHJcbiAgXHRcdFx0aWYgKG1vdmVkKSB7XHJcbiAgXHRcdFx0XHQvLyBwcmV2ZW50IHJlc2l6ZSBoYW5kbGVyIGNhbGwsIHRoZSB2aWV3IHdpbGwgcmVmcmVzaCBhZnRlciBhbmltYXRpb24gYW55d2F5XHJcbiAgXHRcdFx0XHRjbGVhclRpbWVvdXQodGhpcy5fc2l6ZVRpbWVyKTtcclxuICBcdFx0XHRcdHJldHVybiB0aGlzO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0fVxyXG5cclxuICBcdFx0Ly8gYW5pbWF0aW9uIGRpZG4ndCBzdGFydCwganVzdCByZXNldCB0aGUgbWFwIHZpZXdcclxuICBcdFx0dGhpcy5fcmVzZXRWaWV3KGNlbnRlciwgem9vbSk7XHJcblxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBzZXRab29tKHpvb206IE51bWJlciwgb3B0aW9ucz86IFpvb20vcGFuIG9wdGlvbnMpOiB0aGlzXHJcbiAgXHQvLyBTZXRzIHRoZSB6b29tIG9mIHRoZSBtYXAuXHJcbiAgXHRzZXRab29tOiBmdW5jdGlvbiAoem9vbSwgb3B0aW9ucykge1xyXG4gIFx0XHRpZiAoIXRoaXMuX2xvYWRlZCkge1xyXG4gIFx0XHRcdHRoaXMuX3pvb20gPSB6b29tO1xyXG4gIFx0XHRcdHJldHVybiB0aGlzO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiB0aGlzLnNldFZpZXcodGhpcy5nZXRDZW50ZXIoKSwgem9vbSwge3pvb206IG9wdGlvbnN9KTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCB6b29tSW4oZGVsdGE/OiBOdW1iZXIsIG9wdGlvbnM/OiBab29tIG9wdGlvbnMpOiB0aGlzXHJcbiAgXHQvLyBJbmNyZWFzZXMgdGhlIHpvb20gb2YgdGhlIG1hcCBieSBgZGVsdGFgIChbYHpvb21EZWx0YWBdKCNtYXAtem9vbWRlbHRhKSBieSBkZWZhdWx0KS5cclxuICBcdHpvb21JbjogZnVuY3Rpb24gKGRlbHRhLCBvcHRpb25zKSB7XHJcbiAgXHRcdGRlbHRhID0gZGVsdGEgfHwgKGFueTNkID8gdGhpcy5vcHRpb25zLnpvb21EZWx0YSA6IDEpO1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5zZXRab29tKHRoaXMuX3pvb20gKyBkZWx0YSwgb3B0aW9ucyk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2Qgem9vbU91dChkZWx0YT86IE51bWJlciwgb3B0aW9ucz86IFpvb20gb3B0aW9ucyk6IHRoaXNcclxuICBcdC8vIERlY3JlYXNlcyB0aGUgem9vbSBvZiB0aGUgbWFwIGJ5IGBkZWx0YWAgKFtgem9vbURlbHRhYF0oI21hcC16b29tZGVsdGEpIGJ5IGRlZmF1bHQpLlxyXG4gIFx0em9vbU91dDogZnVuY3Rpb24gKGRlbHRhLCBvcHRpb25zKSB7XHJcbiAgXHRcdGRlbHRhID0gZGVsdGEgfHwgKGFueTNkID8gdGhpcy5vcHRpb25zLnpvb21EZWx0YSA6IDEpO1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5zZXRab29tKHRoaXMuX3pvb20gLSBkZWx0YSwgb3B0aW9ucyk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2Qgc2V0Wm9vbUFyb3VuZChsYXRsbmc6IExhdExuZywgem9vbTogTnVtYmVyLCBvcHRpb25zOiBab29tIG9wdGlvbnMpOiB0aGlzXHJcbiAgXHQvLyBab29tcyB0aGUgbWFwIHdoaWxlIGtlZXBpbmcgYSBzcGVjaWZpZWQgZ2VvZ3JhcGhpY2FsIHBvaW50IG9uIHRoZSBtYXBcclxuICBcdC8vIHN0YXRpb25hcnkgKGUuZy4gdXNlZCBpbnRlcm5hbGx5IGZvciBzY3JvbGwgem9vbSBhbmQgZG91YmxlLWNsaWNrIHpvb20pLlxyXG4gIFx0Ly8gQGFsdGVybmF0aXZlXHJcbiAgXHQvLyBAbWV0aG9kIHNldFpvb21Bcm91bmQob2Zmc2V0OiBQb2ludCwgem9vbTogTnVtYmVyLCBvcHRpb25zOiBab29tIG9wdGlvbnMpOiB0aGlzXHJcbiAgXHQvLyBab29tcyB0aGUgbWFwIHdoaWxlIGtlZXBpbmcgYSBzcGVjaWZpZWQgcGl4ZWwgb24gdGhlIG1hcCAocmVsYXRpdmUgdG8gdGhlIHRvcC1sZWZ0IGNvcm5lcikgc3RhdGlvbmFyeS5cclxuICBcdHNldFpvb21Bcm91bmQ6IGZ1bmN0aW9uIChsYXRsbmcsIHpvb20sIG9wdGlvbnMpIHtcclxuICBcdFx0dmFyIHNjYWxlID0gdGhpcy5nZXRab29tU2NhbGUoem9vbSksXHJcbiAgXHRcdCAgICB2aWV3SGFsZiA9IHRoaXMuZ2V0U2l6ZSgpLmRpdmlkZUJ5KDIpLFxyXG4gIFx0XHQgICAgY29udGFpbmVyUG9pbnQgPSBsYXRsbmcgaW5zdGFuY2VvZiBQb2ludCA/IGxhdGxuZyA6IHRoaXMubGF0TG5nVG9Db250YWluZXJQb2ludChsYXRsbmcpLFxyXG5cclxuICBcdFx0ICAgIGNlbnRlck9mZnNldCA9IGNvbnRhaW5lclBvaW50LnN1YnRyYWN0KHZpZXdIYWxmKS5tdWx0aXBseUJ5KDEgLSAxIC8gc2NhbGUpLFxyXG4gIFx0XHQgICAgbmV3Q2VudGVyID0gdGhpcy5jb250YWluZXJQb2ludFRvTGF0TG5nKHZpZXdIYWxmLmFkZChjZW50ZXJPZmZzZXQpKTtcclxuXHJcbiAgXHRcdHJldHVybiB0aGlzLnNldFZpZXcobmV3Q2VudGVyLCB6b29tLCB7em9vbTogb3B0aW9uc30pO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfZ2V0Qm91bmRzQ2VudGVyWm9vbTogZnVuY3Rpb24gKGJvdW5kcywgb3B0aW9ucykge1xyXG5cclxuICBcdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcbiAgXHRcdGJvdW5kcyA9IGJvdW5kcy5nZXRCb3VuZHMgPyBib3VuZHMuZ2V0Qm91bmRzKCkgOiB0b0xhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG5cclxuICBcdFx0dmFyIHBhZGRpbmdUTCA9IHRvUG9pbnQob3B0aW9ucy5wYWRkaW5nVG9wTGVmdCB8fCBvcHRpb25zLnBhZGRpbmcgfHwgWzAsIDBdKSxcclxuICBcdFx0ICAgIHBhZGRpbmdCUiA9IHRvUG9pbnQob3B0aW9ucy5wYWRkaW5nQm90dG9tUmlnaHQgfHwgb3B0aW9ucy5wYWRkaW5nIHx8IFswLCAwXSksXHJcblxyXG4gIFx0XHQgICAgem9vbSA9IHRoaXMuZ2V0Qm91bmRzWm9vbShib3VuZHMsIGZhbHNlLCBwYWRkaW5nVEwuYWRkKHBhZGRpbmdCUikpO1xyXG5cclxuICBcdFx0em9vbSA9ICh0eXBlb2Ygb3B0aW9ucy5tYXhab29tID09PSAnbnVtYmVyJykgPyBNYXRoLm1pbihvcHRpb25zLm1heFpvb20sIHpvb20pIDogem9vbTtcclxuXHJcbiAgXHRcdGlmICh6b29tID09PSBJbmZpbml0eSkge1xyXG4gIFx0XHRcdHJldHVybiB7XHJcbiAgXHRcdFx0XHRjZW50ZXI6IGJvdW5kcy5nZXRDZW50ZXIoKSxcclxuICBcdFx0XHRcdHpvb206IHpvb21cclxuICBcdFx0XHR9O1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR2YXIgcGFkZGluZ09mZnNldCA9IHBhZGRpbmdCUi5zdWJ0cmFjdChwYWRkaW5nVEwpLmRpdmlkZUJ5KDIpLFxyXG5cclxuICBcdFx0ICAgIHN3UG9pbnQgPSB0aGlzLnByb2plY3QoYm91bmRzLmdldFNvdXRoV2VzdCgpLCB6b29tKSxcclxuICBcdFx0ICAgIG5lUG9pbnQgPSB0aGlzLnByb2plY3QoYm91bmRzLmdldE5vcnRoRWFzdCgpLCB6b29tKSxcclxuICBcdFx0ICAgIGNlbnRlciA9IHRoaXMudW5wcm9qZWN0KHN3UG9pbnQuYWRkKG5lUG9pbnQpLmRpdmlkZUJ5KDIpLmFkZChwYWRkaW5nT2Zmc2V0KSwgem9vbSk7XHJcblxyXG4gIFx0XHRyZXR1cm4ge1xyXG4gIFx0XHRcdGNlbnRlcjogY2VudGVyLFxyXG4gIFx0XHRcdHpvb206IHpvb21cclxuICBcdFx0fTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBmaXRCb3VuZHMoYm91bmRzOiBMYXRMbmdCb3VuZHMsIG9wdGlvbnM/OiBmaXRCb3VuZHMgb3B0aW9ucyk6IHRoaXNcclxuICBcdC8vIFNldHMgYSBtYXAgdmlldyB0aGF0IGNvbnRhaW5zIHRoZSBnaXZlbiBnZW9ncmFwaGljYWwgYm91bmRzIHdpdGggdGhlXHJcbiAgXHQvLyBtYXhpbXVtIHpvb20gbGV2ZWwgcG9zc2libGUuXHJcbiAgXHRmaXRCb3VuZHM6IGZ1bmN0aW9uIChib3VuZHMsIG9wdGlvbnMpIHtcclxuXHJcbiAgXHRcdGJvdW5kcyA9IHRvTGF0TG5nQm91bmRzKGJvdW5kcyk7XHJcblxyXG4gIFx0XHRpZiAoIWJvdW5kcy5pc1ZhbGlkKCkpIHtcclxuICBcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0JvdW5kcyBhcmUgbm90IHZhbGlkLicpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR2YXIgdGFyZ2V0ID0gdGhpcy5fZ2V0Qm91bmRzQ2VudGVyWm9vbShib3VuZHMsIG9wdGlvbnMpO1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5zZXRWaWV3KHRhcmdldC5jZW50ZXIsIHRhcmdldC56b29tLCBvcHRpb25zKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBmaXRXb3JsZChvcHRpb25zPzogZml0Qm91bmRzIG9wdGlvbnMpOiB0aGlzXHJcbiAgXHQvLyBTZXRzIGEgbWFwIHZpZXcgdGhhdCBtb3N0bHkgY29udGFpbnMgdGhlIHdob2xlIHdvcmxkIHdpdGggdGhlIG1heGltdW1cclxuICBcdC8vIHpvb20gbGV2ZWwgcG9zc2libGUuXHJcbiAgXHRmaXRXb3JsZDogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMuZml0Qm91bmRzKFtbLTkwLCAtMTgwXSwgWzkwLCAxODBdXSwgb3B0aW9ucyk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgcGFuVG8obGF0bG5nOiBMYXRMbmcsIG9wdGlvbnM/OiBQYW4gb3B0aW9ucyk6IHRoaXNcclxuICBcdC8vIFBhbnMgdGhlIG1hcCB0byBhIGdpdmVuIGNlbnRlci5cclxuICBcdHBhblRvOiBmdW5jdGlvbiAoY2VudGVyLCBvcHRpb25zKSB7IC8vIChMYXRMbmcpXHJcbiAgXHRcdHJldHVybiB0aGlzLnNldFZpZXcoY2VudGVyLCB0aGlzLl96b29tLCB7cGFuOiBvcHRpb25zfSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgcGFuQnkob2Zmc2V0OiBQb2ludCwgb3B0aW9ucz86IFBhbiBvcHRpb25zKTogdGhpc1xyXG4gIFx0Ly8gUGFucyB0aGUgbWFwIGJ5IGEgZ2l2ZW4gbnVtYmVyIG9mIHBpeGVscyAoYW5pbWF0ZWQpLlxyXG4gIFx0cGFuQnk6IGZ1bmN0aW9uIChvZmZzZXQsIG9wdGlvbnMpIHtcclxuICBcdFx0b2Zmc2V0ID0gdG9Qb2ludChvZmZzZXQpLnJvdW5kKCk7XHJcbiAgXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cclxuICBcdFx0aWYgKCFvZmZzZXQueCAmJiAhb2Zmc2V0LnkpIHtcclxuICBcdFx0XHRyZXR1cm4gdGhpcy5maXJlKCdtb3ZlZW5kJyk7XHJcbiAgXHRcdH1cclxuICBcdFx0Ly8gSWYgd2UgcGFuIHRvbyBmYXIsIENocm9tZSBnZXRzIGlzc3VlcyB3aXRoIHRpbGVzXHJcbiAgXHRcdC8vIGFuZCBtYWtlcyB0aGVtIGRpc2FwcGVhciBvciBhcHBlYXIgaW4gdGhlIHdyb25nIHBsYWNlIChzbGlnaHRseSBvZmZzZXQpICMyNjAyXHJcbiAgXHRcdGlmIChvcHRpb25zLmFuaW1hdGUgIT09IHRydWUgJiYgIXRoaXMuZ2V0U2l6ZSgpLmNvbnRhaW5zKG9mZnNldCkpIHtcclxuICBcdFx0XHR0aGlzLl9yZXNldFZpZXcodGhpcy51bnByb2plY3QodGhpcy5wcm9qZWN0KHRoaXMuZ2V0Q2VudGVyKCkpLmFkZChvZmZzZXQpKSwgdGhpcy5nZXRab29tKCkpO1xyXG4gIFx0XHRcdHJldHVybiB0aGlzO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRpZiAoIXRoaXMuX3BhbkFuaW0pIHtcclxuICBcdFx0XHR0aGlzLl9wYW5BbmltID0gbmV3IFBvc0FuaW1hdGlvbigpO1xyXG5cclxuICBcdFx0XHR0aGlzLl9wYW5BbmltLm9uKHtcclxuICBcdFx0XHRcdCdzdGVwJzogdGhpcy5fb25QYW5UcmFuc2l0aW9uU3RlcCxcclxuICBcdFx0XHRcdCdlbmQnOiB0aGlzLl9vblBhblRyYW5zaXRpb25FbmRcclxuICBcdFx0XHR9LCB0aGlzKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0Ly8gZG9uJ3QgZmlyZSBtb3Zlc3RhcnQgaWYgYW5pbWF0aW5nIGluZXJ0aWFcclxuICBcdFx0aWYgKCFvcHRpb25zLm5vTW92ZVN0YXJ0KSB7XHJcbiAgXHRcdFx0dGhpcy5maXJlKCdtb3Zlc3RhcnQnKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0Ly8gYW5pbWF0ZSBwYW4gdW5sZXNzIGFuaW1hdGU6IGZhbHNlIHNwZWNpZmllZFxyXG4gIFx0XHRpZiAob3B0aW9ucy5hbmltYXRlICE9PSBmYWxzZSkge1xyXG4gIFx0XHRcdGFkZENsYXNzKHRoaXMuX21hcFBhbmUsICdsZWFmbGV0LXBhbi1hbmltJyk7XHJcblxyXG4gIFx0XHRcdHZhciBuZXdQb3MgPSB0aGlzLl9nZXRNYXBQYW5lUG9zKCkuc3VidHJhY3Qob2Zmc2V0KS5yb3VuZCgpO1xyXG4gIFx0XHRcdHRoaXMuX3BhbkFuaW0ucnVuKHRoaXMuX21hcFBhbmUsIG5ld1Bvcywgb3B0aW9ucy5kdXJhdGlvbiB8fCAwLjI1LCBvcHRpb25zLmVhc2VMaW5lYXJpdHkpO1xyXG4gIFx0XHR9IGVsc2Uge1xyXG4gIFx0XHRcdHRoaXMuX3Jhd1BhbkJ5KG9mZnNldCk7XHJcbiAgXHRcdFx0dGhpcy5maXJlKCdtb3ZlJykuZmlyZSgnbW92ZWVuZCcpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBmbHlUbyhsYXRsbmc6IExhdExuZywgem9vbT86IE51bWJlciwgb3B0aW9ucz86IFpvb20vcGFuIG9wdGlvbnMpOiB0aGlzXHJcbiAgXHQvLyBTZXRzIHRoZSB2aWV3IG9mIHRoZSBtYXAgKGdlb2dyYXBoaWNhbCBjZW50ZXIgYW5kIHpvb20pIHBlcmZvcm1pbmcgYSBzbW9vdGhcclxuICBcdC8vIHBhbi16b29tIGFuaW1hdGlvbi5cclxuICBcdGZseVRvOiBmdW5jdGlvbiAodGFyZ2V0Q2VudGVyLCB0YXJnZXRab29tLCBvcHRpb25zKSB7XHJcblxyXG4gIFx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuICBcdFx0aWYgKG9wdGlvbnMuYW5pbWF0ZSA9PT0gZmFsc2UgfHwgIWFueTNkKSB7XHJcbiAgXHRcdFx0cmV0dXJuIHRoaXMuc2V0Vmlldyh0YXJnZXRDZW50ZXIsIHRhcmdldFpvb20sIG9wdGlvbnMpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR0aGlzLl9zdG9wKCk7XHJcblxyXG4gIFx0XHR2YXIgZnJvbSA9IHRoaXMucHJvamVjdCh0aGlzLmdldENlbnRlcigpKSxcclxuICBcdFx0ICAgIHRvID0gdGhpcy5wcm9qZWN0KHRhcmdldENlbnRlciksXHJcbiAgXHRcdCAgICBzaXplID0gdGhpcy5nZXRTaXplKCksXHJcbiAgXHRcdCAgICBzdGFydFpvb20gPSB0aGlzLl96b29tO1xyXG5cclxuICBcdFx0dGFyZ2V0Q2VudGVyID0gdG9MYXRMbmcodGFyZ2V0Q2VudGVyKTtcclxuICBcdFx0dGFyZ2V0Wm9vbSA9IHRhcmdldFpvb20gPT09IHVuZGVmaW5lZCA/IHN0YXJ0Wm9vbSA6IHRhcmdldFpvb207XHJcblxyXG4gIFx0XHR2YXIgdzAgPSBNYXRoLm1heChzaXplLngsIHNpemUueSksXHJcbiAgXHRcdCAgICB3MSA9IHcwICogdGhpcy5nZXRab29tU2NhbGUoc3RhcnRab29tLCB0YXJnZXRab29tKSxcclxuICBcdFx0ICAgIHUxID0gKHRvLmRpc3RhbmNlVG8oZnJvbSkpIHx8IDEsXHJcbiAgXHRcdCAgICByaG8gPSAxLjQyLFxyXG4gIFx0XHQgICAgcmhvMiA9IHJobyAqIHJobztcclxuXHJcbiAgXHRcdGZ1bmN0aW9uIHIoaSkge1xyXG4gIFx0XHRcdHZhciBzMSA9IGkgPyAtMSA6IDEsXHJcbiAgXHRcdFx0ICAgIHMyID0gaSA/IHcxIDogdzAsXHJcbiAgXHRcdFx0ICAgIHQxID0gdzEgKiB3MSAtIHcwICogdzAgKyBzMSAqIHJobzIgKiByaG8yICogdTEgKiB1MSxcclxuICBcdFx0XHQgICAgYjEgPSAyICogczIgKiByaG8yICogdTEsXHJcbiAgXHRcdFx0ICAgIGIgPSB0MSAvIGIxLFxyXG4gIFx0XHRcdCAgICBzcSA9IE1hdGguc3FydChiICogYiArIDEpIC0gYjtcclxuXHJcbiAgXHRcdFx0ICAgIC8vIHdvcmthcm91bmQgZm9yIGZsb2F0aW5nIHBvaW50IHByZWNpc2lvbiBidWcgd2hlbiBzcSA9IDAsIGxvZyA9IC1JbmZpbml0ZSxcclxuICBcdFx0XHQgICAgLy8gdGh1cyB0cmlnZ2VyaW5nIGFuIGluZmluaXRlIGxvb3AgaW4gZmx5VG9cclxuICBcdFx0XHQgICAgdmFyIGxvZyA9IHNxIDwgMC4wMDAwMDAwMDEgPyAtMTggOiBNYXRoLmxvZyhzcSk7XHJcblxyXG4gIFx0XHRcdHJldHVybiBsb2c7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGZ1bmN0aW9uIHNpbmgobikgeyByZXR1cm4gKE1hdGguZXhwKG4pIC0gTWF0aC5leHAoLW4pKSAvIDI7IH1cclxuICBcdFx0ZnVuY3Rpb24gY29zaChuKSB7IHJldHVybiAoTWF0aC5leHAobikgKyBNYXRoLmV4cCgtbikpIC8gMjsgfVxyXG4gIFx0XHRmdW5jdGlvbiB0YW5oKG4pIHsgcmV0dXJuIHNpbmgobikgLyBjb3NoKG4pOyB9XHJcblxyXG4gIFx0XHR2YXIgcjAgPSByKDApO1xyXG5cclxuICBcdFx0ZnVuY3Rpb24gdyhzKSB7IHJldHVybiB3MCAqIChjb3NoKHIwKSAvIGNvc2gocjAgKyByaG8gKiBzKSk7IH1cclxuICBcdFx0ZnVuY3Rpb24gdShzKSB7IHJldHVybiB3MCAqIChjb3NoKHIwKSAqIHRhbmgocjAgKyByaG8gKiBzKSAtIHNpbmgocjApKSAvIHJobzI7IH1cclxuXHJcbiAgXHRcdGZ1bmN0aW9uIGVhc2VPdXQodCkgeyByZXR1cm4gMSAtIE1hdGgucG93KDEgLSB0LCAxLjUpOyB9XHJcblxyXG4gIFx0XHR2YXIgc3RhcnQgPSBEYXRlLm5vdygpLFxyXG4gIFx0XHQgICAgUyA9IChyKDEpIC0gcjApIC8gcmhvLFxyXG4gIFx0XHQgICAgZHVyYXRpb24gPSBvcHRpb25zLmR1cmF0aW9uID8gMTAwMCAqIG9wdGlvbnMuZHVyYXRpb24gOiAxMDAwICogUyAqIDAuODtcclxuXHJcbiAgXHRcdGZ1bmN0aW9uIGZyYW1lKCkge1xyXG4gIFx0XHRcdHZhciB0ID0gKERhdGUubm93KCkgLSBzdGFydCkgLyBkdXJhdGlvbixcclxuICBcdFx0XHQgICAgcyA9IGVhc2VPdXQodCkgKiBTO1xyXG5cclxuICBcdFx0XHRpZiAodCA8PSAxKSB7XHJcbiAgXHRcdFx0XHR0aGlzLl9mbHlUb0ZyYW1lID0gcmVxdWVzdEFuaW1GcmFtZShmcmFtZSwgdGhpcyk7XHJcblxyXG4gIFx0XHRcdFx0dGhpcy5fbW92ZShcclxuICBcdFx0XHRcdFx0dGhpcy51bnByb2plY3QoZnJvbS5hZGQodG8uc3VidHJhY3QoZnJvbSkubXVsdGlwbHlCeSh1KHMpIC8gdTEpKSwgc3RhcnRab29tKSxcclxuICBcdFx0XHRcdFx0dGhpcy5nZXRTY2FsZVpvb20odzAgLyB3KHMpLCBzdGFydFpvb20pLFxyXG4gIFx0XHRcdFx0XHR7Zmx5VG86IHRydWV9KTtcclxuXHJcbiAgXHRcdFx0fSBlbHNlIHtcclxuICBcdFx0XHRcdHRoaXNcclxuICBcdFx0XHRcdFx0Ll9tb3ZlKHRhcmdldENlbnRlciwgdGFyZ2V0Wm9vbSlcclxuICBcdFx0XHRcdFx0Ll9tb3ZlRW5kKHRydWUpO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0fVxyXG5cclxuICBcdFx0dGhpcy5fbW92ZVN0YXJ0KHRydWUsIG9wdGlvbnMubm9Nb3ZlU3RhcnQpO1xyXG5cclxuICBcdFx0ZnJhbWUuY2FsbCh0aGlzKTtcclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZmx5VG9Cb3VuZHMoYm91bmRzOiBMYXRMbmdCb3VuZHMsIG9wdGlvbnM/OiBmaXRCb3VuZHMgb3B0aW9ucyk6IHRoaXNcclxuICBcdC8vIFNldHMgdGhlIHZpZXcgb2YgdGhlIG1hcCB3aXRoIGEgc21vb3RoIGFuaW1hdGlvbiBsaWtlIFtgZmx5VG9gXSgjbWFwLWZseXRvKSxcclxuICBcdC8vIGJ1dCB0YWtlcyBhIGJvdW5kcyBwYXJhbWV0ZXIgbGlrZSBbYGZpdEJvdW5kc2BdKCNtYXAtZml0Ym91bmRzKS5cclxuICBcdGZseVRvQm91bmRzOiBmdW5jdGlvbiAoYm91bmRzLCBvcHRpb25zKSB7XHJcbiAgXHRcdHZhciB0YXJnZXQgPSB0aGlzLl9nZXRCb3VuZHNDZW50ZXJab29tKGJvdW5kcywgb3B0aW9ucyk7XHJcbiAgXHRcdHJldHVybiB0aGlzLmZseVRvKHRhcmdldC5jZW50ZXIsIHRhcmdldC56b29tLCBvcHRpb25zKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBzZXRNYXhCb3VuZHMoYm91bmRzOiBMYXRMbmdCb3VuZHMpOiB0aGlzXHJcbiAgXHQvLyBSZXN0cmljdHMgdGhlIG1hcCB2aWV3IHRvIHRoZSBnaXZlbiBib3VuZHMgKHNlZSB0aGUgW21heEJvdW5kc10oI21hcC1tYXhib3VuZHMpIG9wdGlvbikuXHJcbiAgXHRzZXRNYXhCb3VuZHM6IGZ1bmN0aW9uIChib3VuZHMpIHtcclxuICBcdFx0Ym91bmRzID0gdG9MYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcbiAgXHRcdGlmICghYm91bmRzLmlzVmFsaWQoKSkge1xyXG4gIFx0XHRcdHRoaXMub3B0aW9ucy5tYXhCb3VuZHMgPSBudWxsO1xyXG4gIFx0XHRcdHJldHVybiB0aGlzLm9mZignbW92ZWVuZCcsIHRoaXMuX3Bhbkluc2lkZU1heEJvdW5kcyk7XHJcbiAgXHRcdH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLm1heEJvdW5kcykge1xyXG4gIFx0XHRcdHRoaXMub2ZmKCdtb3ZlZW5kJywgdGhpcy5fcGFuSW5zaWRlTWF4Qm91bmRzKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dGhpcy5vcHRpb25zLm1heEJvdW5kcyA9IGJvdW5kcztcclxuXHJcbiAgXHRcdGlmICh0aGlzLl9sb2FkZWQpIHtcclxuICBcdFx0XHR0aGlzLl9wYW5JbnNpZGVNYXhCb3VuZHMoKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0cmV0dXJuIHRoaXMub24oJ21vdmVlbmQnLCB0aGlzLl9wYW5JbnNpZGVNYXhCb3VuZHMpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHNldE1pblpvb20oem9vbTogTnVtYmVyKTogdGhpc1xyXG4gIFx0Ly8gU2V0cyB0aGUgbG93ZXIgbGltaXQgZm9yIHRoZSBhdmFpbGFibGUgem9vbSBsZXZlbHMgKHNlZSB0aGUgW21pblpvb21dKCNtYXAtbWluem9vbSkgb3B0aW9uKS5cclxuICBcdHNldE1pblpvb206IGZ1bmN0aW9uICh6b29tKSB7XHJcbiAgXHRcdHZhciBvbGRab29tID0gdGhpcy5vcHRpb25zLm1pblpvb207XHJcbiAgXHRcdHRoaXMub3B0aW9ucy5taW5ab29tID0gem9vbTtcclxuXHJcbiAgXHRcdGlmICh0aGlzLl9sb2FkZWQgJiYgb2xkWm9vbSAhPT0gem9vbSkge1xyXG4gIFx0XHRcdHRoaXMuZmlyZSgnem9vbWxldmVsc2NoYW5nZScpO1xyXG5cclxuICBcdFx0XHRpZiAodGhpcy5nZXRab29tKCkgPCB0aGlzLm9wdGlvbnMubWluWm9vbSkge1xyXG4gIFx0XHRcdFx0cmV0dXJuIHRoaXMuc2V0Wm9vbSh6b29tKTtcclxuICBcdFx0XHR9XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHNldE1heFpvb20oem9vbTogTnVtYmVyKTogdGhpc1xyXG4gIFx0Ly8gU2V0cyB0aGUgdXBwZXIgbGltaXQgZm9yIHRoZSBhdmFpbGFibGUgem9vbSBsZXZlbHMgKHNlZSB0aGUgW21heFpvb21dKCNtYXAtbWF4em9vbSkgb3B0aW9uKS5cclxuICBcdHNldE1heFpvb206IGZ1bmN0aW9uICh6b29tKSB7XHJcbiAgXHRcdHZhciBvbGRab29tID0gdGhpcy5vcHRpb25zLm1heFpvb207XHJcbiAgXHRcdHRoaXMub3B0aW9ucy5tYXhab29tID0gem9vbTtcclxuXHJcbiAgXHRcdGlmICh0aGlzLl9sb2FkZWQgJiYgb2xkWm9vbSAhPT0gem9vbSkge1xyXG4gIFx0XHRcdHRoaXMuZmlyZSgnem9vbWxldmVsc2NoYW5nZScpO1xyXG5cclxuICBcdFx0XHRpZiAodGhpcy5nZXRab29tKCkgPiB0aGlzLm9wdGlvbnMubWF4Wm9vbSkge1xyXG4gIFx0XHRcdFx0cmV0dXJuIHRoaXMuc2V0Wm9vbSh6b29tKTtcclxuICBcdFx0XHR9XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHBhbkluc2lkZUJvdW5kcyhib3VuZHM6IExhdExuZ0JvdW5kcywgb3B0aW9ucz86IFBhbiBvcHRpb25zKTogdGhpc1xyXG4gIFx0Ly8gUGFucyB0aGUgbWFwIHRvIHRoZSBjbG9zZXN0IHZpZXcgdGhhdCB3b3VsZCBsaWUgaW5zaWRlIHRoZSBnaXZlbiBib3VuZHMgKGlmIGl0J3Mgbm90IGFscmVhZHkpLCBjb250cm9sbGluZyB0aGUgYW5pbWF0aW9uIHVzaW5nIHRoZSBvcHRpb25zIHNwZWNpZmljLCBpZiBhbnkuXHJcbiAgXHRwYW5JbnNpZGVCb3VuZHM6IGZ1bmN0aW9uIChib3VuZHMsIG9wdGlvbnMpIHtcclxuICBcdFx0dGhpcy5fZW5mb3JjaW5nQm91bmRzID0gdHJ1ZTtcclxuICBcdFx0dmFyIGNlbnRlciA9IHRoaXMuZ2V0Q2VudGVyKCksXHJcbiAgXHRcdCAgICBuZXdDZW50ZXIgPSB0aGlzLl9saW1pdENlbnRlcihjZW50ZXIsIHRoaXMuX3pvb20sIHRvTGF0TG5nQm91bmRzKGJvdW5kcykpO1xyXG5cclxuICBcdFx0aWYgKCFjZW50ZXIuZXF1YWxzKG5ld0NlbnRlcikpIHtcclxuICBcdFx0XHR0aGlzLnBhblRvKG5ld0NlbnRlciwgb3B0aW9ucyk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMuX2VuZm9yY2luZ0JvdW5kcyA9IGZhbHNlO1xyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBwYW5JbnNpZGUobGF0bG5nOiBMYXRMbmcsIG9wdGlvbnM/OiBvcHRpb25zKTogdGhpc1xyXG4gIFx0Ly8gUGFucyB0aGUgbWFwIHRoZSBtaW5pbXVtIGFtb3VudCB0byBtYWtlIHRoZSBgbGF0bG5nYCB2aXNpYmxlLiBVc2VcclxuICBcdC8vIGBwYWRkaW5nYCwgYHBhZGRpbmdUb3BMZWZ0YCBhbmQgYHBhZGRpbmdUb3BSaWdodGAgb3B0aW9ucyB0byBmaXRcclxuICBcdC8vIHRoZSBkaXNwbGF5IHRvIG1vcmUgcmVzdHJpY3RlZCBib3VuZHMsIGxpa2UgW2BmaXRCb3VuZHNgXSgjbWFwLWZpdGJvdW5kcykuXHJcbiAgXHQvLyBJZiBgbGF0bG5nYCBpcyBhbHJlYWR5IHdpdGhpbiB0aGUgKG9wdGlvbmFsbHkgcGFkZGVkKSBkaXNwbGF5IGJvdW5kcyxcclxuICBcdC8vIHRoZSBtYXAgd2lsbCBub3QgYmUgcGFubmVkLlxyXG4gIFx0cGFuSW5zaWRlOiBmdW5jdGlvbiAobGF0bG5nLCBvcHRpb25zKSB7XHJcbiAgXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cclxuICBcdFx0dmFyIHBhZGRpbmdUTCA9IHRvUG9pbnQob3B0aW9ucy5wYWRkaW5nVG9wTGVmdCB8fCBvcHRpb25zLnBhZGRpbmcgfHwgWzAsIDBdKSxcclxuICBcdFx0ICAgIHBhZGRpbmdCUiA9IHRvUG9pbnQob3B0aW9ucy5wYWRkaW5nQm90dG9tUmlnaHQgfHwgb3B0aW9ucy5wYWRkaW5nIHx8IFswLCAwXSksXHJcbiAgXHRcdCAgICBjZW50ZXIgPSB0aGlzLmdldENlbnRlcigpLFxyXG4gIFx0XHQgICAgcGl4ZWxDZW50ZXIgPSB0aGlzLnByb2plY3QoY2VudGVyKSxcclxuICBcdFx0ICAgIHBpeGVsUG9pbnQgPSB0aGlzLnByb2plY3QobGF0bG5nKSxcclxuICBcdFx0ICAgIHBpeGVsQm91bmRzID0gdGhpcy5nZXRQaXhlbEJvdW5kcygpLFxyXG4gIFx0XHQgICAgaGFsZlBpeGVsQm91bmRzID0gcGl4ZWxCb3VuZHMuZ2V0U2l6ZSgpLmRpdmlkZUJ5KDIpLFxyXG4gIFx0XHQgICAgcGFkZGVkQm91bmRzID0gdG9Cb3VuZHMoW3BpeGVsQm91bmRzLm1pbi5hZGQocGFkZGluZ1RMKSwgcGl4ZWxCb3VuZHMubWF4LnN1YnRyYWN0KHBhZGRpbmdCUildKTtcclxuXHJcbiAgXHRcdGlmICghcGFkZGVkQm91bmRzLmNvbnRhaW5zKHBpeGVsUG9pbnQpKSB7XHJcbiAgXHRcdFx0dGhpcy5fZW5mb3JjaW5nQm91bmRzID0gdHJ1ZTtcclxuICBcdFx0XHR2YXIgZGlmZiA9IHBpeGVsQ2VudGVyLnN1YnRyYWN0KHBpeGVsUG9pbnQpLFxyXG4gIFx0XHRcdCAgICBuZXdDZW50ZXIgPSB0b1BvaW50KHBpeGVsUG9pbnQueCArIGRpZmYueCwgcGl4ZWxQb2ludC55ICsgZGlmZi55KTtcclxuXHJcbiAgXHRcdFx0aWYgKHBpeGVsUG9pbnQueCA8IHBhZGRlZEJvdW5kcy5taW4ueCB8fCBwaXhlbFBvaW50LnggPiBwYWRkZWRCb3VuZHMubWF4LngpIHtcclxuICBcdFx0XHRcdG5ld0NlbnRlci54ID0gcGl4ZWxDZW50ZXIueCAtIGRpZmYueDtcclxuICBcdFx0XHRcdGlmIChkaWZmLnggPiAwKSB7XHJcbiAgXHRcdFx0XHRcdG5ld0NlbnRlci54ICs9IGhhbGZQaXhlbEJvdW5kcy54IC0gcGFkZGluZ1RMLng7XHJcbiAgXHRcdFx0XHR9IGVsc2Uge1xyXG4gIFx0XHRcdFx0XHRuZXdDZW50ZXIueCAtPSBoYWxmUGl4ZWxCb3VuZHMueCAtIHBhZGRpbmdCUi54O1xyXG4gIFx0XHRcdFx0fVxyXG4gIFx0XHRcdH1cclxuICBcdFx0XHRpZiAocGl4ZWxQb2ludC55IDwgcGFkZGVkQm91bmRzLm1pbi55IHx8IHBpeGVsUG9pbnQueSA+IHBhZGRlZEJvdW5kcy5tYXgueSkge1xyXG4gIFx0XHRcdFx0bmV3Q2VudGVyLnkgPSBwaXhlbENlbnRlci55IC0gZGlmZi55O1xyXG4gIFx0XHRcdFx0aWYgKGRpZmYueSA+IDApIHtcclxuICBcdFx0XHRcdFx0bmV3Q2VudGVyLnkgKz0gaGFsZlBpeGVsQm91bmRzLnkgLSBwYWRkaW5nVEwueTtcclxuICBcdFx0XHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0XHRcdG5ld0NlbnRlci55IC09IGhhbGZQaXhlbEJvdW5kcy55IC0gcGFkZGluZ0JSLnk7XHJcbiAgXHRcdFx0XHR9XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHRcdHRoaXMucGFuVG8odGhpcy51bnByb2plY3QobmV3Q2VudGVyKSwgb3B0aW9ucyk7XHJcbiAgXHRcdFx0dGhpcy5fZW5mb3JjaW5nQm91bmRzID0gZmFsc2U7XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgaW52YWxpZGF0ZVNpemUob3B0aW9uczogWm9vbS9wYW4gb3B0aW9ucyk6IHRoaXNcclxuICBcdC8vIENoZWNrcyBpZiB0aGUgbWFwIGNvbnRhaW5lciBzaXplIGNoYW5nZWQgYW5kIHVwZGF0ZXMgdGhlIG1hcCBpZiBzbyDigJRcclxuICBcdC8vIGNhbGwgaXQgYWZ0ZXIgeW91J3ZlIGNoYW5nZWQgdGhlIG1hcCBzaXplIGR5bmFtaWNhbGx5LCBhbHNvIGFuaW1hdGluZ1xyXG4gIFx0Ly8gcGFuIGJ5IGRlZmF1bHQuIElmIGBvcHRpb25zLnBhbmAgaXMgYGZhbHNlYCwgcGFubmluZyB3aWxsIG5vdCBvY2N1ci5cclxuICBcdC8vIElmIGBvcHRpb25zLmRlYm91bmNlTW92ZWVuZGAgaXMgYHRydWVgLCBpdCB3aWxsIGRlbGF5IGBtb3ZlZW5kYCBldmVudCBzb1xyXG4gIFx0Ly8gdGhhdCBpdCBkb2Vzbid0IGhhcHBlbiBvZnRlbiBldmVuIGlmIHRoZSBtZXRob2QgaXMgY2FsbGVkIG1hbnlcclxuICBcdC8vIHRpbWVzIGluIGEgcm93LlxyXG5cclxuICBcdC8vIEBhbHRlcm5hdGl2ZVxyXG4gIFx0Ly8gQG1ldGhvZCBpbnZhbGlkYXRlU2l6ZShhbmltYXRlOiBCb29sZWFuKTogdGhpc1xyXG4gIFx0Ly8gQ2hlY2tzIGlmIHRoZSBtYXAgY29udGFpbmVyIHNpemUgY2hhbmdlZCBhbmQgdXBkYXRlcyB0aGUgbWFwIGlmIHNvIOKAlFxyXG4gIFx0Ly8gY2FsbCBpdCBhZnRlciB5b3UndmUgY2hhbmdlZCB0aGUgbWFwIHNpemUgZHluYW1pY2FsbHksIGFsc28gYW5pbWF0aW5nXHJcbiAgXHQvLyBwYW4gYnkgZGVmYXVsdC5cclxuICBcdGludmFsaWRhdGVTaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gIFx0XHRpZiAoIXRoaXMuX2xvYWRlZCkgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuICBcdFx0b3B0aW9ucyA9IGV4dGVuZCh7XHJcbiAgXHRcdFx0YW5pbWF0ZTogZmFsc2UsXHJcbiAgXHRcdFx0cGFuOiB0cnVlXHJcbiAgXHRcdH0sIG9wdGlvbnMgPT09IHRydWUgPyB7YW5pbWF0ZTogdHJ1ZX0gOiBvcHRpb25zKTtcclxuXHJcbiAgXHRcdHZhciBvbGRTaXplID0gdGhpcy5nZXRTaXplKCk7XHJcbiAgXHRcdHRoaXMuX3NpemVDaGFuZ2VkID0gdHJ1ZTtcclxuICBcdFx0dGhpcy5fbGFzdENlbnRlciA9IG51bGw7XHJcblxyXG4gIFx0XHR2YXIgbmV3U2l6ZSA9IHRoaXMuZ2V0U2l6ZSgpLFxyXG4gIFx0XHQgICAgb2xkQ2VudGVyID0gb2xkU2l6ZS5kaXZpZGVCeSgyKS5yb3VuZCgpLFxyXG4gIFx0XHQgICAgbmV3Q2VudGVyID0gbmV3U2l6ZS5kaXZpZGVCeSgyKS5yb3VuZCgpLFxyXG4gIFx0XHQgICAgb2Zmc2V0ID0gb2xkQ2VudGVyLnN1YnRyYWN0KG5ld0NlbnRlcik7XHJcblxyXG4gIFx0XHRpZiAoIW9mZnNldC54ICYmICFvZmZzZXQueSkgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuICBcdFx0aWYgKG9wdGlvbnMuYW5pbWF0ZSAmJiBvcHRpb25zLnBhbikge1xyXG4gIFx0XHRcdHRoaXMucGFuQnkob2Zmc2V0KTtcclxuXHJcbiAgXHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0aWYgKG9wdGlvbnMucGFuKSB7XHJcbiAgXHRcdFx0XHR0aGlzLl9yYXdQYW5CeShvZmZzZXQpO1xyXG4gIFx0XHRcdH1cclxuXHJcbiAgXHRcdFx0dGhpcy5maXJlKCdtb3ZlJyk7XHJcblxyXG4gIFx0XHRcdGlmIChvcHRpb25zLmRlYm91bmNlTW92ZWVuZCkge1xyXG4gIFx0XHRcdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX3NpemVUaW1lcik7XHJcbiAgXHRcdFx0XHR0aGlzLl9zaXplVGltZXIgPSBzZXRUaW1lb3V0KGJpbmQodGhpcy5maXJlLCB0aGlzLCAnbW92ZWVuZCcpLCAyMDApO1xyXG4gIFx0XHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0XHR0aGlzLmZpcmUoJ21vdmVlbmQnKTtcclxuICBcdFx0XHR9XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdC8vIEBzZWN0aW9uIE1hcCBzdGF0ZSBjaGFuZ2UgZXZlbnRzXHJcbiAgXHRcdC8vIEBldmVudCByZXNpemU6IFJlc2l6ZUV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcCBpcyByZXNpemVkLlxyXG4gIFx0XHRyZXR1cm4gdGhpcy5maXJlKCdyZXNpemUnLCB7XHJcbiAgXHRcdFx0b2xkU2l6ZTogb2xkU2l6ZSxcclxuICBcdFx0XHRuZXdTaXplOiBuZXdTaXplXHJcbiAgXHRcdH0pO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAc2VjdGlvbiBNZXRob2RzIGZvciBtb2RpZnlpbmcgbWFwIHN0YXRlXHJcbiAgXHQvLyBAbWV0aG9kIHN0b3AoKTogdGhpc1xyXG4gIFx0Ly8gU3RvcHMgdGhlIGN1cnJlbnRseSBydW5uaW5nIGBwYW5Ub2Agb3IgYGZseVRvYCBhbmltYXRpb24sIGlmIGFueS5cclxuICBcdHN0b3A6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dGhpcy5zZXRab29tKHRoaXMuX2xpbWl0Wm9vbSh0aGlzLl96b29tKSk7XHJcbiAgXHRcdGlmICghdGhpcy5vcHRpb25zLnpvb21TbmFwKSB7XHJcbiAgXHRcdFx0dGhpcy5maXJlKCd2aWV3cmVzZXQnKTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gdGhpcy5fc3RvcCgpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAc2VjdGlvbiBHZW9sb2NhdGlvbiBtZXRob2RzXHJcbiAgXHQvLyBAbWV0aG9kIGxvY2F0ZShvcHRpb25zPzogTG9jYXRlIG9wdGlvbnMpOiB0aGlzXHJcbiAgXHQvLyBUcmllcyB0byBsb2NhdGUgdGhlIHVzZXIgdXNpbmcgdGhlIEdlb2xvY2F0aW9uIEFQSSwgZmlyaW5nIGEgW2Bsb2NhdGlvbmZvdW5kYF0oI21hcC1sb2NhdGlvbmZvdW5kKVxyXG4gIFx0Ly8gZXZlbnQgd2l0aCBsb2NhdGlvbiBkYXRhIG9uIHN1Y2Nlc3Mgb3IgYSBbYGxvY2F0aW9uZXJyb3JgXSgjbWFwLWxvY2F0aW9uZXJyb3IpIGV2ZW50IG9uIGZhaWx1cmUsXHJcbiAgXHQvLyBhbmQgb3B0aW9uYWxseSBzZXRzIHRoZSBtYXAgdmlldyB0byB0aGUgdXNlcidzIGxvY2F0aW9uIHdpdGggcmVzcGVjdCB0b1xyXG4gIFx0Ly8gZGV0ZWN0aW9uIGFjY3VyYWN5IChvciB0byB0aGUgd29ybGQgdmlldyBpZiBnZW9sb2NhdGlvbiBmYWlsZWQpLlxyXG4gIFx0Ly8gTm90ZSB0aGF0LCBpZiB5b3VyIHBhZ2UgZG9lc24ndCB1c2UgSFRUUFMsIHRoaXMgbWV0aG9kIHdpbGwgZmFpbCBpblxyXG4gIFx0Ly8gbW9kZXJuIGJyb3dzZXJzIChbQ2hyb21lIDUwIGFuZCBuZXdlcl0oaHR0cHM6Ly9zaXRlcy5nb29nbGUuY29tL2EvY2hyb21pdW0ub3JnL2Rldi9Ib21lL2Nocm9taXVtLXNlY3VyaXR5L2RlcHJlY2F0aW5nLXBvd2VyZnVsLWZlYXR1cmVzLW9uLWluc2VjdXJlLW9yaWdpbnMpKVxyXG4gIFx0Ly8gU2VlIGBMb2NhdGUgb3B0aW9uc2AgZm9yIG1vcmUgZGV0YWlscy5cclxuICBcdGxvY2F0ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHJcbiAgXHRcdG9wdGlvbnMgPSB0aGlzLl9sb2NhdGVPcHRpb25zID0gZXh0ZW5kKHtcclxuICBcdFx0XHR0aW1lb3V0OiAxMDAwMCxcclxuICBcdFx0XHR3YXRjaDogZmFsc2VcclxuICBcdFx0XHQvLyBzZXRWaWV3OiBmYWxzZVxyXG4gIFx0XHRcdC8vIG1heFpvb206IDxOdW1iZXI+XHJcbiAgXHRcdFx0Ly8gbWF4aW11bUFnZTogMFxyXG4gIFx0XHRcdC8vIGVuYWJsZUhpZ2hBY2N1cmFjeTogZmFsc2VcclxuICBcdFx0fSwgb3B0aW9ucyk7XHJcblxyXG4gIFx0XHRpZiAoISgnZ2VvbG9jYXRpb24nIGluIG5hdmlnYXRvcikpIHtcclxuICBcdFx0XHR0aGlzLl9oYW5kbGVHZW9sb2NhdGlvbkVycm9yKHtcclxuICBcdFx0XHRcdGNvZGU6IDAsXHJcbiAgXHRcdFx0XHRtZXNzYWdlOiAnR2VvbG9jYXRpb24gbm90IHN1cHBvcnRlZC4nXHJcbiAgXHRcdFx0fSk7XHJcbiAgXHRcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHZhciBvblJlc3BvbnNlID0gYmluZCh0aGlzLl9oYW5kbGVHZW9sb2NhdGlvblJlc3BvbnNlLCB0aGlzKSxcclxuICBcdFx0ICAgIG9uRXJyb3IgPSBiaW5kKHRoaXMuX2hhbmRsZUdlb2xvY2F0aW9uRXJyb3IsIHRoaXMpO1xyXG5cclxuICBcdFx0aWYgKG9wdGlvbnMud2F0Y2gpIHtcclxuICBcdFx0XHR0aGlzLl9sb2NhdGlvbldhdGNoSWQgPVxyXG4gIFx0XHRcdCAgICAgICAgbmF2aWdhdG9yLmdlb2xvY2F0aW9uLndhdGNoUG9zaXRpb24ob25SZXNwb25zZSwgb25FcnJvciwgb3B0aW9ucyk7XHJcbiAgXHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0bmF2aWdhdG9yLmdlb2xvY2F0aW9uLmdldEN1cnJlbnRQb3NpdGlvbihvblJlc3BvbnNlLCBvbkVycm9yLCBvcHRpb25zKTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBzdG9wTG9jYXRlKCk6IHRoaXNcclxuICBcdC8vIFN0b3BzIHdhdGNoaW5nIGxvY2F0aW9uIHByZXZpb3VzbHkgaW5pdGlhdGVkIGJ5IGBtYXAubG9jYXRlKHt3YXRjaDogdHJ1ZX0pYFxyXG4gIFx0Ly8gYW5kIGFib3J0cyByZXNldHRpbmcgdGhlIG1hcCB2aWV3IGlmIG1hcC5sb2NhdGUgd2FzIGNhbGxlZCB3aXRoXHJcbiAgXHQvLyBge3NldFZpZXc6IHRydWV9YC5cclxuICBcdHN0b3BMb2NhdGU6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0aWYgKG5hdmlnYXRvci5nZW9sb2NhdGlvbiAmJiBuYXZpZ2F0b3IuZ2VvbG9jYXRpb24uY2xlYXJXYXRjaCkge1xyXG4gIFx0XHRcdG5hdmlnYXRvci5nZW9sb2NhdGlvbi5jbGVhcldhdGNoKHRoaXMuX2xvY2F0aW9uV2F0Y2hJZCk7XHJcbiAgXHRcdH1cclxuICBcdFx0aWYgKHRoaXMuX2xvY2F0ZU9wdGlvbnMpIHtcclxuICBcdFx0XHR0aGlzLl9sb2NhdGVPcHRpb25zLnNldFZpZXcgPSBmYWxzZTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0X2hhbmRsZUdlb2xvY2F0aW9uRXJyb3I6IGZ1bmN0aW9uIChlcnJvcikge1xyXG4gIFx0XHR2YXIgYyA9IGVycm9yLmNvZGUsXHJcbiAgXHRcdCAgICBtZXNzYWdlID0gZXJyb3IubWVzc2FnZSB8fFxyXG4gIFx0XHQgICAgICAgICAgICAoYyA9PT0gMSA/ICdwZXJtaXNzaW9uIGRlbmllZCcgOlxyXG4gIFx0XHQgICAgICAgICAgICAoYyA9PT0gMiA/ICdwb3NpdGlvbiB1bmF2YWlsYWJsZScgOiAndGltZW91dCcpKTtcclxuXHJcbiAgXHRcdGlmICh0aGlzLl9sb2NhdGVPcHRpb25zLnNldFZpZXcgJiYgIXRoaXMuX2xvYWRlZCkge1xyXG4gIFx0XHRcdHRoaXMuZml0V29ybGQoKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0Ly8gQHNlY3Rpb24gTG9jYXRpb24gZXZlbnRzXHJcbiAgXHRcdC8vIEBldmVudCBsb2NhdGlvbmVycm9yOiBFcnJvckV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIHdoZW4gZ2VvbG9jYXRpb24gKHVzaW5nIHRoZSBbYGxvY2F0ZWBdKCNtYXAtbG9jYXRlKSBtZXRob2QpIGZhaWxlZC5cclxuICBcdFx0dGhpcy5maXJlKCdsb2NhdGlvbmVycm9yJywge1xyXG4gIFx0XHRcdGNvZGU6IGMsXHJcbiAgXHRcdFx0bWVzc2FnZTogJ0dlb2xvY2F0aW9uIGVycm9yOiAnICsgbWVzc2FnZSArICcuJ1xyXG4gIFx0XHR9KTtcclxuICBcdH0sXHJcblxyXG4gIFx0X2hhbmRsZUdlb2xvY2F0aW9uUmVzcG9uc2U6IGZ1bmN0aW9uIChwb3MpIHtcclxuICBcdFx0dmFyIGxhdCA9IHBvcy5jb29yZHMubGF0aXR1ZGUsXHJcbiAgXHRcdCAgICBsbmcgPSBwb3MuY29vcmRzLmxvbmdpdHVkZSxcclxuICBcdFx0ICAgIGxhdGxuZyA9IG5ldyBMYXRMbmcobGF0LCBsbmcpLFxyXG4gIFx0XHQgICAgYm91bmRzID0gbGF0bG5nLnRvQm91bmRzKHBvcy5jb29yZHMuYWNjdXJhY3kgKiAyKSxcclxuICBcdFx0ICAgIG9wdGlvbnMgPSB0aGlzLl9sb2NhdGVPcHRpb25zO1xyXG5cclxuICBcdFx0aWYgKG9wdGlvbnMuc2V0Vmlldykge1xyXG4gIFx0XHRcdHZhciB6b29tID0gdGhpcy5nZXRCb3VuZHNab29tKGJvdW5kcyk7XHJcbiAgXHRcdFx0dGhpcy5zZXRWaWV3KGxhdGxuZywgb3B0aW9ucy5tYXhab29tID8gTWF0aC5taW4oem9vbSwgb3B0aW9ucy5tYXhab29tKSA6IHpvb20pO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR2YXIgZGF0YSA9IHtcclxuICBcdFx0XHRsYXRsbmc6IGxhdGxuZyxcclxuICBcdFx0XHRib3VuZHM6IGJvdW5kcyxcclxuICBcdFx0XHR0aW1lc3RhbXA6IHBvcy50aW1lc3RhbXBcclxuICBcdFx0fTtcclxuXHJcbiAgXHRcdGZvciAodmFyIGkgaW4gcG9zLmNvb3Jkcykge1xyXG4gIFx0XHRcdGlmICh0eXBlb2YgcG9zLmNvb3Jkc1tpXSA9PT0gJ251bWJlcicpIHtcclxuICBcdFx0XHRcdGRhdGFbaV0gPSBwb3MuY29vcmRzW2ldO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0fVxyXG5cclxuICBcdFx0Ly8gQGV2ZW50IGxvY2F0aW9uZm91bmQ6IExvY2F0aW9uRXZlbnRcclxuICBcdFx0Ly8gRmlyZWQgd2hlbiBnZW9sb2NhdGlvbiAodXNpbmcgdGhlIFtgbG9jYXRlYF0oI21hcC1sb2NhdGUpIG1ldGhvZClcclxuICBcdFx0Ly8gd2VudCBzdWNjZXNzZnVsbHkuXHJcbiAgXHRcdHRoaXMuZmlyZSgnbG9jYXRpb25mb3VuZCcsIGRhdGEpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBUT0RPIEFwcHJvcHJpYXRlIGRvY3Mgc2VjdGlvbj9cclxuICBcdC8vIEBzZWN0aW9uIE90aGVyIE1ldGhvZHNcclxuICBcdC8vIEBtZXRob2QgYWRkSGFuZGxlcihuYW1lOiBTdHJpbmcsIEhhbmRsZXJDbGFzczogRnVuY3Rpb24pOiB0aGlzXHJcbiAgXHQvLyBBZGRzIGEgbmV3IGBIYW5kbGVyYCB0byB0aGUgbWFwLCBnaXZlbiBpdHMgbmFtZSBhbmQgY29uc3RydWN0b3IgZnVuY3Rpb24uXHJcbiAgXHRhZGRIYW5kbGVyOiBmdW5jdGlvbiAobmFtZSwgSGFuZGxlckNsYXNzKSB7XHJcbiAgXHRcdGlmICghSGFuZGxlckNsYXNzKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG4gIFx0XHR2YXIgaGFuZGxlciA9IHRoaXNbbmFtZV0gPSBuZXcgSGFuZGxlckNsYXNzKHRoaXMpO1xyXG5cclxuICBcdFx0dGhpcy5faGFuZGxlcnMucHVzaChoYW5kbGVyKTtcclxuXHJcbiAgXHRcdGlmICh0aGlzLm9wdGlvbnNbbmFtZV0pIHtcclxuICBcdFx0XHRoYW5kbGVyLmVuYWJsZSgpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCByZW1vdmUoKTogdGhpc1xyXG4gIFx0Ly8gRGVzdHJveXMgdGhlIG1hcCBhbmQgY2xlYXJzIGFsbCByZWxhdGVkIGV2ZW50IGxpc3RlbmVycy5cclxuICBcdHJlbW92ZTogZnVuY3Rpb24gKCkge1xyXG5cclxuICBcdFx0dGhpcy5faW5pdEV2ZW50cyh0cnVlKTtcclxuICBcdFx0dGhpcy5vZmYoJ21vdmVlbmQnLCB0aGlzLl9wYW5JbnNpZGVNYXhCb3VuZHMpO1xyXG5cclxuICBcdFx0aWYgKHRoaXMuX2NvbnRhaW5lcklkICE9PSB0aGlzLl9jb250YWluZXIuX2xlYWZsZXRfaWQpIHtcclxuICBcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ01hcCBjb250YWluZXIgaXMgYmVpbmcgcmV1c2VkIGJ5IGFub3RoZXIgaW5zdGFuY2UnKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dHJ5IHtcclxuICBcdFx0XHQvLyB0aHJvd3MgZXJyb3IgaW4gSUU2LThcclxuICBcdFx0XHRkZWxldGUgdGhpcy5fY29udGFpbmVyLl9sZWFmbGV0X2lkO1xyXG4gIFx0XHRcdGRlbGV0ZSB0aGlzLl9jb250YWluZXJJZDtcclxuICBcdFx0fSBjYXRjaCAoZSkge1xyXG4gIFx0XHRcdC8qZXNsaW50LWRpc2FibGUgKi9cclxuICBcdFx0XHR0aGlzLl9jb250YWluZXIuX2xlYWZsZXRfaWQgPSB1bmRlZmluZWQ7XHJcbiAgXHRcdFx0LyogZXNsaW50LWVuYWJsZSAqL1xyXG4gIFx0XHRcdHRoaXMuX2NvbnRhaW5lcklkID0gdW5kZWZpbmVkO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRpZiAodGhpcy5fbG9jYXRpb25XYXRjaElkICE9PSB1bmRlZmluZWQpIHtcclxuICBcdFx0XHR0aGlzLnN0b3BMb2NhdGUoKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dGhpcy5fc3RvcCgpO1xyXG5cclxuICBcdFx0cmVtb3ZlKHRoaXMuX21hcFBhbmUpO1xyXG5cclxuICBcdFx0aWYgKHRoaXMuX2NsZWFyQ29udHJvbFBvcykge1xyXG4gIFx0XHRcdHRoaXMuX2NsZWFyQ29udHJvbFBvcygpO1xyXG4gIFx0XHR9XHJcbiAgXHRcdGlmICh0aGlzLl9yZXNpemVSZXF1ZXN0KSB7XHJcbiAgXHRcdFx0Y2FuY2VsQW5pbUZyYW1lKHRoaXMuX3Jlc2l6ZVJlcXVlc3QpO1xyXG4gIFx0XHRcdHRoaXMuX3Jlc2l6ZVJlcXVlc3QgPSBudWxsO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR0aGlzLl9jbGVhckhhbmRsZXJzKCk7XHJcblxyXG4gIFx0XHRpZiAodGhpcy5fbG9hZGVkKSB7XHJcbiAgXHRcdFx0Ly8gQHNlY3Rpb24gTWFwIHN0YXRlIGNoYW5nZSBldmVudHNcclxuICBcdFx0XHQvLyBAZXZlbnQgdW5sb2FkOiBFdmVudFxyXG4gIFx0XHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcCBpcyBkZXN0cm95ZWQgd2l0aCBbcmVtb3ZlXSgjbWFwLXJlbW92ZSkgbWV0aG9kLlxyXG4gIFx0XHRcdHRoaXMuZmlyZSgndW5sb2FkJyk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHZhciBpO1xyXG4gIFx0XHRmb3IgKGkgaW4gdGhpcy5fbGF5ZXJzKSB7XHJcbiAgXHRcdFx0dGhpcy5fbGF5ZXJzW2ldLnJlbW92ZSgpO1xyXG4gIFx0XHR9XHJcbiAgXHRcdGZvciAoaSBpbiB0aGlzLl9wYW5lcykge1xyXG4gIFx0XHRcdHJlbW92ZSh0aGlzLl9wYW5lc1tpXSk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMuX2xheWVycyA9IFtdO1xyXG4gIFx0XHR0aGlzLl9wYW5lcyA9IFtdO1xyXG4gIFx0XHRkZWxldGUgdGhpcy5fbWFwUGFuZTtcclxuICBcdFx0ZGVsZXRlIHRoaXMuX3JlbmRlcmVyO1xyXG5cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBzZWN0aW9uIE90aGVyIE1ldGhvZHNcclxuICBcdC8vIEBtZXRob2QgY3JlYXRlUGFuZShuYW1lOiBTdHJpbmcsIGNvbnRhaW5lcj86IEhUTUxFbGVtZW50KTogSFRNTEVsZW1lbnRcclxuICBcdC8vIENyZWF0ZXMgYSBuZXcgW21hcCBwYW5lXSgjbWFwLXBhbmUpIHdpdGggdGhlIGdpdmVuIG5hbWUgaWYgaXQgZG9lc24ndCBleGlzdCBhbHJlYWR5LFxyXG4gIFx0Ly8gdGhlbiByZXR1cm5zIGl0LiBUaGUgcGFuZSBpcyBjcmVhdGVkIGFzIGEgY2hpbGQgb2YgYGNvbnRhaW5lcmAsIG9yXHJcbiAgXHQvLyBhcyBhIGNoaWxkIG9mIHRoZSBtYWluIG1hcCBwYW5lIGlmIG5vdCBzZXQuXHJcbiAgXHRjcmVhdGVQYW5lOiBmdW5jdGlvbiAobmFtZSwgY29udGFpbmVyKSB7XHJcbiAgXHRcdHZhciBjbGFzc05hbWUgPSAnbGVhZmxldC1wYW5lJyArIChuYW1lID8gJyBsZWFmbGV0LScgKyBuYW1lLnJlcGxhY2UoJ1BhbmUnLCAnJykgKyAnLXBhbmUnIDogJycpLFxyXG4gIFx0XHQgICAgcGFuZSA9IGNyZWF0ZSQxKCdkaXYnLCBjbGFzc05hbWUsIGNvbnRhaW5lciB8fCB0aGlzLl9tYXBQYW5lKTtcclxuXHJcbiAgXHRcdGlmIChuYW1lKSB7XHJcbiAgXHRcdFx0dGhpcy5fcGFuZXNbbmFtZV0gPSBwYW5lO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiBwYW5lO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAc2VjdGlvbiBNZXRob2RzIGZvciBHZXR0aW5nIE1hcCBTdGF0ZVxyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0Q2VudGVyKCk6IExhdExuZ1xyXG4gIFx0Ly8gUmV0dXJucyB0aGUgZ2VvZ3JhcGhpY2FsIGNlbnRlciBvZiB0aGUgbWFwIHZpZXdcclxuICBcdGdldENlbnRlcjogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR0aGlzLl9jaGVja0lmTG9hZGVkKCk7XHJcblxyXG4gIFx0XHRpZiAodGhpcy5fbGFzdENlbnRlciAmJiAhdGhpcy5fbW92ZWQoKSkge1xyXG4gIFx0XHRcdHJldHVybiB0aGlzLl9sYXN0Q2VudGVyO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiB0aGlzLmxheWVyUG9pbnRUb0xhdExuZyh0aGlzLl9nZXRDZW50ZXJMYXllclBvaW50KCkpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldFpvb20oKTogTnVtYmVyXHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBjdXJyZW50IHpvb20gbGV2ZWwgb2YgdGhlIG1hcCB2aWV3XHJcbiAgXHRnZXRab29tOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLl96b29tO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldEJvdW5kcygpOiBMYXRMbmdCb3VuZHNcclxuICBcdC8vIFJldHVybnMgdGhlIGdlb2dyYXBoaWNhbCBib3VuZHMgdmlzaWJsZSBpbiB0aGUgY3VycmVudCBtYXAgdmlld1xyXG4gIFx0Z2V0Qm91bmRzOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHZhciBib3VuZHMgPSB0aGlzLmdldFBpeGVsQm91bmRzKCksXHJcbiAgXHRcdCAgICBzdyA9IHRoaXMudW5wcm9qZWN0KGJvdW5kcy5nZXRCb3R0b21MZWZ0KCkpLFxyXG4gIFx0XHQgICAgbmUgPSB0aGlzLnVucHJvamVjdChib3VuZHMuZ2V0VG9wUmlnaHQoKSk7XHJcblxyXG4gIFx0XHRyZXR1cm4gbmV3IExhdExuZ0JvdW5kcyhzdywgbmUpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldE1pblpvb20oKTogTnVtYmVyXHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBtaW5pbXVtIHpvb20gbGV2ZWwgb2YgdGhlIG1hcCAoaWYgc2V0IGluIHRoZSBgbWluWm9vbWAgb3B0aW9uIG9mIHRoZSBtYXAgb3Igb2YgYW55IGxheWVycyksIG9yIGAwYCBieSBkZWZhdWx0LlxyXG4gIFx0Z2V0TWluWm9vbTogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLm1pblpvb20gPT09IHVuZGVmaW5lZCA/IHRoaXMuX2xheWVyc01pblpvb20gfHwgMCA6IHRoaXMub3B0aW9ucy5taW5ab29tO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldE1heFpvb20oKTogTnVtYmVyXHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBtYXhpbXVtIHpvb20gbGV2ZWwgb2YgdGhlIG1hcCAoaWYgc2V0IGluIHRoZSBgbWF4Wm9vbWAgb3B0aW9uIG9mIHRoZSBtYXAgb3Igb2YgYW55IGxheWVycykuXHJcbiAgXHRnZXRNYXhab29tOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLm9wdGlvbnMubWF4Wm9vbSA9PT0gdW5kZWZpbmVkID9cclxuICBcdFx0XHQodGhpcy5fbGF5ZXJzTWF4Wm9vbSA9PT0gdW5kZWZpbmVkID8gSW5maW5pdHkgOiB0aGlzLl9sYXllcnNNYXhab29tKSA6XHJcbiAgXHRcdFx0dGhpcy5vcHRpb25zLm1heFpvb207XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0Qm91bmRzWm9vbShib3VuZHM6IExhdExuZ0JvdW5kcywgaW5zaWRlPzogQm9vbGVhbiwgcGFkZGluZz86IFBvaW50KTogTnVtYmVyXHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBtYXhpbXVtIHpvb20gbGV2ZWwgb24gd2hpY2ggdGhlIGdpdmVuIGJvdW5kcyBmaXQgdG8gdGhlIG1hcFxyXG4gIFx0Ly8gdmlldyBpbiBpdHMgZW50aXJldHkuIElmIGBpbnNpZGVgIChvcHRpb25hbCkgaXMgc2V0IHRvIGB0cnVlYCwgdGhlIG1ldGhvZFxyXG4gIFx0Ly8gaW5zdGVhZCByZXR1cm5zIHRoZSBtaW5pbXVtIHpvb20gbGV2ZWwgb24gd2hpY2ggdGhlIG1hcCB2aWV3IGZpdHMgaW50b1xyXG4gIFx0Ly8gdGhlIGdpdmVuIGJvdW5kcyBpbiBpdHMgZW50aXJldHkuXHJcbiAgXHRnZXRCb3VuZHNab29tOiBmdW5jdGlvbiAoYm91bmRzLCBpbnNpZGUsIHBhZGRpbmcpIHsgLy8gKExhdExuZ0JvdW5kc1ssIEJvb2xlYW4sIFBvaW50XSkgLT4gTnVtYmVyXHJcbiAgXHRcdGJvdW5kcyA9IHRvTGF0TG5nQm91bmRzKGJvdW5kcyk7XHJcbiAgXHRcdHBhZGRpbmcgPSB0b1BvaW50KHBhZGRpbmcgfHwgWzAsIDBdKTtcclxuXHJcbiAgXHRcdHZhciB6b29tID0gdGhpcy5nZXRab29tKCkgfHwgMCxcclxuICBcdFx0ICAgIG1pbiA9IHRoaXMuZ2V0TWluWm9vbSgpLFxyXG4gIFx0XHQgICAgbWF4ID0gdGhpcy5nZXRNYXhab29tKCksXHJcbiAgXHRcdCAgICBudyA9IGJvdW5kcy5nZXROb3J0aFdlc3QoKSxcclxuICBcdFx0ICAgIHNlID0gYm91bmRzLmdldFNvdXRoRWFzdCgpLFxyXG4gIFx0XHQgICAgc2l6ZSA9IHRoaXMuZ2V0U2l6ZSgpLnN1YnRyYWN0KHBhZGRpbmcpLFxyXG4gIFx0XHQgICAgYm91bmRzU2l6ZSA9IHRvQm91bmRzKHRoaXMucHJvamVjdChzZSwgem9vbSksIHRoaXMucHJvamVjdChudywgem9vbSkpLmdldFNpemUoKSxcclxuICBcdFx0ICAgIHNuYXAgPSBhbnkzZCA/IHRoaXMub3B0aW9ucy56b29tU25hcCA6IDEsXHJcbiAgXHRcdCAgICBzY2FsZXggPSBzaXplLnggLyBib3VuZHNTaXplLngsXHJcbiAgXHRcdCAgICBzY2FsZXkgPSBzaXplLnkgLyBib3VuZHNTaXplLnksXHJcbiAgXHRcdCAgICBzY2FsZSA9IGluc2lkZSA/IE1hdGgubWF4KHNjYWxleCwgc2NhbGV5KSA6IE1hdGgubWluKHNjYWxleCwgc2NhbGV5KTtcclxuXHJcbiAgXHRcdHpvb20gPSB0aGlzLmdldFNjYWxlWm9vbShzY2FsZSwgem9vbSk7XHJcblxyXG4gIFx0XHRpZiAoc25hcCkge1xyXG4gIFx0XHRcdHpvb20gPSBNYXRoLnJvdW5kKHpvb20gLyAoc25hcCAvIDEwMCkpICogKHNuYXAgLyAxMDApOyAvLyBkb24ndCBqdW1wIGlmIHdpdGhpbiAxJSBvZiBhIHNuYXAgbGV2ZWxcclxuICBcdFx0XHR6b29tID0gaW5zaWRlID8gTWF0aC5jZWlsKHpvb20gLyBzbmFwKSAqIHNuYXAgOiBNYXRoLmZsb29yKHpvb20gLyBzbmFwKSAqIHNuYXA7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHJldHVybiBNYXRoLm1heChtaW4sIE1hdGgubWluKG1heCwgem9vbSkpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldFNpemUoKTogUG9pbnRcclxuICBcdC8vIFJldHVybnMgdGhlIGN1cnJlbnQgc2l6ZSBvZiB0aGUgbWFwIGNvbnRhaW5lciAoaW4gcGl4ZWxzKS5cclxuICBcdGdldFNpemU6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0aWYgKCF0aGlzLl9zaXplIHx8IHRoaXMuX3NpemVDaGFuZ2VkKSB7XHJcbiAgXHRcdFx0dGhpcy5fc2l6ZSA9IG5ldyBQb2ludChcclxuICBcdFx0XHRcdHRoaXMuX2NvbnRhaW5lci5jbGllbnRXaWR0aCB8fCAwLFxyXG4gIFx0XHRcdFx0dGhpcy5fY29udGFpbmVyLmNsaWVudEhlaWdodCB8fCAwKTtcclxuXHJcbiAgXHRcdFx0dGhpcy5fc2l6ZUNoYW5nZWQgPSBmYWxzZTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gdGhpcy5fc2l6ZS5jbG9uZSgpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldFBpeGVsQm91bmRzKCk6IEJvdW5kc1xyXG4gIFx0Ly8gUmV0dXJucyB0aGUgYm91bmRzIG9mIHRoZSBjdXJyZW50IG1hcCB2aWV3IGluIHByb2plY3RlZCBwaXhlbFxyXG4gIFx0Ly8gY29vcmRpbmF0ZXMgKHNvbWV0aW1lcyB1c2VmdWwgaW4gbGF5ZXIgYW5kIG92ZXJsYXkgaW1wbGVtZW50YXRpb25zKS5cclxuICBcdGdldFBpeGVsQm91bmRzOiBmdW5jdGlvbiAoY2VudGVyLCB6b29tKSB7XHJcbiAgXHRcdHZhciB0b3BMZWZ0UG9pbnQgPSB0aGlzLl9nZXRUb3BMZWZ0UG9pbnQoY2VudGVyLCB6b29tKTtcclxuICBcdFx0cmV0dXJuIG5ldyBCb3VuZHModG9wTGVmdFBvaW50LCB0b3BMZWZ0UG9pbnQuYWRkKHRoaXMuZ2V0U2l6ZSgpKSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIFRPRE86IENoZWNrIHNlbWFudGljcyAtIGlzbid0IHRoZSBwaXhlbCBvcmlnaW4gdGhlIDAsMCBjb29yZCByZWxhdGl2ZSB0b1xyXG4gIFx0Ly8gdGhlIG1hcCBwYW5lPyBcImxlZnQgcG9pbnQgb2YgdGhlIG1hcCBsYXllclwiIGNhbiBiZSBjb25mdXNpbmcsIHNwZWNpYWxseVxyXG4gIFx0Ly8gc2luY2UgdGhlcmUgY2FuIGJlIG5lZ2F0aXZlIG9mZnNldHMuXHJcbiAgXHQvLyBAbWV0aG9kIGdldFBpeGVsT3JpZ2luKCk6IFBvaW50XHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBwcm9qZWN0ZWQgcGl4ZWwgY29vcmRpbmF0ZXMgb2YgdGhlIHRvcCBsZWZ0IHBvaW50IG9mXHJcbiAgXHQvLyB0aGUgbWFwIGxheWVyICh1c2VmdWwgaW4gY3VzdG9tIGxheWVyIGFuZCBvdmVybGF5IGltcGxlbWVudGF0aW9ucykuXHJcbiAgXHRnZXRQaXhlbE9yaWdpbjogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR0aGlzLl9jaGVja0lmTG9hZGVkKCk7XHJcbiAgXHRcdHJldHVybiB0aGlzLl9waXhlbE9yaWdpbjtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRQaXhlbFdvcmxkQm91bmRzKHpvb20/OiBOdW1iZXIpOiBCb3VuZHNcclxuICBcdC8vIFJldHVybnMgdGhlIHdvcmxkJ3MgYm91bmRzIGluIHBpeGVsIGNvb3JkaW5hdGVzIGZvciB6b29tIGxldmVsIGB6b29tYC5cclxuICBcdC8vIElmIGB6b29tYCBpcyBvbWl0dGVkLCB0aGUgbWFwJ3MgY3VycmVudCB6b29tIGxldmVsIGlzIHVzZWQuXHJcbiAgXHRnZXRQaXhlbFdvcmxkQm91bmRzOiBmdW5jdGlvbiAoem9vbSkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmNycy5nZXRQcm9qZWN0ZWRCb3VuZHMoem9vbSA9PT0gdW5kZWZpbmVkID8gdGhpcy5nZXRab29tKCkgOiB6b29tKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQHNlY3Rpb24gT3RoZXIgTWV0aG9kc1xyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0UGFuZShwYW5lOiBTdHJpbmd8SFRNTEVsZW1lbnQpOiBIVE1MRWxlbWVudFxyXG4gIFx0Ly8gUmV0dXJucyBhIFttYXAgcGFuZV0oI21hcC1wYW5lKSwgZ2l2ZW4gaXRzIG5hbWUgb3IgaXRzIEhUTUwgZWxlbWVudCAoaXRzIGlkZW50aXR5KS5cclxuICBcdGdldFBhbmU6IGZ1bmN0aW9uIChwYW5lKSB7XHJcbiAgXHRcdHJldHVybiB0eXBlb2YgcGFuZSA9PT0gJ3N0cmluZycgPyB0aGlzLl9wYW5lc1twYW5lXSA6IHBhbmU7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0UGFuZXMoKTogT2JqZWN0XHJcbiAgXHQvLyBSZXR1cm5zIGEgcGxhaW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG5hbWVzIG9mIGFsbCBbcGFuZXNdKCNtYXAtcGFuZSkgYXMga2V5cyBhbmRcclxuICBcdC8vIHRoZSBwYW5lcyBhcyB2YWx1ZXMuXHJcbiAgXHRnZXRQYW5lczogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5fcGFuZXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0Q29udGFpbmVyOiBIVE1MRWxlbWVudFxyXG4gIFx0Ly8gUmV0dXJucyB0aGUgSFRNTCBlbGVtZW50IHRoYXQgY29udGFpbnMgdGhlIG1hcC5cclxuICBcdGdldENvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5fY29udGFpbmVyO1xyXG4gIFx0fSxcclxuXHJcblxyXG4gIFx0Ly8gQHNlY3Rpb24gQ29udmVyc2lvbiBNZXRob2RzXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRab29tU2NhbGUodG9ab29tOiBOdW1iZXIsIGZyb21ab29tOiBOdW1iZXIpOiBOdW1iZXJcclxuICBcdC8vIFJldHVybnMgdGhlIHNjYWxlIGZhY3RvciB0byBiZSBhcHBsaWVkIHRvIGEgbWFwIHRyYW5zaXRpb24gZnJvbSB6b29tIGxldmVsXHJcbiAgXHQvLyBgZnJvbVpvb21gIHRvIGB0b1pvb21gLiBVc2VkIGludGVybmFsbHkgdG8gaGVscCB3aXRoIHpvb20gYW5pbWF0aW9ucy5cclxuICBcdGdldFpvb21TY2FsZTogZnVuY3Rpb24gKHRvWm9vbSwgZnJvbVpvb20pIHtcclxuICBcdFx0Ly8gVE9ETyByZXBsYWNlIHdpdGggdW5pdmVyc2FsIGltcGxlbWVudGF0aW9uIGFmdGVyIHJlZmFjdG9yaW5nIHByb2plY3Rpb25zXHJcbiAgXHRcdHZhciBjcnMgPSB0aGlzLm9wdGlvbnMuY3JzO1xyXG4gIFx0XHRmcm9tWm9vbSA9IGZyb21ab29tID09PSB1bmRlZmluZWQgPyB0aGlzLl96b29tIDogZnJvbVpvb207XHJcbiAgXHRcdHJldHVybiBjcnMuc2NhbGUodG9ab29tKSAvIGNycy5zY2FsZShmcm9tWm9vbSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0U2NhbGVab29tKHNjYWxlOiBOdW1iZXIsIGZyb21ab29tOiBOdW1iZXIpOiBOdW1iZXJcclxuICBcdC8vIFJldHVybnMgdGhlIHpvb20gbGV2ZWwgdGhhdCB0aGUgbWFwIHdvdWxkIGVuZCB1cCBhdCwgaWYgaXQgaXMgYXQgYGZyb21ab29tYFxyXG4gIFx0Ly8gbGV2ZWwgYW5kIGV2ZXJ5dGhpbmcgaXMgc2NhbGVkIGJ5IGEgZmFjdG9yIG9mIGBzY2FsZWAuIEludmVyc2Ugb2ZcclxuICBcdC8vIFtgZ2V0Wm9vbVNjYWxlYF0oI21hcC1nZXRab29tU2NhbGUpLlxyXG4gIFx0Z2V0U2NhbGVab29tOiBmdW5jdGlvbiAoc2NhbGUsIGZyb21ab29tKSB7XHJcbiAgXHRcdHZhciBjcnMgPSB0aGlzLm9wdGlvbnMuY3JzO1xyXG4gIFx0XHRmcm9tWm9vbSA9IGZyb21ab29tID09PSB1bmRlZmluZWQgPyB0aGlzLl96b29tIDogZnJvbVpvb207XHJcbiAgXHRcdHZhciB6b29tID0gY3JzLnpvb20oc2NhbGUgKiBjcnMuc2NhbGUoZnJvbVpvb20pKTtcclxuICBcdFx0cmV0dXJuIGlzTmFOKHpvb20pID8gSW5maW5pdHkgOiB6b29tO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHByb2plY3QobGF0bG5nOiBMYXRMbmcsIHpvb206IE51bWJlcik6IFBvaW50XHJcbiAgXHQvLyBQcm9qZWN0cyBhIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlIGBMYXRMbmdgIGFjY29yZGluZyB0byB0aGUgcHJvamVjdGlvblxyXG4gIFx0Ly8gb2YgdGhlIG1hcCdzIENSUywgdGhlbiBzY2FsZXMgaXQgYWNjb3JkaW5nIHRvIGB6b29tYCBhbmQgdGhlIENSUydzXHJcbiAgXHQvLyBgVHJhbnNmb3JtYXRpb25gLiBUaGUgcmVzdWx0IGlzIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG9cclxuICBcdC8vIHRoZSBDUlMgb3JpZ2luLlxyXG4gIFx0cHJvamVjdDogZnVuY3Rpb24gKGxhdGxuZywgem9vbSkge1xyXG4gIFx0XHR6b29tID0gem9vbSA9PT0gdW5kZWZpbmVkID8gdGhpcy5fem9vbSA6IHpvb207XHJcbiAgXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuY3JzLmxhdExuZ1RvUG9pbnQodG9MYXRMbmcobGF0bG5nKSwgem9vbSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgdW5wcm9qZWN0KHBvaW50OiBQb2ludCwgem9vbTogTnVtYmVyKTogTGF0TG5nXHJcbiAgXHQvLyBJbnZlcnNlIG9mIFtgcHJvamVjdGBdKCNtYXAtcHJvamVjdCkuXHJcbiAgXHR1bnByb2plY3Q6IGZ1bmN0aW9uIChwb2ludCwgem9vbSkge1xyXG4gIFx0XHR6b29tID0gem9vbSA9PT0gdW5kZWZpbmVkID8gdGhpcy5fem9vbSA6IHpvb207XHJcbiAgXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuY3JzLnBvaW50VG9MYXRMbmcodG9Qb2ludChwb2ludCksIHpvb20pO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGxheWVyUG9pbnRUb0xhdExuZyhwb2ludDogUG9pbnQpOiBMYXRMbmdcclxuICBcdC8vIEdpdmVuIGEgcGl4ZWwgY29vcmRpbmF0ZSByZWxhdGl2ZSB0byB0aGUgW29yaWdpbiBwaXhlbF0oI21hcC1nZXRwaXhlbG9yaWdpbiksXHJcbiAgXHQvLyByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlIChmb3IgdGhlIGN1cnJlbnQgem9vbSBsZXZlbCkuXHJcbiAgXHRsYXllclBvaW50VG9MYXRMbmc6IGZ1bmN0aW9uIChwb2ludCkge1xyXG4gIFx0XHR2YXIgcHJvamVjdGVkUG9pbnQgPSB0b1BvaW50KHBvaW50KS5hZGQodGhpcy5nZXRQaXhlbE9yaWdpbigpKTtcclxuICBcdFx0cmV0dXJuIHRoaXMudW5wcm9qZWN0KHByb2plY3RlZFBvaW50KTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBsYXRMbmdUb0xheWVyUG9pbnQobGF0bG5nOiBMYXRMbmcpOiBQb2ludFxyXG4gIFx0Ly8gR2l2ZW4gYSBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZSwgcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBwaXhlbCBjb29yZGluYXRlXHJcbiAgXHQvLyByZWxhdGl2ZSB0byB0aGUgW29yaWdpbiBwaXhlbF0oI21hcC1nZXRwaXhlbG9yaWdpbikuXHJcbiAgXHRsYXRMbmdUb0xheWVyUG9pbnQ6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuICBcdFx0dmFyIHByb2plY3RlZFBvaW50ID0gdGhpcy5wcm9qZWN0KHRvTGF0TG5nKGxhdGxuZykpLl9yb3VuZCgpO1xyXG4gIFx0XHRyZXR1cm4gcHJvamVjdGVkUG9pbnQuX3N1YnRyYWN0KHRoaXMuZ2V0UGl4ZWxPcmlnaW4oKSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2Qgd3JhcExhdExuZyhsYXRsbmc6IExhdExuZyk6IExhdExuZ1xyXG4gIFx0Ly8gUmV0dXJucyBhIGBMYXRMbmdgIHdoZXJlIGBsYXRgIGFuZCBgbG5nYCBoYXMgYmVlbiB3cmFwcGVkIGFjY29yZGluZyB0byB0aGVcclxuICBcdC8vIG1hcCdzIENSUydzIGB3cmFwTGF0YCBhbmQgYHdyYXBMbmdgIHByb3BlcnRpZXMsIGlmIHRoZXkgYXJlIG91dHNpZGUgdGhlXHJcbiAgXHQvLyBDUlMncyBib3VuZHMuXHJcbiAgXHQvLyBCeSBkZWZhdWx0IHRoaXMgbWVhbnMgbG9uZ2l0dWRlIGlzIHdyYXBwZWQgYXJvdW5kIHRoZSBkYXRlbGluZSBzbyBpdHNcclxuICBcdC8vIHZhbHVlIGlzIGJldHdlZW4gLTE4MCBhbmQgKzE4MCBkZWdyZWVzLlxyXG4gIFx0d3JhcExhdExuZzogZnVuY3Rpb24gKGxhdGxuZykge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmNycy53cmFwTGF0TG5nKHRvTGF0TG5nKGxhdGxuZykpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHdyYXBMYXRMbmdCb3VuZHMoYm91bmRzOiBMYXRMbmdCb3VuZHMpOiBMYXRMbmdCb3VuZHNcclxuICBcdC8vIFJldHVybnMgYSBgTGF0TG5nQm91bmRzYCB3aXRoIHRoZSBzYW1lIHNpemUgYXMgdGhlIGdpdmVuIG9uZSwgZW5zdXJpbmcgdGhhdFxyXG4gIFx0Ly8gaXRzIGNlbnRlciBpcyB3aXRoaW4gdGhlIENSUydzIGJvdW5kcy5cclxuICBcdC8vIEJ5IGRlZmF1bHQgdGhpcyBtZWFucyB0aGUgY2VudGVyIGxvbmdpdHVkZSBpcyB3cmFwcGVkIGFyb3VuZCB0aGUgZGF0ZWxpbmUgc28gaXRzXHJcbiAgXHQvLyB2YWx1ZSBpcyBiZXR3ZWVuIC0xODAgYW5kICsxODAgZGVncmVlcywgYW5kIHRoZSBtYWpvcml0eSBvZiB0aGUgYm91bmRzXHJcbiAgXHQvLyBvdmVybGFwcyB0aGUgQ1JTJ3MgYm91bmRzLlxyXG4gIFx0d3JhcExhdExuZ0JvdW5kczogZnVuY3Rpb24gKGxhdGxuZykge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmNycy53cmFwTGF0TG5nQm91bmRzKHRvTGF0TG5nQm91bmRzKGxhdGxuZykpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGRpc3RhbmNlKGxhdGxuZzE6IExhdExuZywgbGF0bG5nMjogTGF0TG5nKTogTnVtYmVyXHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZXMgYWNjb3JkaW5nIHRvXHJcbiAgXHQvLyB0aGUgbWFwJ3MgQ1JTLiBCeSBkZWZhdWx0IHRoaXMgbWVhc3VyZXMgZGlzdGFuY2UgaW4gbWV0ZXJzLlxyXG4gIFx0ZGlzdGFuY2U6IGZ1bmN0aW9uIChsYXRsbmcxLCBsYXRsbmcyKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuY3JzLmRpc3RhbmNlKHRvTGF0TG5nKGxhdGxuZzEpLCB0b0xhdExuZyhsYXRsbmcyKSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQocG9pbnQ6IFBvaW50KTogUG9pbnRcclxuICBcdC8vIEdpdmVuIGEgcGl4ZWwgY29vcmRpbmF0ZSByZWxhdGl2ZSB0byB0aGUgbWFwIGNvbnRhaW5lciwgcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZ1xyXG4gIFx0Ly8gcGl4ZWwgY29vcmRpbmF0ZSByZWxhdGl2ZSB0byB0aGUgW29yaWdpbiBwaXhlbF0oI21hcC1nZXRwaXhlbG9yaWdpbikuXHJcbiAgXHRjb250YWluZXJQb2ludFRvTGF5ZXJQb2ludDogZnVuY3Rpb24gKHBvaW50KSB7IC8vIChQb2ludClcclxuICBcdFx0cmV0dXJuIHRvUG9pbnQocG9pbnQpLnN1YnRyYWN0KHRoaXMuX2dldE1hcFBhbmVQb3MoKSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgbGF5ZXJQb2ludFRvQ29udGFpbmVyUG9pbnQocG9pbnQ6IFBvaW50KTogUG9pbnRcclxuICBcdC8vIEdpdmVuIGEgcGl4ZWwgY29vcmRpbmF0ZSByZWxhdGl2ZSB0byB0aGUgW29yaWdpbiBwaXhlbF0oI21hcC1nZXRwaXhlbG9yaWdpbiksXHJcbiAgXHQvLyByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG8gdGhlIG1hcCBjb250YWluZXIuXHJcbiAgXHRsYXllclBvaW50VG9Db250YWluZXJQb2ludDogZnVuY3Rpb24gKHBvaW50KSB7IC8vIChQb2ludClcclxuICBcdFx0cmV0dXJuIHRvUG9pbnQocG9pbnQpLmFkZCh0aGlzLl9nZXRNYXBQYW5lUG9zKCkpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGNvbnRhaW5lclBvaW50VG9MYXRMbmcocG9pbnQ6IFBvaW50KTogTGF0TG5nXHJcbiAgXHQvLyBHaXZlbiBhIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG8gdGhlIG1hcCBjb250YWluZXIsIHJldHVybnNcclxuICBcdC8vIHRoZSBjb3JyZXNwb25kaW5nIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlIChmb3IgdGhlIGN1cnJlbnQgem9vbSBsZXZlbCkuXHJcbiAgXHRjb250YWluZXJQb2ludFRvTGF0TG5nOiBmdW5jdGlvbiAocG9pbnQpIHtcclxuICBcdFx0dmFyIGxheWVyUG9pbnQgPSB0aGlzLmNvbnRhaW5lclBvaW50VG9MYXllclBvaW50KHRvUG9pbnQocG9pbnQpKTtcclxuICBcdFx0cmV0dXJuIHRoaXMubGF5ZXJQb2ludFRvTGF0TG5nKGxheWVyUG9pbnQpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGxhdExuZ1RvQ29udGFpbmVyUG9pbnQobGF0bG5nOiBMYXRMbmcpOiBQb2ludFxyXG4gIFx0Ly8gR2l2ZW4gYSBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZSwgcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBwaXhlbCBjb29yZGluYXRlXHJcbiAgXHQvLyByZWxhdGl2ZSB0byB0aGUgbWFwIGNvbnRhaW5lci5cclxuICBcdGxhdExuZ1RvQ29udGFpbmVyUG9pbnQ6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMubGF5ZXJQb2ludFRvQ29udGFpbmVyUG9pbnQodGhpcy5sYXRMbmdUb0xheWVyUG9pbnQodG9MYXRMbmcobGF0bG5nKSkpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIG1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGV2OiBNb3VzZUV2ZW50KTogUG9pbnRcclxuICBcdC8vIEdpdmVuIGEgTW91c2VFdmVudCBvYmplY3QsIHJldHVybnMgdGhlIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG8gdGhlXHJcbiAgXHQvLyBtYXAgY29udGFpbmVyIHdoZXJlIHRoZSBldmVudCB0b29rIHBsYWNlLlxyXG4gIFx0bW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQ6IGZ1bmN0aW9uIChlKSB7XHJcbiAgXHRcdHJldHVybiBnZXRNb3VzZVBvc2l0aW9uKGUsIHRoaXMuX2NvbnRhaW5lcik7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgbW91c2VFdmVudFRvTGF5ZXJQb2ludChldjogTW91c2VFdmVudCk6IFBvaW50XHJcbiAgXHQvLyBHaXZlbiBhIE1vdXNlRXZlbnQgb2JqZWN0LCByZXR1cm5zIHRoZSBwaXhlbCBjb29yZGluYXRlIHJlbGF0aXZlIHRvXHJcbiAgXHQvLyB0aGUgW29yaWdpbiBwaXhlbF0oI21hcC1nZXRwaXhlbG9yaWdpbikgd2hlcmUgdGhlIGV2ZW50IHRvb2sgcGxhY2UuXHJcbiAgXHRtb3VzZUV2ZW50VG9MYXllclBvaW50OiBmdW5jdGlvbiAoZSkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5jb250YWluZXJQb2ludFRvTGF5ZXJQb2ludCh0aGlzLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUpKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBtb3VzZUV2ZW50VG9MYXRMbmcoZXY6IE1vdXNlRXZlbnQpOiBMYXRMbmdcclxuICBcdC8vIEdpdmVuIGEgTW91c2VFdmVudCBvYmplY3QsIHJldHVybnMgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGUgd2hlcmUgdGhlXHJcbiAgXHQvLyBldmVudCB0b29rIHBsYWNlLlxyXG4gIFx0bW91c2VFdmVudFRvTGF0TG5nOiBmdW5jdGlvbiAoZSkgeyAvLyAoTW91c2VFdmVudClcclxuICBcdFx0cmV0dXJuIHRoaXMubGF5ZXJQb2ludFRvTGF0TG5nKHRoaXMubW91c2VFdmVudFRvTGF5ZXJQb2ludChlKSk7XHJcbiAgXHR9LFxyXG5cclxuXHJcbiAgXHQvLyBtYXAgaW5pdGlhbGl6YXRpb24gbWV0aG9kc1xyXG5cclxuICBcdF9pbml0Q29udGFpbmVyOiBmdW5jdGlvbiAoaWQpIHtcclxuICBcdFx0dmFyIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lciA9IGdldChpZCk7XHJcblxyXG4gIFx0XHRpZiAoIWNvbnRhaW5lcikge1xyXG4gIFx0XHRcdHRocm93IG5ldyBFcnJvcignTWFwIGNvbnRhaW5lciBub3QgZm91bmQuJyk7XHJcbiAgXHRcdH0gZWxzZSBpZiAoY29udGFpbmVyLl9sZWFmbGV0X2lkKSB7XHJcbiAgXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdNYXAgY29udGFpbmVyIGlzIGFscmVhZHkgaW5pdGlhbGl6ZWQuJyk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdG9uKGNvbnRhaW5lciwgJ3Njcm9sbCcsIHRoaXMuX29uU2Nyb2xsLCB0aGlzKTtcclxuICBcdFx0dGhpcy5fY29udGFpbmVySWQgPSBzdGFtcChjb250YWluZXIpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfaW5pdExheW91dDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR2YXIgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyO1xyXG5cclxuICBcdFx0dGhpcy5fZmFkZUFuaW1hdGVkID0gdGhpcy5vcHRpb25zLmZhZGVBbmltYXRpb24gJiYgYW55M2Q7XHJcblxyXG4gIFx0XHRhZGRDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LWNvbnRhaW5lcicgK1xyXG4gIFx0XHRcdCh0b3VjaCA/ICcgbGVhZmxldC10b3VjaCcgOiAnJykgK1xyXG4gIFx0XHRcdChyZXRpbmEgPyAnIGxlYWZsZXQtcmV0aW5hJyA6ICcnKSArXHJcbiAgXHRcdFx0KGllbHQ5ID8gJyBsZWFmbGV0LW9sZGllJyA6ICcnKSArXHJcbiAgXHRcdFx0KHNhZmFyaSA/ICcgbGVhZmxldC1zYWZhcmknIDogJycpICtcclxuICBcdFx0XHQodGhpcy5fZmFkZUFuaW1hdGVkID8gJyBsZWFmbGV0LWZhZGUtYW5pbScgOiAnJykpO1xyXG5cclxuICBcdFx0dmFyIHBvc2l0aW9uID0gZ2V0U3R5bGUoY29udGFpbmVyLCAncG9zaXRpb24nKTtcclxuXHJcbiAgXHRcdGlmIChwb3NpdGlvbiAhPT0gJ2Fic29sdXRlJyAmJiBwb3NpdGlvbiAhPT0gJ3JlbGF0aXZlJyAmJiBwb3NpdGlvbiAhPT0gJ2ZpeGVkJykge1xyXG4gIFx0XHRcdGNvbnRhaW5lci5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMuX2luaXRQYW5lcygpO1xyXG5cclxuICBcdFx0aWYgKHRoaXMuX2luaXRDb250cm9sUG9zKSB7XHJcbiAgXHRcdFx0dGhpcy5faW5pdENvbnRyb2xQb3MoKTtcclxuICBcdFx0fVxyXG4gIFx0fSxcclxuXHJcbiAgXHRfaW5pdFBhbmVzOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHZhciBwYW5lcyA9IHRoaXMuX3BhbmVzID0ge307XHJcbiAgXHRcdHRoaXMuX3BhbmVSZW5kZXJlcnMgPSB7fTtcclxuXHJcbiAgXHRcdC8vIEBzZWN0aW9uXHJcbiAgXHRcdC8vXHJcbiAgXHRcdC8vIFBhbmVzIGFyZSBET00gZWxlbWVudHMgdXNlZCB0byBjb250cm9sIHRoZSBvcmRlcmluZyBvZiBsYXllcnMgb24gdGhlIG1hcC4gWW91XHJcbiAgXHRcdC8vIGNhbiBhY2Nlc3MgcGFuZXMgd2l0aCBbYG1hcC5nZXRQYW5lYF0oI21hcC1nZXRwYW5lKSBvclxyXG4gIFx0XHQvLyBbYG1hcC5nZXRQYW5lc2BdKCNtYXAtZ2V0cGFuZXMpIG1ldGhvZHMuIE5ldyBwYW5lcyBjYW4gYmUgY3JlYXRlZCB3aXRoIHRoZVxyXG4gIFx0XHQvLyBbYG1hcC5jcmVhdGVQYW5lYF0oI21hcC1jcmVhdGVwYW5lKSBtZXRob2QuXHJcbiAgXHRcdC8vXHJcbiAgXHRcdC8vIEV2ZXJ5IG1hcCBoYXMgdGhlIGZvbGxvd2luZyBkZWZhdWx0IHBhbmVzIHRoYXQgZGlmZmVyIG9ubHkgaW4gekluZGV4LlxyXG4gIFx0XHQvL1xyXG4gIFx0XHQvLyBAcGFuZSBtYXBQYW5lOiBIVE1MRWxlbWVudCA9ICdhdXRvJ1xyXG4gIFx0XHQvLyBQYW5lIHRoYXQgY29udGFpbnMgYWxsIG90aGVyIG1hcCBwYW5lc1xyXG5cclxuICBcdFx0dGhpcy5fbWFwUGFuZSA9IHRoaXMuY3JlYXRlUGFuZSgnbWFwUGFuZScsIHRoaXMuX2NvbnRhaW5lcik7XHJcbiAgXHRcdHNldFBvc2l0aW9uKHRoaXMuX21hcFBhbmUsIG5ldyBQb2ludCgwLCAwKSk7XHJcblxyXG4gIFx0XHQvLyBAcGFuZSB0aWxlUGFuZTogSFRNTEVsZW1lbnQgPSAyMDBcclxuICBcdFx0Ly8gUGFuZSBmb3IgYEdyaWRMYXllcmBzIGFuZCBgVGlsZUxheWVyYHNcclxuICBcdFx0dGhpcy5jcmVhdGVQYW5lKCd0aWxlUGFuZScpO1xyXG4gIFx0XHQvLyBAcGFuZSBvdmVybGF5UGFuZTogSFRNTEVsZW1lbnQgPSA0MDBcclxuICBcdFx0Ly8gUGFuZSBmb3Igb3ZlcmxheSBzaGFkb3dzIChlLmcuIGBNYXJrZXJgIHNoYWRvd3MpXHJcbiAgXHRcdHRoaXMuY3JlYXRlUGFuZSgnc2hhZG93UGFuZScpO1xyXG4gIFx0XHQvLyBAcGFuZSBzaGFkb3dQYW5lOiBIVE1MRWxlbWVudCA9IDUwMFxyXG4gIFx0XHQvLyBQYW5lIGZvciB2ZWN0b3JzIChgUGF0aGBzLCBsaWtlIGBQb2x5bGluZWBzIGFuZCBgUG9seWdvbmBzKSwgYEltYWdlT3ZlcmxheWBzIGFuZCBgVmlkZW9PdmVybGF5YHNcclxuICBcdFx0dGhpcy5jcmVhdGVQYW5lKCdvdmVybGF5UGFuZScpO1xyXG4gIFx0XHQvLyBAcGFuZSBtYXJrZXJQYW5lOiBIVE1MRWxlbWVudCA9IDYwMFxyXG4gIFx0XHQvLyBQYW5lIGZvciBgSWNvbmBzIG9mIGBNYXJrZXJgc1xyXG4gIFx0XHR0aGlzLmNyZWF0ZVBhbmUoJ21hcmtlclBhbmUnKTtcclxuICBcdFx0Ly8gQHBhbmUgdG9vbHRpcFBhbmU6IEhUTUxFbGVtZW50ID0gNjUwXHJcbiAgXHRcdC8vIFBhbmUgZm9yIGBUb29sdGlwYHMuXHJcbiAgXHRcdHRoaXMuY3JlYXRlUGFuZSgndG9vbHRpcFBhbmUnKTtcclxuICBcdFx0Ly8gQHBhbmUgcG9wdXBQYW5lOiBIVE1MRWxlbWVudCA9IDcwMFxyXG4gIFx0XHQvLyBQYW5lIGZvciBgUG9wdXBgcy5cclxuICBcdFx0dGhpcy5jcmVhdGVQYW5lKCdwb3B1cFBhbmUnKTtcclxuXHJcbiAgXHRcdGlmICghdGhpcy5vcHRpb25zLm1hcmtlclpvb21BbmltYXRpb24pIHtcclxuICBcdFx0XHRhZGRDbGFzcyhwYW5lcy5tYXJrZXJQYW5lLCAnbGVhZmxldC16b29tLWhpZGUnKTtcclxuICBcdFx0XHRhZGRDbGFzcyhwYW5lcy5zaGFkb3dQYW5lLCAnbGVhZmxldC16b29tLWhpZGUnKTtcclxuICBcdFx0fVxyXG4gIFx0fSxcclxuXHJcblxyXG4gIFx0Ly8gcHJpdmF0ZSBtZXRob2RzIHRoYXQgbW9kaWZ5IG1hcCBzdGF0ZVxyXG5cclxuICBcdC8vIEBzZWN0aW9uIE1hcCBzdGF0ZSBjaGFuZ2UgZXZlbnRzXHJcbiAgXHRfcmVzZXRWaWV3OiBmdW5jdGlvbiAoY2VudGVyLCB6b29tKSB7XHJcbiAgXHRcdHNldFBvc2l0aW9uKHRoaXMuX21hcFBhbmUsIG5ldyBQb2ludCgwLCAwKSk7XHJcblxyXG4gIFx0XHR2YXIgbG9hZGluZyA9ICF0aGlzLl9sb2FkZWQ7XHJcbiAgXHRcdHRoaXMuX2xvYWRlZCA9IHRydWU7XHJcbiAgXHRcdHpvb20gPSB0aGlzLl9saW1pdFpvb20oem9vbSk7XHJcblxyXG4gIFx0XHR0aGlzLmZpcmUoJ3ZpZXdwcmVyZXNldCcpO1xyXG5cclxuICBcdFx0dmFyIHpvb21DaGFuZ2VkID0gdGhpcy5fem9vbSAhPT0gem9vbTtcclxuICBcdFx0dGhpc1xyXG4gIFx0XHRcdC5fbW92ZVN0YXJ0KHpvb21DaGFuZ2VkLCBmYWxzZSlcclxuICBcdFx0XHQuX21vdmUoY2VudGVyLCB6b29tKVxyXG4gIFx0XHRcdC5fbW92ZUVuZCh6b29tQ2hhbmdlZCk7XHJcblxyXG4gIFx0XHQvLyBAZXZlbnQgdmlld3Jlc2V0OiBFdmVudFxyXG4gIFx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXAgbmVlZHMgdG8gcmVkcmF3IGl0cyBjb250ZW50ICh0aGlzIHVzdWFsbHkgaGFwcGVuc1xyXG4gIFx0XHQvLyBvbiBtYXAgem9vbSBvciBsb2FkKS4gVmVyeSB1c2VmdWwgZm9yIGNyZWF0aW5nIGN1c3RvbSBvdmVybGF5cy5cclxuICBcdFx0dGhpcy5maXJlKCd2aWV3cmVzZXQnKTtcclxuXHJcbiAgXHRcdC8vIEBldmVudCBsb2FkOiBFdmVudFxyXG4gIFx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXAgaXMgaW5pdGlhbGl6ZWQgKHdoZW4gaXRzIGNlbnRlciBhbmQgem9vbSBhcmUgc2V0XHJcbiAgXHRcdC8vIGZvciB0aGUgZmlyc3QgdGltZSkuXHJcbiAgXHRcdGlmIChsb2FkaW5nKSB7XHJcbiAgXHRcdFx0dGhpcy5maXJlKCdsb2FkJyk7XHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0X21vdmVTdGFydDogZnVuY3Rpb24gKHpvb21DaGFuZ2VkLCBub01vdmVTdGFydCkge1xyXG4gIFx0XHQvLyBAZXZlbnQgem9vbXN0YXJ0OiBFdmVudFxyXG4gIFx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXAgem9vbSBpcyBhYm91dCB0byBjaGFuZ2UgKGUuZy4gYmVmb3JlIHpvb20gYW5pbWF0aW9uKS5cclxuICBcdFx0Ly8gQGV2ZW50IG1vdmVzdGFydDogRXZlbnRcclxuICBcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdmlldyBvZiB0aGUgbWFwIHN0YXJ0cyBjaGFuZ2luZyAoZS5nLiB1c2VyIHN0YXJ0cyBkcmFnZ2luZyB0aGUgbWFwKS5cclxuICBcdFx0aWYgKHpvb21DaGFuZ2VkKSB7XHJcbiAgXHRcdFx0dGhpcy5maXJlKCd6b29tc3RhcnQnKTtcclxuICBcdFx0fVxyXG4gIFx0XHRpZiAoIW5vTW92ZVN0YXJ0KSB7XHJcbiAgXHRcdFx0dGhpcy5maXJlKCdtb3Zlc3RhcnQnKTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0X21vdmU6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20sIGRhdGEpIHtcclxuICBcdFx0aWYgKHpvb20gPT09IHVuZGVmaW5lZCkge1xyXG4gIFx0XHRcdHpvb20gPSB0aGlzLl96b29tO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHZhciB6b29tQ2hhbmdlZCA9IHRoaXMuX3pvb20gIT09IHpvb207XHJcblxyXG4gIFx0XHR0aGlzLl96b29tID0gem9vbTtcclxuICBcdFx0dGhpcy5fbGFzdENlbnRlciA9IGNlbnRlcjtcclxuICBcdFx0dGhpcy5fcGl4ZWxPcmlnaW4gPSB0aGlzLl9nZXROZXdQaXhlbE9yaWdpbihjZW50ZXIpO1xyXG5cclxuICBcdFx0Ly8gQGV2ZW50IHpvb206IEV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIHJlcGVhdGVkbHkgZHVyaW5nIGFueSBjaGFuZ2UgaW4gem9vbSBsZXZlbCwgaW5jbHVkaW5nIHpvb21cclxuICBcdFx0Ly8gYW5kIGZseSBhbmltYXRpb25zLlxyXG4gIFx0XHRpZiAoem9vbUNoYW5nZWQgfHwgKGRhdGEgJiYgZGF0YS5waW5jaCkpIHtcdC8vIEFsd2F5cyBmaXJlICd6b29tJyBpZiBwaW5jaGluZyBiZWNhdXNlICMzNTMwXHJcbiAgXHRcdFx0dGhpcy5maXJlKCd6b29tJywgZGF0YSk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdC8vIEBldmVudCBtb3ZlOiBFdmVudFxyXG4gIFx0XHQvLyBGaXJlZCByZXBlYXRlZGx5IGR1cmluZyBhbnkgbW92ZW1lbnQgb2YgdGhlIG1hcCwgaW5jbHVkaW5nIHBhbiBhbmRcclxuICBcdFx0Ly8gZmx5IGFuaW1hdGlvbnMuXHJcbiAgXHRcdHJldHVybiB0aGlzLmZpcmUoJ21vdmUnLCBkYXRhKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X21vdmVFbmQ6IGZ1bmN0aW9uICh6b29tQ2hhbmdlZCkge1xyXG4gIFx0XHQvLyBAZXZlbnQgem9vbWVuZDogRXZlbnRcclxuICBcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFwIGhhcyBjaGFuZ2VkLCBhZnRlciBhbnkgYW5pbWF0aW9ucy5cclxuICBcdFx0aWYgKHpvb21DaGFuZ2VkKSB7XHJcbiAgXHRcdFx0dGhpcy5maXJlKCd6b29tZW5kJyk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdC8vIEBldmVudCBtb3ZlZW5kOiBFdmVudFxyXG4gIFx0XHQvLyBGaXJlZCB3aGVuIHRoZSBjZW50ZXIgb2YgdGhlIG1hcCBzdG9wcyBjaGFuZ2luZyAoZS5nLiB1c2VyIHN0b3BwZWRcclxuICBcdFx0Ly8gZHJhZ2dpbmcgdGhlIG1hcCkuXHJcbiAgXHRcdHJldHVybiB0aGlzLmZpcmUoJ21vdmVlbmQnKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X3N0b3A6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0Y2FuY2VsQW5pbUZyYW1lKHRoaXMuX2ZseVRvRnJhbWUpO1xyXG4gIFx0XHRpZiAodGhpcy5fcGFuQW5pbSkge1xyXG4gIFx0XHRcdHRoaXMuX3BhbkFuaW0uc3RvcCgpO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfcmF3UGFuQnk6IGZ1bmN0aW9uIChvZmZzZXQpIHtcclxuICBcdFx0c2V0UG9zaXRpb24odGhpcy5fbWFwUGFuZSwgdGhpcy5fZ2V0TWFwUGFuZVBvcygpLnN1YnRyYWN0KG9mZnNldCkpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfZ2V0Wm9vbVNwYW46IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMuZ2V0TWF4Wm9vbSgpIC0gdGhpcy5nZXRNaW5ab29tKCk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9wYW5JbnNpZGVNYXhCb3VuZHM6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0aWYgKCF0aGlzLl9lbmZvcmNpbmdCb3VuZHMpIHtcclxuICBcdFx0XHR0aGlzLnBhbkluc2lkZUJvdW5kcyh0aGlzLm9wdGlvbnMubWF4Qm91bmRzKTtcclxuICBcdFx0fVxyXG4gIFx0fSxcclxuXHJcbiAgXHRfY2hlY2tJZkxvYWRlZDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRpZiAoIXRoaXMuX2xvYWRlZCkge1xyXG4gIFx0XHRcdHRocm93IG5ldyBFcnJvcignU2V0IG1hcCBjZW50ZXIgYW5kIHpvb20gZmlyc3QuJyk7XHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gRE9NIGV2ZW50IGhhbmRsaW5nXHJcblxyXG4gIFx0Ly8gQHNlY3Rpb24gSW50ZXJhY3Rpb24gZXZlbnRzXHJcbiAgXHRfaW5pdEV2ZW50czogZnVuY3Rpb24gKHJlbW92ZSQkMSkge1xyXG4gIFx0XHR0aGlzLl90YXJnZXRzID0ge307XHJcbiAgXHRcdHRoaXMuX3RhcmdldHNbc3RhbXAodGhpcy5fY29udGFpbmVyKV0gPSB0aGlzO1xyXG5cclxuICBcdFx0dmFyIG9uT2ZmID0gcmVtb3ZlJCQxID8gb2ZmIDogb247XHJcblxyXG4gIFx0XHQvLyBAZXZlbnQgY2xpY2s6IE1vdXNlRXZlbnRcclxuICBcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdXNlciBjbGlja3MgKG9yIHRhcHMpIHRoZSBtYXAuXHJcbiAgXHRcdC8vIEBldmVudCBkYmxjbGljazogTW91c2VFdmVudFxyXG4gIFx0XHQvLyBGaXJlZCB3aGVuIHRoZSB1c2VyIGRvdWJsZS1jbGlja3MgKG9yIGRvdWJsZS10YXBzKSB0aGUgbWFwLlxyXG4gIFx0XHQvLyBAZXZlbnQgbW91c2Vkb3duOiBNb3VzZUV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgcHVzaGVzIHRoZSBtb3VzZSBidXR0b24gb24gdGhlIG1hcC5cclxuICBcdFx0Ly8gQGV2ZW50IG1vdXNldXA6IE1vdXNlRXZlbnRcclxuICBcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdXNlciByZWxlYXNlcyB0aGUgbW91c2UgYnV0dG9uIG9uIHRoZSBtYXAuXHJcbiAgXHRcdC8vIEBldmVudCBtb3VzZW92ZXI6IE1vdXNlRXZlbnRcclxuICBcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbW91c2UgZW50ZXJzIHRoZSBtYXAuXHJcbiAgXHRcdC8vIEBldmVudCBtb3VzZW91dDogTW91c2VFdmVudFxyXG4gIFx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtb3VzZSBsZWF2ZXMgdGhlIG1hcC5cclxuICBcdFx0Ly8gQGV2ZW50IG1vdXNlbW92ZTogTW91c2VFdmVudFxyXG4gIFx0XHQvLyBGaXJlZCB3aGlsZSB0aGUgbW91c2UgbW92ZXMgb3ZlciB0aGUgbWFwLlxyXG4gIFx0XHQvLyBAZXZlbnQgY29udGV4dG1lbnU6IE1vdXNlRXZlbnRcclxuICBcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdXNlciBwdXNoZXMgdGhlIHJpZ2h0IG1vdXNlIGJ1dHRvbiBvbiB0aGUgbWFwLCBwcmV2ZW50c1xyXG4gIFx0XHQvLyBkZWZhdWx0IGJyb3dzZXIgY29udGV4dCBtZW51IGZyb20gc2hvd2luZyBpZiB0aGVyZSBhcmUgbGlzdGVuZXJzIG9uXHJcbiAgXHRcdC8vIHRoaXMgZXZlbnQuIEFsc28gZmlyZWQgb24gbW9iaWxlIHdoZW4gdGhlIHVzZXIgaG9sZHMgYSBzaW5nbGUgdG91Y2hcclxuICBcdFx0Ly8gZm9yIGEgc2Vjb25kIChhbHNvIGNhbGxlZCBsb25nIHByZXNzKS5cclxuICBcdFx0Ly8gQGV2ZW50IGtleXByZXNzOiBLZXlib2FyZEV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgcHJlc3NlcyBhIGtleSBmcm9tIHRoZSBrZXlib2FyZCB0aGF0IHByb2R1Y2VzIGEgY2hhcmFjdGVyIHZhbHVlIHdoaWxlIHRoZSBtYXAgaXMgZm9jdXNlZC5cclxuICBcdFx0Ly8gQGV2ZW50IGtleWRvd246IEtleWJvYXJkRXZlbnRcclxuICBcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdXNlciBwcmVzc2VzIGEga2V5IGZyb20gdGhlIGtleWJvYXJkIHdoaWxlIHRoZSBtYXAgaXMgZm9jdXNlZC4gVW5saWtlIHRoZSBga2V5cHJlc3NgIGV2ZW50LFxyXG4gIFx0XHQvLyB0aGUgYGtleWRvd25gIGV2ZW50IGlzIGZpcmVkIGZvciBrZXlzIHRoYXQgcHJvZHVjZSBhIGNoYXJhY3RlciB2YWx1ZSBhbmQgZm9yIGtleXNcclxuICBcdFx0Ly8gdGhhdCBkbyBub3QgcHJvZHVjZSBhIGNoYXJhY3RlciB2YWx1ZS5cclxuICBcdFx0Ly8gQGV2ZW50IGtleXVwOiBLZXlib2FyZEV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgcmVsZWFzZXMgYSBrZXkgZnJvbSB0aGUga2V5Ym9hcmQgd2hpbGUgdGhlIG1hcCBpcyBmb2N1c2VkLlxyXG4gIFx0XHRvbk9mZih0aGlzLl9jb250YWluZXIsICdjbGljayBkYmxjbGljayBtb3VzZWRvd24gbW91c2V1cCAnICtcclxuICBcdFx0XHQnbW91c2VvdmVyIG1vdXNlb3V0IG1vdXNlbW92ZSBjb250ZXh0bWVudSBrZXlwcmVzcyBrZXlkb3duIGtleXVwJywgdGhpcy5faGFuZGxlRE9NRXZlbnQsIHRoaXMpO1xyXG5cclxuICBcdFx0aWYgKHRoaXMub3B0aW9ucy50cmFja1Jlc2l6ZSkge1xyXG4gIFx0XHRcdG9uT2ZmKHdpbmRvdywgJ3Jlc2l6ZScsIHRoaXMuX29uUmVzaXplLCB0aGlzKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0aWYgKGFueTNkICYmIHRoaXMub3B0aW9ucy50cmFuc2Zvcm0zRExpbWl0KSB7XHJcbiAgXHRcdFx0KHJlbW92ZSQkMSA/IHRoaXMub2ZmIDogdGhpcy5vbikuY2FsbCh0aGlzLCAnbW92ZWVuZCcsIHRoaXMuX29uTW92ZUVuZCk7XHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0X29uUmVzaXplOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdGNhbmNlbEFuaW1GcmFtZSh0aGlzLl9yZXNpemVSZXF1ZXN0KTtcclxuICBcdFx0dGhpcy5fcmVzaXplUmVxdWVzdCA9IHJlcXVlc3RBbmltRnJhbWUoXHJcbiAgXHRcdCAgICAgICAgZnVuY3Rpb24gKCkgeyB0aGlzLmludmFsaWRhdGVTaXplKHtkZWJvdW5jZU1vdmVlbmQ6IHRydWV9KTsgfSwgdGhpcyk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9vblNjcm9sbDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR0aGlzLl9jb250YWluZXIuc2Nyb2xsVG9wICA9IDA7XHJcbiAgXHRcdHRoaXMuX2NvbnRhaW5lci5zY3JvbGxMZWZ0ID0gMDtcclxuICBcdH0sXHJcblxyXG4gIFx0X29uTW92ZUVuZDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR2YXIgcG9zID0gdGhpcy5fZ2V0TWFwUGFuZVBvcygpO1xyXG4gIFx0XHRpZiAoTWF0aC5tYXgoTWF0aC5hYnMocG9zLngpLCBNYXRoLmFicyhwb3MueSkpID49IHRoaXMub3B0aW9ucy50cmFuc2Zvcm0zRExpbWl0KSB7XHJcbiAgXHRcdFx0Ly8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTIwMzg3MyBidXQgV2Via2l0IGFsc28gaGF2ZVxyXG4gIFx0XHRcdC8vIGEgcGl4ZWwgb2Zmc2V0IG9uIHZlcnkgaGlnaCB2YWx1ZXMsIHNlZTogaHR0cDovL2pzZmlkZGxlLm5ldC9kZzZyNWhoYi9cclxuICBcdFx0XHR0aGlzLl9yZXNldFZpZXcodGhpcy5nZXRDZW50ZXIoKSwgdGhpcy5nZXRab29tKCkpO1xyXG4gIFx0XHR9XHJcbiAgXHR9LFxyXG5cclxuICBcdF9maW5kRXZlbnRUYXJnZXRzOiBmdW5jdGlvbiAoZSwgdHlwZSkge1xyXG4gIFx0XHR2YXIgdGFyZ2V0cyA9IFtdLFxyXG4gIFx0XHQgICAgdGFyZ2V0LFxyXG4gIFx0XHQgICAgaXNIb3ZlciA9IHR5cGUgPT09ICdtb3VzZW91dCcgfHwgdHlwZSA9PT0gJ21vdXNlb3ZlcicsXHJcbiAgXHRcdCAgICBzcmMgPSBlLnRhcmdldCB8fCBlLnNyY0VsZW1lbnQsXHJcbiAgXHRcdCAgICBkcmFnZ2luZyA9IGZhbHNlO1xyXG5cclxuICBcdFx0d2hpbGUgKHNyYykge1xyXG4gIFx0XHRcdHRhcmdldCA9IHRoaXMuX3RhcmdldHNbc3RhbXAoc3JjKV07XHJcbiAgXHRcdFx0aWYgKHRhcmdldCAmJiAodHlwZSA9PT0gJ2NsaWNrJyB8fCB0eXBlID09PSAncHJlY2xpY2snKSAmJiAhZS5fc2ltdWxhdGVkICYmIHRoaXMuX2RyYWdnYWJsZU1vdmVkKHRhcmdldCkpIHtcclxuICBcdFx0XHRcdC8vIFByZXZlbnQgZmlyaW5nIGNsaWNrIGFmdGVyIHlvdSBqdXN0IGRyYWdnZWQgYW4gb2JqZWN0LlxyXG4gIFx0XHRcdFx0ZHJhZ2dpbmcgPSB0cnVlO1xyXG4gIFx0XHRcdFx0YnJlYWs7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHRcdGlmICh0YXJnZXQgJiYgdGFyZ2V0Lmxpc3RlbnModHlwZSwgdHJ1ZSkpIHtcclxuICBcdFx0XHRcdGlmIChpc0hvdmVyICYmICFpc0V4dGVybmFsVGFyZ2V0KHNyYywgZSkpIHsgYnJlYWs7IH1cclxuICBcdFx0XHRcdHRhcmdldHMucHVzaCh0YXJnZXQpO1xyXG4gIFx0XHRcdFx0aWYgKGlzSG92ZXIpIHsgYnJlYWs7IH1cclxuICBcdFx0XHR9XHJcbiAgXHRcdFx0aWYgKHNyYyA9PT0gdGhpcy5fY29udGFpbmVyKSB7IGJyZWFrOyB9XHJcbiAgXHRcdFx0c3JjID0gc3JjLnBhcmVudE5vZGU7XHJcbiAgXHRcdH1cclxuICBcdFx0aWYgKCF0YXJnZXRzLmxlbmd0aCAmJiAhZHJhZ2dpbmcgJiYgIWlzSG92ZXIgJiYgaXNFeHRlcm5hbFRhcmdldChzcmMsIGUpKSB7XHJcbiAgXHRcdFx0dGFyZ2V0cyA9IFt0aGlzXTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gdGFyZ2V0cztcclxuICBcdH0sXHJcblxyXG4gIFx0X2hhbmRsZURPTUV2ZW50OiBmdW5jdGlvbiAoZSkge1xyXG4gIFx0XHRpZiAoIXRoaXMuX2xvYWRlZCB8fCBza2lwcGVkKGUpKSB7IHJldHVybjsgfVxyXG5cclxuICBcdFx0dmFyIHR5cGUgPSBlLnR5cGU7XHJcblxyXG4gIFx0XHRpZiAodHlwZSA9PT0gJ21vdXNlZG93bicgfHwgdHlwZSA9PT0gJ2tleXByZXNzJyB8fCB0eXBlID09PSAna2V5dXAnIHx8IHR5cGUgPT09ICdrZXlkb3duJykge1xyXG4gIFx0XHRcdC8vIHByZXZlbnRzIG91dGxpbmUgd2hlbiBjbGlja2luZyBvbiBrZXlib2FyZC1mb2N1c2FibGUgZWxlbWVudFxyXG4gIFx0XHRcdHByZXZlbnRPdXRsaW5lKGUudGFyZ2V0IHx8IGUuc3JjRWxlbWVudCk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMuX2ZpcmVET01FdmVudChlLCB0eXBlKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X21vdXNlRXZlbnRzOiBbJ2NsaWNrJywgJ2RibGNsaWNrJywgJ21vdXNlb3ZlcicsICdtb3VzZW91dCcsICdjb250ZXh0bWVudSddLFxyXG5cclxuICBcdF9maXJlRE9NRXZlbnQ6IGZ1bmN0aW9uIChlLCB0eXBlLCB0YXJnZXRzKSB7XHJcblxyXG4gIFx0XHRpZiAoZS50eXBlID09PSAnY2xpY2snKSB7XHJcbiAgXHRcdFx0Ly8gRmlyZSBhIHN5bnRoZXRpYyAncHJlY2xpY2snIGV2ZW50IHdoaWNoIHByb3BhZ2F0ZXMgdXAgKG1haW5seSBmb3IgY2xvc2luZyBwb3B1cHMpLlxyXG4gIFx0XHRcdC8vIEBldmVudCBwcmVjbGljazogTW91c2VFdmVudFxyXG4gIFx0XHRcdC8vIEZpcmVkIGJlZm9yZSBtb3VzZSBjbGljayBvbiB0aGUgbWFwIChzb21ldGltZXMgdXNlZnVsIHdoZW4geW91XHJcbiAgXHRcdFx0Ly8gd2FudCBzb21ldGhpbmcgdG8gaGFwcGVuIG9uIGNsaWNrIGJlZm9yZSBhbnkgZXhpc3RpbmcgY2xpY2tcclxuICBcdFx0XHQvLyBoYW5kbGVycyBzdGFydCBydW5uaW5nKS5cclxuICBcdFx0XHR2YXIgc3ludGggPSBleHRlbmQoe30sIGUpO1xyXG4gIFx0XHRcdHN5bnRoLnR5cGUgPSAncHJlY2xpY2snO1xyXG4gIFx0XHRcdHRoaXMuX2ZpcmVET01FdmVudChzeW50aCwgc3ludGgudHlwZSwgdGFyZ2V0cyk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGlmIChlLl9zdG9wcGVkKSB7IHJldHVybjsgfVxyXG5cclxuICBcdFx0Ly8gRmluZCB0aGUgbGF5ZXIgdGhlIGV2ZW50IGlzIHByb3BhZ2F0aW5nIGZyb20gYW5kIGl0cyBwYXJlbnRzLlxyXG4gIFx0XHR0YXJnZXRzID0gKHRhcmdldHMgfHwgW10pLmNvbmNhdCh0aGlzLl9maW5kRXZlbnRUYXJnZXRzKGUsIHR5cGUpKTtcclxuXHJcbiAgXHRcdGlmICghdGFyZ2V0cy5sZW5ndGgpIHsgcmV0dXJuOyB9XHJcblxyXG4gIFx0XHR2YXIgdGFyZ2V0ID0gdGFyZ2V0c1swXTtcclxuICBcdFx0aWYgKHR5cGUgPT09ICdjb250ZXh0bWVudScgJiYgdGFyZ2V0Lmxpc3RlbnModHlwZSwgdHJ1ZSkpIHtcclxuICBcdFx0XHRwcmV2ZW50RGVmYXVsdChlKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dmFyIGRhdGEgPSB7XHJcbiAgXHRcdFx0b3JpZ2luYWxFdmVudDogZVxyXG4gIFx0XHR9O1xyXG5cclxuICBcdFx0aWYgKGUudHlwZSAhPT0gJ2tleXByZXNzJyAmJiBlLnR5cGUgIT09ICdrZXlkb3duJyAmJiBlLnR5cGUgIT09ICdrZXl1cCcpIHtcclxuICBcdFx0XHR2YXIgaXNNYXJrZXIgPSB0YXJnZXQuZ2V0TGF0TG5nICYmICghdGFyZ2V0Ll9yYWRpdXMgfHwgdGFyZ2V0Ll9yYWRpdXMgPD0gMTApO1xyXG4gIFx0XHRcdGRhdGEuY29udGFpbmVyUG9pbnQgPSBpc01hcmtlciA/XHJcbiAgXHRcdFx0XHR0aGlzLmxhdExuZ1RvQ29udGFpbmVyUG9pbnQodGFyZ2V0LmdldExhdExuZygpKSA6IHRoaXMubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZSk7XHJcbiAgXHRcdFx0ZGF0YS5sYXllclBvaW50ID0gdGhpcy5jb250YWluZXJQb2ludFRvTGF5ZXJQb2ludChkYXRhLmNvbnRhaW5lclBvaW50KTtcclxuICBcdFx0XHRkYXRhLmxhdGxuZyA9IGlzTWFya2VyID8gdGFyZ2V0LmdldExhdExuZygpIDogdGhpcy5sYXllclBvaW50VG9MYXRMbmcoZGF0YS5sYXllclBvaW50KTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0YXJnZXRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgXHRcdFx0dGFyZ2V0c1tpXS5maXJlKHR5cGUsIGRhdGEsIHRydWUpO1xyXG4gIFx0XHRcdGlmIChkYXRhLm9yaWdpbmFsRXZlbnQuX3N0b3BwZWQgfHxcclxuICBcdFx0XHRcdCh0YXJnZXRzW2ldLm9wdGlvbnMuYnViYmxpbmdNb3VzZUV2ZW50cyA9PT0gZmFsc2UgJiYgaW5kZXhPZih0aGlzLl9tb3VzZUV2ZW50cywgdHlwZSkgIT09IC0xKSkgeyByZXR1cm47IH1cclxuICBcdFx0fVxyXG4gIFx0fSxcclxuXHJcbiAgXHRfZHJhZ2dhYmxlTW92ZWQ6IGZ1bmN0aW9uIChvYmopIHtcclxuICBcdFx0b2JqID0gb2JqLmRyYWdnaW5nICYmIG9iai5kcmFnZ2luZy5lbmFibGVkKCkgPyBvYmogOiB0aGlzO1xyXG4gIFx0XHRyZXR1cm4gKG9iai5kcmFnZ2luZyAmJiBvYmouZHJhZ2dpbmcubW92ZWQoKSkgfHwgKHRoaXMuYm94Wm9vbSAmJiB0aGlzLmJveFpvb20ubW92ZWQoKSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9jbGVhckhhbmRsZXJzOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9oYW5kbGVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gIFx0XHRcdHRoaXMuX2hhbmRsZXJzW2ldLmRpc2FibGUoKTtcclxuICBcdFx0fVxyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAc2VjdGlvbiBPdGhlciBNZXRob2RzXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCB3aGVuUmVhZHkoZm46IEZ1bmN0aW9uLCBjb250ZXh0PzogT2JqZWN0KTogdGhpc1xyXG4gIFx0Ly8gUnVucyB0aGUgZ2l2ZW4gZnVuY3Rpb24gYGZuYCB3aGVuIHRoZSBtYXAgZ2V0cyBpbml0aWFsaXplZCB3aXRoXHJcbiAgXHQvLyBhIHZpZXcgKGNlbnRlciBhbmQgem9vbSkgYW5kIGF0IGxlYXN0IG9uZSBsYXllciwgb3IgaW1tZWRpYXRlbHlcclxuICBcdC8vIGlmIGl0J3MgYWxyZWFkeSBpbml0aWFsaXplZCwgb3B0aW9uYWxseSBwYXNzaW5nIGEgZnVuY3Rpb24gY29udGV4dC5cclxuICBcdHdoZW5SZWFkeTogZnVuY3Rpb24gKGNhbGxiYWNrLCBjb250ZXh0KSB7XHJcbiAgXHRcdGlmICh0aGlzLl9sb2FkZWQpIHtcclxuICBcdFx0XHRjYWxsYmFjay5jYWxsKGNvbnRleHQgfHwgdGhpcywge3RhcmdldDogdGhpc30pO1xyXG4gIFx0XHR9IGVsc2Uge1xyXG4gIFx0XHRcdHRoaXMub24oJ2xvYWQnLCBjYWxsYmFjaywgY29udGV4dCk7XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuXHJcbiAgXHQvLyBwcml2YXRlIG1ldGhvZHMgZm9yIGdldHRpbmcgbWFwIHN0YXRlXHJcblxyXG4gIFx0X2dldE1hcFBhbmVQb3M6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIGdldFBvc2l0aW9uKHRoaXMuX21hcFBhbmUpIHx8IG5ldyBQb2ludCgwLCAwKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X21vdmVkOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHZhciBwb3MgPSB0aGlzLl9nZXRNYXBQYW5lUG9zKCk7XHJcbiAgXHRcdHJldHVybiBwb3MgJiYgIXBvcy5lcXVhbHMoWzAsIDBdKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X2dldFRvcExlZnRQb2ludDogZnVuY3Rpb24gKGNlbnRlciwgem9vbSkge1xyXG4gIFx0XHR2YXIgcGl4ZWxPcmlnaW4gPSBjZW50ZXIgJiYgem9vbSAhPT0gdW5kZWZpbmVkID9cclxuICBcdFx0XHR0aGlzLl9nZXROZXdQaXhlbE9yaWdpbihjZW50ZXIsIHpvb20pIDpcclxuICBcdFx0XHR0aGlzLmdldFBpeGVsT3JpZ2luKCk7XHJcbiAgXHRcdHJldHVybiBwaXhlbE9yaWdpbi5zdWJ0cmFjdCh0aGlzLl9nZXRNYXBQYW5lUG9zKCkpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfZ2V0TmV3UGl4ZWxPcmlnaW46IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20pIHtcclxuICBcdFx0dmFyIHZpZXdIYWxmID0gdGhpcy5nZXRTaXplKCkuX2RpdmlkZUJ5KDIpO1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5wcm9qZWN0KGNlbnRlciwgem9vbSkuX3N1YnRyYWN0KHZpZXdIYWxmKS5fYWRkKHRoaXMuX2dldE1hcFBhbmVQb3MoKSkuX3JvdW5kKCk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9sYXRMbmdUb05ld0xheWVyUG9pbnQ6IGZ1bmN0aW9uIChsYXRsbmcsIHpvb20sIGNlbnRlcikge1xyXG4gIFx0XHR2YXIgdG9wTGVmdCA9IHRoaXMuX2dldE5ld1BpeGVsT3JpZ2luKGNlbnRlciwgem9vbSk7XHJcbiAgXHRcdHJldHVybiB0aGlzLnByb2plY3QobGF0bG5nLCB6b29tKS5fc3VidHJhY3QodG9wTGVmdCk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9sYXRMbmdCb3VuZHNUb05ld0xheWVyQm91bmRzOiBmdW5jdGlvbiAobGF0TG5nQm91bmRzLCB6b29tLCBjZW50ZXIpIHtcclxuICBcdFx0dmFyIHRvcExlZnQgPSB0aGlzLl9nZXROZXdQaXhlbE9yaWdpbihjZW50ZXIsIHpvb20pO1xyXG4gIFx0XHRyZXR1cm4gdG9Cb3VuZHMoW1xyXG4gIFx0XHRcdHRoaXMucHJvamVjdChsYXRMbmdCb3VuZHMuZ2V0U291dGhXZXN0KCksIHpvb20pLl9zdWJ0cmFjdCh0b3BMZWZ0KSxcclxuICBcdFx0XHR0aGlzLnByb2plY3QobGF0TG5nQm91bmRzLmdldE5vcnRoV2VzdCgpLCB6b29tKS5fc3VidHJhY3QodG9wTGVmdCksXHJcbiAgXHRcdFx0dGhpcy5wcm9qZWN0KGxhdExuZ0JvdW5kcy5nZXRTb3V0aEVhc3QoKSwgem9vbSkuX3N1YnRyYWN0KHRvcExlZnQpLFxyXG4gIFx0XHRcdHRoaXMucHJvamVjdChsYXRMbmdCb3VuZHMuZ2V0Tm9ydGhFYXN0KCksIHpvb20pLl9zdWJ0cmFjdCh0b3BMZWZ0KVxyXG4gIFx0XHRdKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gbGF5ZXIgcG9pbnQgb2YgdGhlIGN1cnJlbnQgY2VudGVyXHJcbiAgXHRfZ2V0Q2VudGVyTGF5ZXJQb2ludDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5jb250YWluZXJQb2ludFRvTGF5ZXJQb2ludCh0aGlzLmdldFNpemUoKS5fZGl2aWRlQnkoMikpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBvZmZzZXQgb2YgdGhlIHNwZWNpZmllZCBwbGFjZSB0byB0aGUgY3VycmVudCBjZW50ZXIgaW4gcGl4ZWxzXHJcbiAgXHRfZ2V0Q2VudGVyT2Zmc2V0OiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLmxhdExuZ1RvTGF5ZXJQb2ludChsYXRsbmcpLnN1YnRyYWN0KHRoaXMuX2dldENlbnRlckxheWVyUG9pbnQoKSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIGFkanVzdCBjZW50ZXIgZm9yIHZpZXcgdG8gZ2V0IGluc2lkZSBib3VuZHNcclxuICBcdF9saW1pdENlbnRlcjogZnVuY3Rpb24gKGNlbnRlciwgem9vbSwgYm91bmRzKSB7XHJcblxyXG4gIFx0XHRpZiAoIWJvdW5kcykgeyByZXR1cm4gY2VudGVyOyB9XHJcblxyXG4gIFx0XHR2YXIgY2VudGVyUG9pbnQgPSB0aGlzLnByb2plY3QoY2VudGVyLCB6b29tKSxcclxuICBcdFx0ICAgIHZpZXdIYWxmID0gdGhpcy5nZXRTaXplKCkuZGl2aWRlQnkoMiksXHJcbiAgXHRcdCAgICB2aWV3Qm91bmRzID0gbmV3IEJvdW5kcyhjZW50ZXJQb2ludC5zdWJ0cmFjdCh2aWV3SGFsZiksIGNlbnRlclBvaW50LmFkZCh2aWV3SGFsZikpLFxyXG4gIFx0XHQgICAgb2Zmc2V0ID0gdGhpcy5fZ2V0Qm91bmRzT2Zmc2V0KHZpZXdCb3VuZHMsIGJvdW5kcywgem9vbSk7XHJcblxyXG4gIFx0XHQvLyBJZiBvZmZzZXQgaXMgbGVzcyB0aGFuIGEgcGl4ZWwsIGlnbm9yZS5cclxuICBcdFx0Ly8gVGhpcyBwcmV2ZW50cyB1bnN0YWJsZSBwcm9qZWN0aW9ucyBmcm9tIGdldHRpbmcgaW50b1xyXG4gIFx0XHQvLyBhbiBpbmZpbml0ZSBsb29wIG9mIHRpbnkgb2Zmc2V0cy5cclxuICBcdFx0aWYgKG9mZnNldC5yb3VuZCgpLmVxdWFscyhbMCwgMF0pKSB7XHJcbiAgXHRcdFx0cmV0dXJuIGNlbnRlcjtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0cmV0dXJuIHRoaXMudW5wcm9qZWN0KGNlbnRlclBvaW50LmFkZChvZmZzZXQpLCB6b29tKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gYWRqdXN0IG9mZnNldCBmb3IgdmlldyB0byBnZXQgaW5zaWRlIGJvdW5kc1xyXG4gIFx0X2xpbWl0T2Zmc2V0OiBmdW5jdGlvbiAob2Zmc2V0LCBib3VuZHMpIHtcclxuICBcdFx0aWYgKCFib3VuZHMpIHsgcmV0dXJuIG9mZnNldDsgfVxyXG5cclxuICBcdFx0dmFyIHZpZXdCb3VuZHMgPSB0aGlzLmdldFBpeGVsQm91bmRzKCksXHJcbiAgXHRcdCAgICBuZXdCb3VuZHMgPSBuZXcgQm91bmRzKHZpZXdCb3VuZHMubWluLmFkZChvZmZzZXQpLCB2aWV3Qm91bmRzLm1heC5hZGQob2Zmc2V0KSk7XHJcblxyXG4gIFx0XHRyZXR1cm4gb2Zmc2V0LmFkZCh0aGlzLl9nZXRCb3VuZHNPZmZzZXQobmV3Qm91bmRzLCBib3VuZHMpKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gcmV0dXJucyBvZmZzZXQgbmVlZGVkIGZvciBweEJvdW5kcyB0byBnZXQgaW5zaWRlIG1heEJvdW5kcyBhdCBhIHNwZWNpZmllZCB6b29tXHJcbiAgXHRfZ2V0Qm91bmRzT2Zmc2V0OiBmdW5jdGlvbiAocHhCb3VuZHMsIG1heEJvdW5kcywgem9vbSkge1xyXG4gIFx0XHR2YXIgcHJvamVjdGVkTWF4Qm91bmRzID0gdG9Cb3VuZHMoXHJcbiAgXHRcdCAgICAgICAgdGhpcy5wcm9qZWN0KG1heEJvdW5kcy5nZXROb3J0aEVhc3QoKSwgem9vbSksXHJcbiAgXHRcdCAgICAgICAgdGhpcy5wcm9qZWN0KG1heEJvdW5kcy5nZXRTb3V0aFdlc3QoKSwgem9vbSlcclxuICBcdFx0ICAgICksXHJcbiAgXHRcdCAgICBtaW5PZmZzZXQgPSBwcm9qZWN0ZWRNYXhCb3VuZHMubWluLnN1YnRyYWN0KHB4Qm91bmRzLm1pbiksXHJcbiAgXHRcdCAgICBtYXhPZmZzZXQgPSBwcm9qZWN0ZWRNYXhCb3VuZHMubWF4LnN1YnRyYWN0KHB4Qm91bmRzLm1heCksXHJcblxyXG4gIFx0XHQgICAgZHggPSB0aGlzLl9yZWJvdW5kKG1pbk9mZnNldC54LCAtbWF4T2Zmc2V0LngpLFxyXG4gIFx0XHQgICAgZHkgPSB0aGlzLl9yZWJvdW5kKG1pbk9mZnNldC55LCAtbWF4T2Zmc2V0LnkpO1xyXG5cclxuICBcdFx0cmV0dXJuIG5ldyBQb2ludChkeCwgZHkpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfcmVib3VuZDogZnVuY3Rpb24gKGxlZnQsIHJpZ2h0KSB7XHJcbiAgXHRcdHJldHVybiBsZWZ0ICsgcmlnaHQgPiAwID9cclxuICBcdFx0XHRNYXRoLnJvdW5kKGxlZnQgLSByaWdodCkgLyAyIDpcclxuICBcdFx0XHRNYXRoLm1heCgwLCBNYXRoLmNlaWwobGVmdCkpIC0gTWF0aC5tYXgoMCwgTWF0aC5mbG9vcihyaWdodCkpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfbGltaXRab29tOiBmdW5jdGlvbiAoem9vbSkge1xyXG4gIFx0XHR2YXIgbWluID0gdGhpcy5nZXRNaW5ab29tKCksXHJcbiAgXHRcdCAgICBtYXggPSB0aGlzLmdldE1heFpvb20oKSxcclxuICBcdFx0ICAgIHNuYXAgPSBhbnkzZCA/IHRoaXMub3B0aW9ucy56b29tU25hcCA6IDE7XHJcbiAgXHRcdGlmIChzbmFwKSB7XHJcbiAgXHRcdFx0em9vbSA9IE1hdGgucm91bmQoem9vbSAvIHNuYXApICogc25hcDtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gTWF0aC5tYXgobWluLCBNYXRoLm1pbihtYXgsIHpvb20pKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X29uUGFuVHJhbnNpdGlvblN0ZXA6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dGhpcy5maXJlKCdtb3ZlJyk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9vblBhblRyYW5zaXRpb25FbmQ6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmVtb3ZlQ2xhc3ModGhpcy5fbWFwUGFuZSwgJ2xlYWZsZXQtcGFuLWFuaW0nKTtcclxuICBcdFx0dGhpcy5maXJlKCdtb3ZlZW5kJyk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF90cnlBbmltYXRlZFBhbjogZnVuY3Rpb24gKGNlbnRlciwgb3B0aW9ucykge1xyXG4gIFx0XHQvLyBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIG5ldyBhbmQgY3VycmVudCBjZW50ZXJzIGluIHBpeGVsc1xyXG4gIFx0XHR2YXIgb2Zmc2V0ID0gdGhpcy5fZ2V0Q2VudGVyT2Zmc2V0KGNlbnRlcikuX3RydW5jKCk7XHJcblxyXG4gIFx0XHQvLyBkb24ndCBhbmltYXRlIHRvbyBmYXIgdW5sZXNzIGFuaW1hdGU6IHRydWUgc3BlY2lmaWVkIGluIG9wdGlvbnNcclxuICBcdFx0aWYgKChvcHRpb25zICYmIG9wdGlvbnMuYW5pbWF0ZSkgIT09IHRydWUgJiYgIXRoaXMuZ2V0U2l6ZSgpLmNvbnRhaW5zKG9mZnNldCkpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblxyXG4gIFx0XHR0aGlzLnBhbkJ5KG9mZnNldCwgb3B0aW9ucyk7XHJcblxyXG4gIFx0XHRyZXR1cm4gdHJ1ZTtcclxuICBcdH0sXHJcblxyXG4gIFx0X2NyZWF0ZUFuaW1Qcm94eTogZnVuY3Rpb24gKCkge1xyXG5cclxuICBcdFx0dmFyIHByb3h5ID0gdGhpcy5fcHJveHkgPSBjcmVhdGUkMSgnZGl2JywgJ2xlYWZsZXQtcHJveHkgbGVhZmxldC16b29tLWFuaW1hdGVkJyk7XHJcbiAgXHRcdHRoaXMuX3BhbmVzLm1hcFBhbmUuYXBwZW5kQ2hpbGQocHJveHkpO1xyXG5cclxuICBcdFx0dGhpcy5vbignem9vbWFuaW0nLCBmdW5jdGlvbiAoZSkge1xyXG4gIFx0XHRcdHZhciBwcm9wID0gVFJBTlNGT1JNLFxyXG4gIFx0XHRcdCAgICB0cmFuc2Zvcm0gPSB0aGlzLl9wcm94eS5zdHlsZVtwcm9wXTtcclxuXHJcbiAgXHRcdFx0c2V0VHJhbnNmb3JtKHRoaXMuX3Byb3h5LCB0aGlzLnByb2plY3QoZS5jZW50ZXIsIGUuem9vbSksIHRoaXMuZ2V0Wm9vbVNjYWxlKGUuem9vbSwgMSkpO1xyXG5cclxuICBcdFx0XHQvLyB3b3JrYXJvdW5kIGZvciBjYXNlIHdoZW4gdHJhbnNmb3JtIGlzIHRoZSBzYW1lIGFuZCBzbyB0cmFuc2l0aW9uZW5kIGV2ZW50IGlzIG5vdCBmaXJlZFxyXG4gIFx0XHRcdGlmICh0cmFuc2Zvcm0gPT09IHRoaXMuX3Byb3h5LnN0eWxlW3Byb3BdICYmIHRoaXMuX2FuaW1hdGluZ1pvb20pIHtcclxuICBcdFx0XHRcdHRoaXMuX29uWm9vbVRyYW5zaXRpb25FbmQoKTtcclxuICBcdFx0XHR9XHJcbiAgXHRcdH0sIHRoaXMpO1xyXG5cclxuICBcdFx0dGhpcy5vbignbG9hZCBtb3ZlZW5kJywgdGhpcy5fYW5pbU1vdmVFbmQsIHRoaXMpO1xyXG5cclxuICBcdFx0dGhpcy5fb24oJ3VubG9hZCcsIHRoaXMuX2Rlc3Ryb3lBbmltUHJveHksIHRoaXMpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfZGVzdHJveUFuaW1Qcm94eTogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZW1vdmUodGhpcy5fcHJveHkpO1xyXG4gIFx0XHR0aGlzLm9mZignbG9hZCBtb3ZlZW5kJywgdGhpcy5fYW5pbU1vdmVFbmQsIHRoaXMpO1xyXG4gIFx0XHRkZWxldGUgdGhpcy5fcHJveHk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9hbmltTW92ZUVuZDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR2YXIgYyA9IHRoaXMuZ2V0Q2VudGVyKCksXHJcbiAgXHRcdCAgICB6ID0gdGhpcy5nZXRab29tKCk7XHJcbiAgXHRcdHNldFRyYW5zZm9ybSh0aGlzLl9wcm94eSwgdGhpcy5wcm9qZWN0KGMsIHopLCB0aGlzLmdldFpvb21TY2FsZSh6LCAxKSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9jYXRjaFRyYW5zaXRpb25FbmQ6IGZ1bmN0aW9uIChlKSB7XHJcbiAgXHRcdGlmICh0aGlzLl9hbmltYXRpbmdab29tICYmIGUucHJvcGVydHlOYW1lLmluZGV4T2YoJ3RyYW5zZm9ybScpID49IDApIHtcclxuICBcdFx0XHR0aGlzLl9vblpvb21UcmFuc2l0aW9uRW5kKCk7XHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0X25vdGhpbmdUb0FuaW1hdGU6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuICF0aGlzLl9jb250YWluZXIuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnbGVhZmxldC16b29tLWFuaW1hdGVkJykubGVuZ3RoO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfdHJ5QW5pbWF0ZWRab29tOiBmdW5jdGlvbiAoY2VudGVyLCB6b29tLCBvcHRpb25zKSB7XHJcblxyXG4gIFx0XHRpZiAodGhpcy5fYW5pbWF0aW5nWm9vbSkgeyByZXR1cm4gdHJ1ZTsgfVxyXG5cclxuICBcdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblxyXG4gIFx0XHQvLyBkb24ndCBhbmltYXRlIGlmIGRpc2FibGVkLCBub3Qgc3VwcG9ydGVkIG9yIHpvb20gZGlmZmVyZW5jZSBpcyB0b28gbGFyZ2VcclxuICBcdFx0aWYgKCF0aGlzLl96b29tQW5pbWF0ZWQgfHwgb3B0aW9ucy5hbmltYXRlID09PSBmYWxzZSB8fCB0aGlzLl9ub3RoaW5nVG9BbmltYXRlKCkgfHxcclxuICBcdFx0ICAgICAgICBNYXRoLmFicyh6b29tIC0gdGhpcy5fem9vbSkgPiB0aGlzLm9wdGlvbnMuem9vbUFuaW1hdGlvblRocmVzaG9sZCkgeyByZXR1cm4gZmFsc2U7IH1cclxuXHJcbiAgXHRcdC8vIG9mZnNldCBpcyB0aGUgcGl4ZWwgY29vcmRzIG9mIHRoZSB6b29tIG9yaWdpbiByZWxhdGl2ZSB0byB0aGUgY3VycmVudCBjZW50ZXJcclxuICBcdFx0dmFyIHNjYWxlID0gdGhpcy5nZXRab29tU2NhbGUoem9vbSksXHJcbiAgXHRcdCAgICBvZmZzZXQgPSB0aGlzLl9nZXRDZW50ZXJPZmZzZXQoY2VudGVyKS5fZGl2aWRlQnkoMSAtIDEgLyBzY2FsZSk7XHJcblxyXG4gIFx0XHQvLyBkb24ndCBhbmltYXRlIGlmIHRoZSB6b29tIG9yaWdpbiBpc24ndCB3aXRoaW4gb25lIHNjcmVlbiBmcm9tIHRoZSBjdXJyZW50IGNlbnRlciwgdW5sZXNzIGZvcmNlZFxyXG4gIFx0XHRpZiAob3B0aW9ucy5hbmltYXRlICE9PSB0cnVlICYmICF0aGlzLmdldFNpemUoKS5jb250YWlucyhvZmZzZXQpKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cclxuICBcdFx0cmVxdWVzdEFuaW1GcmFtZShmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdFx0dGhpc1xyXG4gIFx0XHRcdCAgICAuX21vdmVTdGFydCh0cnVlLCBmYWxzZSlcclxuICBcdFx0XHQgICAgLl9hbmltYXRlWm9vbShjZW50ZXIsIHpvb20sIHRydWUpO1xyXG4gIFx0XHR9LCB0aGlzKTtcclxuXHJcbiAgXHRcdHJldHVybiB0cnVlO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfYW5pbWF0ZVpvb206IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20sIHN0YXJ0QW5pbSwgbm9VcGRhdGUpIHtcclxuICBcdFx0aWYgKCF0aGlzLl9tYXBQYW5lKSB7IHJldHVybjsgfVxyXG5cclxuICBcdFx0aWYgKHN0YXJ0QW5pbSkge1xyXG4gIFx0XHRcdHRoaXMuX2FuaW1hdGluZ1pvb20gPSB0cnVlO1xyXG5cclxuICBcdFx0XHQvLyByZW1lbWJlciB3aGF0IGNlbnRlci96b29tIHRvIHNldCBhZnRlciBhbmltYXRpb25cclxuICBcdFx0XHR0aGlzLl9hbmltYXRlVG9DZW50ZXIgPSBjZW50ZXI7XHJcbiAgXHRcdFx0dGhpcy5fYW5pbWF0ZVRvWm9vbSA9IHpvb207XHJcblxyXG4gIFx0XHRcdGFkZENsYXNzKHRoaXMuX21hcFBhbmUsICdsZWFmbGV0LXpvb20tYW5pbScpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHQvLyBAc2VjdGlvbiBPdGhlciBFdmVudHNcclxuICBcdFx0Ly8gQGV2ZW50IHpvb21hbmltOiBab29tQW5pbUV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIGF0IGxlYXN0IG9uY2UgcGVyIHpvb20gYW5pbWF0aW9uLiBGb3IgY29udGludW91cyB6b29tLCBsaWtlIHBpbmNoIHpvb21pbmcsIGZpcmVkIG9uY2UgcGVyIGZyYW1lIGR1cmluZyB6b29tLlxyXG4gIFx0XHR0aGlzLmZpcmUoJ3pvb21hbmltJywge1xyXG4gIFx0XHRcdGNlbnRlcjogY2VudGVyLFxyXG4gIFx0XHRcdHpvb206IHpvb20sXHJcbiAgXHRcdFx0bm9VcGRhdGU6IG5vVXBkYXRlXHJcbiAgXHRcdH0pO1xyXG5cclxuICBcdFx0Ly8gV29yayBhcm91bmQgd2Via2l0IG5vdCBmaXJpbmcgJ3RyYW5zaXRpb25lbmQnLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL0xlYWZsZXQvTGVhZmxldC9pc3N1ZXMvMzY4OSwgMjY5M1xyXG4gIFx0XHRzZXRUaW1lb3V0KGJpbmQodGhpcy5fb25ab29tVHJhbnNpdGlvbkVuZCwgdGhpcyksIDI1MCk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9vblpvb21UcmFuc2l0aW9uRW5kOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdGlmICghdGhpcy5fYW5pbWF0aW5nWm9vbSkgeyByZXR1cm47IH1cclxuXHJcbiAgXHRcdGlmICh0aGlzLl9tYXBQYW5lKSB7XHJcbiAgXHRcdFx0cmVtb3ZlQ2xhc3ModGhpcy5fbWFwUGFuZSwgJ2xlYWZsZXQtem9vbS1hbmltJyk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMuX2FuaW1hdGluZ1pvb20gPSBmYWxzZTtcclxuXHJcbiAgXHRcdHRoaXMuX21vdmUodGhpcy5fYW5pbWF0ZVRvQ2VudGVyLCB0aGlzLl9hbmltYXRlVG9ab29tKTtcclxuXHJcbiAgXHRcdC8vIFRoaXMgYW5pbSBmcmFtZSBzaG91bGQgcHJldmVudCBhbiBvYnNjdXJlIGlPUyB3ZWJraXQgdGlsZSBsb2FkaW5nIHJhY2UgY29uZGl0aW9uLlxyXG4gIFx0XHRyZXF1ZXN0QW5pbUZyYW1lKGZ1bmN0aW9uICgpIHtcclxuICBcdFx0XHR0aGlzLl9tb3ZlRW5kKHRydWUpO1xyXG4gIFx0XHR9LCB0aGlzKTtcclxuICBcdH1cclxuICB9KTtcclxuXHJcbiAgLy8gQHNlY3Rpb25cclxuXHJcbiAgLy8gQGZhY3RvcnkgTC5tYXAoaWQ6IFN0cmluZywgb3B0aW9ucz86IE1hcCBvcHRpb25zKVxyXG4gIC8vIEluc3RhbnRpYXRlcyBhIG1hcCBvYmplY3QgZ2l2ZW4gdGhlIERPTSBJRCBvZiBhIGA8ZGl2PmAgZWxlbWVudFxyXG4gIC8vIGFuZCBvcHRpb25hbGx5IGFuIG9iamVjdCBsaXRlcmFsIHdpdGggYE1hcCBvcHRpb25zYC5cclxuICAvL1xyXG4gIC8vIEBhbHRlcm5hdGl2ZVxyXG4gIC8vIEBmYWN0b3J5IEwubWFwKGVsOiBIVE1MRWxlbWVudCwgb3B0aW9ucz86IE1hcCBvcHRpb25zKVxyXG4gIC8vIEluc3RhbnRpYXRlcyBhIG1hcCBvYmplY3QgZ2l2ZW4gYW4gaW5zdGFuY2Ugb2YgYSBgPGRpdj5gIEhUTUwgZWxlbWVudFxyXG4gIC8vIGFuZCBvcHRpb25hbGx5IGFuIG9iamVjdCBsaXRlcmFsIHdpdGggYE1hcCBvcHRpb25zYC5cclxuICBmdW5jdGlvbiBjcmVhdGVNYXAoaWQsIG9wdGlvbnMpIHtcclxuICBcdHJldHVybiBuZXcgTWFwKGlkLCBvcHRpb25zKTtcclxuICB9XG5cbiAgLypcclxuICAgKiBAY2xhc3MgQ29udHJvbFxyXG4gICAqIEBha2EgTC5Db250cm9sXHJcbiAgICogQGluaGVyaXRzIENsYXNzXHJcbiAgICpcclxuICAgKiBMLkNvbnRyb2wgaXMgYSBiYXNlIGNsYXNzIGZvciBpbXBsZW1lbnRpbmcgbWFwIGNvbnRyb2xzLiBIYW5kbGVzIHBvc2l0aW9uaW5nLlxyXG4gICAqIEFsbCBvdGhlciBjb250cm9scyBleHRlbmQgZnJvbSB0aGlzIGNsYXNzLlxyXG4gICAqL1xyXG5cclxuICB2YXIgQ29udHJvbCA9IENsYXNzLmV4dGVuZCh7XHJcbiAgXHQvLyBAc2VjdGlvblxyXG4gIFx0Ly8gQGFrYSBDb250cm9sIG9wdGlvbnNcclxuICBcdG9wdGlvbnM6IHtcclxuICBcdFx0Ly8gQG9wdGlvbiBwb3NpdGlvbjogU3RyaW5nID0gJ3RvcHJpZ2h0J1xyXG4gIFx0XHQvLyBUaGUgcG9zaXRpb24gb2YgdGhlIGNvbnRyb2wgKG9uZSBvZiB0aGUgbWFwIGNvcm5lcnMpLiBQb3NzaWJsZSB2YWx1ZXMgYXJlIGAndG9wbGVmdCdgLFxyXG4gIFx0XHQvLyBgJ3RvcHJpZ2h0J2AsIGAnYm90dG9tbGVmdCdgIG9yIGAnYm90dG9tcmlnaHQnYFxyXG4gIFx0XHRwb3NpdGlvbjogJ3RvcHJpZ2h0J1xyXG4gIFx0fSxcclxuXHJcbiAgXHRpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gIFx0XHRzZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvKiBAc2VjdGlvblxyXG4gIFx0ICogQ2xhc3NlcyBleHRlbmRpbmcgTC5Db250cm9sIHdpbGwgaW5oZXJpdCB0aGUgZm9sbG93aW5nIG1ldGhvZHM6XHJcbiAgXHQgKlxyXG4gIFx0ICogQG1ldGhvZCBnZXRQb3NpdGlvbjogc3RyaW5nXHJcbiAgXHQgKiBSZXR1cm5zIHRoZSBwb3NpdGlvbiBvZiB0aGUgY29udHJvbC5cclxuICBcdCAqL1xyXG4gIFx0Z2V0UG9zaXRpb246IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5wb3NpdGlvbjtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBzZXRQb3NpdGlvbihwb3NpdGlvbjogc3RyaW5nKTogdGhpc1xyXG4gIFx0Ly8gU2V0cyB0aGUgcG9zaXRpb24gb2YgdGhlIGNvbnRyb2wuXHJcbiAgXHRzZXRQb3NpdGlvbjogZnVuY3Rpb24gKHBvc2l0aW9uKSB7XHJcbiAgXHRcdHZhciBtYXAgPSB0aGlzLl9tYXA7XHJcblxyXG4gIFx0XHRpZiAobWFwKSB7XHJcbiAgXHRcdFx0bWFwLnJlbW92ZUNvbnRyb2wodGhpcyk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMub3B0aW9ucy5wb3NpdGlvbiA9IHBvc2l0aW9uO1xyXG5cclxuICBcdFx0aWYgKG1hcCkge1xyXG4gIFx0XHRcdG1hcC5hZGRDb250cm9sKHRoaXMpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRDb250YWluZXI6IEhUTUxFbGVtZW50XHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBIVE1MRWxlbWVudCB0aGF0IGNvbnRhaW5zIHRoZSBjb250cm9sLlxyXG4gIFx0Z2V0Q29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLl9jb250YWluZXI7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgYWRkVG8obWFwOiBNYXApOiB0aGlzXHJcbiAgXHQvLyBBZGRzIHRoZSBjb250cm9sIHRvIHRoZSBnaXZlbiBtYXAuXHJcbiAgXHRhZGRUbzogZnVuY3Rpb24gKG1hcCkge1xyXG4gIFx0XHR0aGlzLnJlbW92ZSgpO1xyXG4gIFx0XHR0aGlzLl9tYXAgPSBtYXA7XHJcblxyXG4gIFx0XHR2YXIgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyID0gdGhpcy5vbkFkZChtYXApLFxyXG4gIFx0XHQgICAgcG9zID0gdGhpcy5nZXRQb3NpdGlvbigpLFxyXG4gIFx0XHQgICAgY29ybmVyID0gbWFwLl9jb250cm9sQ29ybmVyc1twb3NdO1xyXG5cclxuICBcdFx0YWRkQ2xhc3MoY29udGFpbmVyLCAnbGVhZmxldC1jb250cm9sJyk7XHJcblxyXG4gIFx0XHRpZiAocG9zLmluZGV4T2YoJ2JvdHRvbScpICE9PSAtMSkge1xyXG4gIFx0XHRcdGNvcm5lci5pbnNlcnRCZWZvcmUoY29udGFpbmVyLCBjb3JuZXIuZmlyc3RDaGlsZCk7XHJcbiAgXHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0Y29ybmVyLmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMuX21hcC5vbigndW5sb2FkJywgdGhpcy5yZW1vdmUsIHRoaXMpO1xyXG5cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgcmVtb3ZlOiB0aGlzXHJcbiAgXHQvLyBSZW1vdmVzIHRoZSBjb250cm9sIGZyb20gdGhlIG1hcCBpdCBpcyBjdXJyZW50bHkgYWN0aXZlIG9uLlxyXG4gIFx0cmVtb3ZlOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdGlmICghdGhpcy5fbWFwKSB7XHJcbiAgXHRcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHJlbW92ZSh0aGlzLl9jb250YWluZXIpO1xyXG5cclxuICBcdFx0aWYgKHRoaXMub25SZW1vdmUpIHtcclxuICBcdFx0XHR0aGlzLm9uUmVtb3ZlKHRoaXMuX21hcCk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMuX21hcC5vZmYoJ3VubG9hZCcsIHRoaXMucmVtb3ZlLCB0aGlzKTtcclxuICBcdFx0dGhpcy5fbWFwID0gbnVsbDtcclxuXHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfcmVmb2N1c09uTWFwOiBmdW5jdGlvbiAoZSkge1xyXG4gIFx0XHQvLyBpZiBtYXAgZXhpc3RzIGFuZCBldmVudCBpcyBub3QgYSBrZXlib2FyZCBldmVudFxyXG4gIFx0XHRpZiAodGhpcy5fbWFwICYmIGUgJiYgZS5zY3JlZW5YID4gMCAmJiBlLnNjcmVlblkgPiAwKSB7XHJcbiAgXHRcdFx0dGhpcy5fbWFwLmdldENvbnRhaW5lcigpLmZvY3VzKCk7XHJcbiAgXHRcdH1cclxuICBcdH1cclxuICB9KTtcclxuXHJcbiAgdmFyIGNvbnRyb2wgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gIFx0cmV0dXJuIG5ldyBDb250cm9sKG9wdGlvbnMpO1xyXG4gIH07XHJcblxyXG4gIC8qIEBzZWN0aW9uIEV4dGVuc2lvbiBtZXRob2RzXHJcbiAgICogQHVuaW5oZXJpdGFibGVcclxuICAgKlxyXG4gICAqIEV2ZXJ5IGNvbnRyb2wgc2hvdWxkIGV4dGVuZCBmcm9tIGBMLkNvbnRyb2xgIGFuZCAocmUtKWltcGxlbWVudCB0aGUgZm9sbG93aW5nIG1ldGhvZHMuXHJcbiAgICpcclxuICAgKiBAbWV0aG9kIG9uQWRkKG1hcDogTWFwKTogSFRNTEVsZW1lbnRcclxuICAgKiBTaG91bGQgcmV0dXJuIHRoZSBjb250YWluZXIgRE9NIGVsZW1lbnQgZm9yIHRoZSBjb250cm9sIGFuZCBhZGQgbGlzdGVuZXJzIG9uIHJlbGV2YW50IG1hcCBldmVudHMuIENhbGxlZCBvbiBbYGNvbnRyb2wuYWRkVG8obWFwKWBdKCNjb250cm9sLWFkZFRvKS5cclxuICAgKlxyXG4gICAqIEBtZXRob2Qgb25SZW1vdmUobWFwOiBNYXApXHJcbiAgICogT3B0aW9uYWwgbWV0aG9kLiBTaG91bGQgY29udGFpbiBhbGwgY2xlYW4gdXAgY29kZSB0aGF0IHJlbW92ZXMgdGhlIGxpc3RlbmVycyBwcmV2aW91c2x5IGFkZGVkIGluIFtgb25BZGRgXSgjY29udHJvbC1vbmFkZCkuIENhbGxlZCBvbiBbYGNvbnRyb2wucmVtb3ZlKClgXSgjY29udHJvbC1yZW1vdmUpLlxyXG4gICAqL1xyXG5cclxuICAvKiBAbmFtZXNwYWNlIE1hcFxyXG4gICAqIEBzZWN0aW9uIE1ldGhvZHMgZm9yIExheWVycyBhbmQgQ29udHJvbHNcclxuICAgKi9cclxuICBNYXAuaW5jbHVkZSh7XHJcbiAgXHQvLyBAbWV0aG9kIGFkZENvbnRyb2woY29udHJvbDogQ29udHJvbCk6IHRoaXNcclxuICBcdC8vIEFkZHMgdGhlIGdpdmVuIGNvbnRyb2wgdG8gdGhlIG1hcFxyXG4gIFx0YWRkQ29udHJvbDogZnVuY3Rpb24gKGNvbnRyb2wpIHtcclxuICBcdFx0Y29udHJvbC5hZGRUbyh0aGlzKTtcclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgcmVtb3ZlQ29udHJvbChjb250cm9sOiBDb250cm9sKTogdGhpc1xyXG4gIFx0Ly8gUmVtb3ZlcyB0aGUgZ2l2ZW4gY29udHJvbCBmcm9tIHRoZSBtYXBcclxuICBcdHJlbW92ZUNvbnRyb2w6IGZ1bmN0aW9uIChjb250cm9sKSB7XHJcbiAgXHRcdGNvbnRyb2wucmVtb3ZlKCk7XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfaW5pdENvbnRyb2xQb3M6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dmFyIGNvcm5lcnMgPSB0aGlzLl9jb250cm9sQ29ybmVycyA9IHt9LFxyXG4gIFx0XHQgICAgbCA9ICdsZWFmbGV0LScsXHJcbiAgXHRcdCAgICBjb250YWluZXIgPSB0aGlzLl9jb250cm9sQ29udGFpbmVyID1cclxuICBcdFx0ICAgICAgICAgICAgY3JlYXRlJDEoJ2RpdicsIGwgKyAnY29udHJvbC1jb250YWluZXInLCB0aGlzLl9jb250YWluZXIpO1xyXG5cclxuICBcdFx0ZnVuY3Rpb24gY3JlYXRlQ29ybmVyKHZTaWRlLCBoU2lkZSkge1xyXG4gIFx0XHRcdHZhciBjbGFzc05hbWUgPSBsICsgdlNpZGUgKyAnICcgKyBsICsgaFNpZGU7XHJcblxyXG4gIFx0XHRcdGNvcm5lcnNbdlNpZGUgKyBoU2lkZV0gPSBjcmVhdGUkMSgnZGl2JywgY2xhc3NOYW1lLCBjb250YWluZXIpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRjcmVhdGVDb3JuZXIoJ3RvcCcsICdsZWZ0Jyk7XHJcbiAgXHRcdGNyZWF0ZUNvcm5lcigndG9wJywgJ3JpZ2h0Jyk7XHJcbiAgXHRcdGNyZWF0ZUNvcm5lcignYm90dG9tJywgJ2xlZnQnKTtcclxuICBcdFx0Y3JlYXRlQ29ybmVyKCdib3R0b20nLCAncmlnaHQnKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X2NsZWFyQ29udHJvbFBvczogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRmb3IgKHZhciBpIGluIHRoaXMuX2NvbnRyb2xDb3JuZXJzKSB7XHJcbiAgXHRcdFx0cmVtb3ZlKHRoaXMuX2NvbnRyb2xDb3JuZXJzW2ldKTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZW1vdmUodGhpcy5fY29udHJvbENvbnRhaW5lcik7XHJcbiAgXHRcdGRlbGV0ZSB0aGlzLl9jb250cm9sQ29ybmVycztcclxuICBcdFx0ZGVsZXRlIHRoaXMuX2NvbnRyb2xDb250YWluZXI7XHJcbiAgXHR9XHJcbiAgfSk7XG5cbiAgLypcclxuICAgKiBAY2xhc3MgQ29udHJvbC5MYXllcnNcclxuICAgKiBAYWthIEwuQ29udHJvbC5MYXllcnNcclxuICAgKiBAaW5oZXJpdHMgQ29udHJvbFxyXG4gICAqXHJcbiAgICogVGhlIGxheWVycyBjb250cm9sIGdpdmVzIHVzZXJzIHRoZSBhYmlsaXR5IHRvIHN3aXRjaCBiZXR3ZWVuIGRpZmZlcmVudCBiYXNlIGxheWVycyBhbmQgc3dpdGNoIG92ZXJsYXlzIG9uL29mZiAoY2hlY2sgb3V0IHRoZSBbZGV0YWlsZWQgZXhhbXBsZV0oaHR0cDovL2xlYWZsZXRqcy5jb20vZXhhbXBsZXMvbGF5ZXJzLWNvbnRyb2wvKSkuIEV4dGVuZHMgYENvbnRyb2xgLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKlxyXG4gICAqIGBgYGpzXHJcbiAgICogdmFyIGJhc2VMYXllcnMgPSB7XHJcbiAgICogXHRcIk1hcGJveFwiOiBtYXBib3gsXHJcbiAgICogXHRcIk9wZW5TdHJlZXRNYXBcIjogb3NtXHJcbiAgICogfTtcclxuICAgKlxyXG4gICAqIHZhciBvdmVybGF5cyA9IHtcclxuICAgKiBcdFwiTWFya2VyXCI6IG1hcmtlcixcclxuICAgKiBcdFwiUm9hZHNcIjogcm9hZHNMYXllclxyXG4gICAqIH07XHJcbiAgICpcclxuICAgKiBMLmNvbnRyb2wubGF5ZXJzKGJhc2VMYXllcnMsIG92ZXJsYXlzKS5hZGRUbyhtYXApO1xyXG4gICAqIGBgYFxyXG4gICAqXHJcbiAgICogVGhlIGBiYXNlTGF5ZXJzYCBhbmQgYG92ZXJsYXlzYCBwYXJhbWV0ZXJzIGFyZSBvYmplY3QgbGl0ZXJhbHMgd2l0aCBsYXllciBuYW1lcyBhcyBrZXlzIGFuZCBgTGF5ZXJgIG9iamVjdHMgYXMgdmFsdWVzOlxyXG4gICAqXHJcbiAgICogYGBganNcclxuICAgKiB7XHJcbiAgICogICAgIFwiPHNvbWVOYW1lMT5cIjogbGF5ZXIxLFxyXG4gICAqICAgICBcIjxzb21lTmFtZTI+XCI6IGxheWVyMlxyXG4gICAqIH1cclxuICAgKiBgYGBcclxuICAgKlxyXG4gICAqIFRoZSBsYXllciBuYW1lcyBjYW4gY29udGFpbiBIVE1MLCB3aGljaCBhbGxvd3MgeW91IHRvIGFkZCBhZGRpdGlvbmFsIHN0eWxpbmcgdG8gdGhlIGl0ZW1zOlxyXG4gICAqXHJcbiAgICogYGBganNcclxuICAgKiB7XCI8aW1nIHNyYz0nbXktbGF5ZXItaWNvbicgLz4gPHNwYW4gY2xhc3M9J215LWxheWVyLWl0ZW0nPk15IExheWVyPC9zcGFuPlwiOiBteUxheWVyfVxyXG4gICAqIGBgYFxyXG4gICAqL1xyXG5cclxuICB2YXIgTGF5ZXJzID0gQ29udHJvbC5leHRlbmQoe1xyXG4gIFx0Ly8gQHNlY3Rpb25cclxuICBcdC8vIEBha2EgQ29udHJvbC5MYXllcnMgb3B0aW9uc1xyXG4gIFx0b3B0aW9uczoge1xyXG4gIFx0XHQvLyBAb3B0aW9uIGNvbGxhcHNlZDogQm9vbGVhbiA9IHRydWVcclxuICBcdFx0Ly8gSWYgYHRydWVgLCB0aGUgY29udHJvbCB3aWxsIGJlIGNvbGxhcHNlZCBpbnRvIGFuIGljb24gYW5kIGV4cGFuZGVkIG9uIG1vdXNlIGhvdmVyIG9yIHRvdWNoLlxyXG4gIFx0XHRjb2xsYXBzZWQ6IHRydWUsXHJcbiAgXHRcdHBvc2l0aW9uOiAndG9wcmlnaHQnLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBhdXRvWkluZGV4OiBCb29sZWFuID0gdHJ1ZVxyXG4gIFx0XHQvLyBJZiBgdHJ1ZWAsIHRoZSBjb250cm9sIHdpbGwgYXNzaWduIHpJbmRleGVzIGluIGluY3JlYXNpbmcgb3JkZXIgdG8gYWxsIG9mIGl0cyBsYXllcnMgc28gdGhhdCB0aGUgb3JkZXIgaXMgcHJlc2VydmVkIHdoZW4gc3dpdGNoaW5nIHRoZW0gb24vb2ZmLlxyXG4gIFx0XHRhdXRvWkluZGV4OiB0cnVlLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBoaWRlU2luZ2xlQmFzZTogQm9vbGVhbiA9IGZhbHNlXHJcbiAgXHRcdC8vIElmIGB0cnVlYCwgdGhlIGJhc2UgbGF5ZXJzIGluIHRoZSBjb250cm9sIHdpbGwgYmUgaGlkZGVuIHdoZW4gdGhlcmUgaXMgb25seSBvbmUuXHJcbiAgXHRcdGhpZGVTaW5nbGVCYXNlOiBmYWxzZSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gc29ydExheWVyczogQm9vbGVhbiA9IGZhbHNlXHJcbiAgXHRcdC8vIFdoZXRoZXIgdG8gc29ydCB0aGUgbGF5ZXJzLiBXaGVuIGBmYWxzZWAsIGxheWVycyB3aWxsIGtlZXAgdGhlIG9yZGVyXHJcbiAgXHRcdC8vIGluIHdoaWNoIHRoZXkgd2VyZSBhZGRlZCB0byB0aGUgY29udHJvbC5cclxuICBcdFx0c29ydExheWVyczogZmFsc2UsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIHNvcnRGdW5jdGlvbjogRnVuY3Rpb24gPSAqXHJcbiAgXHRcdC8vIEEgW2NvbXBhcmUgZnVuY3Rpb25dKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L3NvcnQpXHJcbiAgXHRcdC8vIHRoYXQgd2lsbCBiZSB1c2VkIGZvciBzb3J0aW5nIHRoZSBsYXllcnMsIHdoZW4gYHNvcnRMYXllcnNgIGlzIGB0cnVlYC5cclxuICBcdFx0Ly8gVGhlIGZ1bmN0aW9uIHJlY2VpdmVzIGJvdGggdGhlIGBMLkxheWVyYCBpbnN0YW5jZXMgYW5kIHRoZWlyIG5hbWVzLCBhcyBpblxyXG4gIFx0XHQvLyBgc29ydEZ1bmN0aW9uKGxheWVyQSwgbGF5ZXJCLCBuYW1lQSwgbmFtZUIpYC5cclxuICBcdFx0Ly8gQnkgZGVmYXVsdCwgaXQgc29ydHMgbGF5ZXJzIGFscGhhYmV0aWNhbGx5IGJ5IHRoZWlyIG5hbWUuXHJcbiAgXHRcdHNvcnRGdW5jdGlvbjogZnVuY3Rpb24gKGxheWVyQSwgbGF5ZXJCLCBuYW1lQSwgbmFtZUIpIHtcclxuICBcdFx0XHRyZXR1cm4gbmFtZUEgPCBuYW1lQiA/IC0xIDogKG5hbWVCIDwgbmFtZUEgPyAxIDogMCk7XHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGJhc2VMYXllcnMsIG92ZXJsYXlzLCBvcHRpb25zKSB7XHJcbiAgXHRcdHNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG4gIFx0XHR0aGlzLl9sYXllckNvbnRyb2xJbnB1dHMgPSBbXTtcclxuICBcdFx0dGhpcy5fbGF5ZXJzID0gW107XHJcbiAgXHRcdHRoaXMuX2xhc3RaSW5kZXggPSAwO1xyXG4gIFx0XHR0aGlzLl9oYW5kbGluZ0NsaWNrID0gZmFsc2U7XHJcblxyXG4gIFx0XHRmb3IgKHZhciBpIGluIGJhc2VMYXllcnMpIHtcclxuICBcdFx0XHR0aGlzLl9hZGRMYXllcihiYXNlTGF5ZXJzW2ldLCBpKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0Zm9yIChpIGluIG92ZXJsYXlzKSB7XHJcbiAgXHRcdFx0dGhpcy5fYWRkTGF5ZXIob3ZlcmxheXNbaV0sIGksIHRydWUpO1xyXG4gIFx0XHR9XHJcbiAgXHR9LFxyXG5cclxuICBcdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcbiAgXHRcdHRoaXMuX2luaXRMYXlvdXQoKTtcclxuICBcdFx0dGhpcy5fdXBkYXRlKCk7XHJcblxyXG4gIFx0XHR0aGlzLl9tYXAgPSBtYXA7XHJcbiAgXHRcdG1hcC5vbignem9vbWVuZCcsIHRoaXMuX2NoZWNrRGlzYWJsZWRMYXllcnMsIHRoaXMpO1xyXG5cclxuICBcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9sYXllcnMubGVuZ3RoOyBpKyspIHtcclxuICBcdFx0XHR0aGlzLl9sYXllcnNbaV0ubGF5ZXIub24oJ2FkZCByZW1vdmUnLCB0aGlzLl9vbkxheWVyQ2hhbmdlLCB0aGlzKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0cmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcclxuICBcdH0sXHJcblxyXG4gIFx0YWRkVG86IGZ1bmN0aW9uIChtYXApIHtcclxuICBcdFx0Q29udHJvbC5wcm90b3R5cGUuYWRkVG8uY2FsbCh0aGlzLCBtYXApO1xyXG4gIFx0XHQvLyBUcmlnZ2VyIGV4cGFuZCBhZnRlciBMYXllcnMgQ29udHJvbCBoYXMgYmVlbiBpbnNlcnRlZCBpbnRvIERPTSBzbyB0aGF0IGlzIG5vdyBoYXMgYW4gYWN0dWFsIGhlaWdodC5cclxuICBcdFx0cmV0dXJuIHRoaXMuX2V4cGFuZElmTm90Q29sbGFwc2VkKCk7XHJcbiAgXHR9LFxyXG5cclxuICBcdG9uUmVtb3ZlOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHRoaXMuX21hcC5vZmYoJ3pvb21lbmQnLCB0aGlzLl9jaGVja0Rpc2FibGVkTGF5ZXJzLCB0aGlzKTtcclxuXHJcbiAgXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fbGF5ZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgXHRcdFx0dGhpcy5fbGF5ZXJzW2ldLmxheWVyLm9mZignYWRkIHJlbW92ZScsIHRoaXMuX29uTGF5ZXJDaGFuZ2UsIHRoaXMpO1xyXG4gIFx0XHR9XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgYWRkQmFzZUxheWVyKGxheWVyOiBMYXllciwgbmFtZTogU3RyaW5nKTogdGhpc1xyXG4gIFx0Ly8gQWRkcyBhIGJhc2UgbGF5ZXIgKHJhZGlvIGJ1dHRvbiBlbnRyeSkgd2l0aCB0aGUgZ2l2ZW4gbmFtZSB0byB0aGUgY29udHJvbC5cclxuICBcdGFkZEJhc2VMYXllcjogZnVuY3Rpb24gKGxheWVyLCBuYW1lKSB7XHJcbiAgXHRcdHRoaXMuX2FkZExheWVyKGxheWVyLCBuYW1lKTtcclxuICBcdFx0cmV0dXJuICh0aGlzLl9tYXApID8gdGhpcy5fdXBkYXRlKCkgOiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGFkZE92ZXJsYXkobGF5ZXI6IExheWVyLCBuYW1lOiBTdHJpbmcpOiB0aGlzXHJcbiAgXHQvLyBBZGRzIGFuIG92ZXJsYXkgKGNoZWNrYm94IGVudHJ5KSB3aXRoIHRoZSBnaXZlbiBuYW1lIHRvIHRoZSBjb250cm9sLlxyXG4gIFx0YWRkT3ZlcmxheTogZnVuY3Rpb24gKGxheWVyLCBuYW1lKSB7XHJcbiAgXHRcdHRoaXMuX2FkZExheWVyKGxheWVyLCBuYW1lLCB0cnVlKTtcclxuICBcdFx0cmV0dXJuICh0aGlzLl9tYXApID8gdGhpcy5fdXBkYXRlKCkgOiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHJlbW92ZUxheWVyKGxheWVyOiBMYXllcik6IHRoaXNcclxuICBcdC8vIFJlbW92ZSB0aGUgZ2l2ZW4gbGF5ZXIgZnJvbSB0aGUgY29udHJvbC5cclxuICBcdHJlbW92ZUxheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuICBcdFx0bGF5ZXIub2ZmKCdhZGQgcmVtb3ZlJywgdGhpcy5fb25MYXllckNoYW5nZSwgdGhpcyk7XHJcblxyXG4gIFx0XHR2YXIgb2JqID0gdGhpcy5fZ2V0TGF5ZXIoc3RhbXAobGF5ZXIpKTtcclxuICBcdFx0aWYgKG9iaikge1xyXG4gIFx0XHRcdHRoaXMuX2xheWVycy5zcGxpY2UodGhpcy5fbGF5ZXJzLmluZGV4T2Yob2JqKSwgMSk7XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuICh0aGlzLl9tYXApID8gdGhpcy5fdXBkYXRlKCkgOiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGV4cGFuZCgpOiB0aGlzXHJcbiAgXHQvLyBFeHBhbmQgdGhlIGNvbnRyb2wgY29udGFpbmVyIGlmIGNvbGxhcHNlZC5cclxuICBcdGV4cGFuZDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRhZGRDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLWV4cGFuZGVkJyk7XHJcbiAgXHRcdHRoaXMuX3NlY3Rpb24uc3R5bGUuaGVpZ2h0ID0gbnVsbDtcclxuICBcdFx0dmFyIGFjY2VwdGFibGVIZWlnaHQgPSB0aGlzLl9tYXAuZ2V0U2l6ZSgpLnkgLSAodGhpcy5fY29udGFpbmVyLm9mZnNldFRvcCArIDUwKTtcclxuICBcdFx0aWYgKGFjY2VwdGFibGVIZWlnaHQgPCB0aGlzLl9zZWN0aW9uLmNsaWVudEhlaWdodCkge1xyXG4gIFx0XHRcdGFkZENsYXNzKHRoaXMuX3NlY3Rpb24sICdsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXNjcm9sbGJhcicpO1xyXG4gIFx0XHRcdHRoaXMuX3NlY3Rpb24uc3R5bGUuaGVpZ2h0ID0gYWNjZXB0YWJsZUhlaWdodCArICdweCc7XHJcbiAgXHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0cmVtb3ZlQ2xhc3ModGhpcy5fc2VjdGlvbiwgJ2xlYWZsZXQtY29udHJvbC1sYXllcnMtc2Nyb2xsYmFyJyk7XHJcbiAgXHRcdH1cclxuICBcdFx0dGhpcy5fY2hlY2tEaXNhYmxlZExheWVycygpO1xyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBjb2xsYXBzZSgpOiB0aGlzXHJcbiAgXHQvLyBDb2xsYXBzZSB0aGUgY29udHJvbCBjb250YWluZXIgaWYgZXhwYW5kZWQuXHJcbiAgXHRjb2xsYXBzZTogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZW1vdmVDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLWV4cGFuZGVkJyk7XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfaW5pdExheW91dDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR2YXIgY2xhc3NOYW1lID0gJ2xlYWZsZXQtY29udHJvbC1sYXllcnMnLFxyXG4gIFx0XHQgICAgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyID0gY3JlYXRlJDEoJ2RpdicsIGNsYXNzTmFtZSksXHJcbiAgXHRcdCAgICBjb2xsYXBzZWQgPSB0aGlzLm9wdGlvbnMuY29sbGFwc2VkO1xyXG5cclxuICBcdFx0Ly8gbWFrZXMgdGhpcyB3b3JrIG9uIElFIHRvdWNoIGRldmljZXMgYnkgc3RvcHBpbmcgaXQgZnJvbSBmaXJpbmcgYSBtb3VzZW91dCBldmVudCB3aGVuIHRoZSB0b3VjaCBpcyByZWxlYXNlZFxyXG4gIFx0XHRjb250YWluZXIuc2V0QXR0cmlidXRlKCdhcmlhLWhhc3BvcHVwJywgdHJ1ZSk7XHJcblxyXG4gIFx0XHRkaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbihjb250YWluZXIpO1xyXG4gIFx0XHRkaXNhYmxlU2Nyb2xsUHJvcGFnYXRpb24oY29udGFpbmVyKTtcclxuXHJcbiAgXHRcdHZhciBzZWN0aW9uID0gdGhpcy5fc2VjdGlvbiA9IGNyZWF0ZSQxKCdzZWN0aW9uJywgY2xhc3NOYW1lICsgJy1saXN0Jyk7XHJcblxyXG4gIFx0XHRpZiAoY29sbGFwc2VkKSB7XHJcbiAgXHRcdFx0dGhpcy5fbWFwLm9uKCdjbGljaycsIHRoaXMuY29sbGFwc2UsIHRoaXMpO1xyXG5cclxuICBcdFx0XHRpZiAoIWFuZHJvaWQpIHtcclxuICBcdFx0XHRcdG9uKGNvbnRhaW5lciwge1xyXG4gIFx0XHRcdFx0XHRtb3VzZWVudGVyOiB0aGlzLmV4cGFuZCxcclxuICBcdFx0XHRcdFx0bW91c2VsZWF2ZTogdGhpcy5jb2xsYXBzZVxyXG4gIFx0XHRcdFx0fSwgdGhpcyk7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR2YXIgbGluayA9IHRoaXMuX2xheWVyc0xpbmsgPSBjcmVhdGUkMSgnYScsIGNsYXNzTmFtZSArICctdG9nZ2xlJywgY29udGFpbmVyKTtcclxuICBcdFx0bGluay5ocmVmID0gJyMnO1xyXG4gIFx0XHRsaW5rLnRpdGxlID0gJ0xheWVycyc7XHJcblxyXG4gIFx0XHRpZiAodG91Y2gpIHtcclxuICBcdFx0XHRvbihsaW5rLCAnY2xpY2snLCBzdG9wKTtcclxuICBcdFx0XHRvbihsaW5rLCAnY2xpY2snLCB0aGlzLmV4cGFuZCwgdGhpcyk7XHJcbiAgXHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0b24obGluaywgJ2ZvY3VzJywgdGhpcy5leHBhbmQsIHRoaXMpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRpZiAoIWNvbGxhcHNlZCkge1xyXG4gIFx0XHRcdHRoaXMuZXhwYW5kKCk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMuX2Jhc2VMYXllcnNMaXN0ID0gY3JlYXRlJDEoJ2RpdicsIGNsYXNzTmFtZSArICctYmFzZScsIHNlY3Rpb24pO1xyXG4gIFx0XHR0aGlzLl9zZXBhcmF0b3IgPSBjcmVhdGUkMSgnZGl2JywgY2xhc3NOYW1lICsgJy1zZXBhcmF0b3InLCBzZWN0aW9uKTtcclxuICBcdFx0dGhpcy5fb3ZlcmxheXNMaXN0ID0gY3JlYXRlJDEoJ2RpdicsIGNsYXNzTmFtZSArICctb3ZlcmxheXMnLCBzZWN0aW9uKTtcclxuXHJcbiAgXHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChzZWN0aW9uKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X2dldExheWVyOiBmdW5jdGlvbiAoaWQpIHtcclxuICBcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9sYXllcnMubGVuZ3RoOyBpKyspIHtcclxuXHJcbiAgXHRcdFx0aWYgKHRoaXMuX2xheWVyc1tpXSAmJiBzdGFtcCh0aGlzLl9sYXllcnNbaV0ubGF5ZXIpID09PSBpZCkge1xyXG4gIFx0XHRcdFx0cmV0dXJuIHRoaXMuX2xheWVyc1tpXTtcclxuICBcdFx0XHR9XHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0X2FkZExheWVyOiBmdW5jdGlvbiAobGF5ZXIsIG5hbWUsIG92ZXJsYXkpIHtcclxuICBcdFx0aWYgKHRoaXMuX21hcCkge1xyXG4gIFx0XHRcdGxheWVyLm9uKCdhZGQgcmVtb3ZlJywgdGhpcy5fb25MYXllckNoYW5nZSwgdGhpcyk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMuX2xheWVycy5wdXNoKHtcclxuICBcdFx0XHRsYXllcjogbGF5ZXIsXHJcbiAgXHRcdFx0bmFtZTogbmFtZSxcclxuICBcdFx0XHRvdmVybGF5OiBvdmVybGF5XHJcbiAgXHRcdH0pO1xyXG5cclxuICBcdFx0aWYgKHRoaXMub3B0aW9ucy5zb3J0TGF5ZXJzKSB7XHJcbiAgXHRcdFx0dGhpcy5fbGF5ZXJzLnNvcnQoYmluZChmdW5jdGlvbiAoYSwgYikge1xyXG4gIFx0XHRcdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5zb3J0RnVuY3Rpb24oYS5sYXllciwgYi5sYXllciwgYS5uYW1lLCBiLm5hbWUpO1xyXG4gIFx0XHRcdH0sIHRoaXMpKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0aWYgKHRoaXMub3B0aW9ucy5hdXRvWkluZGV4ICYmIGxheWVyLnNldFpJbmRleCkge1xyXG4gIFx0XHRcdHRoaXMuX2xhc3RaSW5kZXgrKztcclxuICBcdFx0XHRsYXllci5zZXRaSW5kZXgodGhpcy5fbGFzdFpJbmRleCk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMuX2V4cGFuZElmTm90Q29sbGFwc2VkKCk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0aWYgKCF0aGlzLl9jb250YWluZXIpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcbiAgXHRcdGVtcHR5KHRoaXMuX2Jhc2VMYXllcnNMaXN0KTtcclxuICBcdFx0ZW1wdHkodGhpcy5fb3ZlcmxheXNMaXN0KTtcclxuXHJcbiAgXHRcdHRoaXMuX2xheWVyQ29udHJvbElucHV0cyA9IFtdO1xyXG4gIFx0XHR2YXIgYmFzZUxheWVyc1ByZXNlbnQsIG92ZXJsYXlzUHJlc2VudCwgaSwgb2JqLCBiYXNlTGF5ZXJzQ291bnQgPSAwO1xyXG5cclxuICBcdFx0Zm9yIChpID0gMDsgaSA8IHRoaXMuX2xheWVycy5sZW5ndGg7IGkrKykge1xyXG4gIFx0XHRcdG9iaiA9IHRoaXMuX2xheWVyc1tpXTtcclxuICBcdFx0XHR0aGlzLl9hZGRJdGVtKG9iaik7XHJcbiAgXHRcdFx0b3ZlcmxheXNQcmVzZW50ID0gb3ZlcmxheXNQcmVzZW50IHx8IG9iai5vdmVybGF5O1xyXG4gIFx0XHRcdGJhc2VMYXllcnNQcmVzZW50ID0gYmFzZUxheWVyc1ByZXNlbnQgfHwgIW9iai5vdmVybGF5O1xyXG4gIFx0XHRcdGJhc2VMYXllcnNDb3VudCArPSAhb2JqLm92ZXJsYXkgPyAxIDogMDtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0Ly8gSGlkZSBiYXNlIGxheWVycyBzZWN0aW9uIGlmIHRoZXJlJ3Mgb25seSBvbmUgbGF5ZXIuXHJcbiAgXHRcdGlmICh0aGlzLm9wdGlvbnMuaGlkZVNpbmdsZUJhc2UpIHtcclxuICBcdFx0XHRiYXNlTGF5ZXJzUHJlc2VudCA9IGJhc2VMYXllcnNQcmVzZW50ICYmIGJhc2VMYXllcnNDb3VudCA+IDE7XHJcbiAgXHRcdFx0dGhpcy5fYmFzZUxheWVyc0xpc3Quc3R5bGUuZGlzcGxheSA9IGJhc2VMYXllcnNQcmVzZW50ID8gJycgOiAnbm9uZSc7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMuX3NlcGFyYXRvci5zdHlsZS5kaXNwbGF5ID0gb3ZlcmxheXNQcmVzZW50ICYmIGJhc2VMYXllcnNQcmVzZW50ID8gJycgOiAnbm9uZSc7XHJcblxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0X29uTGF5ZXJDaGFuZ2U6IGZ1bmN0aW9uIChlKSB7XHJcbiAgXHRcdGlmICghdGhpcy5faGFuZGxpbmdDbGljaykge1xyXG4gIFx0XHRcdHRoaXMuX3VwZGF0ZSgpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR2YXIgb2JqID0gdGhpcy5fZ2V0TGF5ZXIoc3RhbXAoZS50YXJnZXQpKTtcclxuXHJcbiAgXHRcdC8vIEBuYW1lc3BhY2UgTWFwXHJcbiAgXHRcdC8vIEBzZWN0aW9uIExheWVyIGV2ZW50c1xyXG4gIFx0XHQvLyBAZXZlbnQgYmFzZWxheWVyY2hhbmdlOiBMYXllcnNDb250cm9sRXZlbnRcclxuICBcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgYmFzZSBsYXllciBpcyBjaGFuZ2VkIHRocm91Z2ggdGhlIFtsYXllcnMgY29udHJvbF0oI2NvbnRyb2wtbGF5ZXJzKS5cclxuICBcdFx0Ly8gQGV2ZW50IG92ZXJsYXlhZGQ6IExheWVyc0NvbnRyb2xFdmVudFxyXG4gIFx0XHQvLyBGaXJlZCB3aGVuIGFuIG92ZXJsYXkgaXMgc2VsZWN0ZWQgdGhyb3VnaCB0aGUgW2xheWVycyBjb250cm9sXSgjY29udHJvbC1sYXllcnMpLlxyXG4gIFx0XHQvLyBAZXZlbnQgb3ZlcmxheXJlbW92ZTogTGF5ZXJzQ29udHJvbEV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIHdoZW4gYW4gb3ZlcmxheSBpcyBkZXNlbGVjdGVkIHRocm91Z2ggdGhlIFtsYXllcnMgY29udHJvbF0oI2NvbnRyb2wtbGF5ZXJzKS5cclxuICBcdFx0Ly8gQG5hbWVzcGFjZSBDb250cm9sLkxheWVyc1xyXG4gIFx0XHR2YXIgdHlwZSA9IG9iai5vdmVybGF5ID9cclxuICBcdFx0XHQoZS50eXBlID09PSAnYWRkJyA/ICdvdmVybGF5YWRkJyA6ICdvdmVybGF5cmVtb3ZlJykgOlxyXG4gIFx0XHRcdChlLnR5cGUgPT09ICdhZGQnID8gJ2Jhc2VsYXllcmNoYW5nZScgOiBudWxsKTtcclxuXHJcbiAgXHRcdGlmICh0eXBlKSB7XHJcbiAgXHRcdFx0dGhpcy5fbWFwLmZpcmUodHlwZSwgb2JqKTtcclxuICBcdFx0fVxyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBJRTcgYnVncyBvdXQgaWYgeW91IGNyZWF0ZSBhIHJhZGlvIGR5bmFtaWNhbGx5LCBzbyB5b3UgaGF2ZSB0byBkbyBpdCB0aGlzIGhhY2t5IHdheSAoc2VlIGh0dHA6Ly9iaXQubHkvUHFZTEJlKVxyXG4gIFx0X2NyZWF0ZVJhZGlvRWxlbWVudDogZnVuY3Rpb24gKG5hbWUsIGNoZWNrZWQpIHtcclxuXHJcbiAgXHRcdHZhciByYWRpb0h0bWwgPSAnPGlucHV0IHR5cGU9XCJyYWRpb1wiIGNsYXNzPVwibGVhZmxldC1jb250cm9sLWxheWVycy1zZWxlY3RvclwiIG5hbWU9XCInICtcclxuICBcdFx0XHRcdG5hbWUgKyAnXCInICsgKGNoZWNrZWQgPyAnIGNoZWNrZWQ9XCJjaGVja2VkXCInIDogJycpICsgJy8+JztcclxuXHJcbiAgXHRcdHZhciByYWRpb0ZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgXHRcdHJhZGlvRnJhZ21lbnQuaW5uZXJIVE1MID0gcmFkaW9IdG1sO1xyXG5cclxuICBcdFx0cmV0dXJuIHJhZGlvRnJhZ21lbnQuZmlyc3RDaGlsZDtcclxuICBcdH0sXHJcblxyXG4gIFx0X2FkZEl0ZW06IGZ1bmN0aW9uIChvYmopIHtcclxuICBcdFx0dmFyIGxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGFiZWwnKSxcclxuICBcdFx0ICAgIGNoZWNrZWQgPSB0aGlzLl9tYXAuaGFzTGF5ZXIob2JqLmxheWVyKSxcclxuICBcdFx0ICAgIGlucHV0O1xyXG5cclxuICBcdFx0aWYgKG9iai5vdmVybGF5KSB7XHJcbiAgXHRcdFx0aW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xyXG4gIFx0XHRcdGlucHV0LnR5cGUgPSAnY2hlY2tib3gnO1xyXG4gIFx0XHRcdGlucHV0LmNsYXNzTmFtZSA9ICdsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXNlbGVjdG9yJztcclxuICBcdFx0XHRpbnB1dC5kZWZhdWx0Q2hlY2tlZCA9IGNoZWNrZWQ7XHJcbiAgXHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0aW5wdXQgPSB0aGlzLl9jcmVhdGVSYWRpb0VsZW1lbnQoJ2xlYWZsZXQtYmFzZS1sYXllcnNfJyArIHN0YW1wKHRoaXMpLCBjaGVja2VkKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dGhpcy5fbGF5ZXJDb250cm9sSW5wdXRzLnB1c2goaW5wdXQpO1xyXG4gIFx0XHRpbnB1dC5sYXllcklkID0gc3RhbXAob2JqLmxheWVyKTtcclxuXHJcbiAgXHRcdG9uKGlucHV0LCAnY2xpY2snLCB0aGlzLl9vbklucHV0Q2xpY2ssIHRoaXMpO1xyXG5cclxuICBcdFx0dmFyIG5hbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XHJcbiAgXHRcdG5hbWUuaW5uZXJIVE1MID0gJyAnICsgb2JqLm5hbWU7XHJcblxyXG4gIFx0XHQvLyBIZWxwcyBmcm9tIHByZXZlbnRpbmcgbGF5ZXIgY29udHJvbCBmbGlja2VyIHdoZW4gY2hlY2tib3hlcyBhcmUgZGlzYWJsZWRcclxuICBcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL0xlYWZsZXQvTGVhZmxldC9pc3N1ZXMvMjc3MVxyXG4gIFx0XHR2YXIgaG9sZGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcblxyXG4gIFx0XHRsYWJlbC5hcHBlbmRDaGlsZChob2xkZXIpO1xyXG4gIFx0XHRob2xkZXIuYXBwZW5kQ2hpbGQoaW5wdXQpO1xyXG4gIFx0XHRob2xkZXIuYXBwZW5kQ2hpbGQobmFtZSk7XHJcblxyXG4gIFx0XHR2YXIgY29udGFpbmVyID0gb2JqLm92ZXJsYXkgPyB0aGlzLl9vdmVybGF5c0xpc3QgOiB0aGlzLl9iYXNlTGF5ZXJzTGlzdDtcclxuICBcdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKGxhYmVsKTtcclxuXHJcbiAgXHRcdHRoaXMuX2NoZWNrRGlzYWJsZWRMYXllcnMoKTtcclxuICBcdFx0cmV0dXJuIGxhYmVsO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfb25JbnB1dENsaWNrOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHZhciBpbnB1dHMgPSB0aGlzLl9sYXllckNvbnRyb2xJbnB1dHMsXHJcbiAgXHRcdCAgICBpbnB1dCwgbGF5ZXI7XHJcbiAgXHRcdHZhciBhZGRlZExheWVycyA9IFtdLFxyXG4gIFx0XHQgICAgcmVtb3ZlZExheWVycyA9IFtdO1xyXG5cclxuICBcdFx0dGhpcy5faGFuZGxpbmdDbGljayA9IHRydWU7XHJcblxyXG4gIFx0XHRmb3IgKHZhciBpID0gaW5wdXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgXHRcdFx0aW5wdXQgPSBpbnB1dHNbaV07XHJcbiAgXHRcdFx0bGF5ZXIgPSB0aGlzLl9nZXRMYXllcihpbnB1dC5sYXllcklkKS5sYXllcjtcclxuXHJcbiAgXHRcdFx0aWYgKGlucHV0LmNoZWNrZWQpIHtcclxuICBcdFx0XHRcdGFkZGVkTGF5ZXJzLnB1c2gobGF5ZXIpO1xyXG4gIFx0XHRcdH0gZWxzZSBpZiAoIWlucHV0LmNoZWNrZWQpIHtcclxuICBcdFx0XHRcdHJlbW92ZWRMYXllcnMucHVzaChsYXllcik7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHQvLyBCdWdmaXggaXNzdWUgMjMxODogU2hvdWxkIHJlbW92ZSBhbGwgb2xkIGxheWVycyBiZWZvcmUgcmVhZGRpbmcgbmV3IG9uZXNcclxuICBcdFx0Zm9yIChpID0gMDsgaSA8IHJlbW92ZWRMYXllcnMubGVuZ3RoOyBpKyspIHtcclxuICBcdFx0XHRpZiAodGhpcy5fbWFwLmhhc0xheWVyKHJlbW92ZWRMYXllcnNbaV0pKSB7XHJcbiAgXHRcdFx0XHR0aGlzLl9tYXAucmVtb3ZlTGF5ZXIocmVtb3ZlZExheWVyc1tpXSk7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHR9XHJcbiAgXHRcdGZvciAoaSA9IDA7IGkgPCBhZGRlZExheWVycy5sZW5ndGg7IGkrKykge1xyXG4gIFx0XHRcdGlmICghdGhpcy5fbWFwLmhhc0xheWVyKGFkZGVkTGF5ZXJzW2ldKSkge1xyXG4gIFx0XHRcdFx0dGhpcy5fbWFwLmFkZExheWVyKGFkZGVkTGF5ZXJzW2ldKTtcclxuICBcdFx0XHR9XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMuX2hhbmRsaW5nQ2xpY2sgPSBmYWxzZTtcclxuXHJcbiAgXHRcdHRoaXMuX3JlZm9jdXNPbk1hcCgpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfY2hlY2tEaXNhYmxlZExheWVyczogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR2YXIgaW5wdXRzID0gdGhpcy5fbGF5ZXJDb250cm9sSW5wdXRzLFxyXG4gIFx0XHQgICAgaW5wdXQsXHJcbiAgXHRcdCAgICBsYXllcixcclxuICBcdFx0ICAgIHpvb20gPSB0aGlzLl9tYXAuZ2V0Wm9vbSgpO1xyXG5cclxuICBcdFx0Zm9yICh2YXIgaSA9IGlucHV0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gIFx0XHRcdGlucHV0ID0gaW5wdXRzW2ldO1xyXG4gIFx0XHRcdGxheWVyID0gdGhpcy5fZ2V0TGF5ZXIoaW5wdXQubGF5ZXJJZCkubGF5ZXI7XHJcbiAgXHRcdFx0aW5wdXQuZGlzYWJsZWQgPSAobGF5ZXIub3B0aW9ucy5taW5ab29tICE9PSB1bmRlZmluZWQgJiYgem9vbSA8IGxheWVyLm9wdGlvbnMubWluWm9vbSkgfHxcclxuICBcdFx0XHQgICAgICAgICAgICAgICAgIChsYXllci5vcHRpb25zLm1heFpvb20gIT09IHVuZGVmaW5lZCAmJiB6b29tID4gbGF5ZXIub3B0aW9ucy5tYXhab29tKTtcclxuXHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0X2V4cGFuZElmTm90Q29sbGFwc2VkOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdGlmICh0aGlzLl9tYXAgJiYgIXRoaXMub3B0aW9ucy5jb2xsYXBzZWQpIHtcclxuICBcdFx0XHR0aGlzLmV4cGFuZCgpO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfZXhwYW5kOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdC8vIEJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHJlbW92ZSBtZSBpbiAxLjEuXHJcbiAgXHRcdHJldHVybiB0aGlzLmV4cGFuZCgpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfY29sbGFwc2U6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0Ly8gQmFja3dhcmQgY29tcGF0aWJpbGl0eSwgcmVtb3ZlIG1lIGluIDEuMS5cclxuICBcdFx0cmV0dXJuIHRoaXMuY29sbGFwc2UoKTtcclxuICBcdH1cclxuXHJcbiAgfSk7XHJcblxyXG5cclxuICAvLyBAZmFjdG9yeSBMLmNvbnRyb2wubGF5ZXJzKGJhc2VsYXllcnM/OiBPYmplY3QsIG92ZXJsYXlzPzogT2JqZWN0LCBvcHRpb25zPzogQ29udHJvbC5MYXllcnMgb3B0aW9ucylcclxuICAvLyBDcmVhdGVzIGEgbGF5ZXJzIGNvbnRyb2wgd2l0aCB0aGUgZ2l2ZW4gbGF5ZXJzLiBCYXNlIGxheWVycyB3aWxsIGJlIHN3aXRjaGVkIHdpdGggcmFkaW8gYnV0dG9ucywgd2hpbGUgb3ZlcmxheXMgd2lsbCBiZSBzd2l0Y2hlZCB3aXRoIGNoZWNrYm94ZXMuIE5vdGUgdGhhdCBhbGwgYmFzZSBsYXllcnMgc2hvdWxkIGJlIHBhc3NlZCBpbiB0aGUgYmFzZSBsYXllcnMgb2JqZWN0LCBidXQgb25seSBvbmUgc2hvdWxkIGJlIGFkZGVkIHRvIHRoZSBtYXAgZHVyaW5nIG1hcCBpbnN0YW50aWF0aW9uLlxyXG4gIHZhciBsYXllcnMgPSBmdW5jdGlvbiAoYmFzZUxheWVycywgb3ZlcmxheXMsIG9wdGlvbnMpIHtcclxuICBcdHJldHVybiBuZXcgTGF5ZXJzKGJhc2VMYXllcnMsIG92ZXJsYXlzLCBvcHRpb25zKTtcclxuICB9O1xuXG4gIC8qXHJcbiAgICogQGNsYXNzIENvbnRyb2wuWm9vbVxyXG4gICAqIEBha2EgTC5Db250cm9sLlpvb21cclxuICAgKiBAaW5oZXJpdHMgQ29udHJvbFxyXG4gICAqXHJcbiAgICogQSBiYXNpYyB6b29tIGNvbnRyb2wgd2l0aCB0d28gYnV0dG9ucyAoem9vbSBpbiBhbmQgem9vbSBvdXQpLiBJdCBpcyBwdXQgb24gdGhlIG1hcCBieSBkZWZhdWx0IHVubGVzcyB5b3Ugc2V0IGl0cyBbYHpvb21Db250cm9sYCBvcHRpb25dKCNtYXAtem9vbWNvbnRyb2wpIHRvIGBmYWxzZWAuIEV4dGVuZHMgYENvbnRyb2xgLlxyXG4gICAqL1xyXG5cclxuICB2YXIgWm9vbSA9IENvbnRyb2wuZXh0ZW5kKHtcclxuICBcdC8vIEBzZWN0aW9uXHJcbiAgXHQvLyBAYWthIENvbnRyb2wuWm9vbSBvcHRpb25zXHJcbiAgXHRvcHRpb25zOiB7XHJcbiAgXHRcdHBvc2l0aW9uOiAndG9wbGVmdCcsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIHpvb21JblRleHQ6IFN0cmluZyA9ICcrJ1xyXG4gIFx0XHQvLyBUaGUgdGV4dCBzZXQgb24gdGhlICd6b29tIGluJyBidXR0b24uXHJcbiAgXHRcdHpvb21JblRleHQ6ICcrJyxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gem9vbUluVGl0bGU6IFN0cmluZyA9ICdab29tIGluJ1xyXG4gIFx0XHQvLyBUaGUgdGl0bGUgc2V0IG9uIHRoZSAnem9vbSBpbicgYnV0dG9uLlxyXG4gIFx0XHR6b29tSW5UaXRsZTogJ1pvb20gaW4nLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiB6b29tT3V0VGV4dDogU3RyaW5nID0gJyYjeDIyMTI7J1xyXG4gIFx0XHQvLyBUaGUgdGV4dCBzZXQgb24gdGhlICd6b29tIG91dCcgYnV0dG9uLlxyXG4gIFx0XHR6b29tT3V0VGV4dDogJyYjeDIyMTI7JyxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gem9vbU91dFRpdGxlOiBTdHJpbmcgPSAnWm9vbSBvdXQnXHJcbiAgXHRcdC8vIFRoZSB0aXRsZSBzZXQgb24gdGhlICd6b29tIG91dCcgYnV0dG9uLlxyXG4gIFx0XHR6b29tT3V0VGl0bGU6ICdab29tIG91dCdcclxuICBcdH0sXHJcblxyXG4gIFx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuICBcdFx0dmFyIHpvb21OYW1lID0gJ2xlYWZsZXQtY29udHJvbC16b29tJyxcclxuICBcdFx0ICAgIGNvbnRhaW5lciA9IGNyZWF0ZSQxKCdkaXYnLCB6b29tTmFtZSArICcgbGVhZmxldC1iYXInKSxcclxuICBcdFx0ICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XHJcblxyXG4gIFx0XHR0aGlzLl96b29tSW5CdXR0b24gID0gdGhpcy5fY3JlYXRlQnV0dG9uKG9wdGlvbnMuem9vbUluVGV4dCwgb3B0aW9ucy56b29tSW5UaXRsZSxcclxuICBcdFx0ICAgICAgICB6b29tTmFtZSArICctaW4nLCAgY29udGFpbmVyLCB0aGlzLl96b29tSW4pO1xyXG4gIFx0XHR0aGlzLl96b29tT3V0QnV0dG9uID0gdGhpcy5fY3JlYXRlQnV0dG9uKG9wdGlvbnMuem9vbU91dFRleHQsIG9wdGlvbnMuem9vbU91dFRpdGxlLFxyXG4gIFx0XHQgICAgICAgIHpvb21OYW1lICsgJy1vdXQnLCBjb250YWluZXIsIHRoaXMuX3pvb21PdXQpO1xyXG5cclxuICBcdFx0dGhpcy5fdXBkYXRlRGlzYWJsZWQoKTtcclxuICBcdFx0bWFwLm9uKCd6b29tZW5kIHpvb21sZXZlbHNjaGFuZ2UnLCB0aGlzLl91cGRhdGVEaXNhYmxlZCwgdGhpcyk7XHJcblxyXG4gIFx0XHRyZXR1cm4gY29udGFpbmVyO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xyXG4gIFx0XHRtYXAub2ZmKCd6b29tZW5kIHpvb21sZXZlbHNjaGFuZ2UnLCB0aGlzLl91cGRhdGVEaXNhYmxlZCwgdGhpcyk7XHJcbiAgXHR9LFxyXG5cclxuICBcdGRpc2FibGU6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dGhpcy5fZGlzYWJsZWQgPSB0cnVlO1xyXG4gIFx0XHR0aGlzLl91cGRhdGVEaXNhYmxlZCgpO1xyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0ZW5hYmxlOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHRoaXMuX2Rpc2FibGVkID0gZmFsc2U7XHJcbiAgXHRcdHRoaXMuX3VwZGF0ZURpc2FibGVkKCk7XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfem9vbUluOiBmdW5jdGlvbiAoZSkge1xyXG4gIFx0XHRpZiAoIXRoaXMuX2Rpc2FibGVkICYmIHRoaXMuX21hcC5fem9vbSA8IHRoaXMuX21hcC5nZXRNYXhab29tKCkpIHtcclxuICBcdFx0XHR0aGlzLl9tYXAuem9vbUluKHRoaXMuX21hcC5vcHRpb25zLnpvb21EZWx0YSAqIChlLnNoaWZ0S2V5ID8gMyA6IDEpKTtcclxuICBcdFx0fVxyXG4gIFx0fSxcclxuXHJcbiAgXHRfem9vbU91dDogZnVuY3Rpb24gKGUpIHtcclxuICBcdFx0aWYgKCF0aGlzLl9kaXNhYmxlZCAmJiB0aGlzLl9tYXAuX3pvb20gPiB0aGlzLl9tYXAuZ2V0TWluWm9vbSgpKSB7XHJcbiAgXHRcdFx0dGhpcy5fbWFwLnpvb21PdXQodGhpcy5fbWFwLm9wdGlvbnMuem9vbURlbHRhICogKGUuc2hpZnRLZXkgPyAzIDogMSkpO1xyXG4gIFx0XHR9XHJcbiAgXHR9LFxyXG5cclxuICBcdF9jcmVhdGVCdXR0b246IGZ1bmN0aW9uIChodG1sLCB0aXRsZSwgY2xhc3NOYW1lLCBjb250YWluZXIsIGZuKSB7XHJcbiAgXHRcdHZhciBsaW5rID0gY3JlYXRlJDEoJ2EnLCBjbGFzc05hbWUsIGNvbnRhaW5lcik7XHJcbiAgXHRcdGxpbmsuaW5uZXJIVE1MID0gaHRtbDtcclxuICBcdFx0bGluay5ocmVmID0gJyMnO1xyXG4gIFx0XHRsaW5rLnRpdGxlID0gdGl0bGU7XHJcblxyXG4gIFx0XHQvKlxyXG4gIFx0XHQgKiBXaWxsIGZvcmNlIHNjcmVlbiByZWFkZXJzIGxpa2UgVm9pY2VPdmVyIHRvIHJlYWQgdGhpcyBhcyBcIlpvb20gaW4gLSBidXR0b25cIlxyXG4gIFx0XHQgKi9cclxuICBcdFx0bGluay5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAnYnV0dG9uJyk7XHJcbiAgXHRcdGxpbmsuc2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsJywgdGl0bGUpO1xyXG5cclxuICBcdFx0ZGlzYWJsZUNsaWNrUHJvcGFnYXRpb24obGluayk7XHJcbiAgXHRcdG9uKGxpbmssICdjbGljaycsIHN0b3ApO1xyXG4gIFx0XHRvbihsaW5rLCAnY2xpY2snLCBmbiwgdGhpcyk7XHJcbiAgXHRcdG9uKGxpbmssICdjbGljaycsIHRoaXMuX3JlZm9jdXNPbk1hcCwgdGhpcyk7XHJcblxyXG4gIFx0XHRyZXR1cm4gbGluaztcclxuICBcdH0sXHJcblxyXG4gIFx0X3VwZGF0ZURpc2FibGVkOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXHJcbiAgXHRcdCAgICBjbGFzc05hbWUgPSAnbGVhZmxldC1kaXNhYmxlZCc7XHJcblxyXG4gIFx0XHRyZW1vdmVDbGFzcyh0aGlzLl96b29tSW5CdXR0b24sIGNsYXNzTmFtZSk7XHJcbiAgXHRcdHJlbW92ZUNsYXNzKHRoaXMuX3pvb21PdXRCdXR0b24sIGNsYXNzTmFtZSk7XHJcblxyXG4gIFx0XHRpZiAodGhpcy5fZGlzYWJsZWQgfHwgbWFwLl96b29tID09PSBtYXAuZ2V0TWluWm9vbSgpKSB7XHJcbiAgXHRcdFx0YWRkQ2xhc3ModGhpcy5fem9vbU91dEJ1dHRvbiwgY2xhc3NOYW1lKTtcclxuICBcdFx0fVxyXG4gIFx0XHRpZiAodGhpcy5fZGlzYWJsZWQgfHwgbWFwLl96b29tID09PSBtYXAuZ2V0TWF4Wm9vbSgpKSB7XHJcbiAgXHRcdFx0YWRkQ2xhc3ModGhpcy5fem9vbUluQnV0dG9uLCBjbGFzc05hbWUpO1xyXG4gIFx0XHR9XHJcbiAgXHR9XHJcbiAgfSk7XHJcblxyXG4gIC8vIEBuYW1lc3BhY2UgTWFwXHJcbiAgLy8gQHNlY3Rpb24gQ29udHJvbCBvcHRpb25zXHJcbiAgLy8gQG9wdGlvbiB6b29tQ29udHJvbDogQm9vbGVhbiA9IHRydWVcclxuICAvLyBXaGV0aGVyIGEgW3pvb20gY29udHJvbF0oI2NvbnRyb2wtem9vbSkgaXMgYWRkZWQgdG8gdGhlIG1hcCBieSBkZWZhdWx0LlxyXG4gIE1hcC5tZXJnZU9wdGlvbnMoe1xyXG4gIFx0em9vbUNvbnRyb2w6IHRydWVcclxuICB9KTtcclxuXHJcbiAgTWFwLmFkZEluaXRIb29rKGZ1bmN0aW9uICgpIHtcclxuICBcdGlmICh0aGlzLm9wdGlvbnMuem9vbUNvbnRyb2wpIHtcclxuICBcdFx0Ly8gQHNlY3Rpb24gQ29udHJvbHNcclxuICBcdFx0Ly8gQHByb3BlcnR5IHpvb21Db250cm9sOiBDb250cm9sLlpvb21cclxuICBcdFx0Ly8gVGhlIGRlZmF1bHQgem9vbSBjb250cm9sIChvbmx5IGF2YWlsYWJsZSBpZiB0aGVcclxuICBcdFx0Ly8gW2B6b29tQ29udHJvbGAgb3B0aW9uXSgjbWFwLXpvb21jb250cm9sKSB3YXMgYHRydWVgIHdoZW4gY3JlYXRpbmcgdGhlIG1hcCkuXHJcbiAgXHRcdHRoaXMuem9vbUNvbnRyb2wgPSBuZXcgWm9vbSgpO1xyXG4gIFx0XHR0aGlzLmFkZENvbnRyb2wodGhpcy56b29tQ29udHJvbCk7XHJcbiAgXHR9XHJcbiAgfSk7XHJcblxyXG4gIC8vIEBuYW1lc3BhY2UgQ29udHJvbC5ab29tXHJcbiAgLy8gQGZhY3RvcnkgTC5jb250cm9sLnpvb20ob3B0aW9uczogQ29udHJvbC5ab29tIG9wdGlvbnMpXHJcbiAgLy8gQ3JlYXRlcyBhIHpvb20gY29udHJvbFxyXG4gIHZhciB6b29tID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICBcdHJldHVybiBuZXcgWm9vbShvcHRpb25zKTtcclxuICB9O1xuXG4gIC8qXG4gICAqIEBjbGFzcyBDb250cm9sLlNjYWxlXG4gICAqIEBha2EgTC5Db250cm9sLlNjYWxlXG4gICAqIEBpbmhlcml0cyBDb250cm9sXG4gICAqXG4gICAqIEEgc2ltcGxlIHNjYWxlIGNvbnRyb2wgdGhhdCBzaG93cyB0aGUgc2NhbGUgb2YgdGhlIGN1cnJlbnQgY2VudGVyIG9mIHNjcmVlbiBpbiBtZXRyaWMgKG0va20pIGFuZCBpbXBlcmlhbCAobWkvZnQpIHN5c3RlbXMuIEV4dGVuZHMgYENvbnRyb2xgLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBMLmNvbnRyb2wuc2NhbGUoKS5hZGRUbyhtYXApO1xuICAgKiBgYGBcbiAgICovXG5cbiAgdmFyIFNjYWxlID0gQ29udHJvbC5leHRlbmQoe1xuICBcdC8vIEBzZWN0aW9uXG4gIFx0Ly8gQGFrYSBDb250cm9sLlNjYWxlIG9wdGlvbnNcbiAgXHRvcHRpb25zOiB7XG4gIFx0XHRwb3NpdGlvbjogJ2JvdHRvbWxlZnQnLFxuXG4gIFx0XHQvLyBAb3B0aW9uIG1heFdpZHRoOiBOdW1iZXIgPSAxMDBcbiAgXHRcdC8vIE1heGltdW0gd2lkdGggb2YgdGhlIGNvbnRyb2wgaW4gcGl4ZWxzLiBUaGUgd2lkdGggaXMgc2V0IGR5bmFtaWNhbGx5IHRvIHNob3cgcm91bmQgdmFsdWVzIChlLmcuIDEwMCwgMjAwLCA1MDApLlxuICBcdFx0bWF4V2lkdGg6IDEwMCxcblxuICBcdFx0Ly8gQG9wdGlvbiBtZXRyaWM6IEJvb2xlYW4gPSBUcnVlXG4gIFx0XHQvLyBXaGV0aGVyIHRvIHNob3cgdGhlIG1ldHJpYyBzY2FsZSBsaW5lIChtL2ttKS5cbiAgXHRcdG1ldHJpYzogdHJ1ZSxcblxuICBcdFx0Ly8gQG9wdGlvbiBpbXBlcmlhbDogQm9vbGVhbiA9IFRydWVcbiAgXHRcdC8vIFdoZXRoZXIgdG8gc2hvdyB0aGUgaW1wZXJpYWwgc2NhbGUgbGluZSAobWkvZnQpLlxuICBcdFx0aW1wZXJpYWw6IHRydWVcblxuICBcdFx0Ly8gQG9wdGlvbiB1cGRhdGVXaGVuSWRsZTogQm9vbGVhbiA9IGZhbHNlXG4gIFx0XHQvLyBJZiBgdHJ1ZWAsIHRoZSBjb250cm9sIGlzIHVwZGF0ZWQgb24gW2Btb3ZlZW5kYF0oI21hcC1tb3ZlZW5kKSwgb3RoZXJ3aXNlIGl0J3MgYWx3YXlzIHVwLXRvLWRhdGUgKHVwZGF0ZWQgb24gW2Btb3ZlYF0oI21hcC1tb3ZlKSkuXG4gIFx0fSxcblxuICBcdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XG4gIFx0XHR2YXIgY2xhc3NOYW1lID0gJ2xlYWZsZXQtY29udHJvbC1zY2FsZScsXG4gIFx0XHQgICAgY29udGFpbmVyID0gY3JlYXRlJDEoJ2RpdicsIGNsYXNzTmFtZSksXG4gIFx0XHQgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuICBcdFx0dGhpcy5fYWRkU2NhbGVzKG9wdGlvbnMsIGNsYXNzTmFtZSArICctbGluZScsIGNvbnRhaW5lcik7XG5cbiAgXHRcdG1hcC5vbihvcHRpb25zLnVwZGF0ZVdoZW5JZGxlID8gJ21vdmVlbmQnIDogJ21vdmUnLCB0aGlzLl91cGRhdGUsIHRoaXMpO1xuICBcdFx0bWFwLndoZW5SZWFkeSh0aGlzLl91cGRhdGUsIHRoaXMpO1xuXG4gIFx0XHRyZXR1cm4gY29udGFpbmVyO1xuICBcdH0sXG5cbiAgXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xuICBcdFx0bWFwLm9mZih0aGlzLm9wdGlvbnMudXBkYXRlV2hlbklkbGUgPyAnbW92ZWVuZCcgOiAnbW92ZScsIHRoaXMuX3VwZGF0ZSwgdGhpcyk7XG4gIFx0fSxcblxuICBcdF9hZGRTY2FsZXM6IGZ1bmN0aW9uIChvcHRpb25zLCBjbGFzc05hbWUsIGNvbnRhaW5lcikge1xuICBcdFx0aWYgKG9wdGlvbnMubWV0cmljKSB7XG4gIFx0XHRcdHRoaXMuX21TY2FsZSA9IGNyZWF0ZSQxKCdkaXYnLCBjbGFzc05hbWUsIGNvbnRhaW5lcik7XG4gIFx0XHR9XG4gIFx0XHRpZiAob3B0aW9ucy5pbXBlcmlhbCkge1xuICBcdFx0XHR0aGlzLl9pU2NhbGUgPSBjcmVhdGUkMSgnZGl2JywgY2xhc3NOYW1lLCBjb250YWluZXIpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuICBcdFx0ICAgIHkgPSBtYXAuZ2V0U2l6ZSgpLnkgLyAyO1xuXG4gIFx0XHR2YXIgbWF4TWV0ZXJzID0gbWFwLmRpc3RhbmNlKFxuICBcdFx0XHRtYXAuY29udGFpbmVyUG9pbnRUb0xhdExuZyhbMCwgeV0pLFxuICBcdFx0XHRtYXAuY29udGFpbmVyUG9pbnRUb0xhdExuZyhbdGhpcy5vcHRpb25zLm1heFdpZHRoLCB5XSkpO1xuXG4gIFx0XHR0aGlzLl91cGRhdGVTY2FsZXMobWF4TWV0ZXJzKTtcbiAgXHR9LFxuXG4gIFx0X3VwZGF0ZVNjYWxlczogZnVuY3Rpb24gKG1heE1ldGVycykge1xuICBcdFx0aWYgKHRoaXMub3B0aW9ucy5tZXRyaWMgJiYgbWF4TWV0ZXJzKSB7XG4gIFx0XHRcdHRoaXMuX3VwZGF0ZU1ldHJpYyhtYXhNZXRlcnMpO1xuICBcdFx0fVxuICBcdFx0aWYgKHRoaXMub3B0aW9ucy5pbXBlcmlhbCAmJiBtYXhNZXRlcnMpIHtcbiAgXHRcdFx0dGhpcy5fdXBkYXRlSW1wZXJpYWwobWF4TWV0ZXJzKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X3VwZGF0ZU1ldHJpYzogZnVuY3Rpb24gKG1heE1ldGVycykge1xuICBcdFx0dmFyIG1ldGVycyA9IHRoaXMuX2dldFJvdW5kTnVtKG1heE1ldGVycyksXG4gIFx0XHQgICAgbGFiZWwgPSBtZXRlcnMgPCAxMDAwID8gbWV0ZXJzICsgJyBtJyA6IChtZXRlcnMgLyAxMDAwKSArICcga20nO1xuXG4gIFx0XHR0aGlzLl91cGRhdGVTY2FsZSh0aGlzLl9tU2NhbGUsIGxhYmVsLCBtZXRlcnMgLyBtYXhNZXRlcnMpO1xuICBcdH0sXG5cbiAgXHRfdXBkYXRlSW1wZXJpYWw6IGZ1bmN0aW9uIChtYXhNZXRlcnMpIHtcbiAgXHRcdHZhciBtYXhGZWV0ID0gbWF4TWV0ZXJzICogMy4yODA4Mzk5LFxuICBcdFx0ICAgIG1heE1pbGVzLCBtaWxlcywgZmVldDtcblxuICBcdFx0aWYgKG1heEZlZXQgPiA1MjgwKSB7XG4gIFx0XHRcdG1heE1pbGVzID0gbWF4RmVldCAvIDUyODA7XG4gIFx0XHRcdG1pbGVzID0gdGhpcy5fZ2V0Um91bmROdW0obWF4TWlsZXMpO1xuICBcdFx0XHR0aGlzLl91cGRhdGVTY2FsZSh0aGlzLl9pU2NhbGUsIG1pbGVzICsgJyBtaScsIG1pbGVzIC8gbWF4TWlsZXMpO1xuXG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRmZWV0ID0gdGhpcy5fZ2V0Um91bmROdW0obWF4RmVldCk7XG4gIFx0XHRcdHRoaXMuX3VwZGF0ZVNjYWxlKHRoaXMuX2lTY2FsZSwgZmVldCArICcgZnQnLCBmZWV0IC8gbWF4RmVldCk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF91cGRhdGVTY2FsZTogZnVuY3Rpb24gKHNjYWxlLCB0ZXh0LCByYXRpbykge1xuICBcdFx0c2NhbGUuc3R5bGUud2lkdGggPSBNYXRoLnJvdW5kKHRoaXMub3B0aW9ucy5tYXhXaWR0aCAqIHJhdGlvKSArICdweCc7XG4gIFx0XHRzY2FsZS5pbm5lckhUTUwgPSB0ZXh0O1xuICBcdH0sXG5cbiAgXHRfZ2V0Um91bmROdW06IGZ1bmN0aW9uIChudW0pIHtcbiAgXHRcdHZhciBwb3cxMCA9IE1hdGgucG93KDEwLCAoTWF0aC5mbG9vcihudW0pICsgJycpLmxlbmd0aCAtIDEpLFxuICBcdFx0ICAgIGQgPSBudW0gLyBwb3cxMDtcblxuICBcdFx0ZCA9IGQgPj0gMTAgPyAxMCA6XG4gIFx0XHQgICAgZCA+PSA1ID8gNSA6XG4gIFx0XHQgICAgZCA+PSAzID8gMyA6XG4gIFx0XHQgICAgZCA+PSAyID8gMiA6IDE7XG5cbiAgXHRcdHJldHVybiBwb3cxMCAqIGQ7XG4gIFx0fVxuICB9KTtcblxuXG4gIC8vIEBmYWN0b3J5IEwuY29udHJvbC5zY2FsZShvcHRpb25zPzogQ29udHJvbC5TY2FsZSBvcHRpb25zKVxuICAvLyBDcmVhdGVzIGFuIHNjYWxlIGNvbnRyb2wgd2l0aCB0aGUgZ2l2ZW4gb3B0aW9ucy5cbiAgdmFyIHNjYWxlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgXHRyZXR1cm4gbmV3IFNjYWxlKG9wdGlvbnMpO1xuICB9O1xuXG4gIC8qXHJcbiAgICogQGNsYXNzIENvbnRyb2wuQXR0cmlidXRpb25cclxuICAgKiBAYWthIEwuQ29udHJvbC5BdHRyaWJ1dGlvblxyXG4gICAqIEBpbmhlcml0cyBDb250cm9sXHJcbiAgICpcclxuICAgKiBUaGUgYXR0cmlidXRpb24gY29udHJvbCBhbGxvd3MgeW91IHRvIGRpc3BsYXkgYXR0cmlidXRpb24gZGF0YSBpbiBhIHNtYWxsIHRleHQgYm94IG9uIGEgbWFwLiBJdCBpcyBwdXQgb24gdGhlIG1hcCBieSBkZWZhdWx0IHVubGVzcyB5b3Ugc2V0IGl0cyBbYGF0dHJpYnV0aW9uQ29udHJvbGAgb3B0aW9uXSgjbWFwLWF0dHJpYnV0aW9uY29udHJvbCkgdG8gYGZhbHNlYCwgYW5kIGl0IGZldGNoZXMgYXR0cmlidXRpb24gdGV4dHMgZnJvbSBsYXllcnMgd2l0aCB0aGUgW2BnZXRBdHRyaWJ1dGlvbmAgbWV0aG9kXSgjbGF5ZXItZ2V0YXR0cmlidXRpb24pIGF1dG9tYXRpY2FsbHkuIEV4dGVuZHMgQ29udHJvbC5cclxuICAgKi9cclxuXHJcbiAgdmFyIEF0dHJpYnV0aW9uID0gQ29udHJvbC5leHRlbmQoe1xyXG4gIFx0Ly8gQHNlY3Rpb25cclxuICBcdC8vIEBha2EgQ29udHJvbC5BdHRyaWJ1dGlvbiBvcHRpb25zXHJcbiAgXHRvcHRpb25zOiB7XHJcbiAgXHRcdHBvc2l0aW9uOiAnYm90dG9tcmlnaHQnLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBwcmVmaXg6IFN0cmluZyA9ICdMZWFmbGV0J1xyXG4gIFx0XHQvLyBUaGUgSFRNTCB0ZXh0IHNob3duIGJlZm9yZSB0aGUgYXR0cmlidXRpb25zLiBQYXNzIGBmYWxzZWAgdG8gZGlzYWJsZS5cclxuICBcdFx0cHJlZml4OiAnPGEgaHJlZj1cImh0dHBzOi8vbGVhZmxldGpzLmNvbVwiIHRpdGxlPVwiQSBKUyBsaWJyYXJ5IGZvciBpbnRlcmFjdGl2ZSBtYXBzXCI+TGVhZmxldDwvYT4nXHJcbiAgXHR9LFxyXG5cclxuICBcdGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgXHRcdHNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG4gIFx0XHR0aGlzLl9hdHRyaWJ1dGlvbnMgPSB7fTtcclxuICBcdH0sXHJcblxyXG4gIFx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuICBcdFx0bWFwLmF0dHJpYnV0aW9uQ29udHJvbCA9IHRoaXM7XHJcbiAgXHRcdHRoaXMuX2NvbnRhaW5lciA9IGNyZWF0ZSQxKCdkaXYnLCAnbGVhZmxldC1jb250cm9sLWF0dHJpYnV0aW9uJyk7XHJcbiAgXHRcdGRpc2FibGVDbGlja1Byb3BhZ2F0aW9uKHRoaXMuX2NvbnRhaW5lcik7XHJcblxyXG4gIFx0XHQvLyBUT0RPIHVnbHksIHJlZmFjdG9yXHJcbiAgXHRcdGZvciAodmFyIGkgaW4gbWFwLl9sYXllcnMpIHtcclxuICBcdFx0XHRpZiAobWFwLl9sYXllcnNbaV0uZ2V0QXR0cmlidXRpb24pIHtcclxuICBcdFx0XHRcdHRoaXMuYWRkQXR0cmlidXRpb24obWFwLl9sYXllcnNbaV0uZ2V0QXR0cmlidXRpb24oKSk7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR0aGlzLl91cGRhdGUoKTtcclxuXHJcbiAgXHRcdHJldHVybiB0aGlzLl9jb250YWluZXI7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2Qgc2V0UHJlZml4KHByZWZpeDogU3RyaW5nKTogdGhpc1xyXG4gIFx0Ly8gU2V0cyB0aGUgdGV4dCBiZWZvcmUgdGhlIGF0dHJpYnV0aW9ucy5cclxuICBcdHNldFByZWZpeDogZnVuY3Rpb24gKHByZWZpeCkge1xyXG4gIFx0XHR0aGlzLm9wdGlvbnMucHJlZml4ID0gcHJlZml4O1xyXG4gIFx0XHR0aGlzLl91cGRhdGUoKTtcclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgYWRkQXR0cmlidXRpb24odGV4dDogU3RyaW5nKTogdGhpc1xyXG4gIFx0Ly8gQWRkcyBhbiBhdHRyaWJ1dGlvbiB0ZXh0IChlLmcuIGAnVmVjdG9yIGRhdGEgJmNvcHk7IE1hcGJveCdgKS5cclxuICBcdGFkZEF0dHJpYnV0aW9uOiBmdW5jdGlvbiAodGV4dCkge1xyXG4gIFx0XHRpZiAoIXRleHQpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcbiAgXHRcdGlmICghdGhpcy5fYXR0cmlidXRpb25zW3RleHRdKSB7XHJcbiAgXHRcdFx0dGhpcy5fYXR0cmlidXRpb25zW3RleHRdID0gMDtcclxuICBcdFx0fVxyXG4gIFx0XHR0aGlzLl9hdHRyaWJ1dGlvbnNbdGV4dF0rKztcclxuXHJcbiAgXHRcdHRoaXMuX3VwZGF0ZSgpO1xyXG5cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgcmVtb3ZlQXR0cmlidXRpb24odGV4dDogU3RyaW5nKTogdGhpc1xyXG4gIFx0Ly8gUmVtb3ZlcyBhbiBhdHRyaWJ1dGlvbiB0ZXh0LlxyXG4gIFx0cmVtb3ZlQXR0cmlidXRpb246IGZ1bmN0aW9uICh0ZXh0KSB7XHJcbiAgXHRcdGlmICghdGV4dCkgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuICBcdFx0aWYgKHRoaXMuX2F0dHJpYnV0aW9uc1t0ZXh0XSkge1xyXG4gIFx0XHRcdHRoaXMuX2F0dHJpYnV0aW9uc1t0ZXh0XS0tO1xyXG4gIFx0XHRcdHRoaXMuX3VwZGF0ZSgpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRpZiAoIXRoaXMuX21hcCkgeyByZXR1cm47IH1cclxuXHJcbiAgXHRcdHZhciBhdHRyaWJzID0gW107XHJcblxyXG4gIFx0XHRmb3IgKHZhciBpIGluIHRoaXMuX2F0dHJpYnV0aW9ucykge1xyXG4gIFx0XHRcdGlmICh0aGlzLl9hdHRyaWJ1dGlvbnNbaV0pIHtcclxuICBcdFx0XHRcdGF0dHJpYnMucHVzaChpKTtcclxuICBcdFx0XHR9XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHZhciBwcmVmaXhBbmRBdHRyaWJzID0gW107XHJcblxyXG4gIFx0XHRpZiAodGhpcy5vcHRpb25zLnByZWZpeCkge1xyXG4gIFx0XHRcdHByZWZpeEFuZEF0dHJpYnMucHVzaCh0aGlzLm9wdGlvbnMucHJlZml4KTtcclxuICBcdFx0fVxyXG4gIFx0XHRpZiAoYXR0cmlicy5sZW5ndGgpIHtcclxuICBcdFx0XHRwcmVmaXhBbmRBdHRyaWJzLnB1c2goYXR0cmlicy5qb2luKCcsICcpKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dGhpcy5fY29udGFpbmVyLmlubmVySFRNTCA9IHByZWZpeEFuZEF0dHJpYnMuam9pbignIHwgJyk7XHJcbiAgXHR9XHJcbiAgfSk7XHJcblxyXG4gIC8vIEBuYW1lc3BhY2UgTWFwXHJcbiAgLy8gQHNlY3Rpb24gQ29udHJvbCBvcHRpb25zXHJcbiAgLy8gQG9wdGlvbiBhdHRyaWJ1dGlvbkNvbnRyb2w6IEJvb2xlYW4gPSB0cnVlXHJcbiAgLy8gV2hldGhlciBhIFthdHRyaWJ1dGlvbiBjb250cm9sXSgjY29udHJvbC1hdHRyaWJ1dGlvbikgaXMgYWRkZWQgdG8gdGhlIG1hcCBieSBkZWZhdWx0LlxyXG4gIE1hcC5tZXJnZU9wdGlvbnMoe1xyXG4gIFx0YXR0cmlidXRpb25Db250cm9sOiB0cnVlXHJcbiAgfSk7XHJcblxyXG4gIE1hcC5hZGRJbml0SG9vayhmdW5jdGlvbiAoKSB7XHJcbiAgXHRpZiAodGhpcy5vcHRpb25zLmF0dHJpYnV0aW9uQ29udHJvbCkge1xyXG4gIFx0XHRuZXcgQXR0cmlidXRpb24oKS5hZGRUbyh0aGlzKTtcclxuICBcdH1cclxuICB9KTtcclxuXHJcbiAgLy8gQG5hbWVzcGFjZSBDb250cm9sLkF0dHJpYnV0aW9uXHJcbiAgLy8gQGZhY3RvcnkgTC5jb250cm9sLmF0dHJpYnV0aW9uKG9wdGlvbnM6IENvbnRyb2wuQXR0cmlidXRpb24gb3B0aW9ucylcclxuICAvLyBDcmVhdGVzIGFuIGF0dHJpYnV0aW9uIGNvbnRyb2wuXHJcbiAgdmFyIGF0dHJpYnV0aW9uID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICBcdHJldHVybiBuZXcgQXR0cmlidXRpb24ob3B0aW9ucyk7XHJcbiAgfTtcblxuICBDb250cm9sLkxheWVycyA9IExheWVycztcbiAgQ29udHJvbC5ab29tID0gWm9vbTtcbiAgQ29udHJvbC5TY2FsZSA9IFNjYWxlO1xuICBDb250cm9sLkF0dHJpYnV0aW9uID0gQXR0cmlidXRpb247XG5cbiAgY29udHJvbC5sYXllcnMgPSBsYXllcnM7XG4gIGNvbnRyb2wuem9vbSA9IHpvb207XG4gIGNvbnRyb2wuc2NhbGUgPSBzY2FsZTtcbiAgY29udHJvbC5hdHRyaWJ1dGlvbiA9IGF0dHJpYnV0aW9uO1xuXG4gIC8qXG4gIFx0TC5IYW5kbGVyIGlzIGEgYmFzZSBjbGFzcyBmb3IgaGFuZGxlciBjbGFzc2VzIHRoYXQgYXJlIHVzZWQgaW50ZXJuYWxseSB0byBpbmplY3RcbiAgXHRpbnRlcmFjdGlvbiBmZWF0dXJlcyBsaWtlIGRyYWdnaW5nIHRvIGNsYXNzZXMgbGlrZSBNYXAgYW5kIE1hcmtlci5cbiAgKi9cblxuICAvLyBAY2xhc3MgSGFuZGxlclxuICAvLyBAYWthIEwuSGFuZGxlclxuICAvLyBBYnN0cmFjdCBjbGFzcyBmb3IgbWFwIGludGVyYWN0aW9uIGhhbmRsZXJzXG5cbiAgdmFyIEhhbmRsZXIgPSBDbGFzcy5leHRlbmQoe1xuICBcdGluaXRpYWxpemU6IGZ1bmN0aW9uIChtYXApIHtcbiAgXHRcdHRoaXMuX21hcCA9IG1hcDtcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCBlbmFibGUoKTogdGhpc1xuICBcdC8vIEVuYWJsZXMgdGhlIGhhbmRsZXJcbiAgXHRlbmFibGU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICh0aGlzLl9lbmFibGVkKSB7IHJldHVybiB0aGlzOyB9XG5cbiAgXHRcdHRoaXMuX2VuYWJsZWQgPSB0cnVlO1xuICBcdFx0dGhpcy5hZGRIb29rcygpO1xuICBcdFx0cmV0dXJuIHRoaXM7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2QgZGlzYWJsZSgpOiB0aGlzXG4gIFx0Ly8gRGlzYWJsZXMgdGhlIGhhbmRsZXJcbiAgXHRkaXNhYmxlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAoIXRoaXMuX2VuYWJsZWQpIHsgcmV0dXJuIHRoaXM7IH1cblxuICBcdFx0dGhpcy5fZW5hYmxlZCA9IGZhbHNlO1xuICBcdFx0dGhpcy5yZW1vdmVIb29rcygpO1xuICBcdFx0cmV0dXJuIHRoaXM7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2QgZW5hYmxlZCgpOiBCb29sZWFuXG4gIFx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGhhbmRsZXIgaXMgZW5hYmxlZFxuICBcdGVuYWJsZWQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiAhIXRoaXMuX2VuYWJsZWQ7XG4gIFx0fVxuXG4gIFx0Ly8gQHNlY3Rpb24gRXh0ZW5zaW9uIG1ldGhvZHNcbiAgXHQvLyBDbGFzc2VzIGluaGVyaXRpbmcgZnJvbSBgSGFuZGxlcmAgbXVzdCBpbXBsZW1lbnQgdGhlIHR3byBmb2xsb3dpbmcgbWV0aG9kczpcbiAgXHQvLyBAbWV0aG9kIGFkZEhvb2tzKClcbiAgXHQvLyBDYWxsZWQgd2hlbiB0aGUgaGFuZGxlciBpcyBlbmFibGVkLCBzaG91bGQgYWRkIGV2ZW50IGhvb2tzLlxuICBcdC8vIEBtZXRob2QgcmVtb3ZlSG9va3MoKVxuICBcdC8vIENhbGxlZCB3aGVuIHRoZSBoYW5kbGVyIGlzIGRpc2FibGVkLCBzaG91bGQgcmVtb3ZlIHRoZSBldmVudCBob29rcyBhZGRlZCBwcmV2aW91c2x5LlxuICB9KTtcblxuICAvLyBAc2VjdGlvbiBUaGVyZSBpcyBzdGF0aWMgZnVuY3Rpb24gd2hpY2ggY2FuIGJlIGNhbGxlZCB3aXRob3V0IGluc3RhbnRpYXRpbmcgTC5IYW5kbGVyOlxuICAvLyBAZnVuY3Rpb24gYWRkVG8obWFwOiBNYXAsIG5hbWU6IFN0cmluZyk6IHRoaXNcbiAgLy8gQWRkcyBhIG5ldyBIYW5kbGVyIHRvIHRoZSBnaXZlbiBtYXAgd2l0aCB0aGUgZ2l2ZW4gbmFtZS5cbiAgSGFuZGxlci5hZGRUbyA9IGZ1bmN0aW9uIChtYXAsIG5hbWUpIHtcbiAgXHRtYXAuYWRkSGFuZGxlcihuYW1lLCB0aGlzKTtcbiAgXHRyZXR1cm4gdGhpcztcbiAgfTtcblxuICB2YXIgTWl4aW4gPSB7RXZlbnRzOiBFdmVudHN9O1xuXG4gIC8qXHJcbiAgICogQGNsYXNzIERyYWdnYWJsZVxyXG4gICAqIEBha2EgTC5EcmFnZ2FibGVcclxuICAgKiBAaW5oZXJpdHMgRXZlbnRlZFxyXG4gICAqXHJcbiAgICogQSBjbGFzcyBmb3IgbWFraW5nIERPTSBlbGVtZW50cyBkcmFnZ2FibGUgKGluY2x1ZGluZyB0b3VjaCBzdXBwb3J0KS5cclxuICAgKiBVc2VkIGludGVybmFsbHkgZm9yIG1hcCBhbmQgbWFya2VyIGRyYWdnaW5nLiBPbmx5IHdvcmtzIGZvciBlbGVtZW50c1xyXG4gICAqIHRoYXQgd2VyZSBwb3NpdGlvbmVkIHdpdGggW2BMLkRvbVV0aWwuc2V0UG9zaXRpb25gXSgjZG9tdXRpbC1zZXRwb3NpdGlvbikuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGBgYGpzXHJcbiAgICogdmFyIGRyYWdnYWJsZSA9IG5ldyBMLkRyYWdnYWJsZShlbGVtZW50VG9EcmFnKTtcclxuICAgKiBkcmFnZ2FibGUuZW5hYmxlKCk7XHJcbiAgICogYGBgXHJcbiAgICovXHJcblxyXG4gIHZhciBTVEFSVCA9IHRvdWNoID8gJ3RvdWNoc3RhcnQgbW91c2Vkb3duJyA6ICdtb3VzZWRvd24nO1xyXG4gIHZhciBFTkQgPSB7XHJcbiAgXHRtb3VzZWRvd246ICdtb3VzZXVwJyxcclxuICBcdHRvdWNoc3RhcnQ6ICd0b3VjaGVuZCcsXHJcbiAgXHRwb2ludGVyZG93bjogJ3RvdWNoZW5kJyxcclxuICBcdE1TUG9pbnRlckRvd246ICd0b3VjaGVuZCdcclxuICB9O1xyXG4gIHZhciBNT1ZFID0ge1xyXG4gIFx0bW91c2Vkb3duOiAnbW91c2Vtb3ZlJyxcclxuICBcdHRvdWNoc3RhcnQ6ICd0b3VjaG1vdmUnLFxyXG4gIFx0cG9pbnRlcmRvd246ICd0b3VjaG1vdmUnLFxyXG4gIFx0TVNQb2ludGVyRG93bjogJ3RvdWNobW92ZSdcclxuICB9O1xyXG5cclxuXHJcbiAgdmFyIERyYWdnYWJsZSA9IEV2ZW50ZWQuZXh0ZW5kKHtcclxuXHJcbiAgXHRvcHRpb25zOiB7XHJcbiAgXHRcdC8vIEBzZWN0aW9uXHJcbiAgXHRcdC8vIEBha2EgRHJhZ2dhYmxlIG9wdGlvbnNcclxuICBcdFx0Ly8gQG9wdGlvbiBjbGlja1RvbGVyYW5jZTogTnVtYmVyID0gM1xyXG4gIFx0XHQvLyBUaGUgbWF4IG51bWJlciBvZiBwaXhlbHMgYSB1c2VyIGNhbiBzaGlmdCB0aGUgbW91c2UgcG9pbnRlciBkdXJpbmcgYSBjbGlja1xyXG4gIFx0XHQvLyBmb3IgaXQgdG8gYmUgY29uc2lkZXJlZCBhIHZhbGlkIGNsaWNrIChhcyBvcHBvc2VkIHRvIGEgbW91c2UgZHJhZykuXHJcbiAgXHRcdGNsaWNrVG9sZXJhbmNlOiAzXHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBjb25zdHJ1Y3RvciBMLkRyYWdnYWJsZShlbDogSFRNTEVsZW1lbnQsIGRyYWdIYW5kbGU/OiBIVE1MRWxlbWVudCwgcHJldmVudE91dGxpbmU/OiBCb29sZWFuLCBvcHRpb25zPzogRHJhZ2dhYmxlIG9wdGlvbnMpXHJcbiAgXHQvLyBDcmVhdGVzIGEgYERyYWdnYWJsZWAgb2JqZWN0IGZvciBtb3ZpbmcgYGVsYCB3aGVuIHlvdSBzdGFydCBkcmFnZ2luZyB0aGUgYGRyYWdIYW5kbGVgIGVsZW1lbnQgKGVxdWFscyBgZWxgIGl0c2VsZiBieSBkZWZhdWx0KS5cclxuICBcdGluaXRpYWxpemU6IGZ1bmN0aW9uIChlbGVtZW50LCBkcmFnU3RhcnRUYXJnZXQsIHByZXZlbnRPdXRsaW5lJCQxLCBvcHRpb25zKSB7XHJcbiAgXHRcdHNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG4gIFx0XHR0aGlzLl9lbGVtZW50ID0gZWxlbWVudDtcclxuICBcdFx0dGhpcy5fZHJhZ1N0YXJ0VGFyZ2V0ID0gZHJhZ1N0YXJ0VGFyZ2V0IHx8IGVsZW1lbnQ7XHJcbiAgXHRcdHRoaXMuX3ByZXZlbnRPdXRsaW5lID0gcHJldmVudE91dGxpbmUkJDE7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZW5hYmxlKClcclxuICBcdC8vIEVuYWJsZXMgdGhlIGRyYWdnaW5nIGFiaWxpdHlcclxuICBcdGVuYWJsZTogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRpZiAodGhpcy5fZW5hYmxlZCkgeyByZXR1cm47IH1cclxuXHJcbiAgXHRcdG9uKHRoaXMuX2RyYWdTdGFydFRhcmdldCwgU1RBUlQsIHRoaXMuX29uRG93biwgdGhpcyk7XHJcblxyXG4gIFx0XHR0aGlzLl9lbmFibGVkID0gdHJ1ZTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBkaXNhYmxlKClcclxuICBcdC8vIERpc2FibGVzIHRoZSBkcmFnZ2luZyBhYmlsaXR5XHJcbiAgXHRkaXNhYmxlOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdGlmICghdGhpcy5fZW5hYmxlZCkgeyByZXR1cm47IH1cclxuXHJcbiAgXHRcdC8vIElmIHdlJ3JlIGN1cnJlbnRseSBkcmFnZ2luZyB0aGlzIGRyYWdnYWJsZSxcclxuICBcdFx0Ly8gZGlzYWJsaW5nIGl0IGNvdW50cyBhcyBmaXJzdCBlbmRpbmcgdGhlIGRyYWcuXHJcbiAgXHRcdGlmIChEcmFnZ2FibGUuX2RyYWdnaW5nID09PSB0aGlzKSB7XHJcbiAgXHRcdFx0dGhpcy5maW5pc2hEcmFnKCk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdG9mZih0aGlzLl9kcmFnU3RhcnRUYXJnZXQsIFNUQVJULCB0aGlzLl9vbkRvd24sIHRoaXMpO1xyXG5cclxuICBcdFx0dGhpcy5fZW5hYmxlZCA9IGZhbHNlO1xyXG4gIFx0XHR0aGlzLl9tb3ZlZCA9IGZhbHNlO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfb25Eb3duOiBmdW5jdGlvbiAoZSkge1xyXG4gIFx0XHQvLyBJZ25vcmUgc2ltdWxhdGVkIGV2ZW50cywgc2luY2Ugd2UgaGFuZGxlIGJvdGggdG91Y2ggYW5kXHJcbiAgXHRcdC8vIG1vdXNlIGV4cGxpY2l0bHk7IG90aGVyd2lzZSB3ZSByaXNrIGdldHRpbmcgZHVwbGljYXRlcyBvZlxyXG4gIFx0XHQvLyB0b3VjaCBldmVudHMsIHNlZSAjNDMxNS5cclxuICBcdFx0Ly8gQWxzbyBpZ25vcmUgdGhlIGV2ZW50IGlmIGRpc2FibGVkOyB0aGlzIGhhcHBlbnMgaW4gSUUxMVxyXG4gIFx0XHQvLyB1bmRlciBzb21lIGNpcmN1bXN0YW5jZXMsIHNlZSAjMzY2Ni5cclxuICBcdFx0aWYgKGUuX3NpbXVsYXRlZCB8fCAhdGhpcy5fZW5hYmxlZCkgeyByZXR1cm47IH1cclxuXHJcbiAgXHRcdHRoaXMuX21vdmVkID0gZmFsc2U7XHJcblxyXG4gIFx0XHRpZiAoaGFzQ2xhc3ModGhpcy5fZWxlbWVudCwgJ2xlYWZsZXQtem9vbS1hbmltJykpIHsgcmV0dXJuOyB9XHJcblxyXG4gIFx0XHRpZiAoRHJhZ2dhYmxlLl9kcmFnZ2luZyB8fCBlLnNoaWZ0S2V5IHx8ICgoZS53aGljaCAhPT0gMSkgJiYgKGUuYnV0dG9uICE9PSAxKSAmJiAhZS50b3VjaGVzKSkgeyByZXR1cm47IH1cclxuICBcdFx0RHJhZ2dhYmxlLl9kcmFnZ2luZyA9IHRoaXM7ICAvLyBQcmV2ZW50IGRyYWdnaW5nIG11bHRpcGxlIG9iamVjdHMgYXQgb25jZS5cclxuXHJcbiAgXHRcdGlmICh0aGlzLl9wcmV2ZW50T3V0bGluZSkge1xyXG4gIFx0XHRcdHByZXZlbnRPdXRsaW5lKHRoaXMuX2VsZW1lbnQpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRkaXNhYmxlSW1hZ2VEcmFnKCk7XHJcbiAgXHRcdGRpc2FibGVUZXh0U2VsZWN0aW9uKCk7XHJcblxyXG4gIFx0XHRpZiAodGhpcy5fbW92aW5nKSB7IHJldHVybjsgfVxyXG5cclxuICBcdFx0Ly8gQGV2ZW50IGRvd246IEV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIHdoZW4gYSBkcmFnIGlzIGFib3V0IHRvIHN0YXJ0LlxyXG4gIFx0XHR0aGlzLmZpcmUoJ2Rvd24nKTtcclxuXHJcbiAgXHRcdHZhciBmaXJzdCA9IGUudG91Y2hlcyA/IGUudG91Y2hlc1swXSA6IGUsXHJcbiAgXHRcdCAgICBzaXplZFBhcmVudCA9IGdldFNpemVkUGFyZW50Tm9kZSh0aGlzLl9lbGVtZW50KTtcclxuXHJcbiAgXHRcdHRoaXMuX3N0YXJ0UG9pbnQgPSBuZXcgUG9pbnQoZmlyc3QuY2xpZW50WCwgZmlyc3QuY2xpZW50WSk7XHJcblxyXG4gIFx0XHQvLyBDYWNoZSB0aGUgc2NhbGUsIHNvIHRoYXQgd2UgY2FuIGNvbnRpbnVvdXNseSBjb21wZW5zYXRlIGZvciBpdCBkdXJpbmcgZHJhZyAoX29uTW92ZSkuXHJcbiAgXHRcdHRoaXMuX3BhcmVudFNjYWxlID0gZ2V0U2NhbGUoc2l6ZWRQYXJlbnQpO1xyXG5cclxuICBcdFx0b24oZG9jdW1lbnQsIE1PVkVbZS50eXBlXSwgdGhpcy5fb25Nb3ZlLCB0aGlzKTtcclxuICBcdFx0b24oZG9jdW1lbnQsIEVORFtlLnR5cGVdLCB0aGlzLl9vblVwLCB0aGlzKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X29uTW92ZTogZnVuY3Rpb24gKGUpIHtcclxuICBcdFx0Ly8gSWdub3JlIHNpbXVsYXRlZCBldmVudHMsIHNpbmNlIHdlIGhhbmRsZSBib3RoIHRvdWNoIGFuZFxyXG4gIFx0XHQvLyBtb3VzZSBleHBsaWNpdGx5OyBvdGhlcndpc2Ugd2UgcmlzayBnZXR0aW5nIGR1cGxpY2F0ZXMgb2ZcclxuICBcdFx0Ly8gdG91Y2ggZXZlbnRzLCBzZWUgIzQzMTUuXHJcbiAgXHRcdC8vIEFsc28gaWdub3JlIHRoZSBldmVudCBpZiBkaXNhYmxlZDsgdGhpcyBoYXBwZW5zIGluIElFMTFcclxuICBcdFx0Ly8gdW5kZXIgc29tZSBjaXJjdW1zdGFuY2VzLCBzZWUgIzM2NjYuXHJcbiAgXHRcdGlmIChlLl9zaW11bGF0ZWQgfHwgIXRoaXMuX2VuYWJsZWQpIHsgcmV0dXJuOyB9XHJcblxyXG4gIFx0XHRpZiAoZS50b3VjaGVzICYmIGUudG91Y2hlcy5sZW5ndGggPiAxKSB7XHJcbiAgXHRcdFx0dGhpcy5fbW92ZWQgPSB0cnVlO1xyXG4gIFx0XHRcdHJldHVybjtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dmFyIGZpcnN0ID0gKGUudG91Y2hlcyAmJiBlLnRvdWNoZXMubGVuZ3RoID09PSAxID8gZS50b3VjaGVzWzBdIDogZSksXHJcbiAgXHRcdCAgICBvZmZzZXQgPSBuZXcgUG9pbnQoZmlyc3QuY2xpZW50WCwgZmlyc3QuY2xpZW50WSkuX3N1YnRyYWN0KHRoaXMuX3N0YXJ0UG9pbnQpO1xyXG5cclxuICBcdFx0aWYgKCFvZmZzZXQueCAmJiAhb2Zmc2V0LnkpIHsgcmV0dXJuOyB9XHJcbiAgXHRcdGlmIChNYXRoLmFicyhvZmZzZXQueCkgKyBNYXRoLmFicyhvZmZzZXQueSkgPCB0aGlzLm9wdGlvbnMuY2xpY2tUb2xlcmFuY2UpIHsgcmV0dXJuOyB9XHJcblxyXG4gIFx0XHQvLyBXZSBhc3N1bWUgdGhhdCB0aGUgcGFyZW50IGNvbnRhaW5lcidzIHBvc2l0aW9uLCBib3JkZXIgYW5kIHNjYWxlIGRvIG5vdCBjaGFuZ2UgZm9yIHRoZSBkdXJhdGlvbiBvZiB0aGUgZHJhZy5cclxuICBcdFx0Ly8gVGhlcmVmb3JlIHRoZXJlIGlzIG5vIG5lZWQgdG8gYWNjb3VudCBmb3IgdGhlIHBvc2l0aW9uIGFuZCBib3JkZXIgKHRoZXkgYXJlIGVsaW1pbmF0ZWQgYnkgdGhlIHN1YnRyYWN0aW9uKVxyXG4gIFx0XHQvLyBhbmQgd2UgY2FuIHVzZSB0aGUgY2FjaGVkIHZhbHVlIGZvciB0aGUgc2NhbGUuXHJcbiAgXHRcdG9mZnNldC54IC89IHRoaXMuX3BhcmVudFNjYWxlLng7XHJcbiAgXHRcdG9mZnNldC55IC89IHRoaXMuX3BhcmVudFNjYWxlLnk7XHJcblxyXG4gIFx0XHRwcmV2ZW50RGVmYXVsdChlKTtcclxuXHJcbiAgXHRcdGlmICghdGhpcy5fbW92ZWQpIHtcclxuICBcdFx0XHQvLyBAZXZlbnQgZHJhZ3N0YXJ0OiBFdmVudFxyXG4gIFx0XHRcdC8vIEZpcmVkIHdoZW4gYSBkcmFnIHN0YXJ0c1xyXG4gIFx0XHRcdHRoaXMuZmlyZSgnZHJhZ3N0YXJ0Jyk7XHJcblxyXG4gIFx0XHRcdHRoaXMuX21vdmVkID0gdHJ1ZTtcclxuICBcdFx0XHR0aGlzLl9zdGFydFBvcyA9IGdldFBvc2l0aW9uKHRoaXMuX2VsZW1lbnQpLnN1YnRyYWN0KG9mZnNldCk7XHJcblxyXG4gIFx0XHRcdGFkZENsYXNzKGRvY3VtZW50LmJvZHksICdsZWFmbGV0LWRyYWdnaW5nJyk7XHJcblxyXG4gIFx0XHRcdHRoaXMuX2xhc3RUYXJnZXQgPSBlLnRhcmdldCB8fCBlLnNyY0VsZW1lbnQ7XHJcbiAgXHRcdFx0Ly8gSUUgYW5kIEVkZ2UgZG8gbm90IGdpdmUgdGhlIDx1c2U+IGVsZW1lbnQsIHNvIGZldGNoIGl0XHJcbiAgXHRcdFx0Ly8gaWYgbmVjZXNzYXJ5XHJcbiAgXHRcdFx0aWYgKHdpbmRvdy5TVkdFbGVtZW50SW5zdGFuY2UgJiYgdGhpcy5fbGFzdFRhcmdldCBpbnN0YW5jZW9mIHdpbmRvdy5TVkdFbGVtZW50SW5zdGFuY2UpIHtcclxuICBcdFx0XHRcdHRoaXMuX2xhc3RUYXJnZXQgPSB0aGlzLl9sYXN0VGFyZ2V0LmNvcnJlc3BvbmRpbmdVc2VFbGVtZW50O1xyXG4gIFx0XHRcdH1cclxuICBcdFx0XHRhZGRDbGFzcyh0aGlzLl9sYXN0VGFyZ2V0LCAnbGVhZmxldC1kcmFnLXRhcmdldCcpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR0aGlzLl9uZXdQb3MgPSB0aGlzLl9zdGFydFBvcy5hZGQob2Zmc2V0KTtcclxuICBcdFx0dGhpcy5fbW92aW5nID0gdHJ1ZTtcclxuXHJcbiAgXHRcdGNhbmNlbEFuaW1GcmFtZSh0aGlzLl9hbmltUmVxdWVzdCk7XHJcbiAgXHRcdHRoaXMuX2xhc3RFdmVudCA9IGU7XHJcbiAgXHRcdHRoaXMuX2FuaW1SZXF1ZXN0ID0gcmVxdWVzdEFuaW1GcmFtZSh0aGlzLl91cGRhdGVQb3NpdGlvbiwgdGhpcywgdHJ1ZSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF91cGRhdGVQb3NpdGlvbjogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR2YXIgZSA9IHtvcmlnaW5hbEV2ZW50OiB0aGlzLl9sYXN0RXZlbnR9O1xyXG5cclxuICBcdFx0Ly8gQGV2ZW50IHByZWRyYWc6IEV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIGNvbnRpbnVvdXNseSBkdXJpbmcgZHJhZ2dpbmcgKmJlZm9yZSogZWFjaCBjb3JyZXNwb25kaW5nXHJcbiAgXHRcdC8vIHVwZGF0ZSBvZiB0aGUgZWxlbWVudCdzIHBvc2l0aW9uLlxyXG4gIFx0XHR0aGlzLmZpcmUoJ3ByZWRyYWcnLCBlKTtcclxuICBcdFx0c2V0UG9zaXRpb24odGhpcy5fZWxlbWVudCwgdGhpcy5fbmV3UG9zKTtcclxuXHJcbiAgXHRcdC8vIEBldmVudCBkcmFnOiBFdmVudFxyXG4gIFx0XHQvLyBGaXJlZCBjb250aW51b3VzbHkgZHVyaW5nIGRyYWdnaW5nLlxyXG4gIFx0XHR0aGlzLmZpcmUoJ2RyYWcnLCBlKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X29uVXA6IGZ1bmN0aW9uIChlKSB7XHJcbiAgXHRcdC8vIElnbm9yZSBzaW11bGF0ZWQgZXZlbnRzLCBzaW5jZSB3ZSBoYW5kbGUgYm90aCB0b3VjaCBhbmRcclxuICBcdFx0Ly8gbW91c2UgZXhwbGljaXRseTsgb3RoZXJ3aXNlIHdlIHJpc2sgZ2V0dGluZyBkdXBsaWNhdGVzIG9mXHJcbiAgXHRcdC8vIHRvdWNoIGV2ZW50cywgc2VlICM0MzE1LlxyXG4gIFx0XHQvLyBBbHNvIGlnbm9yZSB0aGUgZXZlbnQgaWYgZGlzYWJsZWQ7IHRoaXMgaGFwcGVucyBpbiBJRTExXHJcbiAgXHRcdC8vIHVuZGVyIHNvbWUgY2lyY3Vtc3RhbmNlcywgc2VlICMzNjY2LlxyXG4gIFx0XHRpZiAoZS5fc2ltdWxhdGVkIHx8ICF0aGlzLl9lbmFibGVkKSB7IHJldHVybjsgfVxyXG4gIFx0XHR0aGlzLmZpbmlzaERyYWcoKTtcclxuICBcdH0sXHJcblxyXG4gIFx0ZmluaXNoRHJhZzogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZW1vdmVDbGFzcyhkb2N1bWVudC5ib2R5LCAnbGVhZmxldC1kcmFnZ2luZycpO1xyXG5cclxuICBcdFx0aWYgKHRoaXMuX2xhc3RUYXJnZXQpIHtcclxuICBcdFx0XHRyZW1vdmVDbGFzcyh0aGlzLl9sYXN0VGFyZ2V0LCAnbGVhZmxldC1kcmFnLXRhcmdldCcpO1xyXG4gIFx0XHRcdHRoaXMuX2xhc3RUYXJnZXQgPSBudWxsO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRmb3IgKHZhciBpIGluIE1PVkUpIHtcclxuICBcdFx0XHRvZmYoZG9jdW1lbnQsIE1PVkVbaV0sIHRoaXMuX29uTW92ZSwgdGhpcyk7XHJcbiAgXHRcdFx0b2ZmKGRvY3VtZW50LCBFTkRbaV0sIHRoaXMuX29uVXAsIHRoaXMpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRlbmFibGVJbWFnZURyYWcoKTtcclxuICBcdFx0ZW5hYmxlVGV4dFNlbGVjdGlvbigpO1xyXG5cclxuICBcdFx0aWYgKHRoaXMuX21vdmVkICYmIHRoaXMuX21vdmluZykge1xyXG4gIFx0XHRcdC8vIGVuc3VyZSBkcmFnIGlzIG5vdCBmaXJlZCBhZnRlciBkcmFnZW5kXHJcbiAgXHRcdFx0Y2FuY2VsQW5pbUZyYW1lKHRoaXMuX2FuaW1SZXF1ZXN0KTtcclxuXHJcbiAgXHRcdFx0Ly8gQGV2ZW50IGRyYWdlbmQ6IERyYWdFbmRFdmVudFxyXG4gIFx0XHRcdC8vIEZpcmVkIHdoZW4gdGhlIGRyYWcgZW5kcy5cclxuICBcdFx0XHR0aGlzLmZpcmUoJ2RyYWdlbmQnLCB7XHJcbiAgXHRcdFx0XHRkaXN0YW5jZTogdGhpcy5fbmV3UG9zLmRpc3RhbmNlVG8odGhpcy5fc3RhcnRQb3MpXHJcbiAgXHRcdFx0fSk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMuX21vdmluZyA9IGZhbHNlO1xyXG4gIFx0XHREcmFnZ2FibGUuX2RyYWdnaW5nID0gZmFsc2U7XHJcbiAgXHR9XHJcblxyXG4gIH0pO1xuXG4gIC8qXHJcbiAgICogQG5hbWVzcGFjZSBMaW5lVXRpbFxyXG4gICAqXHJcbiAgICogVmFyaW91cyB1dGlsaXR5IGZ1bmN0aW9ucyBmb3IgcG9seWxpbmUgcG9pbnRzIHByb2Nlc3NpbmcsIHVzZWQgYnkgTGVhZmxldCBpbnRlcm5hbGx5IHRvIG1ha2UgcG9seWxpbmVzIGxpZ2h0bmluZy1mYXN0LlxyXG4gICAqL1xyXG5cclxuICAvLyBTaW1wbGlmeSBwb2x5bGluZSB3aXRoIHZlcnRleCByZWR1Y3Rpb24gYW5kIERvdWdsYXMtUGV1Y2tlciBzaW1wbGlmaWNhdGlvbi5cclxuICAvLyBJbXByb3ZlcyByZW5kZXJpbmcgcGVyZm9ybWFuY2UgZHJhbWF0aWNhbGx5IGJ5IGxlc3NlbmluZyB0aGUgbnVtYmVyIG9mIHBvaW50cyB0byBkcmF3LlxyXG5cclxuICAvLyBAZnVuY3Rpb24gc2ltcGxpZnkocG9pbnRzOiBQb2ludFtdLCB0b2xlcmFuY2U6IE51bWJlcik6IFBvaW50W11cclxuICAvLyBEcmFtYXRpY2FsbHkgcmVkdWNlcyB0aGUgbnVtYmVyIG9mIHBvaW50cyBpbiBhIHBvbHlsaW5lIHdoaWxlIHJldGFpbmluZ1xyXG4gIC8vIGl0cyBzaGFwZSBhbmQgcmV0dXJucyBhIG5ldyBhcnJheSBvZiBzaW1wbGlmaWVkIHBvaW50cywgdXNpbmcgdGhlXHJcbiAgLy8gW0RvdWdsYXMtUGV1Y2tlciBhbGdvcml0aG1dKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRG91Z2xhcy1QZXVja2VyX2FsZ29yaXRobSkuXHJcbiAgLy8gVXNlZCBmb3IgYSBodWdlIHBlcmZvcm1hbmNlIGJvb3N0IHdoZW4gcHJvY2Vzc2luZy9kaXNwbGF5aW5nIExlYWZsZXQgcG9seWxpbmVzIGZvclxyXG4gIC8vIGVhY2ggem9vbSBsZXZlbCBhbmQgYWxzbyByZWR1Y2luZyB2aXN1YWwgbm9pc2UuIHRvbGVyYW5jZSBhZmZlY3RzIHRoZSBhbW91bnQgb2ZcclxuICAvLyBzaW1wbGlmaWNhdGlvbiAobGVzc2VyIHZhbHVlIG1lYW5zIGhpZ2hlciBxdWFsaXR5IGJ1dCBzbG93ZXIgYW5kIHdpdGggbW9yZSBwb2ludHMpLlxyXG4gIC8vIEFsc28gcmVsZWFzZWQgYXMgYSBzZXBhcmF0ZWQgbWljcm8tbGlicmFyeSBbU2ltcGxpZnkuanNdKGh0dHA6Ly9tb3VybmVyLmdpdGh1Yi5jb20vc2ltcGxpZnktanMvKS5cclxuICBmdW5jdGlvbiBzaW1wbGlmeShwb2ludHMsIHRvbGVyYW5jZSkge1xyXG4gIFx0aWYgKCF0b2xlcmFuY2UgfHwgIXBvaW50cy5sZW5ndGgpIHtcclxuICBcdFx0cmV0dXJuIHBvaW50cy5zbGljZSgpO1xyXG4gIFx0fVxyXG5cclxuICBcdHZhciBzcVRvbGVyYW5jZSA9IHRvbGVyYW5jZSAqIHRvbGVyYW5jZTtcclxuXHJcbiAgXHQgICAgLy8gc3RhZ2UgMTogdmVydGV4IHJlZHVjdGlvblxyXG4gIFx0ICAgIHBvaW50cyA9IF9yZWR1Y2VQb2ludHMocG9pbnRzLCBzcVRvbGVyYW5jZSk7XHJcblxyXG4gIFx0ICAgIC8vIHN0YWdlIDI6IERvdWdsYXMtUGV1Y2tlciBzaW1wbGlmaWNhdGlvblxyXG4gIFx0ICAgIHBvaW50cyA9IF9zaW1wbGlmeURQKHBvaW50cywgc3FUb2xlcmFuY2UpO1xyXG5cclxuICBcdHJldHVybiBwb2ludHM7XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gcG9pbnRUb1NlZ21lbnREaXN0YW5jZShwOiBQb2ludCwgcDE6IFBvaW50LCBwMjogUG9pbnQpOiBOdW1iZXJcclxuICAvLyBSZXR1cm5zIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHBvaW50IGBwYCBhbmQgc2VnbWVudCBgcDFgIHRvIGBwMmAuXHJcbiAgZnVuY3Rpb24gcG9pbnRUb1NlZ21lbnREaXN0YW5jZShwLCBwMSwgcDIpIHtcclxuICBcdHJldHVybiBNYXRoLnNxcnQoX3NxQ2xvc2VzdFBvaW50T25TZWdtZW50KHAsIHAxLCBwMiwgdHJ1ZSkpO1xyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGNsb3Nlc3RQb2ludE9uU2VnbWVudChwOiBQb2ludCwgcDE6IFBvaW50LCBwMjogUG9pbnQpOiBOdW1iZXJcclxuICAvLyBSZXR1cm5zIHRoZSBjbG9zZXN0IHBvaW50IGZyb20gYSBwb2ludCBgcGAgb24gYSBzZWdtZW50IGBwMWAgdG8gYHAyYC5cclxuICBmdW5jdGlvbiBjbG9zZXN0UG9pbnRPblNlZ21lbnQocCwgcDEsIHAyKSB7XHJcbiAgXHRyZXR1cm4gX3NxQ2xvc2VzdFBvaW50T25TZWdtZW50KHAsIHAxLCBwMik7XHJcbiAgfVxyXG5cclxuICAvLyBEb3VnbGFzLVBldWNrZXIgc2ltcGxpZmljYXRpb24sIHNlZSBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0RvdWdsYXMtUGV1Y2tlcl9hbGdvcml0aG1cclxuICBmdW5jdGlvbiBfc2ltcGxpZnlEUChwb2ludHMsIHNxVG9sZXJhbmNlKSB7XHJcblxyXG4gIFx0dmFyIGxlbiA9IHBvaW50cy5sZW5ndGgsXHJcbiAgXHQgICAgQXJyYXlDb25zdHJ1Y3RvciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSB1bmRlZmluZWQgKyAnJyA/IFVpbnQ4QXJyYXkgOiBBcnJheSxcclxuICBcdCAgICBtYXJrZXJzID0gbmV3IEFycmF5Q29uc3RydWN0b3IobGVuKTtcclxuXHJcbiAgXHQgICAgbWFya2Vyc1swXSA9IG1hcmtlcnNbbGVuIC0gMV0gPSAxO1xyXG5cclxuICBcdF9zaW1wbGlmeURQU3RlcChwb2ludHMsIG1hcmtlcnMsIHNxVG9sZXJhbmNlLCAwLCBsZW4gLSAxKTtcclxuXHJcbiAgXHR2YXIgaSxcclxuICBcdCAgICBuZXdQb2ludHMgPSBbXTtcclxuXHJcbiAgXHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICBcdFx0aWYgKG1hcmtlcnNbaV0pIHtcclxuICBcdFx0XHRuZXdQb2ludHMucHVzaChwb2ludHNbaV0pO1xyXG4gIFx0XHR9XHJcbiAgXHR9XHJcblxyXG4gIFx0cmV0dXJuIG5ld1BvaW50cztcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIF9zaW1wbGlmeURQU3RlcChwb2ludHMsIG1hcmtlcnMsIHNxVG9sZXJhbmNlLCBmaXJzdCwgbGFzdCkge1xyXG5cclxuICBcdHZhciBtYXhTcURpc3QgPSAwLFxyXG4gIFx0aW5kZXgsIGksIHNxRGlzdDtcclxuXHJcbiAgXHRmb3IgKGkgPSBmaXJzdCArIDE7IGkgPD0gbGFzdCAtIDE7IGkrKykge1xyXG4gIFx0XHRzcURpc3QgPSBfc3FDbG9zZXN0UG9pbnRPblNlZ21lbnQocG9pbnRzW2ldLCBwb2ludHNbZmlyc3RdLCBwb2ludHNbbGFzdF0sIHRydWUpO1xyXG5cclxuICBcdFx0aWYgKHNxRGlzdCA+IG1heFNxRGlzdCkge1xyXG4gIFx0XHRcdGluZGV4ID0gaTtcclxuICBcdFx0XHRtYXhTcURpc3QgPSBzcURpc3Q7XHJcbiAgXHRcdH1cclxuICBcdH1cclxuXHJcbiAgXHRpZiAobWF4U3FEaXN0ID4gc3FUb2xlcmFuY2UpIHtcclxuICBcdFx0bWFya2Vyc1tpbmRleF0gPSAxO1xyXG5cclxuICBcdFx0X3NpbXBsaWZ5RFBTdGVwKHBvaW50cywgbWFya2Vycywgc3FUb2xlcmFuY2UsIGZpcnN0LCBpbmRleCk7XHJcbiAgXHRcdF9zaW1wbGlmeURQU3RlcChwb2ludHMsIG1hcmtlcnMsIHNxVG9sZXJhbmNlLCBpbmRleCwgbGFzdCk7XHJcbiAgXHR9XHJcbiAgfVxyXG5cclxuICAvLyByZWR1Y2UgcG9pbnRzIHRoYXQgYXJlIHRvbyBjbG9zZSB0byBlYWNoIG90aGVyIHRvIGEgc2luZ2xlIHBvaW50XHJcbiAgZnVuY3Rpb24gX3JlZHVjZVBvaW50cyhwb2ludHMsIHNxVG9sZXJhbmNlKSB7XHJcbiAgXHR2YXIgcmVkdWNlZFBvaW50cyA9IFtwb2ludHNbMF1dO1xyXG5cclxuICBcdGZvciAodmFyIGkgPSAxLCBwcmV2ID0gMCwgbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgXHRcdGlmIChfc3FEaXN0KHBvaW50c1tpXSwgcG9pbnRzW3ByZXZdKSA+IHNxVG9sZXJhbmNlKSB7XHJcbiAgXHRcdFx0cmVkdWNlZFBvaW50cy5wdXNoKHBvaW50c1tpXSk7XHJcbiAgXHRcdFx0cHJldiA9IGk7XHJcbiAgXHRcdH1cclxuICBcdH1cclxuICBcdGlmIChwcmV2IDwgbGVuIC0gMSkge1xyXG4gIFx0XHRyZWR1Y2VkUG9pbnRzLnB1c2gocG9pbnRzW2xlbiAtIDFdKTtcclxuICBcdH1cclxuICBcdHJldHVybiByZWR1Y2VkUG9pbnRzO1xyXG4gIH1cclxuXHJcbiAgdmFyIF9sYXN0Q29kZTtcclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGNsaXBTZWdtZW50KGE6IFBvaW50LCBiOiBQb2ludCwgYm91bmRzOiBCb3VuZHMsIHVzZUxhc3RDb2RlPzogQm9vbGVhbiwgcm91bmQ/OiBCb29sZWFuKTogUG9pbnRbXXxCb29sZWFuXHJcbiAgLy8gQ2xpcHMgdGhlIHNlZ21lbnQgYSB0byBiIGJ5IHJlY3Rhbmd1bGFyIGJvdW5kcyB3aXRoIHRoZVxyXG4gIC8vIFtDb2hlbi1TdXRoZXJsYW5kIGFsZ29yaXRobV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29oZW4lRTIlODAlOTNTdXRoZXJsYW5kX2FsZ29yaXRobSlcclxuICAvLyAobW9kaWZ5aW5nIHRoZSBzZWdtZW50IHBvaW50cyBkaXJlY3RseSEpLiBVc2VkIGJ5IExlYWZsZXQgdG8gb25seSBzaG93IHBvbHlsaW5lXHJcbiAgLy8gcG9pbnRzIHRoYXQgYXJlIG9uIHRoZSBzY3JlZW4gb3IgbmVhciwgaW5jcmVhc2luZyBwZXJmb3JtYW5jZS5cclxuICBmdW5jdGlvbiBjbGlwU2VnbWVudChhLCBiLCBib3VuZHMsIHVzZUxhc3RDb2RlLCByb3VuZCkge1xyXG4gIFx0dmFyIGNvZGVBID0gdXNlTGFzdENvZGUgPyBfbGFzdENvZGUgOiBfZ2V0Qml0Q29kZShhLCBib3VuZHMpLFxyXG4gIFx0ICAgIGNvZGVCID0gX2dldEJpdENvZGUoYiwgYm91bmRzKSxcclxuXHJcbiAgXHQgICAgY29kZU91dCwgcCwgbmV3Q29kZTtcclxuXHJcbiAgXHQgICAgLy8gc2F2ZSAybmQgY29kZSB0byBhdm9pZCBjYWxjdWxhdGluZyBpdCBvbiB0aGUgbmV4dCBzZWdtZW50XHJcbiAgXHQgICAgX2xhc3RDb2RlID0gY29kZUI7XHJcblxyXG4gIFx0d2hpbGUgKHRydWUpIHtcclxuICBcdFx0Ly8gaWYgYSxiIGlzIGluc2lkZSB0aGUgY2xpcCB3aW5kb3cgKHRyaXZpYWwgYWNjZXB0KVxyXG4gIFx0XHRpZiAoIShjb2RlQSB8IGNvZGVCKSkge1xyXG4gIFx0XHRcdHJldHVybiBbYSwgYl07XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdC8vIGlmIGEsYiBpcyBvdXRzaWRlIHRoZSBjbGlwIHdpbmRvdyAodHJpdmlhbCByZWplY3QpXHJcbiAgXHRcdGlmIChjb2RlQSAmIGNvZGVCKSB7XHJcbiAgXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHQvLyBvdGhlciBjYXNlc1xyXG4gIFx0XHRjb2RlT3V0ID0gY29kZUEgfHwgY29kZUI7XHJcbiAgXHRcdHAgPSBfZ2V0RWRnZUludGVyc2VjdGlvbihhLCBiLCBjb2RlT3V0LCBib3VuZHMsIHJvdW5kKTtcclxuICBcdFx0bmV3Q29kZSA9IF9nZXRCaXRDb2RlKHAsIGJvdW5kcyk7XHJcblxyXG4gIFx0XHRpZiAoY29kZU91dCA9PT0gY29kZUEpIHtcclxuICBcdFx0XHRhID0gcDtcclxuICBcdFx0XHRjb2RlQSA9IG5ld0NvZGU7XHJcbiAgXHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0YiA9IHA7XHJcbiAgXHRcdFx0Y29kZUIgPSBuZXdDb2RlO1xyXG4gIFx0XHR9XHJcbiAgXHR9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBfZ2V0RWRnZUludGVyc2VjdGlvbihhLCBiLCBjb2RlLCBib3VuZHMsIHJvdW5kKSB7XHJcbiAgXHR2YXIgZHggPSBiLnggLSBhLngsXHJcbiAgXHQgICAgZHkgPSBiLnkgLSBhLnksXHJcbiAgXHQgICAgbWluID0gYm91bmRzLm1pbixcclxuICBcdCAgICBtYXggPSBib3VuZHMubWF4LFxyXG4gIFx0ICAgIHgsIHk7XHJcblxyXG4gIFx0aWYgKGNvZGUgJiA4KSB7IC8vIHRvcFxyXG4gIFx0XHR4ID0gYS54ICsgZHggKiAobWF4LnkgLSBhLnkpIC8gZHk7XHJcbiAgXHRcdHkgPSBtYXgueTtcclxuXHJcbiAgXHR9IGVsc2UgaWYgKGNvZGUgJiA0KSB7IC8vIGJvdHRvbVxyXG4gIFx0XHR4ID0gYS54ICsgZHggKiAobWluLnkgLSBhLnkpIC8gZHk7XHJcbiAgXHRcdHkgPSBtaW4ueTtcclxuXHJcbiAgXHR9IGVsc2UgaWYgKGNvZGUgJiAyKSB7IC8vIHJpZ2h0XHJcbiAgXHRcdHggPSBtYXgueDtcclxuICBcdFx0eSA9IGEueSArIGR5ICogKG1heC54IC0gYS54KSAvIGR4O1xyXG5cclxuICBcdH0gZWxzZSBpZiAoY29kZSAmIDEpIHsgLy8gbGVmdFxyXG4gIFx0XHR4ID0gbWluLng7XHJcbiAgXHRcdHkgPSBhLnkgKyBkeSAqIChtaW4ueCAtIGEueCkgLyBkeDtcclxuICBcdH1cclxuXHJcbiAgXHRyZXR1cm4gbmV3IFBvaW50KHgsIHksIHJvdW5kKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIF9nZXRCaXRDb2RlKHAsIGJvdW5kcykge1xyXG4gIFx0dmFyIGNvZGUgPSAwO1xyXG5cclxuICBcdGlmIChwLnggPCBib3VuZHMubWluLngpIHsgLy8gbGVmdFxyXG4gIFx0XHRjb2RlIHw9IDE7XHJcbiAgXHR9IGVsc2UgaWYgKHAueCA+IGJvdW5kcy5tYXgueCkgeyAvLyByaWdodFxyXG4gIFx0XHRjb2RlIHw9IDI7XHJcbiAgXHR9XHJcblxyXG4gIFx0aWYgKHAueSA8IGJvdW5kcy5taW4ueSkgeyAvLyBib3R0b21cclxuICBcdFx0Y29kZSB8PSA0O1xyXG4gIFx0fSBlbHNlIGlmIChwLnkgPiBib3VuZHMubWF4LnkpIHsgLy8gdG9wXHJcbiAgXHRcdGNvZGUgfD0gODtcclxuICBcdH1cclxuXHJcbiAgXHRyZXR1cm4gY29kZTtcclxuICB9XHJcblxyXG4gIC8vIHNxdWFyZSBkaXN0YW5jZSAodG8gYXZvaWQgdW5uZWNlc3NhcnkgTWF0aC5zcXJ0IGNhbGxzKVxyXG4gIGZ1bmN0aW9uIF9zcURpc3QocDEsIHAyKSB7XHJcbiAgXHR2YXIgZHggPSBwMi54IC0gcDEueCxcclxuICBcdCAgICBkeSA9IHAyLnkgLSBwMS55O1xyXG4gIFx0cmV0dXJuIGR4ICogZHggKyBkeSAqIGR5O1xyXG4gIH1cclxuXHJcbiAgLy8gcmV0dXJuIGNsb3Nlc3QgcG9pbnQgb24gc2VnbWVudCBvciBkaXN0YW5jZSB0byB0aGF0IHBvaW50XHJcbiAgZnVuY3Rpb24gX3NxQ2xvc2VzdFBvaW50T25TZWdtZW50KHAsIHAxLCBwMiwgc3FEaXN0KSB7XHJcbiAgXHR2YXIgeCA9IHAxLngsXHJcbiAgXHQgICAgeSA9IHAxLnksXHJcbiAgXHQgICAgZHggPSBwMi54IC0geCxcclxuICBcdCAgICBkeSA9IHAyLnkgLSB5LFxyXG4gIFx0ICAgIGRvdCA9IGR4ICogZHggKyBkeSAqIGR5LFxyXG4gIFx0ICAgIHQ7XHJcblxyXG4gIFx0aWYgKGRvdCA+IDApIHtcclxuICBcdFx0dCA9ICgocC54IC0geCkgKiBkeCArIChwLnkgLSB5KSAqIGR5KSAvIGRvdDtcclxuXHJcbiAgXHRcdGlmICh0ID4gMSkge1xyXG4gIFx0XHRcdHggPSBwMi54O1xyXG4gIFx0XHRcdHkgPSBwMi55O1xyXG4gIFx0XHR9IGVsc2UgaWYgKHQgPiAwKSB7XHJcbiAgXHRcdFx0eCArPSBkeCAqIHQ7XHJcbiAgXHRcdFx0eSArPSBkeSAqIHQ7XHJcbiAgXHRcdH1cclxuICBcdH1cclxuXHJcbiAgXHRkeCA9IHAueCAtIHg7XHJcbiAgXHRkeSA9IHAueSAtIHk7XHJcblxyXG4gIFx0cmV0dXJuIHNxRGlzdCA/IGR4ICogZHggKyBkeSAqIGR5IDogbmV3IFBvaW50KHgsIHkpO1xyXG4gIH1cclxuXHJcblxyXG4gIC8vIEBmdW5jdGlvbiBpc0ZsYXQobGF0bG5nczogTGF0TG5nW10pOiBCb29sZWFuXHJcbiAgLy8gUmV0dXJucyB0cnVlIGlmIGBsYXRsbmdzYCBpcyBhIGZsYXQgYXJyYXksIGZhbHNlIGlzIG5lc3RlZC5cclxuICBmdW5jdGlvbiBpc0ZsYXQobGF0bG5ncykge1xyXG4gIFx0cmV0dXJuICFpc0FycmF5KGxhdGxuZ3NbMF0pIHx8ICh0eXBlb2YgbGF0bG5nc1swXVswXSAhPT0gJ29iamVjdCcgJiYgdHlwZW9mIGxhdGxuZ3NbMF1bMF0gIT09ICd1bmRlZmluZWQnKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIF9mbGF0KGxhdGxuZ3MpIHtcclxuICBcdGNvbnNvbGUud2FybignRGVwcmVjYXRlZCB1c2Ugb2YgX2ZsYXQsIHBsZWFzZSB1c2UgTC5MaW5lVXRpbC5pc0ZsYXQgaW5zdGVhZC4nKTtcclxuICBcdHJldHVybiBpc0ZsYXQobGF0bG5ncyk7XHJcbiAgfVxuXG4gIHZhciBMaW5lVXRpbCA9ICh7XG4gICAgc2ltcGxpZnk6IHNpbXBsaWZ5LFxuICAgIHBvaW50VG9TZWdtZW50RGlzdGFuY2U6IHBvaW50VG9TZWdtZW50RGlzdGFuY2UsXG4gICAgY2xvc2VzdFBvaW50T25TZWdtZW50OiBjbG9zZXN0UG9pbnRPblNlZ21lbnQsXG4gICAgY2xpcFNlZ21lbnQ6IGNsaXBTZWdtZW50LFxuICAgIF9nZXRFZGdlSW50ZXJzZWN0aW9uOiBfZ2V0RWRnZUludGVyc2VjdGlvbixcbiAgICBfZ2V0Qml0Q29kZTogX2dldEJpdENvZGUsXG4gICAgX3NxQ2xvc2VzdFBvaW50T25TZWdtZW50OiBfc3FDbG9zZXN0UG9pbnRPblNlZ21lbnQsXG4gICAgaXNGbGF0OiBpc0ZsYXQsXG4gICAgX2ZsYXQ6IF9mbGF0XG4gIH0pO1xuXG4gIC8qXHJcbiAgICogQG5hbWVzcGFjZSBQb2x5VXRpbFxyXG4gICAqIFZhcmlvdXMgdXRpbGl0eSBmdW5jdGlvbnMgZm9yIHBvbHlnb24gZ2VvbWV0cmllcy5cclxuICAgKi9cclxuXHJcbiAgLyogQGZ1bmN0aW9uIGNsaXBQb2x5Z29uKHBvaW50czogUG9pbnRbXSwgYm91bmRzOiBCb3VuZHMsIHJvdW5kPzogQm9vbGVhbik6IFBvaW50W11cclxuICAgKiBDbGlwcyB0aGUgcG9seWdvbiBnZW9tZXRyeSBkZWZpbmVkIGJ5IHRoZSBnaXZlbiBgcG9pbnRzYCBieSB0aGUgZ2l2ZW4gYm91bmRzICh1c2luZyB0aGUgW1N1dGhlcmxhbmQtSG9kZ21hbiBhbGdvcml0aG1dKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1N1dGhlcmxhbmQlRTIlODAlOTNIb2RnbWFuX2FsZ29yaXRobSkpLlxyXG4gICAqIFVzZWQgYnkgTGVhZmxldCB0byBvbmx5IHNob3cgcG9seWdvbiBwb2ludHMgdGhhdCBhcmUgb24gdGhlIHNjcmVlbiBvciBuZWFyLCBpbmNyZWFzaW5nXHJcbiAgICogcGVyZm9ybWFuY2UuIE5vdGUgdGhhdCBwb2x5Z29uIHBvaW50cyBuZWVkcyBkaWZmZXJlbnQgYWxnb3JpdGhtIGZvciBjbGlwcGluZ1xyXG4gICAqIHRoYW4gcG9seWxpbmUsIHNvIHRoZXJlJ3MgYSBzZXBhcmF0ZSBtZXRob2QgZm9yIGl0LlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGNsaXBQb2x5Z29uKHBvaW50cywgYm91bmRzLCByb3VuZCkge1xyXG4gIFx0dmFyIGNsaXBwZWRQb2ludHMsXHJcbiAgXHQgICAgZWRnZXMgPSBbMSwgNCwgMiwgOF0sXHJcbiAgXHQgICAgaSwgaiwgayxcclxuICBcdCAgICBhLCBiLFxyXG4gIFx0ICAgIGxlbiwgZWRnZSwgcDtcclxuXHJcbiAgXHRmb3IgKGkgPSAwLCBsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICBcdFx0cG9pbnRzW2ldLl9jb2RlID0gX2dldEJpdENvZGUocG9pbnRzW2ldLCBib3VuZHMpO1xyXG4gIFx0fVxyXG5cclxuICBcdC8vIGZvciBlYWNoIGVkZ2UgKGxlZnQsIGJvdHRvbSwgcmlnaHQsIHRvcClcclxuICBcdGZvciAoayA9IDA7IGsgPCA0OyBrKyspIHtcclxuICBcdFx0ZWRnZSA9IGVkZ2VzW2tdO1xyXG4gIFx0XHRjbGlwcGVkUG9pbnRzID0gW107XHJcblxyXG4gIFx0XHRmb3IgKGkgPSAwLCBsZW4gPSBwb2ludHMubGVuZ3RoLCBqID0gbGVuIC0gMTsgaSA8IGxlbjsgaiA9IGkrKykge1xyXG4gIFx0XHRcdGEgPSBwb2ludHNbaV07XHJcbiAgXHRcdFx0YiA9IHBvaW50c1tqXTtcclxuXHJcbiAgXHRcdFx0Ly8gaWYgYSBpcyBpbnNpZGUgdGhlIGNsaXAgd2luZG93XHJcbiAgXHRcdFx0aWYgKCEoYS5fY29kZSAmIGVkZ2UpKSB7XHJcbiAgXHRcdFx0XHQvLyBpZiBiIGlzIG91dHNpZGUgdGhlIGNsaXAgd2luZG93IChhLT5iIGdvZXMgb3V0IG9mIHNjcmVlbilcclxuICBcdFx0XHRcdGlmIChiLl9jb2RlICYgZWRnZSkge1xyXG4gIFx0XHRcdFx0XHRwID0gX2dldEVkZ2VJbnRlcnNlY3Rpb24oYiwgYSwgZWRnZSwgYm91bmRzLCByb3VuZCk7XHJcbiAgXHRcdFx0XHRcdHAuX2NvZGUgPSBfZ2V0Qml0Q29kZShwLCBib3VuZHMpO1xyXG4gIFx0XHRcdFx0XHRjbGlwcGVkUG9pbnRzLnB1c2gocCk7XHJcbiAgXHRcdFx0XHR9XHJcbiAgXHRcdFx0XHRjbGlwcGVkUG9pbnRzLnB1c2goYSk7XHJcblxyXG4gIFx0XHRcdC8vIGVsc2UgaWYgYiBpcyBpbnNpZGUgdGhlIGNsaXAgd2luZG93IChhLT5iIGVudGVycyB0aGUgc2NyZWVuKVxyXG4gIFx0XHRcdH0gZWxzZSBpZiAoIShiLl9jb2RlICYgZWRnZSkpIHtcclxuICBcdFx0XHRcdHAgPSBfZ2V0RWRnZUludGVyc2VjdGlvbihiLCBhLCBlZGdlLCBib3VuZHMsIHJvdW5kKTtcclxuICBcdFx0XHRcdHAuX2NvZGUgPSBfZ2V0Qml0Q29kZShwLCBib3VuZHMpO1xyXG4gIFx0XHRcdFx0Y2xpcHBlZFBvaW50cy5wdXNoKHApO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0fVxyXG4gIFx0XHRwb2ludHMgPSBjbGlwcGVkUG9pbnRzO1xyXG4gIFx0fVxyXG5cclxuICBcdHJldHVybiBwb2ludHM7XHJcbiAgfVxuXG4gIHZhciBQb2x5VXRpbCA9ICh7XG4gICAgY2xpcFBvbHlnb246IGNsaXBQb2x5Z29uXG4gIH0pO1xuXG4gIC8qXHJcbiAgICogQG5hbWVzcGFjZSBQcm9qZWN0aW9uXHJcbiAgICogQHNlY3Rpb25cclxuICAgKiBMZWFmbGV0IGNvbWVzIHdpdGggYSBzZXQgb2YgYWxyZWFkeSBkZWZpbmVkIFByb2plY3Rpb25zIG91dCBvZiB0aGUgYm94OlxyXG4gICAqXHJcbiAgICogQHByb2plY3Rpb24gTC5Qcm9qZWN0aW9uLkxvbkxhdFxyXG4gICAqXHJcbiAgICogRXF1aXJlY3Rhbmd1bGFyLCBvciBQbGF0ZSBDYXJyZWUgcHJvamVjdGlvbiDigJQgdGhlIG1vc3Qgc2ltcGxlIHByb2plY3Rpb24sXHJcbiAgICogbW9zdGx5IHVzZWQgYnkgR0lTIGVudGh1c2lhc3RzLiBEaXJlY3RseSBtYXBzIGB4YCBhcyBsb25naXR1ZGUsIGFuZCBgeWAgYXNcclxuICAgKiBsYXRpdHVkZS4gQWxzbyBzdWl0YWJsZSBmb3IgZmxhdCB3b3JsZHMsIGUuZy4gZ2FtZSBtYXBzLiBVc2VkIGJ5IHRoZVxyXG4gICAqIGBFUFNHOjQzMjZgIGFuZCBgU2ltcGxlYCBDUlMuXHJcbiAgICovXHJcblxyXG4gIHZhciBMb25MYXQgPSB7XHJcbiAgXHRwcm9qZWN0OiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcbiAgXHRcdHJldHVybiBuZXcgUG9pbnQobGF0bG5nLmxuZywgbGF0bG5nLmxhdCk7XHJcbiAgXHR9LFxyXG5cclxuICBcdHVucHJvamVjdDogZnVuY3Rpb24gKHBvaW50KSB7XHJcbiAgXHRcdHJldHVybiBuZXcgTGF0TG5nKHBvaW50LnksIHBvaW50LngpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRib3VuZHM6IG5ldyBCb3VuZHMoWy0xODAsIC05MF0sIFsxODAsIDkwXSlcclxuICB9O1xuXG4gIC8qXHJcbiAgICogQG5hbWVzcGFjZSBQcm9qZWN0aW9uXHJcbiAgICogQHByb2plY3Rpb24gTC5Qcm9qZWN0aW9uLk1lcmNhdG9yXHJcbiAgICpcclxuICAgKiBFbGxpcHRpY2FsIE1lcmNhdG9yIHByb2plY3Rpb24g4oCUIG1vcmUgY29tcGxleCB0aGFuIFNwaGVyaWNhbCBNZXJjYXRvci4gQXNzdW1lcyB0aGF0IEVhcnRoIGlzIGFuIGVsbGlwc29pZC4gVXNlZCBieSB0aGUgRVBTRzozMzk1IENSUy5cclxuICAgKi9cclxuXHJcbiAgdmFyIE1lcmNhdG9yID0ge1xyXG4gIFx0UjogNjM3ODEzNyxcclxuICBcdFJfTUlOT1I6IDYzNTY3NTIuMzE0MjQ1MTc5LFxyXG5cclxuICBcdGJvdW5kczogbmV3IEJvdW5kcyhbLTIwMDM3NTA4LjM0Mjc5LCAtMTU0OTY1NzAuNzM5NzJdLCBbMjAwMzc1MDguMzQyNzksIDE4NzY0NjU2LjIzMTM4XSksXHJcblxyXG4gIFx0cHJvamVjdDogZnVuY3Rpb24gKGxhdGxuZykge1xyXG4gIFx0XHR2YXIgZCA9IE1hdGguUEkgLyAxODAsXHJcbiAgXHRcdCAgICByID0gdGhpcy5SLFxyXG4gIFx0XHQgICAgeSA9IGxhdGxuZy5sYXQgKiBkLFxyXG4gIFx0XHQgICAgdG1wID0gdGhpcy5SX01JTk9SIC8gcixcclxuICBcdFx0ICAgIGUgPSBNYXRoLnNxcnQoMSAtIHRtcCAqIHRtcCksXHJcbiAgXHRcdCAgICBjb24gPSBlICogTWF0aC5zaW4oeSk7XHJcblxyXG4gIFx0XHR2YXIgdHMgPSBNYXRoLnRhbihNYXRoLlBJIC8gNCAtIHkgLyAyKSAvIE1hdGgucG93KCgxIC0gY29uKSAvICgxICsgY29uKSwgZSAvIDIpO1xyXG4gIFx0XHR5ID0gLXIgKiBNYXRoLmxvZyhNYXRoLm1heCh0cywgMUUtMTApKTtcclxuXHJcbiAgXHRcdHJldHVybiBuZXcgUG9pbnQobGF0bG5nLmxuZyAqIGQgKiByLCB5KTtcclxuICBcdH0sXHJcblxyXG4gIFx0dW5wcm9qZWN0OiBmdW5jdGlvbiAocG9pbnQpIHtcclxuICBcdFx0dmFyIGQgPSAxODAgLyBNYXRoLlBJLFxyXG4gIFx0XHQgICAgciA9IHRoaXMuUixcclxuICBcdFx0ICAgIHRtcCA9IHRoaXMuUl9NSU5PUiAvIHIsXHJcbiAgXHRcdCAgICBlID0gTWF0aC5zcXJ0KDEgLSB0bXAgKiB0bXApLFxyXG4gIFx0XHQgICAgdHMgPSBNYXRoLmV4cCgtcG9pbnQueSAvIHIpLFxyXG4gIFx0XHQgICAgcGhpID0gTWF0aC5QSSAvIDIgLSAyICogTWF0aC5hdGFuKHRzKTtcclxuXHJcbiAgXHRcdGZvciAodmFyIGkgPSAwLCBkcGhpID0gMC4xLCBjb247IGkgPCAxNSAmJiBNYXRoLmFicyhkcGhpKSA+IDFlLTc7IGkrKykge1xyXG4gIFx0XHRcdGNvbiA9IGUgKiBNYXRoLnNpbihwaGkpO1xyXG4gIFx0XHRcdGNvbiA9IE1hdGgucG93KCgxIC0gY29uKSAvICgxICsgY29uKSwgZSAvIDIpO1xyXG4gIFx0XHRcdGRwaGkgPSBNYXRoLlBJIC8gMiAtIDIgKiBNYXRoLmF0YW4odHMgKiBjb24pIC0gcGhpO1xyXG4gIFx0XHRcdHBoaSArPSBkcGhpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZXR1cm4gbmV3IExhdExuZyhwaGkgKiBkLCBwb2ludC54ICogZCAvIHIpO1xyXG4gIFx0fVxyXG4gIH07XG5cbiAgLypcbiAgICogQGNsYXNzIFByb2plY3Rpb25cblxuICAgKiBBbiBvYmplY3Qgd2l0aCBtZXRob2RzIGZvciBwcm9qZWN0aW5nIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlcyBvZiB0aGUgd29ybGQgb250b1xuICAgKiBhIGZsYXQgc3VyZmFjZSAoYW5kIGJhY2spLiBTZWUgW01hcCBwcm9qZWN0aW9uXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01hcF9wcm9qZWN0aW9uKS5cblxuICAgKiBAcHJvcGVydHkgYm91bmRzOiBCb3VuZHNcbiAgICogVGhlIGJvdW5kcyAoc3BlY2lmaWVkIGluIENSUyB1bml0cykgd2hlcmUgdGhlIHByb2plY3Rpb24gaXMgdmFsaWRcblxuICAgKiBAbWV0aG9kIHByb2plY3QobGF0bG5nOiBMYXRMbmcpOiBQb2ludFxuICAgKiBQcm9qZWN0cyBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZXMgaW50byBhIDJEIHBvaW50LlxuICAgKiBPbmx5IGFjY2VwdHMgYWN0dWFsIGBMLkxhdExuZ2AgaW5zdGFuY2VzLCBub3QgYXJyYXlzLlxuXG4gICAqIEBtZXRob2QgdW5wcm9qZWN0KHBvaW50OiBQb2ludCk6IExhdExuZ1xuICAgKiBUaGUgaW52ZXJzZSBvZiBgcHJvamVjdGAuIFByb2plY3RzIGEgMkQgcG9pbnQgaW50byBhIGdlb2dyYXBoaWNhbCBsb2NhdGlvbi5cbiAgICogT25seSBhY2NlcHRzIGFjdHVhbCBgTC5Qb2ludGAgaW5zdGFuY2VzLCBub3QgYXJyYXlzLlxuXG4gICAqIE5vdGUgdGhhdCB0aGUgcHJvamVjdGlvbiBpbnN0YW5jZXMgZG8gbm90IGluaGVyaXQgZnJvbSBMZWFmbGV0J3MgYENsYXNzYCBvYmplY3QsXG4gICAqIGFuZCBjYW4ndCBiZSBpbnN0YW50aWF0ZWQuIEFsc28sIG5ldyBjbGFzc2VzIGNhbid0IGluaGVyaXQgZnJvbSB0aGVtLFxuICAgKiBhbmQgbWV0aG9kcyBjYW4ndCBiZSBhZGRlZCB0byB0aGVtIHdpdGggdGhlIGBpbmNsdWRlYCBmdW5jdGlvbi5cblxuICAgKi9cblxuICB2YXIgaW5kZXggPSAoe1xuICAgIExvbkxhdDogTG9uTGF0LFxuICAgIE1lcmNhdG9yOiBNZXJjYXRvcixcbiAgICBTcGhlcmljYWxNZXJjYXRvcjogU3BoZXJpY2FsTWVyY2F0b3JcbiAgfSk7XG5cbiAgLypcclxuICAgKiBAbmFtZXNwYWNlIENSU1xyXG4gICAqIEBjcnMgTC5DUlMuRVBTRzMzOTVcclxuICAgKlxyXG4gICAqIFJhcmVseSB1c2VkIGJ5IHNvbWUgY29tbWVyY2lhbCB0aWxlIHByb3ZpZGVycy4gVXNlcyBFbGxpcHRpY2FsIE1lcmNhdG9yIHByb2plY3Rpb24uXHJcbiAgICovXHJcbiAgdmFyIEVQU0czMzk1ID0gZXh0ZW5kKHt9LCBFYXJ0aCwge1xyXG4gIFx0Y29kZTogJ0VQU0c6MzM5NScsXHJcbiAgXHRwcm9qZWN0aW9uOiBNZXJjYXRvcixcclxuXHJcbiAgXHR0cmFuc2Zvcm1hdGlvbjogKGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dmFyIHNjYWxlID0gMC41IC8gKE1hdGguUEkgKiBNZXJjYXRvci5SKTtcclxuICBcdFx0cmV0dXJuIHRvVHJhbnNmb3JtYXRpb24oc2NhbGUsIDAuNSwgLXNjYWxlLCAwLjUpO1xyXG4gIFx0fSgpKVxyXG4gIH0pO1xuXG4gIC8qXHJcbiAgICogQG5hbWVzcGFjZSBDUlNcclxuICAgKiBAY3JzIEwuQ1JTLkVQU0c0MzI2XHJcbiAgICpcclxuICAgKiBBIGNvbW1vbiBDUlMgYW1vbmcgR0lTIGVudGh1c2lhc3RzLiBVc2VzIHNpbXBsZSBFcXVpcmVjdGFuZ3VsYXIgcHJvamVjdGlvbi5cclxuICAgKlxyXG4gICAqIExlYWZsZXQgMS4wLnggY29tcGxpZXMgd2l0aCB0aGUgW1RNUyBjb29yZGluYXRlIHNjaGVtZSBmb3IgRVBTRzo0MzI2XShodHRwczovL3dpa2kub3NnZW8ub3JnL3dpa2kvVGlsZV9NYXBfU2VydmljZV9TcGVjaWZpY2F0aW9uI2dsb2JhbC1nZW9kZXRpYyksXHJcbiAgICogd2hpY2ggaXMgYSBicmVha2luZyBjaGFuZ2UgZnJvbSAwLjcueCBiZWhhdmlvdXIuICBJZiB5b3UgYXJlIHVzaW5nIGEgYFRpbGVMYXllcmBcclxuICAgKiB3aXRoIHRoaXMgQ1JTLCBlbnN1cmUgdGhhdCB0aGVyZSBhcmUgdHdvIDI1NngyNTYgcGl4ZWwgdGlsZXMgY292ZXJpbmcgdGhlXHJcbiAgICogd2hvbGUgZWFydGggYXQgem9vbSBsZXZlbCB6ZXJvLCBhbmQgdGhhdCB0aGUgdGlsZSBjb29yZGluYXRlIG9yaWdpbiBpcyAoLTE4MCwrOTApLFxyXG4gICAqIG9yICgtMTgwLC05MCkgZm9yIGBUaWxlTGF5ZXJgcyB3aXRoIFt0aGUgYHRtc2Agb3B0aW9uXSgjdGlsZWxheWVyLXRtcykgc2V0LlxyXG4gICAqL1xyXG5cclxuICB2YXIgRVBTRzQzMjYgPSBleHRlbmQoe30sIEVhcnRoLCB7XHJcbiAgXHRjb2RlOiAnRVBTRzo0MzI2JyxcclxuICBcdHByb2plY3Rpb246IExvbkxhdCxcclxuICBcdHRyYW5zZm9ybWF0aW9uOiB0b1RyYW5zZm9ybWF0aW9uKDEgLyAxODAsIDEsIC0xIC8gMTgwLCAwLjUpXHJcbiAgfSk7XG5cbiAgLypcbiAgICogQG5hbWVzcGFjZSBDUlNcbiAgICogQGNycyBMLkNSUy5TaW1wbGVcbiAgICpcbiAgICogQSBzaW1wbGUgQ1JTIHRoYXQgbWFwcyBsb25naXR1ZGUgYW5kIGxhdGl0dWRlIGludG8gYHhgIGFuZCBgeWAgZGlyZWN0bHkuXG4gICAqIE1heSBiZSB1c2VkIGZvciBtYXBzIG9mIGZsYXQgc3VyZmFjZXMgKGUuZy4gZ2FtZSBtYXBzKS4gTm90ZSB0aGF0IHRoZSBgeWBcbiAgICogYXhpcyBzaG91bGQgc3RpbGwgYmUgaW52ZXJ0ZWQgKGdvaW5nIGZyb20gYm90dG9tIHRvIHRvcCkuIGBkaXN0YW5jZSgpYCByZXR1cm5zXG4gICAqIHNpbXBsZSBldWNsaWRlYW4gZGlzdGFuY2UuXG4gICAqL1xuXG4gIHZhciBTaW1wbGUgPSBleHRlbmQoe30sIENSUywge1xuICBcdHByb2plY3Rpb246IExvbkxhdCxcbiAgXHR0cmFuc2Zvcm1hdGlvbjogdG9UcmFuc2Zvcm1hdGlvbigxLCAwLCAtMSwgMCksXG5cbiAgXHRzY2FsZTogZnVuY3Rpb24gKHpvb20pIHtcbiAgXHRcdHJldHVybiBNYXRoLnBvdygyLCB6b29tKTtcbiAgXHR9LFxuXG4gIFx0em9vbTogZnVuY3Rpb24gKHNjYWxlKSB7XG4gIFx0XHRyZXR1cm4gTWF0aC5sb2coc2NhbGUpIC8gTWF0aC5MTjI7XG4gIFx0fSxcblxuICBcdGRpc3RhbmNlOiBmdW5jdGlvbiAobGF0bG5nMSwgbGF0bG5nMikge1xuICBcdFx0dmFyIGR4ID0gbGF0bG5nMi5sbmcgLSBsYXRsbmcxLmxuZyxcbiAgXHRcdCAgICBkeSA9IGxhdGxuZzIubGF0IC0gbGF0bG5nMS5sYXQ7XG5cbiAgXHRcdHJldHVybiBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICBcdH0sXG5cbiAgXHRpbmZpbml0ZTogdHJ1ZVxuICB9KTtcblxuICBDUlMuRWFydGggPSBFYXJ0aDtcbiAgQ1JTLkVQU0czMzk1ID0gRVBTRzMzOTU7XG4gIENSUy5FUFNHMzg1NyA9IEVQU0czODU3O1xuICBDUlMuRVBTRzkwMDkxMyA9IEVQU0c5MDA5MTM7XG4gIENSUy5FUFNHNDMyNiA9IEVQU0c0MzI2O1xuICBDUlMuU2ltcGxlID0gU2ltcGxlO1xuXG4gIC8qXG4gICAqIEBjbGFzcyBMYXllclxuICAgKiBAaW5oZXJpdHMgRXZlbnRlZFxuICAgKiBAYWthIEwuTGF5ZXJcbiAgICogQGFrYSBJTGF5ZXJcbiAgICpcbiAgICogQSBzZXQgb2YgbWV0aG9kcyBmcm9tIHRoZSBMYXllciBiYXNlIGNsYXNzIHRoYXQgYWxsIExlYWZsZXQgbGF5ZXJzIHVzZS5cbiAgICogSW5oZXJpdHMgYWxsIG1ldGhvZHMsIG9wdGlvbnMgYW5kIGV2ZW50cyBmcm9tIGBMLkV2ZW50ZWRgLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBgYGBqc1xuICAgKiB2YXIgbGF5ZXIgPSBMLm1hcmtlcihsYXRsbmcpLmFkZFRvKG1hcCk7XG4gICAqIGxheWVyLmFkZFRvKG1hcCk7XG4gICAqIGxheWVyLnJlbW92ZSgpO1xuICAgKiBgYGBcbiAgICpcbiAgICogQGV2ZW50IGFkZDogRXZlbnRcbiAgICogRmlyZWQgYWZ0ZXIgdGhlIGxheWVyIGlzIGFkZGVkIHRvIGEgbWFwXG4gICAqXG4gICAqIEBldmVudCByZW1vdmU6IEV2ZW50XG4gICAqIEZpcmVkIGFmdGVyIHRoZSBsYXllciBpcyByZW1vdmVkIGZyb20gYSBtYXBcbiAgICovXG5cblxuICB2YXIgTGF5ZXIgPSBFdmVudGVkLmV4dGVuZCh7XG5cbiAgXHQvLyBDbGFzc2VzIGV4dGVuZGluZyBgTC5MYXllcmAgd2lsbCBpbmhlcml0IHRoZSBmb2xsb3dpbmcgb3B0aW9uczpcbiAgXHRvcHRpb25zOiB7XG4gIFx0XHQvLyBAb3B0aW9uIHBhbmU6IFN0cmluZyA9ICdvdmVybGF5UGFuZSdcbiAgXHRcdC8vIEJ5IGRlZmF1bHQgdGhlIGxheWVyIHdpbGwgYmUgYWRkZWQgdG8gdGhlIG1hcCdzIFtvdmVybGF5IHBhbmVdKCNtYXAtb3ZlcmxheXBhbmUpLiBPdmVycmlkaW5nIHRoaXMgb3B0aW9uIHdpbGwgY2F1c2UgdGhlIGxheWVyIHRvIGJlIHBsYWNlZCBvbiBhbm90aGVyIHBhbmUgYnkgZGVmYXVsdC5cbiAgXHRcdHBhbmU6ICdvdmVybGF5UGFuZScsXG5cbiAgXHRcdC8vIEBvcHRpb24gYXR0cmlidXRpb246IFN0cmluZyA9IG51bGxcbiAgXHRcdC8vIFN0cmluZyB0byBiZSBzaG93biBpbiB0aGUgYXR0cmlidXRpb24gY29udHJvbCwgZS5nLiBcIsKpIE9wZW5TdHJlZXRNYXAgY29udHJpYnV0b3JzXCIuIEl0IGRlc2NyaWJlcyB0aGUgbGF5ZXIgZGF0YSBhbmQgaXMgb2Z0ZW4gYSBsZWdhbCBvYmxpZ2F0aW9uIHRvd2FyZHMgY29weXJpZ2h0IGhvbGRlcnMgYW5kIHRpbGUgcHJvdmlkZXJzLlxuICBcdFx0YXR0cmlidXRpb246IG51bGwsXG5cbiAgXHRcdGJ1YmJsaW5nTW91c2VFdmVudHM6IHRydWVcbiAgXHR9LFxuXG4gIFx0LyogQHNlY3Rpb25cbiAgXHQgKiBDbGFzc2VzIGV4dGVuZGluZyBgTC5MYXllcmAgd2lsbCBpbmhlcml0IHRoZSBmb2xsb3dpbmcgbWV0aG9kczpcbiAgXHQgKlxuICBcdCAqIEBtZXRob2QgYWRkVG8obWFwOiBNYXB8TGF5ZXJHcm91cCk6IHRoaXNcbiAgXHQgKiBBZGRzIHRoZSBsYXllciB0byB0aGUgZ2l2ZW4gbWFwIG9yIGxheWVyIGdyb3VwLlxuICBcdCAqL1xuICBcdGFkZFRvOiBmdW5jdGlvbiAobWFwKSB7XG4gIFx0XHRtYXAuYWRkTGF5ZXIodGhpcyk7XG4gIFx0XHRyZXR1cm4gdGhpcztcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCByZW1vdmU6IHRoaXNcbiAgXHQvLyBSZW1vdmVzIHRoZSBsYXllciBmcm9tIHRoZSBtYXAgaXQgaXMgY3VycmVudGx5IGFjdGl2ZSBvbi5cbiAgXHRyZW1vdmU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLnJlbW92ZUZyb20odGhpcy5fbWFwIHx8IHRoaXMuX21hcFRvQWRkKTtcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCByZW1vdmVGcm9tKG1hcDogTWFwKTogdGhpc1xuICBcdC8vIFJlbW92ZXMgdGhlIGxheWVyIGZyb20gdGhlIGdpdmVuIG1hcFxuICBcdC8vXG4gIFx0Ly8gQGFsdGVybmF0aXZlXG4gIFx0Ly8gQG1ldGhvZCByZW1vdmVGcm9tKGdyb3VwOiBMYXllckdyb3VwKTogdGhpc1xuICBcdC8vIFJlbW92ZXMgdGhlIGxheWVyIGZyb20gdGhlIGdpdmVuIGBMYXllckdyb3VwYFxuICBcdHJlbW92ZUZyb206IGZ1bmN0aW9uIChvYmopIHtcbiAgXHRcdGlmIChvYmopIHtcbiAgXHRcdFx0b2JqLnJlbW92ZUxheWVyKHRoaXMpO1xuICBcdFx0fVxuICBcdFx0cmV0dXJuIHRoaXM7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2QgZ2V0UGFuZShuYW1lPyA6IFN0cmluZyk6IEhUTUxFbGVtZW50XG4gIFx0Ly8gUmV0dXJucyB0aGUgYEhUTUxFbGVtZW50YCByZXByZXNlbnRpbmcgdGhlIG5hbWVkIHBhbmUgb24gdGhlIG1hcC4gSWYgYG5hbWVgIGlzIG9taXR0ZWQsIHJldHVybnMgdGhlIHBhbmUgZm9yIHRoaXMgbGF5ZXIuXG4gIFx0Z2V0UGFuZTogZnVuY3Rpb24gKG5hbWUpIHtcbiAgXHRcdHJldHVybiB0aGlzLl9tYXAuZ2V0UGFuZShuYW1lID8gKHRoaXMub3B0aW9uc1tuYW1lXSB8fCBuYW1lKSA6IHRoaXMub3B0aW9ucy5wYW5lKTtcbiAgXHR9LFxuXG4gIFx0YWRkSW50ZXJhY3RpdmVUYXJnZXQ6IGZ1bmN0aW9uICh0YXJnZXRFbCkge1xuICBcdFx0dGhpcy5fbWFwLl90YXJnZXRzW3N0YW1wKHRhcmdldEVsKV0gPSB0aGlzO1xuICBcdFx0cmV0dXJuIHRoaXM7XG4gIFx0fSxcblxuICBcdHJlbW92ZUludGVyYWN0aXZlVGFyZ2V0OiBmdW5jdGlvbiAodGFyZ2V0RWwpIHtcbiAgXHRcdGRlbGV0ZSB0aGlzLl9tYXAuX3RhcmdldHNbc3RhbXAodGFyZ2V0RWwpXTtcbiAgXHRcdHJldHVybiB0aGlzO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIGdldEF0dHJpYnV0aW9uOiBTdHJpbmdcbiAgXHQvLyBVc2VkIGJ5IHRoZSBgYXR0cmlidXRpb24gY29udHJvbGAsIHJldHVybnMgdGhlIFthdHRyaWJ1dGlvbiBvcHRpb25dKCNncmlkbGF5ZXItYXR0cmlidXRpb24pLlxuICBcdGdldEF0dHJpYnV0aW9uOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmF0dHJpYnV0aW9uO1xuICBcdH0sXG5cbiAgXHRfbGF5ZXJBZGQ6IGZ1bmN0aW9uIChlKSB7XG4gIFx0XHR2YXIgbWFwID0gZS50YXJnZXQ7XG5cbiAgXHRcdC8vIGNoZWNrIGluIGNhc2UgbGF5ZXIgZ2V0cyBhZGRlZCBhbmQgdGhlbiByZW1vdmVkIGJlZm9yZSB0aGUgbWFwIGlzIHJlYWR5XG4gIFx0XHRpZiAoIW1hcC5oYXNMYXllcih0aGlzKSkgeyByZXR1cm47IH1cblxuICBcdFx0dGhpcy5fbWFwID0gbWFwO1xuICBcdFx0dGhpcy5fem9vbUFuaW1hdGVkID0gbWFwLl96b29tQW5pbWF0ZWQ7XG5cbiAgXHRcdGlmICh0aGlzLmdldEV2ZW50cykge1xuICBcdFx0XHR2YXIgZXZlbnRzID0gdGhpcy5nZXRFdmVudHMoKTtcbiAgXHRcdFx0bWFwLm9uKGV2ZW50cywgdGhpcyk7XG4gIFx0XHRcdHRoaXMub25jZSgncmVtb3ZlJywgZnVuY3Rpb24gKCkge1xuICBcdFx0XHRcdG1hcC5vZmYoZXZlbnRzLCB0aGlzKTtcbiAgXHRcdFx0fSwgdGhpcyk7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMub25BZGQobWFwKTtcblxuICBcdFx0aWYgKHRoaXMuZ2V0QXR0cmlidXRpb24gJiYgbWFwLmF0dHJpYnV0aW9uQ29udHJvbCkge1xuICBcdFx0XHRtYXAuYXR0cmlidXRpb25Db250cm9sLmFkZEF0dHJpYnV0aW9uKHRoaXMuZ2V0QXR0cmlidXRpb24oKSk7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMuZmlyZSgnYWRkJyk7XG4gIFx0XHRtYXAuZmlyZSgnbGF5ZXJhZGQnLCB7bGF5ZXI6IHRoaXN9KTtcbiAgXHR9XG4gIH0pO1xuXG4gIC8qIEBzZWN0aW9uIEV4dGVuc2lvbiBtZXRob2RzXG4gICAqIEB1bmluaGVyaXRhYmxlXG4gICAqXG4gICAqIEV2ZXJ5IGxheWVyIHNob3VsZCBleHRlbmQgZnJvbSBgTC5MYXllcmAgYW5kIChyZS0paW1wbGVtZW50IHRoZSBmb2xsb3dpbmcgbWV0aG9kcy5cbiAgICpcbiAgICogQG1ldGhvZCBvbkFkZChtYXA6IE1hcCk6IHRoaXNcbiAgICogU2hvdWxkIGNvbnRhaW4gY29kZSB0aGF0IGNyZWF0ZXMgRE9NIGVsZW1lbnRzIGZvciB0aGUgbGF5ZXIsIGFkZHMgdGhlbSB0byBgbWFwIHBhbmVzYCB3aGVyZSB0aGV5IHNob3VsZCBiZWxvbmcgYW5kIHB1dHMgbGlzdGVuZXJzIG9uIHJlbGV2YW50IG1hcCBldmVudHMuIENhbGxlZCBvbiBbYG1hcC5hZGRMYXllcihsYXllcilgXSgjbWFwLWFkZGxheWVyKS5cbiAgICpcbiAgICogQG1ldGhvZCBvblJlbW92ZShtYXA6IE1hcCk6IHRoaXNcbiAgICogU2hvdWxkIGNvbnRhaW4gYWxsIGNsZWFuIHVwIGNvZGUgdGhhdCByZW1vdmVzIHRoZSBsYXllcidzIGVsZW1lbnRzIGZyb20gdGhlIERPTSBhbmQgcmVtb3ZlcyBsaXN0ZW5lcnMgcHJldmlvdXNseSBhZGRlZCBpbiBbYG9uQWRkYF0oI2xheWVyLW9uYWRkKS4gQ2FsbGVkIG9uIFtgbWFwLnJlbW92ZUxheWVyKGxheWVyKWBdKCNtYXAtcmVtb3ZlbGF5ZXIpLlxuICAgKlxuICAgKiBAbWV0aG9kIGdldEV2ZW50cygpOiBPYmplY3RcbiAgICogVGhpcyBvcHRpb25hbCBtZXRob2Qgc2hvdWxkIHJldHVybiBhbiBvYmplY3QgbGlrZSBgeyB2aWV3cmVzZXQ6IHRoaXMuX3Jlc2V0IH1gIGZvciBbYGFkZEV2ZW50TGlzdGVuZXJgXSgjZXZlbnRlZC1hZGRldmVudGxpc3RlbmVyKS4gVGhlIGV2ZW50IGhhbmRsZXJzIGluIHRoaXMgb2JqZWN0IHdpbGwgYmUgYXV0b21hdGljYWxseSBhZGRlZCBhbmQgcmVtb3ZlZCBmcm9tIHRoZSBtYXAgd2l0aCB5b3VyIGxheWVyLlxuICAgKlxuICAgKiBAbWV0aG9kIGdldEF0dHJpYnV0aW9uKCk6IFN0cmluZ1xuICAgKiBUaGlzIG9wdGlvbmFsIG1ldGhvZCBzaG91bGQgcmV0dXJuIGEgc3RyaW5nIGNvbnRhaW5pbmcgSFRNTCB0byBiZSBzaG93biBvbiB0aGUgYEF0dHJpYnV0aW9uIGNvbnRyb2xgIHdoZW5ldmVyIHRoZSBsYXllciBpcyB2aXNpYmxlLlxuICAgKlxuICAgKiBAbWV0aG9kIGJlZm9yZUFkZChtYXA6IE1hcCk6IHRoaXNcbiAgICogT3B0aW9uYWwgbWV0aG9kLiBDYWxsZWQgb24gW2BtYXAuYWRkTGF5ZXIobGF5ZXIpYF0oI21hcC1hZGRsYXllciksIGJlZm9yZSB0aGUgbGF5ZXIgaXMgYWRkZWQgdG8gdGhlIG1hcCwgYmVmb3JlIGV2ZW50cyBhcmUgaW5pdGlhbGl6ZWQsIHdpdGhvdXQgd2FpdGluZyB1bnRpbCB0aGUgbWFwIGlzIGluIGEgdXNhYmxlIHN0YXRlLiBVc2UgZm9yIGVhcmx5IGluaXRpYWxpemF0aW9uIG9ubHkuXG4gICAqL1xuXG5cbiAgLyogQG5hbWVzcGFjZSBNYXBcbiAgICogQHNlY3Rpb24gTGF5ZXIgZXZlbnRzXG4gICAqXG4gICAqIEBldmVudCBsYXllcmFkZDogTGF5ZXJFdmVudFxuICAgKiBGaXJlZCB3aGVuIGEgbmV3IGxheWVyIGlzIGFkZGVkIHRvIHRoZSBtYXAuXG4gICAqXG4gICAqIEBldmVudCBsYXllcnJlbW92ZTogTGF5ZXJFdmVudFxuICAgKiBGaXJlZCB3aGVuIHNvbWUgbGF5ZXIgaXMgcmVtb3ZlZCBmcm9tIHRoZSBtYXBcbiAgICpcbiAgICogQHNlY3Rpb24gTWV0aG9kcyBmb3IgTGF5ZXJzIGFuZCBDb250cm9sc1xuICAgKi9cbiAgTWFwLmluY2x1ZGUoe1xuICBcdC8vIEBtZXRob2QgYWRkTGF5ZXIobGF5ZXI6IExheWVyKTogdGhpc1xuICBcdC8vIEFkZHMgdGhlIGdpdmVuIGxheWVyIHRvIHRoZSBtYXBcbiAgXHRhZGRMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XG4gIFx0XHRpZiAoIWxheWVyLl9sYXllckFkZCkge1xuICBcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1RoZSBwcm92aWRlZCBvYmplY3QgaXMgbm90IGEgTGF5ZXIuJyk7XG4gIFx0XHR9XG5cbiAgXHRcdHZhciBpZCA9IHN0YW1wKGxheWVyKTtcbiAgXHRcdGlmICh0aGlzLl9sYXllcnNbaWRdKSB7IHJldHVybiB0aGlzOyB9XG4gIFx0XHR0aGlzLl9sYXllcnNbaWRdID0gbGF5ZXI7XG5cbiAgXHRcdGxheWVyLl9tYXBUb0FkZCA9IHRoaXM7XG5cbiAgXHRcdGlmIChsYXllci5iZWZvcmVBZGQpIHtcbiAgXHRcdFx0bGF5ZXIuYmVmb3JlQWRkKHRoaXMpO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLndoZW5SZWFkeShsYXllci5fbGF5ZXJBZGQsIGxheWVyKTtcblxuICBcdFx0cmV0dXJuIHRoaXM7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2QgcmVtb3ZlTGF5ZXIobGF5ZXI6IExheWVyKTogdGhpc1xuICBcdC8vIFJlbW92ZXMgdGhlIGdpdmVuIGxheWVyIGZyb20gdGhlIG1hcC5cbiAgXHRyZW1vdmVMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XG4gIFx0XHR2YXIgaWQgPSBzdGFtcChsYXllcik7XG5cbiAgXHRcdGlmICghdGhpcy5fbGF5ZXJzW2lkXSkgeyByZXR1cm4gdGhpczsgfVxuXG4gIFx0XHRpZiAodGhpcy5fbG9hZGVkKSB7XG4gIFx0XHRcdGxheWVyLm9uUmVtb3ZlKHRoaXMpO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAobGF5ZXIuZ2V0QXR0cmlidXRpb24gJiYgdGhpcy5hdHRyaWJ1dGlvbkNvbnRyb2wpIHtcbiAgXHRcdFx0dGhpcy5hdHRyaWJ1dGlvbkNvbnRyb2wucmVtb3ZlQXR0cmlidXRpb24obGF5ZXIuZ2V0QXR0cmlidXRpb24oKSk7XG4gIFx0XHR9XG5cbiAgXHRcdGRlbGV0ZSB0aGlzLl9sYXllcnNbaWRdO1xuXG4gIFx0XHRpZiAodGhpcy5fbG9hZGVkKSB7XG4gIFx0XHRcdHRoaXMuZmlyZSgnbGF5ZXJyZW1vdmUnLCB7bGF5ZXI6IGxheWVyfSk7XG4gIFx0XHRcdGxheWVyLmZpcmUoJ3JlbW92ZScpO1xuICBcdFx0fVxuXG4gIFx0XHRsYXllci5fbWFwID0gbGF5ZXIuX21hcFRvQWRkID0gbnVsbDtcblxuICBcdFx0cmV0dXJuIHRoaXM7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2QgaGFzTGF5ZXIobGF5ZXI6IExheWVyKTogQm9vbGVhblxuICBcdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiBsYXllciBpcyBjdXJyZW50bHkgYWRkZWQgdG8gdGhlIG1hcFxuICBcdGhhc0xheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgXHRcdHJldHVybiAhIWxheWVyICYmIChzdGFtcChsYXllcikgaW4gdGhpcy5fbGF5ZXJzKTtcbiAgXHR9LFxuXG4gIFx0LyogQG1ldGhvZCBlYWNoTGF5ZXIoZm46IEZ1bmN0aW9uLCBjb250ZXh0PzogT2JqZWN0KTogdGhpc1xuICBcdCAqIEl0ZXJhdGVzIG92ZXIgdGhlIGxheWVycyBvZiB0aGUgbWFwLCBvcHRpb25hbGx5IHNwZWNpZnlpbmcgY29udGV4dCBvZiB0aGUgaXRlcmF0b3IgZnVuY3Rpb24uXG4gIFx0ICogYGBgXG4gIFx0ICogbWFwLmVhY2hMYXllcihmdW5jdGlvbihsYXllcil7XG4gIFx0ICogICAgIGxheWVyLmJpbmRQb3B1cCgnSGVsbG8nKTtcbiAgXHQgKiB9KTtcbiAgXHQgKiBgYGBcbiAgXHQgKi9cbiAgXHRlYWNoTGF5ZXI6IGZ1bmN0aW9uIChtZXRob2QsIGNvbnRleHQpIHtcbiAgXHRcdGZvciAodmFyIGkgaW4gdGhpcy5fbGF5ZXJzKSB7XG4gIFx0XHRcdG1ldGhvZC5jYWxsKGNvbnRleHQsIHRoaXMuX2xheWVyc1tpXSk7XG4gIFx0XHR9XG4gIFx0XHRyZXR1cm4gdGhpcztcbiAgXHR9LFxuXG4gIFx0X2FkZExheWVyczogZnVuY3Rpb24gKGxheWVycykge1xuICBcdFx0bGF5ZXJzID0gbGF5ZXJzID8gKGlzQXJyYXkobGF5ZXJzKSA/IGxheWVycyA6IFtsYXllcnNdKSA6IFtdO1xuXG4gIFx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gbGF5ZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gIFx0XHRcdHRoaXMuYWRkTGF5ZXIobGF5ZXJzW2ldKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X2FkZFpvb21MaW1pdDogZnVuY3Rpb24gKGxheWVyKSB7XG4gIFx0XHRpZiAoaXNOYU4obGF5ZXIub3B0aW9ucy5tYXhab29tKSB8fCAhaXNOYU4obGF5ZXIub3B0aW9ucy5taW5ab29tKSkge1xuICBcdFx0XHR0aGlzLl96b29tQm91bmRMYXllcnNbc3RhbXAobGF5ZXIpXSA9IGxheWVyO1xuICBcdFx0XHR0aGlzLl91cGRhdGVab29tTGV2ZWxzKCk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF9yZW1vdmVab29tTGltaXQ6IGZ1bmN0aW9uIChsYXllcikge1xuICBcdFx0dmFyIGlkID0gc3RhbXAobGF5ZXIpO1xuXG4gIFx0XHRpZiAodGhpcy5fem9vbUJvdW5kTGF5ZXJzW2lkXSkge1xuICBcdFx0XHRkZWxldGUgdGhpcy5fem9vbUJvdW5kTGF5ZXJzW2lkXTtcbiAgXHRcdFx0dGhpcy5fdXBkYXRlWm9vbUxldmVscygpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfdXBkYXRlWm9vbUxldmVsczogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIG1pblpvb20gPSBJbmZpbml0eSxcbiAgXHRcdCAgICBtYXhab29tID0gLUluZmluaXR5LFxuICBcdFx0ICAgIG9sZFpvb21TcGFuID0gdGhpcy5fZ2V0Wm9vbVNwYW4oKTtcblxuICBcdFx0Zm9yICh2YXIgaSBpbiB0aGlzLl96b29tQm91bmRMYXllcnMpIHtcbiAgXHRcdFx0dmFyIG9wdGlvbnMgPSB0aGlzLl96b29tQm91bmRMYXllcnNbaV0ub3B0aW9ucztcblxuICBcdFx0XHRtaW5ab29tID0gb3B0aW9ucy5taW5ab29tID09PSB1bmRlZmluZWQgPyBtaW5ab29tIDogTWF0aC5taW4obWluWm9vbSwgb3B0aW9ucy5taW5ab29tKTtcbiAgXHRcdFx0bWF4Wm9vbSA9IG9wdGlvbnMubWF4Wm9vbSA9PT0gdW5kZWZpbmVkID8gbWF4Wm9vbSA6IE1hdGgubWF4KG1heFpvb20sIG9wdGlvbnMubWF4Wm9vbSk7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMuX2xheWVyc01heFpvb20gPSBtYXhab29tID09PSAtSW5maW5pdHkgPyB1bmRlZmluZWQgOiBtYXhab29tO1xuICBcdFx0dGhpcy5fbGF5ZXJzTWluWm9vbSA9IG1pblpvb20gPT09IEluZmluaXR5ID8gdW5kZWZpbmVkIDogbWluWm9vbTtcblxuICBcdFx0Ly8gQHNlY3Rpb24gTWFwIHN0YXRlIGNoYW5nZSBldmVudHNcbiAgXHRcdC8vIEBldmVudCB6b29tbGV2ZWxzY2hhbmdlOiBFdmVudFxuICBcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbnVtYmVyIG9mIHpvb21sZXZlbHMgb24gdGhlIG1hcCBpcyBjaGFuZ2VkIGR1ZVxuICBcdFx0Ly8gdG8gYWRkaW5nIG9yIHJlbW92aW5nIGEgbGF5ZXIuXG4gIFx0XHRpZiAob2xkWm9vbVNwYW4gIT09IHRoaXMuX2dldFpvb21TcGFuKCkpIHtcbiAgXHRcdFx0dGhpcy5maXJlKCd6b29tbGV2ZWxzY2hhbmdlJyk7XG4gIFx0XHR9XG5cbiAgXHRcdGlmICh0aGlzLm9wdGlvbnMubWF4Wm9vbSA9PT0gdW5kZWZpbmVkICYmIHRoaXMuX2xheWVyc01heFpvb20gJiYgdGhpcy5nZXRab29tKCkgPiB0aGlzLl9sYXllcnNNYXhab29tKSB7XG4gIFx0XHRcdHRoaXMuc2V0Wm9vbSh0aGlzLl9sYXllcnNNYXhab29tKTtcbiAgXHRcdH1cbiAgXHRcdGlmICh0aGlzLm9wdGlvbnMubWluWm9vbSA9PT0gdW5kZWZpbmVkICYmIHRoaXMuX2xheWVyc01pblpvb20gJiYgdGhpcy5nZXRab29tKCkgPCB0aGlzLl9sYXllcnNNaW5ab29tKSB7XG4gIFx0XHRcdHRoaXMuc2V0Wm9vbSh0aGlzLl9sYXllcnNNaW5ab29tKTtcbiAgXHRcdH1cbiAgXHR9XG4gIH0pO1xuXG4gIC8qXHJcbiAgICogQGNsYXNzIExheWVyR3JvdXBcclxuICAgKiBAYWthIEwuTGF5ZXJHcm91cFxyXG4gICAqIEBpbmhlcml0cyBMYXllclxyXG4gICAqXHJcbiAgICogVXNlZCB0byBncm91cCBzZXZlcmFsIGxheWVycyBhbmQgaGFuZGxlIHRoZW0gYXMgb25lLiBJZiB5b3UgYWRkIGl0IHRvIHRoZSBtYXAsXHJcbiAgICogYW55IGxheWVycyBhZGRlZCBvciByZW1vdmVkIGZyb20gdGhlIGdyb3VwIHdpbGwgYmUgYWRkZWQvcmVtb3ZlZCBvbiB0aGUgbWFwIGFzXHJcbiAgICogd2VsbC4gRXh0ZW5kcyBgTGF5ZXJgLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKlxyXG4gICAqIGBgYGpzXHJcbiAgICogTC5sYXllckdyb3VwKFttYXJrZXIxLCBtYXJrZXIyXSlcclxuICAgKiBcdC5hZGRMYXllcihwb2x5bGluZSlcclxuICAgKiBcdC5hZGRUbyhtYXApO1xyXG4gICAqIGBgYFxyXG4gICAqL1xyXG5cclxuICB2YXIgTGF5ZXJHcm91cCA9IExheWVyLmV4dGVuZCh7XHJcblxyXG4gIFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGxheWVycywgb3B0aW9ucykge1xyXG4gIFx0XHRzZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuICBcdFx0dGhpcy5fbGF5ZXJzID0ge307XHJcblxyXG4gIFx0XHR2YXIgaSwgbGVuO1xyXG5cclxuICBcdFx0aWYgKGxheWVycykge1xyXG4gIFx0XHRcdGZvciAoaSA9IDAsIGxlbiA9IGxheWVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gIFx0XHRcdFx0dGhpcy5hZGRMYXllcihsYXllcnNbaV0pO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0fVxyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGFkZExheWVyKGxheWVyOiBMYXllcik6IHRoaXNcclxuICBcdC8vIEFkZHMgdGhlIGdpdmVuIGxheWVyIHRvIHRoZSBncm91cC5cclxuICBcdGFkZExheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuICBcdFx0dmFyIGlkID0gdGhpcy5nZXRMYXllcklkKGxheWVyKTtcclxuXHJcbiAgXHRcdHRoaXMuX2xheWVyc1tpZF0gPSBsYXllcjtcclxuXHJcbiAgXHRcdGlmICh0aGlzLl9tYXApIHtcclxuICBcdFx0XHR0aGlzLl9tYXAuYWRkTGF5ZXIobGF5ZXIpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCByZW1vdmVMYXllcihsYXllcjogTGF5ZXIpOiB0aGlzXHJcbiAgXHQvLyBSZW1vdmVzIHRoZSBnaXZlbiBsYXllciBmcm9tIHRoZSBncm91cC5cclxuICBcdC8vIEBhbHRlcm5hdGl2ZVxyXG4gIFx0Ly8gQG1ldGhvZCByZW1vdmVMYXllcihpZDogTnVtYmVyKTogdGhpc1xyXG4gIFx0Ly8gUmVtb3ZlcyB0aGUgbGF5ZXIgd2l0aCB0aGUgZ2l2ZW4gaW50ZXJuYWwgSUQgZnJvbSB0aGUgZ3JvdXAuXHJcbiAgXHRyZW1vdmVMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XHJcbiAgXHRcdHZhciBpZCA9IGxheWVyIGluIHRoaXMuX2xheWVycyA/IGxheWVyIDogdGhpcy5nZXRMYXllcklkKGxheWVyKTtcclxuXHJcbiAgXHRcdGlmICh0aGlzLl9tYXAgJiYgdGhpcy5fbGF5ZXJzW2lkXSkge1xyXG4gIFx0XHRcdHRoaXMuX21hcC5yZW1vdmVMYXllcih0aGlzLl9sYXllcnNbaWRdKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0ZGVsZXRlIHRoaXMuX2xheWVyc1tpZF07XHJcblxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBoYXNMYXllcihsYXllcjogTGF5ZXIpOiBCb29sZWFuXHJcbiAgXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gbGF5ZXIgaXMgY3VycmVudGx5IGFkZGVkIHRvIHRoZSBncm91cC5cclxuICBcdC8vIEBhbHRlcm5hdGl2ZVxyXG4gIFx0Ly8gQG1ldGhvZCBoYXNMYXllcihpZDogTnVtYmVyKTogQm9vbGVhblxyXG4gIFx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIGludGVybmFsIElEIGlzIGN1cnJlbnRseSBhZGRlZCB0byB0aGUgZ3JvdXAuXHJcbiAgXHRoYXNMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XHJcbiAgXHRcdGlmICghbGF5ZXIpIHsgcmV0dXJuIGZhbHNlOyB9XHJcbiAgXHRcdHZhciBsYXllcklkID0gdHlwZW9mIGxheWVyID09PSAnbnVtYmVyJyA/IGxheWVyIDogdGhpcy5nZXRMYXllcklkKGxheWVyKTtcclxuICBcdFx0cmV0dXJuIGxheWVySWQgaW4gdGhpcy5fbGF5ZXJzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGNsZWFyTGF5ZXJzKCk6IHRoaXNcclxuICBcdC8vIFJlbW92ZXMgYWxsIHRoZSBsYXllcnMgZnJvbSB0aGUgZ3JvdXAuXHJcbiAgXHRjbGVhckxheWVyczogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5lYWNoTGF5ZXIodGhpcy5yZW1vdmVMYXllciwgdGhpcyk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgaW52b2tlKG1ldGhvZE5hbWU6IFN0cmluZywg4oCmKTogdGhpc1xyXG4gIFx0Ly8gQ2FsbHMgYG1ldGhvZE5hbWVgIG9uIGV2ZXJ5IGxheWVyIGNvbnRhaW5lZCBpbiB0aGlzIGdyb3VwLCBwYXNzaW5nIGFueVxyXG4gIFx0Ly8gYWRkaXRpb25hbCBwYXJhbWV0ZXJzLiBIYXMgbm8gZWZmZWN0IGlmIHRoZSBsYXllcnMgY29udGFpbmVkIGRvIG5vdFxyXG4gIFx0Ly8gaW1wbGVtZW50IGBtZXRob2ROYW1lYC5cclxuICBcdGludm9rZTogZnVuY3Rpb24gKG1ldGhvZE5hbWUpIHtcclxuICBcdFx0dmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpLFxyXG4gIFx0XHQgICAgaSwgbGF5ZXI7XHJcblxyXG4gIFx0XHRmb3IgKGkgaW4gdGhpcy5fbGF5ZXJzKSB7XHJcbiAgXHRcdFx0bGF5ZXIgPSB0aGlzLl9sYXllcnNbaV07XHJcblxyXG4gIFx0XHRcdGlmIChsYXllclttZXRob2ROYW1lXSkge1xyXG4gIFx0XHRcdFx0bGF5ZXJbbWV0aG9kTmFtZV0uYXBwbHkobGF5ZXIsIGFyZ3MpO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0fVxyXG5cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcbiAgXHRcdHRoaXMuZWFjaExheWVyKG1hcC5hZGRMYXllciwgbWFwKTtcclxuICBcdH0sXHJcblxyXG4gIFx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcclxuICBcdFx0dGhpcy5lYWNoTGF5ZXIobWFwLnJlbW92ZUxheWVyLCBtYXApO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGVhY2hMYXllcihmbjogRnVuY3Rpb24sIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXHJcbiAgXHQvLyBJdGVyYXRlcyBvdmVyIHRoZSBsYXllcnMgb2YgdGhlIGdyb3VwLCBvcHRpb25hbGx5IHNwZWNpZnlpbmcgY29udGV4dCBvZiB0aGUgaXRlcmF0b3IgZnVuY3Rpb24uXHJcbiAgXHQvLyBgYGBqc1xyXG4gIFx0Ly8gZ3JvdXAuZWFjaExheWVyKGZ1bmN0aW9uIChsYXllcikge1xyXG4gIFx0Ly8gXHRsYXllci5iaW5kUG9wdXAoJ0hlbGxvJyk7XHJcbiAgXHQvLyB9KTtcclxuICBcdC8vIGBgYFxyXG4gIFx0ZWFjaExheWVyOiBmdW5jdGlvbiAobWV0aG9kLCBjb250ZXh0KSB7XHJcbiAgXHRcdGZvciAodmFyIGkgaW4gdGhpcy5fbGF5ZXJzKSB7XHJcbiAgXHRcdFx0bWV0aG9kLmNhbGwoY29udGV4dCwgdGhpcy5fbGF5ZXJzW2ldKTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRMYXllcihpZDogTnVtYmVyKTogTGF5ZXJcclxuICBcdC8vIFJldHVybnMgdGhlIGxheWVyIHdpdGggdGhlIGdpdmVuIGludGVybmFsIElELlxyXG4gIFx0Z2V0TGF5ZXI6IGZ1bmN0aW9uIChpZCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5fbGF5ZXJzW2lkXTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRMYXllcnMoKTogTGF5ZXJbXVxyXG4gIFx0Ly8gUmV0dXJucyBhbiBhcnJheSBvZiBhbGwgdGhlIGxheWVycyBhZGRlZCB0byB0aGUgZ3JvdXAuXHJcbiAgXHRnZXRMYXllcnM6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dmFyIGxheWVycyA9IFtdO1xyXG4gIFx0XHR0aGlzLmVhY2hMYXllcihsYXllcnMucHVzaCwgbGF5ZXJzKTtcclxuICBcdFx0cmV0dXJuIGxheWVycztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBzZXRaSW5kZXgoekluZGV4OiBOdW1iZXIpOiB0aGlzXHJcbiAgXHQvLyBDYWxscyBgc2V0WkluZGV4YCBvbiBldmVyeSBsYXllciBjb250YWluZWQgaW4gdGhpcyBncm91cCwgcGFzc2luZyB0aGUgei1pbmRleC5cclxuICBcdHNldFpJbmRleDogZnVuY3Rpb24gKHpJbmRleCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5pbnZva2UoJ3NldFpJbmRleCcsIHpJbmRleCk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0TGF5ZXJJZChsYXllcjogTGF5ZXIpOiBOdW1iZXJcclxuICBcdC8vIFJldHVybnMgdGhlIGludGVybmFsIElEIGZvciBhIGxheWVyXHJcbiAgXHRnZXRMYXllcklkOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuICBcdFx0cmV0dXJuIHN0YW1wKGxheWVyKTtcclxuICBcdH1cclxuICB9KTtcclxuXHJcblxyXG4gIC8vIEBmYWN0b3J5IEwubGF5ZXJHcm91cChsYXllcnM/OiBMYXllcltdLCBvcHRpb25zPzogT2JqZWN0KVxyXG4gIC8vIENyZWF0ZSBhIGxheWVyIGdyb3VwLCBvcHRpb25hbGx5IGdpdmVuIGFuIGluaXRpYWwgc2V0IG9mIGxheWVycyBhbmQgYW4gYG9wdGlvbnNgIG9iamVjdC5cclxuICB2YXIgbGF5ZXJHcm91cCA9IGZ1bmN0aW9uIChsYXllcnMsIG9wdGlvbnMpIHtcclxuICBcdHJldHVybiBuZXcgTGF5ZXJHcm91cChsYXllcnMsIG9wdGlvbnMpO1xyXG4gIH07XG5cbiAgLypcclxuICAgKiBAY2xhc3MgRmVhdHVyZUdyb3VwXHJcbiAgICogQGFrYSBMLkZlYXR1cmVHcm91cFxyXG4gICAqIEBpbmhlcml0cyBMYXllckdyb3VwXHJcbiAgICpcclxuICAgKiBFeHRlbmRlZCBgTGF5ZXJHcm91cGAgdGhhdCBtYWtlcyBpdCBlYXNpZXIgdG8gZG8gdGhlIHNhbWUgdGhpbmcgdG8gYWxsIGl0cyBtZW1iZXIgbGF5ZXJzOlxyXG4gICAqICAqIFtgYmluZFBvcHVwYF0oI2xheWVyLWJpbmRwb3B1cCkgYmluZHMgYSBwb3B1cCB0byBhbGwgb2YgdGhlIGxheWVycyBhdCBvbmNlIChsaWtld2lzZSB3aXRoIFtgYmluZFRvb2x0aXBgXSgjbGF5ZXItYmluZHRvb2x0aXApKVxyXG4gICAqICAqIEV2ZW50cyBhcmUgcHJvcGFnYXRlZCB0byB0aGUgYEZlYXR1cmVHcm91cGAsIHNvIGlmIHRoZSBncm91cCBoYXMgYW4gZXZlbnRcclxuICAgKiBoYW5kbGVyLCBpdCB3aWxsIGhhbmRsZSBldmVudHMgZnJvbSBhbnkgb2YgdGhlIGxheWVycy4gVGhpcyBpbmNsdWRlcyBtb3VzZSBldmVudHNcclxuICAgKiBhbmQgY3VzdG9tIGV2ZW50cy5cclxuICAgKiAgKiBIYXMgYGxheWVyYWRkYCBhbmQgYGxheWVycmVtb3ZlYCBldmVudHNcclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICpcclxuICAgKiBgYGBqc1xyXG4gICAqIEwuZmVhdHVyZUdyb3VwKFttYXJrZXIxLCBtYXJrZXIyLCBwb2x5bGluZV0pXHJcbiAgICogXHQuYmluZFBvcHVwKCdIZWxsbyB3b3JsZCEnKVxyXG4gICAqIFx0Lm9uKCdjbGljaycsIGZ1bmN0aW9uKCkgeyBhbGVydCgnQ2xpY2tlZCBvbiBhIG1lbWJlciBvZiB0aGUgZ3JvdXAhJyk7IH0pXHJcbiAgICogXHQuYWRkVG8obWFwKTtcclxuICAgKiBgYGBcclxuICAgKi9cclxuXHJcbiAgdmFyIEZlYXR1cmVHcm91cCA9IExheWVyR3JvdXAuZXh0ZW5kKHtcclxuXHJcbiAgXHRhZGRMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XHJcbiAgXHRcdGlmICh0aGlzLmhhc0xheWVyKGxheWVyKSkge1xyXG4gIFx0XHRcdHJldHVybiB0aGlzO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRsYXllci5hZGRFdmVudFBhcmVudCh0aGlzKTtcclxuXHJcbiAgXHRcdExheWVyR3JvdXAucHJvdG90eXBlLmFkZExheWVyLmNhbGwodGhpcywgbGF5ZXIpO1xyXG5cclxuICBcdFx0Ly8gQGV2ZW50IGxheWVyYWRkOiBMYXllckV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIHdoZW4gYSBsYXllciBpcyBhZGRlZCB0byB0aGlzIGBGZWF0dXJlR3JvdXBgXHJcbiAgXHRcdHJldHVybiB0aGlzLmZpcmUoJ2xheWVyYWRkJywge2xheWVyOiBsYXllcn0pO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRyZW1vdmVMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XHJcbiAgXHRcdGlmICghdGhpcy5oYXNMYXllcihsYXllcikpIHtcclxuICBcdFx0XHRyZXR1cm4gdGhpcztcclxuICBcdFx0fVxyXG4gIFx0XHRpZiAobGF5ZXIgaW4gdGhpcy5fbGF5ZXJzKSB7XHJcbiAgXHRcdFx0bGF5ZXIgPSB0aGlzLl9sYXllcnNbbGF5ZXJdO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRsYXllci5yZW1vdmVFdmVudFBhcmVudCh0aGlzKTtcclxuXHJcbiAgXHRcdExheWVyR3JvdXAucHJvdG90eXBlLnJlbW92ZUxheWVyLmNhbGwodGhpcywgbGF5ZXIpO1xyXG5cclxuICBcdFx0Ly8gQGV2ZW50IGxheWVycmVtb3ZlOiBMYXllckV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIHdoZW4gYSBsYXllciBpcyByZW1vdmVkIGZyb20gdGhpcyBgRmVhdHVyZUdyb3VwYFxyXG4gIFx0XHRyZXR1cm4gdGhpcy5maXJlKCdsYXllcnJlbW92ZScsIHtsYXllcjogbGF5ZXJ9KTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBzZXRTdHlsZShzdHlsZTogUGF0aCBvcHRpb25zKTogdGhpc1xyXG4gIFx0Ly8gU2V0cyB0aGUgZ2l2ZW4gcGF0aCBvcHRpb25zIHRvIGVhY2ggbGF5ZXIgb2YgdGhlIGdyb3VwIHRoYXQgaGFzIGEgYHNldFN0eWxlYCBtZXRob2QuXHJcbiAgXHRzZXRTdHlsZTogZnVuY3Rpb24gKHN0eWxlKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLmludm9rZSgnc2V0U3R5bGUnLCBzdHlsZSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgYnJpbmdUb0Zyb250KCk6IHRoaXNcclxuICBcdC8vIEJyaW5ncyB0aGUgbGF5ZXIgZ3JvdXAgdG8gdGhlIHRvcCBvZiBhbGwgb3RoZXIgbGF5ZXJzXHJcbiAgXHRicmluZ1RvRnJvbnQ6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMuaW52b2tlKCdicmluZ1RvRnJvbnQnKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBicmluZ1RvQmFjaygpOiB0aGlzXHJcbiAgXHQvLyBCcmluZ3MgdGhlIGxheWVyIGdyb3VwIHRvIHRoZSBiYWNrIG9mIGFsbCBvdGhlciBsYXllcnNcclxuICBcdGJyaW5nVG9CYWNrOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLmludm9rZSgnYnJpbmdUb0JhY2snKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRCb3VuZHMoKTogTGF0TG5nQm91bmRzXHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBMYXRMbmdCb3VuZHMgb2YgdGhlIEZlYXR1cmUgR3JvdXAgKGNyZWF0ZWQgZnJvbSBib3VuZHMgYW5kIGNvb3JkaW5hdGVzIG9mIGl0cyBjaGlsZHJlbikuXHJcbiAgXHRnZXRCb3VuZHM6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dmFyIGJvdW5kcyA9IG5ldyBMYXRMbmdCb3VuZHMoKTtcclxuXHJcbiAgXHRcdGZvciAodmFyIGlkIGluIHRoaXMuX2xheWVycykge1xyXG4gIFx0XHRcdHZhciBsYXllciA9IHRoaXMuX2xheWVyc1tpZF07XHJcbiAgXHRcdFx0Ym91bmRzLmV4dGVuZChsYXllci5nZXRCb3VuZHMgPyBsYXllci5nZXRCb3VuZHMoKSA6IGxheWVyLmdldExhdExuZygpKTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gYm91bmRzO1xyXG4gIFx0fVxyXG4gIH0pO1xyXG5cclxuICAvLyBAZmFjdG9yeSBMLmZlYXR1cmVHcm91cChsYXllcnM/OiBMYXllcltdLCBvcHRpb25zPzogT2JqZWN0KVxyXG4gIC8vIENyZWF0ZSBhIGZlYXR1cmUgZ3JvdXAsIG9wdGlvbmFsbHkgZ2l2ZW4gYW4gaW5pdGlhbCBzZXQgb2YgbGF5ZXJzIGFuZCBhbiBgb3B0aW9uc2Agb2JqZWN0LlxyXG4gIHZhciBmZWF0dXJlR3JvdXAgPSBmdW5jdGlvbiAobGF5ZXJzLCBvcHRpb25zKSB7XHJcbiAgXHRyZXR1cm4gbmV3IEZlYXR1cmVHcm91cChsYXllcnMsIG9wdGlvbnMpO1xyXG4gIH07XG5cbiAgLypcclxuICAgKiBAY2xhc3MgSWNvblxyXG4gICAqIEBha2EgTC5JY29uXHJcbiAgICpcclxuICAgKiBSZXByZXNlbnRzIGFuIGljb24gdG8gcHJvdmlkZSB3aGVuIGNyZWF0aW5nIGEgbWFya2VyLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKlxyXG4gICAqIGBgYGpzXHJcbiAgICogdmFyIG15SWNvbiA9IEwuaWNvbih7XHJcbiAgICogICAgIGljb25Vcmw6ICdteS1pY29uLnBuZycsXHJcbiAgICogICAgIGljb25SZXRpbmFVcmw6ICdteS1pY29uQDJ4LnBuZycsXHJcbiAgICogICAgIGljb25TaXplOiBbMzgsIDk1XSxcclxuICAgKiAgICAgaWNvbkFuY2hvcjogWzIyLCA5NF0sXHJcbiAgICogICAgIHBvcHVwQW5jaG9yOiBbLTMsIC03Nl0sXHJcbiAgICogICAgIHNoYWRvd1VybDogJ215LWljb24tc2hhZG93LnBuZycsXHJcbiAgICogICAgIHNoYWRvd1JldGluYVVybDogJ215LWljb24tc2hhZG93QDJ4LnBuZycsXHJcbiAgICogICAgIHNoYWRvd1NpemU6IFs2OCwgOTVdLFxyXG4gICAqICAgICBzaGFkb3dBbmNob3I6IFsyMiwgOTRdXHJcbiAgICogfSk7XHJcbiAgICpcclxuICAgKiBMLm1hcmtlcihbNTAuNTA1LCAzMC41N10sIHtpY29uOiBteUljb259KS5hZGRUbyhtYXApO1xyXG4gICAqIGBgYFxyXG4gICAqXHJcbiAgICogYEwuSWNvbi5EZWZhdWx0YCBleHRlbmRzIGBMLkljb25gIGFuZCBpcyB0aGUgYmx1ZSBpY29uIExlYWZsZXQgdXNlcyBmb3IgbWFya2VycyBieSBkZWZhdWx0LlxyXG4gICAqXHJcbiAgICovXHJcblxyXG4gIHZhciBJY29uID0gQ2xhc3MuZXh0ZW5kKHtcclxuXHJcbiAgXHQvKiBAc2VjdGlvblxyXG4gIFx0ICogQGFrYSBJY29uIG9wdGlvbnNcclxuICBcdCAqXHJcbiAgXHQgKiBAb3B0aW9uIGljb25Vcmw6IFN0cmluZyA9IG51bGxcclxuICBcdCAqICoqKHJlcXVpcmVkKSoqIFRoZSBVUkwgdG8gdGhlIGljb24gaW1hZ2UgKGFic29sdXRlIG9yIHJlbGF0aXZlIHRvIHlvdXIgc2NyaXB0IHBhdGgpLlxyXG4gIFx0ICpcclxuICBcdCAqIEBvcHRpb24gaWNvblJldGluYVVybDogU3RyaW5nID0gbnVsbFxyXG4gIFx0ICogVGhlIFVSTCB0byBhIHJldGluYSBzaXplZCB2ZXJzaW9uIG9mIHRoZSBpY29uIGltYWdlIChhYnNvbHV0ZSBvciByZWxhdGl2ZSB0byB5b3VyXHJcbiAgXHQgKiBzY3JpcHQgcGF0aCkuIFVzZWQgZm9yIFJldGluYSBzY3JlZW4gZGV2aWNlcy5cclxuICBcdCAqXHJcbiAgXHQgKiBAb3B0aW9uIGljb25TaXplOiBQb2ludCA9IG51bGxcclxuICBcdCAqIFNpemUgb2YgdGhlIGljb24gaW1hZ2UgaW4gcGl4ZWxzLlxyXG4gIFx0ICpcclxuICBcdCAqIEBvcHRpb24gaWNvbkFuY2hvcjogUG9pbnQgPSBudWxsXHJcbiAgXHQgKiBUaGUgY29vcmRpbmF0ZXMgb2YgdGhlIFwidGlwXCIgb2YgdGhlIGljb24gKHJlbGF0aXZlIHRvIGl0cyB0b3AgbGVmdCBjb3JuZXIpLiBUaGUgaWNvblxyXG4gIFx0ICogd2lsbCBiZSBhbGlnbmVkIHNvIHRoYXQgdGhpcyBwb2ludCBpcyBhdCB0aGUgbWFya2VyJ3MgZ2VvZ3JhcGhpY2FsIGxvY2F0aW9uLiBDZW50ZXJlZFxyXG4gIFx0ICogYnkgZGVmYXVsdCBpZiBzaXplIGlzIHNwZWNpZmllZCwgYWxzbyBjYW4gYmUgc2V0IGluIENTUyB3aXRoIG5lZ2F0aXZlIG1hcmdpbnMuXHJcbiAgXHQgKlxyXG4gIFx0ICogQG9wdGlvbiBwb3B1cEFuY2hvcjogUG9pbnQgPSBbMCwgMF1cclxuICBcdCAqIFRoZSBjb29yZGluYXRlcyBvZiB0aGUgcG9pbnQgZnJvbSB3aGljaCBwb3B1cHMgd2lsbCBcIm9wZW5cIiwgcmVsYXRpdmUgdG8gdGhlIGljb24gYW5jaG9yLlxyXG4gIFx0ICpcclxuICBcdCAqIEBvcHRpb24gdG9vbHRpcEFuY2hvcjogUG9pbnQgPSBbMCwgMF1cclxuICBcdCAqIFRoZSBjb29yZGluYXRlcyBvZiB0aGUgcG9pbnQgZnJvbSB3aGljaCB0b29sdGlwcyB3aWxsIFwib3BlblwiLCByZWxhdGl2ZSB0byB0aGUgaWNvbiBhbmNob3IuXHJcbiAgXHQgKlxyXG4gIFx0ICogQG9wdGlvbiBzaGFkb3dVcmw6IFN0cmluZyA9IG51bGxcclxuICBcdCAqIFRoZSBVUkwgdG8gdGhlIGljb24gc2hhZG93IGltYWdlLiBJZiBub3Qgc3BlY2lmaWVkLCBubyBzaGFkb3cgaW1hZ2Ugd2lsbCBiZSBjcmVhdGVkLlxyXG4gIFx0ICpcclxuICBcdCAqIEBvcHRpb24gc2hhZG93UmV0aW5hVXJsOiBTdHJpbmcgPSBudWxsXHJcbiAgXHQgKlxyXG4gIFx0ICogQG9wdGlvbiBzaGFkb3dTaXplOiBQb2ludCA9IG51bGxcclxuICBcdCAqIFNpemUgb2YgdGhlIHNoYWRvdyBpbWFnZSBpbiBwaXhlbHMuXHJcbiAgXHQgKlxyXG4gIFx0ICogQG9wdGlvbiBzaGFkb3dBbmNob3I6IFBvaW50ID0gbnVsbFxyXG4gIFx0ICogVGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBcInRpcFwiIG9mIHRoZSBzaGFkb3cgKHJlbGF0aXZlIHRvIGl0cyB0b3AgbGVmdCBjb3JuZXIpICh0aGUgc2FtZVxyXG4gIFx0ICogYXMgaWNvbkFuY2hvciBpZiBub3Qgc3BlY2lmaWVkKS5cclxuICBcdCAqXHJcbiAgXHQgKiBAb3B0aW9uIGNsYXNzTmFtZTogU3RyaW5nID0gJydcclxuICBcdCAqIEEgY3VzdG9tIGNsYXNzIG5hbWUgdG8gYXNzaWduIHRvIGJvdGggaWNvbiBhbmQgc2hhZG93IGltYWdlcy4gRW1wdHkgYnkgZGVmYXVsdC5cclxuICBcdCAqL1xyXG5cclxuICBcdG9wdGlvbnM6IHtcclxuICBcdFx0cG9wdXBBbmNob3I6IFswLCAwXSxcclxuICBcdFx0dG9vbHRpcEFuY2hvcjogWzAsIDBdXHJcbiAgXHR9LFxyXG5cclxuICBcdGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgXHRcdHNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgY3JlYXRlSWNvbihvbGRJY29uPzogSFRNTEVsZW1lbnQpOiBIVE1MRWxlbWVudFxyXG4gIFx0Ly8gQ2FsbGVkIGludGVybmFsbHkgd2hlbiB0aGUgaWNvbiBoYXMgdG8gYmUgc2hvd24sIHJldHVybnMgYSBgPGltZz5gIEhUTUwgZWxlbWVudFxyXG4gIFx0Ly8gc3R5bGVkIGFjY29yZGluZyB0byB0aGUgb3B0aW9ucy5cclxuICBcdGNyZWF0ZUljb246IGZ1bmN0aW9uIChvbGRJY29uKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLl9jcmVhdGVJY29uKCdpY29uJywgb2xkSWNvbik7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgY3JlYXRlU2hhZG93KG9sZEljb24/OiBIVE1MRWxlbWVudCk6IEhUTUxFbGVtZW50XHJcbiAgXHQvLyBBcyBgY3JlYXRlSWNvbmAsIGJ1dCBmb3IgdGhlIHNoYWRvdyBiZW5lYXRoIGl0LlxyXG4gIFx0Y3JlYXRlU2hhZG93OiBmdW5jdGlvbiAob2xkSWNvbikge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5fY3JlYXRlSWNvbignc2hhZG93Jywgb2xkSWNvbik7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9jcmVhdGVJY29uOiBmdW5jdGlvbiAobmFtZSwgb2xkSWNvbikge1xyXG4gIFx0XHR2YXIgc3JjID0gdGhpcy5fZ2V0SWNvblVybChuYW1lKTtcclxuXHJcbiAgXHRcdGlmICghc3JjKSB7XHJcbiAgXHRcdFx0aWYgKG5hbWUgPT09ICdpY29uJykge1xyXG4gIFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdpY29uVXJsIG5vdCBzZXQgaW4gSWNvbiBvcHRpb25zIChzZWUgdGhlIGRvY3MpLicpO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0XHRyZXR1cm4gbnVsbDtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dmFyIGltZyA9IHRoaXMuX2NyZWF0ZUltZyhzcmMsIG9sZEljb24gJiYgb2xkSWNvbi50YWdOYW1lID09PSAnSU1HJyA/IG9sZEljb24gOiBudWxsKTtcclxuICBcdFx0dGhpcy5fc2V0SWNvblN0eWxlcyhpbWcsIG5hbWUpO1xyXG5cclxuICBcdFx0cmV0dXJuIGltZztcclxuICBcdH0sXHJcblxyXG4gIFx0X3NldEljb25TdHlsZXM6IGZ1bmN0aW9uIChpbWcsIG5hbWUpIHtcclxuICBcdFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XHJcbiAgXHRcdHZhciBzaXplT3B0aW9uID0gb3B0aW9uc1tuYW1lICsgJ1NpemUnXTtcclxuXHJcbiAgXHRcdGlmICh0eXBlb2Ygc2l6ZU9wdGlvbiA9PT0gJ251bWJlcicpIHtcclxuICBcdFx0XHRzaXplT3B0aW9uID0gW3NpemVPcHRpb24sIHNpemVPcHRpb25dO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR2YXIgc2l6ZSA9IHRvUG9pbnQoc2l6ZU9wdGlvbiksXHJcbiAgXHRcdCAgICBhbmNob3IgPSB0b1BvaW50KG5hbWUgPT09ICdzaGFkb3cnICYmIG9wdGlvbnMuc2hhZG93QW5jaG9yIHx8IG9wdGlvbnMuaWNvbkFuY2hvciB8fFxyXG4gIFx0XHQgICAgICAgICAgICBzaXplICYmIHNpemUuZGl2aWRlQnkoMiwgdHJ1ZSkpO1xyXG5cclxuICBcdFx0aW1nLmNsYXNzTmFtZSA9ICdsZWFmbGV0LW1hcmtlci0nICsgbmFtZSArICcgJyArIChvcHRpb25zLmNsYXNzTmFtZSB8fCAnJyk7XHJcblxyXG4gIFx0XHRpZiAoYW5jaG9yKSB7XHJcbiAgXHRcdFx0aW1nLnN0eWxlLm1hcmdpbkxlZnQgPSAoLWFuY2hvci54KSArICdweCc7XHJcbiAgXHRcdFx0aW1nLnN0eWxlLm1hcmdpblRvcCAgPSAoLWFuY2hvci55KSArICdweCc7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGlmIChzaXplKSB7XHJcbiAgXHRcdFx0aW1nLnN0eWxlLndpZHRoICA9IHNpemUueCArICdweCc7XHJcbiAgXHRcdFx0aW1nLnN0eWxlLmhlaWdodCA9IHNpemUueSArICdweCc7XHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0X2NyZWF0ZUltZzogZnVuY3Rpb24gKHNyYywgZWwpIHtcclxuICBcdFx0ZWwgPSBlbCB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcclxuICBcdFx0ZWwuc3JjID0gc3JjO1xyXG4gIFx0XHRyZXR1cm4gZWw7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9nZXRJY29uVXJsOiBmdW5jdGlvbiAobmFtZSkge1xyXG4gIFx0XHRyZXR1cm4gcmV0aW5hICYmIHRoaXMub3B0aW9uc1tuYW1lICsgJ1JldGluYVVybCddIHx8IHRoaXMub3B0aW9uc1tuYW1lICsgJ1VybCddO1xyXG4gIFx0fVxyXG4gIH0pO1xyXG5cclxuXHJcbiAgLy8gQGZhY3RvcnkgTC5pY29uKG9wdGlvbnM6IEljb24gb3B0aW9ucylcclxuICAvLyBDcmVhdGVzIGFuIGljb24gaW5zdGFuY2Ugd2l0aCB0aGUgZ2l2ZW4gb3B0aW9ucy5cclxuICBmdW5jdGlvbiBpY29uKG9wdGlvbnMpIHtcclxuICBcdHJldHVybiBuZXcgSWNvbihvcHRpb25zKTtcclxuICB9XG5cbiAgLypcbiAgICogQG1pbmljbGFzcyBJY29uLkRlZmF1bHQgKEljb24pXG4gICAqIEBha2EgTC5JY29uLkRlZmF1bHRcbiAgICogQHNlY3Rpb25cbiAgICpcbiAgICogQSB0cml2aWFsIHN1YmNsYXNzIG9mIGBJY29uYCwgcmVwcmVzZW50cyB0aGUgaWNvbiB0byB1c2UgaW4gYE1hcmtlcmBzIHdoZW5cbiAgICogbm8gaWNvbiBpcyBzcGVjaWZpZWQuIFBvaW50cyB0byB0aGUgYmx1ZSBtYXJrZXIgaW1hZ2UgZGlzdHJpYnV0ZWQgd2l0aCBMZWFmbGV0XG4gICAqIHJlbGVhc2VzLlxuICAgKlxuICAgKiBJbiBvcmRlciB0byBjdXN0b21pemUgdGhlIGRlZmF1bHQgaWNvbiwganVzdCBjaGFuZ2UgdGhlIHByb3BlcnRpZXMgb2YgYEwuSWNvbi5EZWZhdWx0LnByb3RvdHlwZS5vcHRpb25zYFxuICAgKiAod2hpY2ggaXMgYSBzZXQgb2YgYEljb24gb3B0aW9uc2ApLlxuICAgKlxuICAgKiBJZiB5b3Ugd2FudCB0byBfY29tcGxldGVseV8gcmVwbGFjZSB0aGUgZGVmYXVsdCBpY29uLCBvdmVycmlkZSB0aGVcbiAgICogYEwuTWFya2VyLnByb3RvdHlwZS5vcHRpb25zLmljb25gIHdpdGggeW91ciBvd24gaWNvbiBpbnN0ZWFkLlxuICAgKi9cblxuICB2YXIgSWNvbkRlZmF1bHQgPSBJY29uLmV4dGVuZCh7XG5cbiAgXHRvcHRpb25zOiB7XG4gIFx0XHRpY29uVXJsOiAgICAgICAnbWFya2VyLWljb24ucG5nJyxcbiAgXHRcdGljb25SZXRpbmFVcmw6ICdtYXJrZXItaWNvbi0yeC5wbmcnLFxuICBcdFx0c2hhZG93VXJsOiAgICAgJ21hcmtlci1zaGFkb3cucG5nJyxcbiAgXHRcdGljb25TaXplOiAgICBbMjUsIDQxXSxcbiAgXHRcdGljb25BbmNob3I6ICBbMTIsIDQxXSxcbiAgXHRcdHBvcHVwQW5jaG9yOiBbMSwgLTM0XSxcbiAgXHRcdHRvb2x0aXBBbmNob3I6IFsxNiwgLTI4XSxcbiAgXHRcdHNoYWRvd1NpemU6ICBbNDEsIDQxXVxuICBcdH0sXG5cbiAgXHRfZ2V0SWNvblVybDogZnVuY3Rpb24gKG5hbWUpIHtcbiAgXHRcdGlmICghSWNvbkRlZmF1bHQuaW1hZ2VQYXRoKSB7XHQvLyBEZXByZWNhdGVkLCBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSBvbmx5XG4gIFx0XHRcdEljb25EZWZhdWx0LmltYWdlUGF0aCA9IHRoaXMuX2RldGVjdEljb25QYXRoKCk7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIEBvcHRpb24gaW1hZ2VQYXRoOiBTdHJpbmdcbiAgXHRcdC8vIGBJY29uLkRlZmF1bHRgIHdpbGwgdHJ5IHRvIGF1dG8tZGV0ZWN0IHRoZSBsb2NhdGlvbiBvZiB0aGVcbiAgXHRcdC8vIGJsdWUgaWNvbiBpbWFnZXMuIElmIHlvdSBhcmUgcGxhY2luZyB0aGVzZSBpbWFnZXMgaW4gYSBub24tc3RhbmRhcmRcbiAgXHRcdC8vIHdheSwgc2V0IHRoaXMgb3B0aW9uIHRvIHBvaW50IHRvIHRoZSByaWdodCBwYXRoLlxuICBcdFx0cmV0dXJuICh0aGlzLm9wdGlvbnMuaW1hZ2VQYXRoIHx8IEljb25EZWZhdWx0LmltYWdlUGF0aCkgKyBJY29uLnByb3RvdHlwZS5fZ2V0SWNvblVybC5jYWxsKHRoaXMsIG5hbWUpO1xuICBcdH0sXG5cbiAgXHRfZGV0ZWN0SWNvblBhdGg6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBlbCA9IGNyZWF0ZSQxKCdkaXYnLCAgJ2xlYWZsZXQtZGVmYXVsdC1pY29uLXBhdGgnLCBkb2N1bWVudC5ib2R5KTtcbiAgXHRcdHZhciBwYXRoID0gZ2V0U3R5bGUoZWwsICdiYWNrZ3JvdW5kLWltYWdlJykgfHxcbiAgXHRcdCAgICAgICAgICAgZ2V0U3R5bGUoZWwsICdiYWNrZ3JvdW5kSW1hZ2UnKTtcdC8vIElFOFxuXG4gIFx0XHRkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGVsKTtcblxuICBcdFx0aWYgKHBhdGggPT09IG51bGwgfHwgcGF0aC5pbmRleE9mKCd1cmwnKSAhPT0gMCkge1xuICBcdFx0XHRwYXRoID0gJyc7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRwYXRoID0gcGF0aC5yZXBsYWNlKC9edXJsXFwoW1wiJ10/LywgJycpLnJlcGxhY2UoL21hcmtlci1pY29uXFwucG5nW1wiJ10/XFwpJC8sICcnKTtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIHBhdGg7XG4gIFx0fVxuICB9KTtcblxuICAvKlxuICAgKiBMLkhhbmRsZXIuTWFya2VyRHJhZyBpcyB1c2VkIGludGVybmFsbHkgYnkgTC5NYXJrZXIgdG8gbWFrZSB0aGUgbWFya2VycyBkcmFnZ2FibGUuXG4gICAqL1xuXG5cbiAgLyogQG5hbWVzcGFjZSBNYXJrZXJcbiAgICogQHNlY3Rpb24gSW50ZXJhY3Rpb24gaGFuZGxlcnNcbiAgICpcbiAgICogSW50ZXJhY3Rpb24gaGFuZGxlcnMgYXJlIHByb3BlcnRpZXMgb2YgYSBtYXJrZXIgaW5zdGFuY2UgdGhhdCBhbGxvdyB5b3UgdG8gY29udHJvbCBpbnRlcmFjdGlvbiBiZWhhdmlvciBpbiBydW50aW1lLCBlbmFibGluZyBvciBkaXNhYmxpbmcgY2VydGFpbiBmZWF0dXJlcyBzdWNoIGFzIGRyYWdnaW5nIChzZWUgYEhhbmRsZXJgIG1ldGhvZHMpLiBFeGFtcGxlOlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBtYXJrZXIuZHJhZ2dpbmcuZGlzYWJsZSgpO1xuICAgKiBgYGBcbiAgICpcbiAgICogQHByb3BlcnR5IGRyYWdnaW5nOiBIYW5kbGVyXG4gICAqIE1hcmtlciBkcmFnZ2luZyBoYW5kbGVyIChieSBib3RoIG1vdXNlIGFuZCB0b3VjaCkuIE9ubHkgdmFsaWQgd2hlbiB0aGUgbWFya2VyIGlzIG9uIHRoZSBtYXAgKE90aGVyd2lzZSBzZXQgW2BtYXJrZXIub3B0aW9ucy5kcmFnZ2FibGVgXSgjbWFya2VyLWRyYWdnYWJsZSkpLlxuICAgKi9cblxuICB2YXIgTWFya2VyRHJhZyA9IEhhbmRsZXIuZXh0ZW5kKHtcbiAgXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobWFya2VyKSB7XG4gIFx0XHR0aGlzLl9tYXJrZXIgPSBtYXJrZXI7XG4gIFx0fSxcblxuICBcdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgaWNvbiA9IHRoaXMuX21hcmtlci5faWNvbjtcblxuICBcdFx0aWYgKCF0aGlzLl9kcmFnZ2FibGUpIHtcbiAgXHRcdFx0dGhpcy5fZHJhZ2dhYmxlID0gbmV3IERyYWdnYWJsZShpY29uLCBpY29uLCB0cnVlKTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5fZHJhZ2dhYmxlLm9uKHtcbiAgXHRcdFx0ZHJhZ3N0YXJ0OiB0aGlzLl9vbkRyYWdTdGFydCxcbiAgXHRcdFx0cHJlZHJhZzogdGhpcy5fb25QcmVEcmFnLFxuICBcdFx0XHRkcmFnOiB0aGlzLl9vbkRyYWcsXG4gIFx0XHRcdGRyYWdlbmQ6IHRoaXMuX29uRHJhZ0VuZFxuICBcdFx0fSwgdGhpcykuZW5hYmxlKCk7XG5cbiAgXHRcdGFkZENsYXNzKGljb24sICdsZWFmbGV0LW1hcmtlci1kcmFnZ2FibGUnKTtcbiAgXHR9LFxuXG4gIFx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMuX2RyYWdnYWJsZS5vZmYoe1xuICBcdFx0XHRkcmFnc3RhcnQ6IHRoaXMuX29uRHJhZ1N0YXJ0LFxuICBcdFx0XHRwcmVkcmFnOiB0aGlzLl9vblByZURyYWcsXG4gIFx0XHRcdGRyYWc6IHRoaXMuX29uRHJhZyxcbiAgXHRcdFx0ZHJhZ2VuZDogdGhpcy5fb25EcmFnRW5kXG4gIFx0XHR9LCB0aGlzKS5kaXNhYmxlKCk7XG5cbiAgXHRcdGlmICh0aGlzLl9tYXJrZXIuX2ljb24pIHtcbiAgXHRcdFx0cmVtb3ZlQ2xhc3ModGhpcy5fbWFya2VyLl9pY29uLCAnbGVhZmxldC1tYXJrZXItZHJhZ2dhYmxlJyk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdG1vdmVkOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5fZHJhZ2dhYmxlICYmIHRoaXMuX2RyYWdnYWJsZS5fbW92ZWQ7XG4gIFx0fSxcblxuICBcdF9hZGp1c3RQYW46IGZ1bmN0aW9uIChlKSB7XG4gIFx0XHR2YXIgbWFya2VyID0gdGhpcy5fbWFya2VyLFxuICBcdFx0ICAgIG1hcCA9IG1hcmtlci5fbWFwLFxuICBcdFx0ICAgIHNwZWVkID0gdGhpcy5fbWFya2VyLm9wdGlvbnMuYXV0b1BhblNwZWVkLFxuICBcdFx0ICAgIHBhZGRpbmcgPSB0aGlzLl9tYXJrZXIub3B0aW9ucy5hdXRvUGFuUGFkZGluZyxcbiAgXHRcdCAgICBpY29uUG9zID0gZ2V0UG9zaXRpb24obWFya2VyLl9pY29uKSxcbiAgXHRcdCAgICBib3VuZHMgPSBtYXAuZ2V0UGl4ZWxCb3VuZHMoKSxcbiAgXHRcdCAgICBvcmlnaW4gPSBtYXAuZ2V0UGl4ZWxPcmlnaW4oKTtcblxuICBcdFx0dmFyIHBhbkJvdW5kcyA9IHRvQm91bmRzKFxuICBcdFx0XHRib3VuZHMubWluLl9zdWJ0cmFjdChvcmlnaW4pLmFkZChwYWRkaW5nKSxcbiAgXHRcdFx0Ym91bmRzLm1heC5fc3VidHJhY3Qob3JpZ2luKS5zdWJ0cmFjdChwYWRkaW5nKVxuICBcdFx0KTtcblxuICBcdFx0aWYgKCFwYW5Cb3VuZHMuY29udGFpbnMoaWNvblBvcykpIHtcbiAgXHRcdFx0Ly8gQ29tcHV0ZSBpbmNyZW1lbnRhbCBtb3ZlbWVudFxuICBcdFx0XHR2YXIgbW92ZW1lbnQgPSB0b1BvaW50KFxuICBcdFx0XHRcdChNYXRoLm1heChwYW5Cb3VuZHMubWF4LngsIGljb25Qb3MueCkgLSBwYW5Cb3VuZHMubWF4LngpIC8gKGJvdW5kcy5tYXgueCAtIHBhbkJvdW5kcy5tYXgueCkgLVxuICBcdFx0XHRcdChNYXRoLm1pbihwYW5Cb3VuZHMubWluLngsIGljb25Qb3MueCkgLSBwYW5Cb3VuZHMubWluLngpIC8gKGJvdW5kcy5taW4ueCAtIHBhbkJvdW5kcy5taW4ueCksXG5cbiAgXHRcdFx0XHQoTWF0aC5tYXgocGFuQm91bmRzLm1heC55LCBpY29uUG9zLnkpIC0gcGFuQm91bmRzLm1heC55KSAvIChib3VuZHMubWF4LnkgLSBwYW5Cb3VuZHMubWF4LnkpIC1cbiAgXHRcdFx0XHQoTWF0aC5taW4ocGFuQm91bmRzLm1pbi55LCBpY29uUG9zLnkpIC0gcGFuQm91bmRzLm1pbi55KSAvIChib3VuZHMubWluLnkgLSBwYW5Cb3VuZHMubWluLnkpXG4gIFx0XHRcdCkubXVsdGlwbHlCeShzcGVlZCk7XG5cbiAgXHRcdFx0bWFwLnBhbkJ5KG1vdmVtZW50LCB7YW5pbWF0ZTogZmFsc2V9KTtcblxuICBcdFx0XHR0aGlzLl9kcmFnZ2FibGUuX25ld1Bvcy5fYWRkKG1vdmVtZW50KTtcbiAgXHRcdFx0dGhpcy5fZHJhZ2dhYmxlLl9zdGFydFBvcy5fYWRkKG1vdmVtZW50KTtcblxuICBcdFx0XHRzZXRQb3NpdGlvbihtYXJrZXIuX2ljb24sIHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zKTtcbiAgXHRcdFx0dGhpcy5fb25EcmFnKGUpO1xuXG4gIFx0XHRcdHRoaXMuX3BhblJlcXVlc3QgPSByZXF1ZXN0QW5pbUZyYW1lKHRoaXMuX2FkanVzdFBhbi5iaW5kKHRoaXMsIGUpKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X29uRHJhZ1N0YXJ0OiBmdW5jdGlvbiAoKSB7XG4gIFx0XHQvLyBAc2VjdGlvbiBEcmFnZ2luZyBldmVudHNcbiAgXHRcdC8vIEBldmVudCBkcmFnc3RhcnQ6IEV2ZW50XG4gIFx0XHQvLyBGaXJlZCB3aGVuIHRoZSB1c2VyIHN0YXJ0cyBkcmFnZ2luZyB0aGUgbWFya2VyLlxuXG4gIFx0XHQvLyBAZXZlbnQgbW92ZXN0YXJ0OiBFdmVudFxuICBcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFya2VyIHN0YXJ0cyBtb3ZpbmcgKGJlY2F1c2Ugb2YgZHJhZ2dpbmcpLlxuXG4gIFx0XHR0aGlzLl9vbGRMYXRMbmcgPSB0aGlzLl9tYXJrZXIuZ2V0TGF0TG5nKCk7XG5cbiAgXHRcdC8vIFdoZW4gdXNpbmcgRVM2IGltcG9ydHMgaXQgY291bGQgbm90IGJlIHNldCB3aGVuIGBQb3B1cGAgd2FzIG5vdCBpbXBvcnRlZCBhcyB3ZWxsXG4gIFx0XHR0aGlzLl9tYXJrZXIuY2xvc2VQb3B1cCAmJiB0aGlzLl9tYXJrZXIuY2xvc2VQb3B1cCgpO1xuXG4gIFx0XHR0aGlzLl9tYXJrZXJcbiAgXHRcdFx0LmZpcmUoJ21vdmVzdGFydCcpXG4gIFx0XHRcdC5maXJlKCdkcmFnc3RhcnQnKTtcbiAgXHR9LFxuXG4gIFx0X29uUHJlRHJhZzogZnVuY3Rpb24gKGUpIHtcbiAgXHRcdGlmICh0aGlzLl9tYXJrZXIub3B0aW9ucy5hdXRvUGFuKSB7XG4gIFx0XHRcdGNhbmNlbEFuaW1GcmFtZSh0aGlzLl9wYW5SZXF1ZXN0KTtcbiAgXHRcdFx0dGhpcy5fcGFuUmVxdWVzdCA9IHJlcXVlc3RBbmltRnJhbWUodGhpcy5fYWRqdXN0UGFuLmJpbmQodGhpcywgZSkpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfb25EcmFnOiBmdW5jdGlvbiAoZSkge1xuICBcdFx0dmFyIG1hcmtlciA9IHRoaXMuX21hcmtlcixcbiAgXHRcdCAgICBzaGFkb3cgPSBtYXJrZXIuX3NoYWRvdyxcbiAgXHRcdCAgICBpY29uUG9zID0gZ2V0UG9zaXRpb24obWFya2VyLl9pY29uKSxcbiAgXHRcdCAgICBsYXRsbmcgPSBtYXJrZXIuX21hcC5sYXllclBvaW50VG9MYXRMbmcoaWNvblBvcyk7XG5cbiAgXHRcdC8vIHVwZGF0ZSBzaGFkb3cgcG9zaXRpb25cbiAgXHRcdGlmIChzaGFkb3cpIHtcbiAgXHRcdFx0c2V0UG9zaXRpb24oc2hhZG93LCBpY29uUG9zKTtcbiAgXHRcdH1cblxuICBcdFx0bWFya2VyLl9sYXRsbmcgPSBsYXRsbmc7XG4gIFx0XHRlLmxhdGxuZyA9IGxhdGxuZztcbiAgXHRcdGUub2xkTGF0TG5nID0gdGhpcy5fb2xkTGF0TG5nO1xuXG4gIFx0XHQvLyBAZXZlbnQgZHJhZzogRXZlbnRcbiAgXHRcdC8vIEZpcmVkIHJlcGVhdGVkbHkgd2hpbGUgdGhlIHVzZXIgZHJhZ3MgdGhlIG1hcmtlci5cbiAgXHRcdG1hcmtlclxuICBcdFx0ICAgIC5maXJlKCdtb3ZlJywgZSlcbiAgXHRcdCAgICAuZmlyZSgnZHJhZycsIGUpO1xuICBcdH0sXG5cbiAgXHRfb25EcmFnRW5kOiBmdW5jdGlvbiAoZSkge1xuICBcdFx0Ly8gQGV2ZW50IGRyYWdlbmQ6IERyYWdFbmRFdmVudFxuICBcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdXNlciBzdG9wcyBkcmFnZ2luZyB0aGUgbWFya2VyLlxuXG4gIFx0XHQgY2FuY2VsQW5pbUZyYW1lKHRoaXMuX3BhblJlcXVlc3QpO1xuXG4gIFx0XHQvLyBAZXZlbnQgbW92ZWVuZDogRXZlbnRcbiAgXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcmtlciBzdG9wcyBtb3ZpbmcgKGJlY2F1c2Ugb2YgZHJhZ2dpbmcpLlxuICBcdFx0ZGVsZXRlIHRoaXMuX29sZExhdExuZztcbiAgXHRcdHRoaXMuX21hcmtlclxuICBcdFx0ICAgIC5maXJlKCdtb3ZlZW5kJylcbiAgXHRcdCAgICAuZmlyZSgnZHJhZ2VuZCcsIGUpO1xuICBcdH1cbiAgfSk7XG5cbiAgLypcclxuICAgKiBAY2xhc3MgTWFya2VyXHJcbiAgICogQGluaGVyaXRzIEludGVyYWN0aXZlIGxheWVyXHJcbiAgICogQGFrYSBMLk1hcmtlclxyXG4gICAqIEwuTWFya2VyIGlzIHVzZWQgdG8gZGlzcGxheSBjbGlja2FibGUvZHJhZ2dhYmxlIGljb25zIG9uIHRoZSBtYXAuIEV4dGVuZHMgYExheWVyYC5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICpcclxuICAgKiBgYGBqc1xyXG4gICAqIEwubWFya2VyKFs1MC41LCAzMC41XSkuYWRkVG8obWFwKTtcclxuICAgKiBgYGBcclxuICAgKi9cclxuXHJcbiAgdmFyIE1hcmtlciA9IExheWVyLmV4dGVuZCh7XHJcblxyXG4gIFx0Ly8gQHNlY3Rpb25cclxuICBcdC8vIEBha2EgTWFya2VyIG9wdGlvbnNcclxuICBcdG9wdGlvbnM6IHtcclxuICBcdFx0Ly8gQG9wdGlvbiBpY29uOiBJY29uID0gKlxyXG4gIFx0XHQvLyBJY29uIGluc3RhbmNlIHRvIHVzZSBmb3IgcmVuZGVyaW5nIHRoZSBtYXJrZXIuXHJcbiAgXHRcdC8vIFNlZSBbSWNvbiBkb2N1bWVudGF0aW9uXSgjTC5JY29uKSBmb3IgZGV0YWlscyBvbiBob3cgdG8gY3VzdG9taXplIHRoZSBtYXJrZXIgaWNvbi5cclxuICBcdFx0Ly8gSWYgbm90IHNwZWNpZmllZCwgYSBjb21tb24gaW5zdGFuY2Ugb2YgYEwuSWNvbi5EZWZhdWx0YCBpcyB1c2VkLlxyXG4gIFx0XHRpY29uOiBuZXcgSWNvbkRlZmF1bHQoKSxcclxuXHJcbiAgXHRcdC8vIE9wdGlvbiBpbmhlcml0ZWQgZnJvbSBcIkludGVyYWN0aXZlIGxheWVyXCIgYWJzdHJhY3QgY2xhc3NcclxuICBcdFx0aW50ZXJhY3RpdmU6IHRydWUsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIGtleWJvYXJkOiBCb29sZWFuID0gdHJ1ZVxyXG4gIFx0XHQvLyBXaGV0aGVyIHRoZSBtYXJrZXIgY2FuIGJlIHRhYmJlZCB0byB3aXRoIGEga2V5Ym9hcmQgYW5kIGNsaWNrZWQgYnkgcHJlc3NpbmcgZW50ZXIuXHJcbiAgXHRcdGtleWJvYXJkOiB0cnVlLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiB0aXRsZTogU3RyaW5nID0gJydcclxuICBcdFx0Ly8gVGV4dCBmb3IgdGhlIGJyb3dzZXIgdG9vbHRpcCB0aGF0IGFwcGVhciBvbiBtYXJrZXIgaG92ZXIgKG5vIHRvb2x0aXAgYnkgZGVmYXVsdCkuXHJcbiAgXHRcdHRpdGxlOiAnJyxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gYWx0OiBTdHJpbmcgPSAnJ1xyXG4gIFx0XHQvLyBUZXh0IGZvciB0aGUgYGFsdGAgYXR0cmlidXRlIG9mIHRoZSBpY29uIGltYWdlICh1c2VmdWwgZm9yIGFjY2Vzc2liaWxpdHkpLlxyXG4gIFx0XHRhbHQ6ICcnLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiB6SW5kZXhPZmZzZXQ6IE51bWJlciA9IDBcclxuICBcdFx0Ly8gQnkgZGVmYXVsdCwgbWFya2VyIGltYWdlcyB6SW5kZXggaXMgc2V0IGF1dG9tYXRpY2FsbHkgYmFzZWQgb24gaXRzIGxhdGl0dWRlLiBVc2UgdGhpcyBvcHRpb24gaWYgeW91IHdhbnQgdG8gcHV0IHRoZSBtYXJrZXIgb24gdG9wIG9mIGFsbCBvdGhlcnMgKG9yIGJlbG93KSwgc3BlY2lmeWluZyBhIGhpZ2ggdmFsdWUgbGlrZSBgMTAwMGAgKG9yIGhpZ2ggbmVnYXRpdmUgdmFsdWUsIHJlc3BlY3RpdmVseSkuXHJcbiAgXHRcdHpJbmRleE9mZnNldDogMCxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gb3BhY2l0eTogTnVtYmVyID0gMS4wXHJcbiAgXHRcdC8vIFRoZSBvcGFjaXR5IG9mIHRoZSBtYXJrZXIuXHJcbiAgXHRcdG9wYWNpdHk6IDEsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIHJpc2VPbkhvdmVyOiBCb29sZWFuID0gZmFsc2VcclxuICBcdFx0Ly8gSWYgYHRydWVgLCB0aGUgbWFya2VyIHdpbGwgZ2V0IG9uIHRvcCBvZiBvdGhlcnMgd2hlbiB5b3UgaG92ZXIgdGhlIG1vdXNlIG92ZXIgaXQuXHJcbiAgXHRcdHJpc2VPbkhvdmVyOiBmYWxzZSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gcmlzZU9mZnNldDogTnVtYmVyID0gMjUwXHJcbiAgXHRcdC8vIFRoZSB6LWluZGV4IG9mZnNldCB1c2VkIGZvciB0aGUgYHJpc2VPbkhvdmVyYCBmZWF0dXJlLlxyXG4gIFx0XHRyaXNlT2Zmc2V0OiAyNTAsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIHBhbmU6IFN0cmluZyA9ICdtYXJrZXJQYW5lJ1xyXG4gIFx0XHQvLyBgTWFwIHBhbmVgIHdoZXJlIHRoZSBtYXJrZXJzIGljb24gd2lsbCBiZSBhZGRlZC5cclxuICBcdFx0cGFuZTogJ21hcmtlclBhbmUnLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBzaGFkb3dQYW5lOiBTdHJpbmcgPSAnc2hhZG93UGFuZSdcclxuICBcdFx0Ly8gYE1hcCBwYW5lYCB3aGVyZSB0aGUgbWFya2VycyBzaGFkb3cgd2lsbCBiZSBhZGRlZC5cclxuICBcdFx0c2hhZG93UGFuZTogJ3NoYWRvd1BhbmUnLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBidWJibGluZ01vdXNlRXZlbnRzOiBCb29sZWFuID0gZmFsc2VcclxuICBcdFx0Ly8gV2hlbiBgdHJ1ZWAsIGEgbW91c2UgZXZlbnQgb24gdGhpcyBtYXJrZXIgd2lsbCB0cmlnZ2VyIHRoZSBzYW1lIGV2ZW50IG9uIHRoZSBtYXBcclxuICBcdFx0Ly8gKHVubGVzcyBbYEwuRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uYF0oI2RvbWV2ZW50LXN0b3Bwcm9wYWdhdGlvbikgaXMgdXNlZCkuXHJcbiAgXHRcdGJ1YmJsaW5nTW91c2VFdmVudHM6IGZhbHNlLFxyXG5cclxuICBcdFx0Ly8gQHNlY3Rpb24gRHJhZ2dhYmxlIG1hcmtlciBvcHRpb25zXHJcbiAgXHRcdC8vIEBvcHRpb24gZHJhZ2dhYmxlOiBCb29sZWFuID0gZmFsc2VcclxuICBcdFx0Ly8gV2hldGhlciB0aGUgbWFya2VyIGlzIGRyYWdnYWJsZSB3aXRoIG1vdXNlL3RvdWNoIG9yIG5vdC5cclxuICBcdFx0ZHJhZ2dhYmxlOiBmYWxzZSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gYXV0b1BhbjogQm9vbGVhbiA9IGZhbHNlXHJcbiAgXHRcdC8vIFdoZXRoZXIgdG8gcGFuIHRoZSBtYXAgd2hlbiBkcmFnZ2luZyB0aGlzIG1hcmtlciBuZWFyIGl0cyBlZGdlIG9yIG5vdC5cclxuICBcdFx0YXV0b1BhbjogZmFsc2UsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIGF1dG9QYW5QYWRkaW5nOiBQb2ludCA9IFBvaW50KDUwLCA1MClcclxuICBcdFx0Ly8gRGlzdGFuY2UgKGluIHBpeGVscyB0byB0aGUgbGVmdC9yaWdodCBhbmQgdG8gdGhlIHRvcC9ib3R0b20pIG9mIHRoZVxyXG4gIFx0XHQvLyBtYXAgZWRnZSB0byBzdGFydCBwYW5uaW5nIHRoZSBtYXAuXHJcbiAgXHRcdGF1dG9QYW5QYWRkaW5nOiBbNTAsIDUwXSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gYXV0b1BhblNwZWVkOiBOdW1iZXIgPSAxMFxyXG4gIFx0XHQvLyBOdW1iZXIgb2YgcGl4ZWxzIHRoZSBtYXAgc2hvdWxkIHBhbiBieS5cclxuICBcdFx0YXV0b1BhblNwZWVkOiAxMFxyXG4gIFx0fSxcclxuXHJcbiAgXHQvKiBAc2VjdGlvblxyXG4gIFx0ICpcclxuICBcdCAqIEluIGFkZGl0aW9uIHRvIFtzaGFyZWQgbGF5ZXIgbWV0aG9kc10oI0xheWVyKSBsaWtlIGBhZGRUbygpYCBhbmQgYHJlbW92ZSgpYCBhbmQgW3BvcHVwIG1ldGhvZHNdKCNQb3B1cCkgbGlrZSBiaW5kUG9wdXAoKSB5b3UgY2FuIGFsc28gdXNlIHRoZSBmb2xsb3dpbmcgbWV0aG9kczpcclxuICBcdCAqL1xyXG5cclxuICBcdGluaXRpYWxpemU6IGZ1bmN0aW9uIChsYXRsbmcsIG9wdGlvbnMpIHtcclxuICBcdFx0c2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuICBcdFx0dGhpcy5fbGF0bG5nID0gdG9MYXRMbmcobGF0bG5nKTtcclxuICBcdH0sXHJcblxyXG4gIFx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuICBcdFx0dGhpcy5fem9vbUFuaW1hdGVkID0gdGhpcy5fem9vbUFuaW1hdGVkICYmIG1hcC5vcHRpb25zLm1hcmtlclpvb21BbmltYXRpb247XHJcblxyXG4gIFx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XHJcbiAgXHRcdFx0bWFwLm9uKCd6b29tYW5pbScsIHRoaXMuX2FuaW1hdGVab29tLCB0aGlzKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dGhpcy5faW5pdEljb24oKTtcclxuICBcdFx0dGhpcy51cGRhdGUoKTtcclxuICBcdH0sXHJcblxyXG4gIFx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcclxuICBcdFx0aWYgKHRoaXMuZHJhZ2dpbmcgJiYgdGhpcy5kcmFnZ2luZy5lbmFibGVkKCkpIHtcclxuICBcdFx0XHR0aGlzLm9wdGlvbnMuZHJhZ2dhYmxlID0gdHJ1ZTtcclxuICBcdFx0XHR0aGlzLmRyYWdnaW5nLnJlbW92ZUhvb2tzKCk7XHJcbiAgXHRcdH1cclxuICBcdFx0ZGVsZXRlIHRoaXMuZHJhZ2dpbmc7XHJcblxyXG4gIFx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XHJcbiAgXHRcdFx0bWFwLm9mZignem9vbWFuaW0nLCB0aGlzLl9hbmltYXRlWm9vbSwgdGhpcyk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMuX3JlbW92ZUljb24oKTtcclxuICBcdFx0dGhpcy5fcmVtb3ZlU2hhZG93KCk7XHJcbiAgXHR9LFxyXG5cclxuICBcdGdldEV2ZW50czogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4ge1xyXG4gIFx0XHRcdHpvb206IHRoaXMudXBkYXRlLFxyXG4gIFx0XHRcdHZpZXdyZXNldDogdGhpcy51cGRhdGVcclxuICBcdFx0fTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRMYXRMbmc6IExhdExuZ1xyXG4gIFx0Ly8gUmV0dXJucyB0aGUgY3VycmVudCBnZW9ncmFwaGljYWwgcG9zaXRpb24gb2YgdGhlIG1hcmtlci5cclxuICBcdGdldExhdExuZzogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5fbGF0bG5nO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHNldExhdExuZyhsYXRsbmc6IExhdExuZyk6IHRoaXNcclxuICBcdC8vIENoYW5nZXMgdGhlIG1hcmtlciBwb3NpdGlvbiB0byB0aGUgZ2l2ZW4gcG9pbnQuXHJcbiAgXHRzZXRMYXRMbmc6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuICBcdFx0dmFyIG9sZExhdExuZyA9IHRoaXMuX2xhdGxuZztcclxuICBcdFx0dGhpcy5fbGF0bG5nID0gdG9MYXRMbmcobGF0bG5nKTtcclxuICBcdFx0dGhpcy51cGRhdGUoKTtcclxuXHJcbiAgXHRcdC8vIEBldmVudCBtb3ZlOiBFdmVudFxyXG4gIFx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXJrZXIgaXMgbW92ZWQgdmlhIFtgc2V0TGF0TG5nYF0oI21hcmtlci1zZXRsYXRsbmcpIG9yIGJ5IFtkcmFnZ2luZ10oI21hcmtlci1kcmFnZ2luZykuIE9sZCBhbmQgbmV3IGNvb3JkaW5hdGVzIGFyZSBpbmNsdWRlZCBpbiBldmVudCBhcmd1bWVudHMgYXMgYG9sZExhdExuZ2AsIGBsYXRsbmdgLlxyXG4gIFx0XHRyZXR1cm4gdGhpcy5maXJlKCdtb3ZlJywge29sZExhdExuZzogb2xkTGF0TG5nLCBsYXRsbmc6IHRoaXMuX2xhdGxuZ30pO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHNldFpJbmRleE9mZnNldChvZmZzZXQ6IE51bWJlcik6IHRoaXNcclxuICBcdC8vIENoYW5nZXMgdGhlIFt6SW5kZXggb2Zmc2V0XSgjbWFya2VyLXppbmRleG9mZnNldCkgb2YgdGhlIG1hcmtlci5cclxuICBcdHNldFpJbmRleE9mZnNldDogZnVuY3Rpb24gKG9mZnNldCkge1xyXG4gIFx0XHR0aGlzLm9wdGlvbnMuekluZGV4T2Zmc2V0ID0gb2Zmc2V0O1xyXG4gIFx0XHRyZXR1cm4gdGhpcy51cGRhdGUoKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRJY29uOiBJY29uXHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBjdXJyZW50IGljb24gdXNlZCBieSB0aGUgbWFya2VyXHJcbiAgXHRnZXRJY29uOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuaWNvbjtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBzZXRJY29uKGljb246IEljb24pOiB0aGlzXHJcbiAgXHQvLyBDaGFuZ2VzIHRoZSBtYXJrZXIgaWNvbi5cclxuICBcdHNldEljb246IGZ1bmN0aW9uIChpY29uKSB7XHJcblxyXG4gIFx0XHR0aGlzLm9wdGlvbnMuaWNvbiA9IGljb247XHJcblxyXG4gIFx0XHRpZiAodGhpcy5fbWFwKSB7XHJcbiAgXHRcdFx0dGhpcy5faW5pdEljb24oKTtcclxuICBcdFx0XHR0aGlzLnVwZGF0ZSgpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRpZiAodGhpcy5fcG9wdXApIHtcclxuICBcdFx0XHR0aGlzLmJpbmRQb3B1cCh0aGlzLl9wb3B1cCwgdGhpcy5fcG9wdXAub3B0aW9ucyk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRnZXRFbGVtZW50OiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLl9pY29uO1xyXG4gIFx0fSxcclxuXHJcbiAgXHR1cGRhdGU6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgXHRcdGlmICh0aGlzLl9pY29uICYmIHRoaXMuX21hcCkge1xyXG4gIFx0XHRcdHZhciBwb3MgPSB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX2xhdGxuZykucm91bmQoKTtcclxuICBcdFx0XHR0aGlzLl9zZXRQb3MocG9zKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9pbml0SWNvbjogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcclxuICBcdFx0ICAgIGNsYXNzVG9BZGQgPSAnbGVhZmxldC16b29tLScgKyAodGhpcy5fem9vbUFuaW1hdGVkID8gJ2FuaW1hdGVkJyA6ICdoaWRlJyk7XHJcblxyXG4gIFx0XHR2YXIgaWNvbiA9IG9wdGlvbnMuaWNvbi5jcmVhdGVJY29uKHRoaXMuX2ljb24pLFxyXG4gIFx0XHQgICAgYWRkSWNvbiA9IGZhbHNlO1xyXG5cclxuICBcdFx0Ly8gaWYgd2UncmUgbm90IHJldXNpbmcgdGhlIGljb24sIHJlbW92ZSB0aGUgb2xkIG9uZSBhbmQgaW5pdCBuZXcgb25lXHJcbiAgXHRcdGlmIChpY29uICE9PSB0aGlzLl9pY29uKSB7XHJcbiAgXHRcdFx0aWYgKHRoaXMuX2ljb24pIHtcclxuICBcdFx0XHRcdHRoaXMuX3JlbW92ZUljb24oKTtcclxuICBcdFx0XHR9XHJcbiAgXHRcdFx0YWRkSWNvbiA9IHRydWU7XHJcblxyXG4gIFx0XHRcdGlmIChvcHRpb25zLnRpdGxlKSB7XHJcbiAgXHRcdFx0XHRpY29uLnRpdGxlID0gb3B0aW9ucy50aXRsZTtcclxuICBcdFx0XHR9XHJcblxyXG4gIFx0XHRcdGlmIChpY29uLnRhZ05hbWUgPT09ICdJTUcnKSB7XHJcbiAgXHRcdFx0XHRpY29uLmFsdCA9IG9wdGlvbnMuYWx0IHx8ICcnO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0fVxyXG5cclxuICBcdFx0YWRkQ2xhc3MoaWNvbiwgY2xhc3NUb0FkZCk7XHJcblxyXG4gIFx0XHRpZiAob3B0aW9ucy5rZXlib2FyZCkge1xyXG4gIFx0XHRcdGljb24udGFiSW5kZXggPSAnMCc7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMuX2ljb24gPSBpY29uO1xyXG5cclxuICBcdFx0aWYgKG9wdGlvbnMucmlzZU9uSG92ZXIpIHtcclxuICBcdFx0XHR0aGlzLm9uKHtcclxuICBcdFx0XHRcdG1vdXNlb3ZlcjogdGhpcy5fYnJpbmdUb0Zyb250LFxyXG4gIFx0XHRcdFx0bW91c2VvdXQ6IHRoaXMuX3Jlc2V0WkluZGV4XHJcbiAgXHRcdFx0fSk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHZhciBuZXdTaGFkb3cgPSBvcHRpb25zLmljb24uY3JlYXRlU2hhZG93KHRoaXMuX3NoYWRvdyksXHJcbiAgXHRcdCAgICBhZGRTaGFkb3cgPSBmYWxzZTtcclxuXHJcbiAgXHRcdGlmIChuZXdTaGFkb3cgIT09IHRoaXMuX3NoYWRvdykge1xyXG4gIFx0XHRcdHRoaXMuX3JlbW92ZVNoYWRvdygpO1xyXG4gIFx0XHRcdGFkZFNoYWRvdyA9IHRydWU7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGlmIChuZXdTaGFkb3cpIHtcclxuICBcdFx0XHRhZGRDbGFzcyhuZXdTaGFkb3csIGNsYXNzVG9BZGQpO1xyXG4gIFx0XHRcdG5ld1NoYWRvdy5hbHQgPSAnJztcclxuICBcdFx0fVxyXG4gIFx0XHR0aGlzLl9zaGFkb3cgPSBuZXdTaGFkb3c7XHJcblxyXG5cclxuICBcdFx0aWYgKG9wdGlvbnMub3BhY2l0eSA8IDEpIHtcclxuICBcdFx0XHR0aGlzLl91cGRhdGVPcGFjaXR5KCk7XHJcbiAgXHRcdH1cclxuXHJcblxyXG4gIFx0XHRpZiAoYWRkSWNvbikge1xyXG4gIFx0XHRcdHRoaXMuZ2V0UGFuZSgpLmFwcGVuZENoaWxkKHRoaXMuX2ljb24pO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHRoaXMuX2luaXRJbnRlcmFjdGlvbigpO1xyXG4gIFx0XHRpZiAobmV3U2hhZG93ICYmIGFkZFNoYWRvdykge1xyXG4gIFx0XHRcdHRoaXMuZ2V0UGFuZShvcHRpb25zLnNoYWRvd1BhbmUpLmFwcGVuZENoaWxkKHRoaXMuX3NoYWRvdyk7XHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0X3JlbW92ZUljb246IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0aWYgKHRoaXMub3B0aW9ucy5yaXNlT25Ib3Zlcikge1xyXG4gIFx0XHRcdHRoaXMub2ZmKHtcclxuICBcdFx0XHRcdG1vdXNlb3ZlcjogdGhpcy5fYnJpbmdUb0Zyb250LFxyXG4gIFx0XHRcdFx0bW91c2VvdXQ6IHRoaXMuX3Jlc2V0WkluZGV4XHJcbiAgXHRcdFx0fSk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHJlbW92ZSh0aGlzLl9pY29uKTtcclxuICBcdFx0dGhpcy5yZW1vdmVJbnRlcmFjdGl2ZVRhcmdldCh0aGlzLl9pY29uKTtcclxuXHJcbiAgXHRcdHRoaXMuX2ljb24gPSBudWxsO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfcmVtb3ZlU2hhZG93OiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdGlmICh0aGlzLl9zaGFkb3cpIHtcclxuICBcdFx0XHRyZW1vdmUodGhpcy5fc2hhZG93KTtcclxuICBcdFx0fVxyXG4gIFx0XHR0aGlzLl9zaGFkb3cgPSBudWxsO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfc2V0UG9zOiBmdW5jdGlvbiAocG9zKSB7XHJcblxyXG4gIFx0XHRpZiAodGhpcy5faWNvbikge1xyXG4gIFx0XHRcdHNldFBvc2l0aW9uKHRoaXMuX2ljb24sIHBvcyk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGlmICh0aGlzLl9zaGFkb3cpIHtcclxuICBcdFx0XHRzZXRQb3NpdGlvbih0aGlzLl9zaGFkb3csIHBvcyk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMuX3pJbmRleCA9IHBvcy55ICsgdGhpcy5vcHRpb25zLnpJbmRleE9mZnNldDtcclxuXHJcbiAgXHRcdHRoaXMuX3Jlc2V0WkluZGV4KCk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF91cGRhdGVaSW5kZXg6IGZ1bmN0aW9uIChvZmZzZXQpIHtcclxuICBcdFx0aWYgKHRoaXMuX2ljb24pIHtcclxuICBcdFx0XHR0aGlzLl9pY29uLnN0eWxlLnpJbmRleCA9IHRoaXMuX3pJbmRleCArIG9mZnNldDtcclxuICBcdFx0fVxyXG4gIFx0fSxcclxuXHJcbiAgXHRfYW5pbWF0ZVpvb206IGZ1bmN0aW9uIChvcHQpIHtcclxuICBcdFx0dmFyIHBvcyA9IHRoaXMuX21hcC5fbGF0TG5nVG9OZXdMYXllclBvaW50KHRoaXMuX2xhdGxuZywgb3B0Lnpvb20sIG9wdC5jZW50ZXIpLnJvdW5kKCk7XHJcblxyXG4gIFx0XHR0aGlzLl9zZXRQb3MocG9zKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X2luaXRJbnRlcmFjdGlvbjogZnVuY3Rpb24gKCkge1xyXG5cclxuICBcdFx0aWYgKCF0aGlzLm9wdGlvbnMuaW50ZXJhY3RpdmUpIHsgcmV0dXJuOyB9XHJcblxyXG4gIFx0XHRhZGRDbGFzcyh0aGlzLl9pY29uLCAnbGVhZmxldC1pbnRlcmFjdGl2ZScpO1xyXG5cclxuICBcdFx0dGhpcy5hZGRJbnRlcmFjdGl2ZVRhcmdldCh0aGlzLl9pY29uKTtcclxuXHJcbiAgXHRcdGlmIChNYXJrZXJEcmFnKSB7XHJcbiAgXHRcdFx0dmFyIGRyYWdnYWJsZSA9IHRoaXMub3B0aW9ucy5kcmFnZ2FibGU7XHJcbiAgXHRcdFx0aWYgKHRoaXMuZHJhZ2dpbmcpIHtcclxuICBcdFx0XHRcdGRyYWdnYWJsZSA9IHRoaXMuZHJhZ2dpbmcuZW5hYmxlZCgpO1xyXG4gIFx0XHRcdFx0dGhpcy5kcmFnZ2luZy5kaXNhYmxlKCk7XHJcbiAgXHRcdFx0fVxyXG5cclxuICBcdFx0XHR0aGlzLmRyYWdnaW5nID0gbmV3IE1hcmtlckRyYWcodGhpcyk7XHJcblxyXG4gIFx0XHRcdGlmIChkcmFnZ2FibGUpIHtcclxuICBcdFx0XHRcdHRoaXMuZHJhZ2dpbmcuZW5hYmxlKCk7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHR9XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2Qgc2V0T3BhY2l0eShvcGFjaXR5OiBOdW1iZXIpOiB0aGlzXHJcbiAgXHQvLyBDaGFuZ2VzIHRoZSBvcGFjaXR5IG9mIHRoZSBtYXJrZXIuXHJcbiAgXHRzZXRPcGFjaXR5OiBmdW5jdGlvbiAob3BhY2l0eSkge1xyXG4gIFx0XHR0aGlzLm9wdGlvbnMub3BhY2l0eSA9IG9wYWNpdHk7XHJcbiAgXHRcdGlmICh0aGlzLl9tYXApIHtcclxuICBcdFx0XHR0aGlzLl91cGRhdGVPcGFjaXR5KCk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfdXBkYXRlT3BhY2l0eTogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR2YXIgb3BhY2l0eSA9IHRoaXMub3B0aW9ucy5vcGFjaXR5O1xyXG5cclxuICBcdFx0aWYgKHRoaXMuX2ljb24pIHtcclxuICBcdFx0XHRzZXRPcGFjaXR5KHRoaXMuX2ljb24sIG9wYWNpdHkpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRpZiAodGhpcy5fc2hhZG93KSB7XHJcbiAgXHRcdFx0c2V0T3BhY2l0eSh0aGlzLl9zaGFkb3csIG9wYWNpdHkpO1xyXG4gIFx0XHR9XHJcbiAgXHR9LFxyXG5cclxuICBcdF9icmluZ1RvRnJvbnQ6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dGhpcy5fdXBkYXRlWkluZGV4KHRoaXMub3B0aW9ucy5yaXNlT2Zmc2V0KTtcclxuICBcdH0sXHJcblxyXG4gIFx0X3Jlc2V0WkluZGV4OiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHRoaXMuX3VwZGF0ZVpJbmRleCgwKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X2dldFBvcHVwQW5jaG9yOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuaWNvbi5vcHRpb25zLnBvcHVwQW5jaG9yO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfZ2V0VG9vbHRpcEFuY2hvcjogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmljb24ub3B0aW9ucy50b29sdGlwQW5jaG9yO1xyXG4gIFx0fVxyXG4gIH0pO1xyXG5cclxuXHJcbiAgLy8gZmFjdG9yeSBMLm1hcmtlcihsYXRsbmc6IExhdExuZywgb3B0aW9ucz8gOiBNYXJrZXIgb3B0aW9ucylcclxuXHJcbiAgLy8gQGZhY3RvcnkgTC5tYXJrZXIobGF0bG5nOiBMYXRMbmcsIG9wdGlvbnM/IDogTWFya2VyIG9wdGlvbnMpXHJcbiAgLy8gSW5zdGFudGlhdGVzIGEgTWFya2VyIG9iamVjdCBnaXZlbiBhIGdlb2dyYXBoaWNhbCBwb2ludCBhbmQgb3B0aW9uYWxseSBhbiBvcHRpb25zIG9iamVjdC5cclxuICBmdW5jdGlvbiBtYXJrZXIobGF0bG5nLCBvcHRpb25zKSB7XHJcbiAgXHRyZXR1cm4gbmV3IE1hcmtlcihsYXRsbmcsIG9wdGlvbnMpO1xyXG4gIH1cblxuICAvKlxuICAgKiBAY2xhc3MgUGF0aFxuICAgKiBAYWthIEwuUGF0aFxuICAgKiBAaW5oZXJpdHMgSW50ZXJhY3RpdmUgbGF5ZXJcbiAgICpcbiAgICogQW4gYWJzdHJhY3QgY2xhc3MgdGhhdCBjb250YWlucyBvcHRpb25zIGFuZCBjb25zdGFudHMgc2hhcmVkIGJldHdlZW4gdmVjdG9yXG4gICAqIG92ZXJsYXlzIChQb2x5Z29uLCBQb2x5bGluZSwgQ2lyY2xlKS4gRG8gbm90IHVzZSBpdCBkaXJlY3RseS4gRXh0ZW5kcyBgTGF5ZXJgLlxuICAgKi9cblxuICB2YXIgUGF0aCA9IExheWVyLmV4dGVuZCh7XG5cbiAgXHQvLyBAc2VjdGlvblxuICBcdC8vIEBha2EgUGF0aCBvcHRpb25zXG4gIFx0b3B0aW9uczoge1xuICBcdFx0Ly8gQG9wdGlvbiBzdHJva2U6IEJvb2xlYW4gPSB0cnVlXG4gIFx0XHQvLyBXaGV0aGVyIHRvIGRyYXcgc3Ryb2tlIGFsb25nIHRoZSBwYXRoLiBTZXQgaXQgdG8gYGZhbHNlYCB0byBkaXNhYmxlIGJvcmRlcnMgb24gcG9seWdvbnMgb3IgY2lyY2xlcy5cbiAgXHRcdHN0cm9rZTogdHJ1ZSxcblxuICBcdFx0Ly8gQG9wdGlvbiBjb2xvcjogU3RyaW5nID0gJyMzMzg4ZmYnXG4gIFx0XHQvLyBTdHJva2UgY29sb3JcbiAgXHRcdGNvbG9yOiAnIzMzODhmZicsXG5cbiAgXHRcdC8vIEBvcHRpb24gd2VpZ2h0OiBOdW1iZXIgPSAzXG4gIFx0XHQvLyBTdHJva2Ugd2lkdGggaW4gcGl4ZWxzXG4gIFx0XHR3ZWlnaHQ6IDMsXG5cbiAgXHRcdC8vIEBvcHRpb24gb3BhY2l0eTogTnVtYmVyID0gMS4wXG4gIFx0XHQvLyBTdHJva2Ugb3BhY2l0eVxuICBcdFx0b3BhY2l0eTogMSxcblxuICBcdFx0Ly8gQG9wdGlvbiBsaW5lQ2FwOiBTdHJpbmc9ICdyb3VuZCdcbiAgXHRcdC8vIEEgc3RyaW5nIHRoYXQgZGVmaW5lcyBbc2hhcGUgdG8gYmUgdXNlZCBhdCB0aGUgZW5kXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9TVkcvQXR0cmlidXRlL3N0cm9rZS1saW5lY2FwKSBvZiB0aGUgc3Ryb2tlLlxuICBcdFx0bGluZUNhcDogJ3JvdW5kJyxcblxuICBcdFx0Ly8gQG9wdGlvbiBsaW5lSm9pbjogU3RyaW5nID0gJ3JvdW5kJ1xuICBcdFx0Ly8gQSBzdHJpbmcgdGhhdCBkZWZpbmVzIFtzaGFwZSB0byBiZSB1c2VkIGF0IHRoZSBjb3JuZXJzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9TVkcvQXR0cmlidXRlL3N0cm9rZS1saW5lam9pbikgb2YgdGhlIHN0cm9rZS5cbiAgXHRcdGxpbmVKb2luOiAncm91bmQnLFxuXG4gIFx0XHQvLyBAb3B0aW9uIGRhc2hBcnJheTogU3RyaW5nID0gbnVsbFxuICBcdFx0Ly8gQSBzdHJpbmcgdGhhdCBkZWZpbmVzIHRoZSBzdHJva2UgW2Rhc2ggcGF0dGVybl0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvU1ZHL0F0dHJpYnV0ZS9zdHJva2UtZGFzaGFycmF5KS4gRG9lc24ndCB3b3JrIG9uIGBDYW52YXNgLXBvd2VyZWQgbGF5ZXJzIGluIFtzb21lIG9sZCBicm93c2Vyc10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC9zZXRMaW5lRGFzaCNCcm93c2VyX2NvbXBhdGliaWxpdHkpLlxuICBcdFx0ZGFzaEFycmF5OiBudWxsLFxuXG4gIFx0XHQvLyBAb3B0aW9uIGRhc2hPZmZzZXQ6IFN0cmluZyA9IG51bGxcbiAgXHRcdC8vIEEgc3RyaW5nIHRoYXQgZGVmaW5lcyB0aGUgW2Rpc3RhbmNlIGludG8gdGhlIGRhc2ggcGF0dGVybiB0byBzdGFydCB0aGUgZGFzaF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvU1ZHL0F0dHJpYnV0ZS9zdHJva2UtZGFzaG9mZnNldCkuIERvZXNuJ3Qgd29yayBvbiBgQ2FudmFzYC1wb3dlcmVkIGxheWVycyBpbiBbc29tZSBvbGQgYnJvd3NlcnNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQvc2V0TGluZURhc2gjQnJvd3Nlcl9jb21wYXRpYmlsaXR5KS5cbiAgXHRcdGRhc2hPZmZzZXQ6IG51bGwsXG5cbiAgXHRcdC8vIEBvcHRpb24gZmlsbDogQm9vbGVhbiA9IGRlcGVuZHNcbiAgXHRcdC8vIFdoZXRoZXIgdG8gZmlsbCB0aGUgcGF0aCB3aXRoIGNvbG9yLiBTZXQgaXQgdG8gYGZhbHNlYCB0byBkaXNhYmxlIGZpbGxpbmcgb24gcG9seWdvbnMgb3IgY2lyY2xlcy5cbiAgXHRcdGZpbGw6IGZhbHNlLFxuXG4gIFx0XHQvLyBAb3B0aW9uIGZpbGxDb2xvcjogU3RyaW5nID0gKlxuICBcdFx0Ly8gRmlsbCBjb2xvci4gRGVmYXVsdHMgdG8gdGhlIHZhbHVlIG9mIHRoZSBbYGNvbG9yYF0oI3BhdGgtY29sb3IpIG9wdGlvblxuICBcdFx0ZmlsbENvbG9yOiBudWxsLFxuXG4gIFx0XHQvLyBAb3B0aW9uIGZpbGxPcGFjaXR5OiBOdW1iZXIgPSAwLjJcbiAgXHRcdC8vIEZpbGwgb3BhY2l0eS5cbiAgXHRcdGZpbGxPcGFjaXR5OiAwLjIsXG5cbiAgXHRcdC8vIEBvcHRpb24gZmlsbFJ1bGU6IFN0cmluZyA9ICdldmVub2RkJ1xuICBcdFx0Ly8gQSBzdHJpbmcgdGhhdCBkZWZpbmVzIFtob3cgdGhlIGluc2lkZSBvZiBhIHNoYXBlXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9TVkcvQXR0cmlidXRlL2ZpbGwtcnVsZSkgaXMgZGV0ZXJtaW5lZC5cbiAgXHRcdGZpbGxSdWxlOiAnZXZlbm9kZCcsXG5cbiAgXHRcdC8vIGNsYXNzTmFtZTogJycsXG5cbiAgXHRcdC8vIE9wdGlvbiBpbmhlcml0ZWQgZnJvbSBcIkludGVyYWN0aXZlIGxheWVyXCIgYWJzdHJhY3QgY2xhc3NcbiAgXHRcdGludGVyYWN0aXZlOiB0cnVlLFxuXG4gIFx0XHQvLyBAb3B0aW9uIGJ1YmJsaW5nTW91c2VFdmVudHM6IEJvb2xlYW4gPSB0cnVlXG4gIFx0XHQvLyBXaGVuIGB0cnVlYCwgYSBtb3VzZSBldmVudCBvbiB0aGlzIHBhdGggd2lsbCB0cmlnZ2VyIHRoZSBzYW1lIGV2ZW50IG9uIHRoZSBtYXBcbiAgXHRcdC8vICh1bmxlc3MgW2BMLkRvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbmBdKCNkb21ldmVudC1zdG9wcHJvcGFnYXRpb24pIGlzIHVzZWQpLlxuICBcdFx0YnViYmxpbmdNb3VzZUV2ZW50czogdHJ1ZVxuICBcdH0sXG5cbiAgXHRiZWZvcmVBZGQ6IGZ1bmN0aW9uIChtYXApIHtcbiAgXHRcdC8vIFJlbmRlcmVyIGlzIHNldCBoZXJlIGJlY2F1c2Ugd2UgbmVlZCB0byBjYWxsIHJlbmRlcmVyLmdldEV2ZW50c1xuICBcdFx0Ly8gYmVmb3JlIHRoaXMuZ2V0RXZlbnRzLlxuICBcdFx0dGhpcy5fcmVuZGVyZXIgPSBtYXAuZ2V0UmVuZGVyZXIodGhpcyk7XG4gIFx0fSxcblxuICBcdG9uQWRkOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLl9yZW5kZXJlci5faW5pdFBhdGgodGhpcyk7XG4gIFx0XHR0aGlzLl9yZXNldCgpO1xuICBcdFx0dGhpcy5fcmVuZGVyZXIuX2FkZFBhdGgodGhpcyk7XG4gIFx0fSxcblxuICBcdG9uUmVtb3ZlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLl9yZW5kZXJlci5fcmVtb3ZlUGF0aCh0aGlzKTtcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCByZWRyYXcoKTogdGhpc1xuICBcdC8vIFJlZHJhd3MgdGhlIGxheWVyLiBTb21ldGltZXMgdXNlZnVsIGFmdGVyIHlvdSBjaGFuZ2VkIHRoZSBjb29yZGluYXRlcyB0aGF0IHRoZSBwYXRoIHVzZXMuXG4gIFx0cmVkcmF3OiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAodGhpcy5fbWFwKSB7XG4gIFx0XHRcdHRoaXMuX3JlbmRlcmVyLl91cGRhdGVQYXRoKHRoaXMpO1xuICBcdFx0fVxuICBcdFx0cmV0dXJuIHRoaXM7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2Qgc2V0U3R5bGUoc3R5bGU6IFBhdGggb3B0aW9ucyk6IHRoaXNcbiAgXHQvLyBDaGFuZ2VzIHRoZSBhcHBlYXJhbmNlIG9mIGEgUGF0aCBiYXNlZCBvbiB0aGUgb3B0aW9ucyBpbiB0aGUgYFBhdGggb3B0aW9uc2Agb2JqZWN0LlxuICBcdHNldFN0eWxlOiBmdW5jdGlvbiAoc3R5bGUpIHtcbiAgXHRcdHNldE9wdGlvbnModGhpcywgc3R5bGUpO1xuICBcdFx0aWYgKHRoaXMuX3JlbmRlcmVyKSB7XG4gIFx0XHRcdHRoaXMuX3JlbmRlcmVyLl91cGRhdGVTdHlsZSh0aGlzKTtcbiAgXHRcdFx0aWYgKHRoaXMub3B0aW9ucy5zdHJva2UgJiYgc3R5bGUgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHN0eWxlLCAnd2VpZ2h0JykpIHtcbiAgXHRcdFx0XHR0aGlzLl91cGRhdGVCb3VuZHMoKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdFx0cmV0dXJuIHRoaXM7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2QgYnJpbmdUb0Zyb250KCk6IHRoaXNcbiAgXHQvLyBCcmluZ3MgdGhlIGxheWVyIHRvIHRoZSB0b3Agb2YgYWxsIHBhdGggbGF5ZXJzLlxuICBcdGJyaW5nVG9Gcm9udDogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKHRoaXMuX3JlbmRlcmVyKSB7XG4gIFx0XHRcdHRoaXMuX3JlbmRlcmVyLl9icmluZ1RvRnJvbnQodGhpcyk7XG4gIFx0XHR9XG4gIFx0XHRyZXR1cm4gdGhpcztcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCBicmluZ1RvQmFjaygpOiB0aGlzXG4gIFx0Ly8gQnJpbmdzIHRoZSBsYXllciB0byB0aGUgYm90dG9tIG9mIGFsbCBwYXRoIGxheWVycy5cbiAgXHRicmluZ1RvQmFjazogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKHRoaXMuX3JlbmRlcmVyKSB7XG4gIFx0XHRcdHRoaXMuX3JlbmRlcmVyLl9icmluZ1RvQmFjayh0aGlzKTtcbiAgXHRcdH1cbiAgXHRcdHJldHVybiB0aGlzO1xuICBcdH0sXG5cbiAgXHRnZXRFbGVtZW50OiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5fcGF0aDtcbiAgXHR9LFxuXG4gIFx0X3Jlc2V0OiBmdW5jdGlvbiAoKSB7XG4gIFx0XHQvLyBkZWZpbmVkIGluIGNoaWxkIGNsYXNzZXNcbiAgXHRcdHRoaXMuX3Byb2plY3QoKTtcbiAgXHRcdHRoaXMuX3VwZGF0ZSgpO1xuICBcdH0sXG5cbiAgXHRfY2xpY2tUb2xlcmFuY2U6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdC8vIHVzZWQgd2hlbiBkb2luZyBoaXQgZGV0ZWN0aW9uIGZvciBDYW52YXMgbGF5ZXJzXG4gIFx0XHRyZXR1cm4gKHRoaXMub3B0aW9ucy5zdHJva2UgPyB0aGlzLm9wdGlvbnMud2VpZ2h0IC8gMiA6IDApICsgdGhpcy5fcmVuZGVyZXIub3B0aW9ucy50b2xlcmFuY2U7XG4gIFx0fVxuICB9KTtcblxuICAvKlxuICAgKiBAY2xhc3MgQ2lyY2xlTWFya2VyXG4gICAqIEBha2EgTC5DaXJjbGVNYXJrZXJcbiAgICogQGluaGVyaXRzIFBhdGhcbiAgICpcbiAgICogQSBjaXJjbGUgb2YgYSBmaXhlZCBzaXplIHdpdGggcmFkaXVzIHNwZWNpZmllZCBpbiBwaXhlbHMuIEV4dGVuZHMgYFBhdGhgLlxuICAgKi9cblxuICB2YXIgQ2lyY2xlTWFya2VyID0gUGF0aC5leHRlbmQoe1xuXG4gIFx0Ly8gQHNlY3Rpb25cbiAgXHQvLyBAYWthIENpcmNsZU1hcmtlciBvcHRpb25zXG4gIFx0b3B0aW9uczoge1xuICBcdFx0ZmlsbDogdHJ1ZSxcblxuICBcdFx0Ly8gQG9wdGlvbiByYWRpdXM6IE51bWJlciA9IDEwXG4gIFx0XHQvLyBSYWRpdXMgb2YgdGhlIGNpcmNsZSBtYXJrZXIsIGluIHBpeGVsc1xuICBcdFx0cmFkaXVzOiAxMFxuICBcdH0sXG5cbiAgXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobGF0bG5nLCBvcHRpb25zKSB7XG4gIFx0XHRzZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuICBcdFx0dGhpcy5fbGF0bG5nID0gdG9MYXRMbmcobGF0bG5nKTtcbiAgXHRcdHRoaXMuX3JhZGl1cyA9IHRoaXMub3B0aW9ucy5yYWRpdXM7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2Qgc2V0TGF0TG5nKGxhdExuZzogTGF0TG5nKTogdGhpc1xuICBcdC8vIFNldHMgdGhlIHBvc2l0aW9uIG9mIGEgY2lyY2xlIG1hcmtlciB0byBhIG5ldyBsb2NhdGlvbi5cbiAgXHRzZXRMYXRMbmc6IGZ1bmN0aW9uIChsYXRsbmcpIHtcbiAgXHRcdHZhciBvbGRMYXRMbmcgPSB0aGlzLl9sYXRsbmc7XG4gIFx0XHR0aGlzLl9sYXRsbmcgPSB0b0xhdExuZyhsYXRsbmcpO1xuICBcdFx0dGhpcy5yZWRyYXcoKTtcblxuICBcdFx0Ly8gQGV2ZW50IG1vdmU6IEV2ZW50XG4gIFx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXJrZXIgaXMgbW92ZWQgdmlhIFtgc2V0TGF0TG5nYF0oI2NpcmNsZW1hcmtlci1zZXRsYXRsbmcpLiBPbGQgYW5kIG5ldyBjb29yZGluYXRlcyBhcmUgaW5jbHVkZWQgaW4gZXZlbnQgYXJndW1lbnRzIGFzIGBvbGRMYXRMbmdgLCBgbGF0bG5nYC5cbiAgXHRcdHJldHVybiB0aGlzLmZpcmUoJ21vdmUnLCB7b2xkTGF0TG5nOiBvbGRMYXRMbmcsIGxhdGxuZzogdGhpcy5fbGF0bG5nfSk7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2QgZ2V0TGF0TG5nKCk6IExhdExuZ1xuICBcdC8vIFJldHVybnMgdGhlIGN1cnJlbnQgZ2VvZ3JhcGhpY2FsIHBvc2l0aW9uIG9mIHRoZSBjaXJjbGUgbWFya2VyXG4gIFx0Z2V0TGF0TG5nOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5fbGF0bG5nO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIHNldFJhZGl1cyhyYWRpdXM6IE51bWJlcik6IHRoaXNcbiAgXHQvLyBTZXRzIHRoZSByYWRpdXMgb2YgYSBjaXJjbGUgbWFya2VyLiBVbml0cyBhcmUgaW4gcGl4ZWxzLlxuICBcdHNldFJhZGl1czogZnVuY3Rpb24gKHJhZGl1cykge1xuICBcdFx0dGhpcy5vcHRpb25zLnJhZGl1cyA9IHRoaXMuX3JhZGl1cyA9IHJhZGl1cztcbiAgXHRcdHJldHVybiB0aGlzLnJlZHJhdygpO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIGdldFJhZGl1cygpOiBOdW1iZXJcbiAgXHQvLyBSZXR1cm5zIHRoZSBjdXJyZW50IHJhZGl1cyBvZiB0aGUgY2lyY2xlXG4gIFx0Z2V0UmFkaXVzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5fcmFkaXVzO1xuICBcdH0sXG5cbiAgXHRzZXRTdHlsZSA6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIFx0XHR2YXIgcmFkaXVzID0gb3B0aW9ucyAmJiBvcHRpb25zLnJhZGl1cyB8fCB0aGlzLl9yYWRpdXM7XG4gIFx0XHRQYXRoLnByb3RvdHlwZS5zZXRTdHlsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICBcdFx0dGhpcy5zZXRSYWRpdXMocmFkaXVzKTtcbiAgXHRcdHJldHVybiB0aGlzO1xuICBcdH0sXG5cbiAgXHRfcHJvamVjdDogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5fcG9pbnQgPSB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX2xhdGxuZyk7XG4gIFx0XHR0aGlzLl91cGRhdGVCb3VuZHMoKTtcbiAgXHR9LFxuXG4gIFx0X3VwZGF0ZUJvdW5kczogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIHIgPSB0aGlzLl9yYWRpdXMsXG4gIFx0XHQgICAgcjIgPSB0aGlzLl9yYWRpdXNZIHx8IHIsXG4gIFx0XHQgICAgdyA9IHRoaXMuX2NsaWNrVG9sZXJhbmNlKCksXG4gIFx0XHQgICAgcCA9IFtyICsgdywgcjIgKyB3XTtcbiAgXHRcdHRoaXMuX3B4Qm91bmRzID0gbmV3IEJvdW5kcyh0aGlzLl9wb2ludC5zdWJ0cmFjdChwKSwgdGhpcy5fcG9pbnQuYWRkKHApKTtcbiAgXHR9LFxuXG4gIFx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKHRoaXMuX21hcCkge1xuICBcdFx0XHR0aGlzLl91cGRhdGVQYXRoKCk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF91cGRhdGVQYXRoOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLl9yZW5kZXJlci5fdXBkYXRlQ2lyY2xlKHRoaXMpO1xuICBcdH0sXG5cbiAgXHRfZW1wdHk6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLl9yYWRpdXMgJiYgIXRoaXMuX3JlbmRlcmVyLl9ib3VuZHMuaW50ZXJzZWN0cyh0aGlzLl9weEJvdW5kcyk7XG4gIFx0fSxcblxuICBcdC8vIE5lZWRlZCBieSB0aGUgYENhbnZhc2AgcmVuZGVyZXIgZm9yIGludGVyYWN0aXZpdHlcbiAgXHRfY29udGFpbnNQb2ludDogZnVuY3Rpb24gKHApIHtcbiAgXHRcdHJldHVybiBwLmRpc3RhbmNlVG8odGhpcy5fcG9pbnQpIDw9IHRoaXMuX3JhZGl1cyArIHRoaXMuX2NsaWNrVG9sZXJhbmNlKCk7XG4gIFx0fVxuICB9KTtcblxuXG4gIC8vIEBmYWN0b3J5IEwuY2lyY2xlTWFya2VyKGxhdGxuZzogTGF0TG5nLCBvcHRpb25zPzogQ2lyY2xlTWFya2VyIG9wdGlvbnMpXG4gIC8vIEluc3RhbnRpYXRlcyBhIGNpcmNsZSBtYXJrZXIgb2JqZWN0IGdpdmVuIGEgZ2VvZ3JhcGhpY2FsIHBvaW50LCBhbmQgYW4gb3B0aW9uYWwgb3B0aW9ucyBvYmplY3QuXG4gIGZ1bmN0aW9uIGNpcmNsZU1hcmtlcihsYXRsbmcsIG9wdGlvbnMpIHtcbiAgXHRyZXR1cm4gbmV3IENpcmNsZU1hcmtlcihsYXRsbmcsIG9wdGlvbnMpO1xuICB9XG5cbiAgLypcbiAgICogQGNsYXNzIENpcmNsZVxuICAgKiBAYWthIEwuQ2lyY2xlXG4gICAqIEBpbmhlcml0cyBDaXJjbGVNYXJrZXJcbiAgICpcbiAgICogQSBjbGFzcyBmb3IgZHJhd2luZyBjaXJjbGUgb3ZlcmxheXMgb24gYSBtYXAuIEV4dGVuZHMgYENpcmNsZU1hcmtlcmAuXG4gICAqXG4gICAqIEl0J3MgYW4gYXBwcm94aW1hdGlvbiBhbmQgc3RhcnRzIHRvIGRpdmVyZ2UgZnJvbSBhIHJlYWwgY2lyY2xlIGNsb3NlciB0byBwb2xlcyAoZHVlIHRvIHByb2plY3Rpb24gZGlzdG9ydGlvbikuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIEwuY2lyY2xlKFs1MC41LCAzMC41XSwge3JhZGl1czogMjAwfSkuYWRkVG8obWFwKTtcbiAgICogYGBgXG4gICAqL1xuXG4gIHZhciBDaXJjbGUgPSBDaXJjbGVNYXJrZXIuZXh0ZW5kKHtcblxuICBcdGluaXRpYWxpemU6IGZ1bmN0aW9uIChsYXRsbmcsIG9wdGlvbnMsIGxlZ2FjeU9wdGlvbnMpIHtcbiAgXHRcdGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ251bWJlcicpIHtcbiAgXHRcdFx0Ly8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHkgd2l0aCAwLjcueCBmYWN0b3J5IChsYXRsbmcsIHJhZGl1cywgb3B0aW9ucz8pXG4gIFx0XHRcdG9wdGlvbnMgPSBleHRlbmQoe30sIGxlZ2FjeU9wdGlvbnMsIHtyYWRpdXM6IG9wdGlvbnN9KTtcbiAgXHRcdH1cbiAgXHRcdHNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG4gIFx0XHR0aGlzLl9sYXRsbmcgPSB0b0xhdExuZyhsYXRsbmcpO1xuXG4gIFx0XHRpZiAoaXNOYU4odGhpcy5vcHRpb25zLnJhZGl1cykpIHsgdGhyb3cgbmV3IEVycm9yKCdDaXJjbGUgcmFkaXVzIGNhbm5vdCBiZSBOYU4nKTsgfVxuXG4gIFx0XHQvLyBAc2VjdGlvblxuICBcdFx0Ly8gQGFrYSBDaXJjbGUgb3B0aW9uc1xuICBcdFx0Ly8gQG9wdGlvbiByYWRpdXM6IE51bWJlcjsgUmFkaXVzIG9mIHRoZSBjaXJjbGUsIGluIG1ldGVycy5cbiAgXHRcdHRoaXMuX21SYWRpdXMgPSB0aGlzLm9wdGlvbnMucmFkaXVzO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIHNldFJhZGl1cyhyYWRpdXM6IE51bWJlcik6IHRoaXNcbiAgXHQvLyBTZXRzIHRoZSByYWRpdXMgb2YgYSBjaXJjbGUuIFVuaXRzIGFyZSBpbiBtZXRlcnMuXG4gIFx0c2V0UmFkaXVzOiBmdW5jdGlvbiAocmFkaXVzKSB7XG4gIFx0XHR0aGlzLl9tUmFkaXVzID0gcmFkaXVzO1xuICBcdFx0cmV0dXJuIHRoaXMucmVkcmF3KCk7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2QgZ2V0UmFkaXVzKCk6IE51bWJlclxuICBcdC8vIFJldHVybnMgdGhlIGN1cnJlbnQgcmFkaXVzIG9mIGEgY2lyY2xlLiBVbml0cyBhcmUgaW4gbWV0ZXJzLlxuICBcdGdldFJhZGl1czogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMuX21SYWRpdXM7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2QgZ2V0Qm91bmRzKCk6IExhdExuZ0JvdW5kc1xuICBcdC8vIFJldHVybnMgdGhlIGBMYXRMbmdCb3VuZHNgIG9mIHRoZSBwYXRoLlxuICBcdGdldEJvdW5kczogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIGhhbGYgPSBbdGhpcy5fcmFkaXVzLCB0aGlzLl9yYWRpdXNZIHx8IHRoaXMuX3JhZGl1c107XG5cbiAgXHRcdHJldHVybiBuZXcgTGF0TG5nQm91bmRzKFxuICBcdFx0XHR0aGlzLl9tYXAubGF5ZXJQb2ludFRvTGF0TG5nKHRoaXMuX3BvaW50LnN1YnRyYWN0KGhhbGYpKSxcbiAgXHRcdFx0dGhpcy5fbWFwLmxheWVyUG9pbnRUb0xhdExuZyh0aGlzLl9wb2ludC5hZGQoaGFsZikpKTtcbiAgXHR9LFxuXG4gIFx0c2V0U3R5bGU6IFBhdGgucHJvdG90eXBlLnNldFN0eWxlLFxuXG4gIFx0X3Byb2plY3Q6IGZ1bmN0aW9uICgpIHtcblxuICBcdFx0dmFyIGxuZyA9IHRoaXMuX2xhdGxuZy5sbmcsXG4gIFx0XHQgICAgbGF0ID0gdGhpcy5fbGF0bG5nLmxhdCxcbiAgXHRcdCAgICBtYXAgPSB0aGlzLl9tYXAsXG4gIFx0XHQgICAgY3JzID0gbWFwLm9wdGlvbnMuY3JzO1xuXG4gIFx0XHRpZiAoY3JzLmRpc3RhbmNlID09PSBFYXJ0aC5kaXN0YW5jZSkge1xuICBcdFx0XHR2YXIgZCA9IE1hdGguUEkgLyAxODAsXG4gIFx0XHRcdCAgICBsYXRSID0gKHRoaXMuX21SYWRpdXMgLyBFYXJ0aC5SKSAvIGQsXG4gIFx0XHRcdCAgICB0b3AgPSBtYXAucHJvamVjdChbbGF0ICsgbGF0UiwgbG5nXSksXG4gIFx0XHRcdCAgICBib3R0b20gPSBtYXAucHJvamVjdChbbGF0IC0gbGF0UiwgbG5nXSksXG4gIFx0XHRcdCAgICBwID0gdG9wLmFkZChib3R0b20pLmRpdmlkZUJ5KDIpLFxuICBcdFx0XHQgICAgbGF0MiA9IG1hcC51bnByb2plY3QocCkubGF0LFxuICBcdFx0XHQgICAgbG5nUiA9IE1hdGguYWNvcygoTWF0aC5jb3MobGF0UiAqIGQpIC0gTWF0aC5zaW4obGF0ICogZCkgKiBNYXRoLnNpbihsYXQyICogZCkpIC9cbiAgXHRcdFx0ICAgICAgICAgICAgKE1hdGguY29zKGxhdCAqIGQpICogTWF0aC5jb3MobGF0MiAqIGQpKSkgLyBkO1xuXG4gIFx0XHRcdGlmIChpc05hTihsbmdSKSB8fCBsbmdSID09PSAwKSB7XG4gIFx0XHRcdFx0bG5nUiA9IGxhdFIgLyBNYXRoLmNvcyhNYXRoLlBJIC8gMTgwICogbGF0KTsgLy8gRmFsbGJhY2sgZm9yIGVkZ2UgY2FzZSwgIzI0MjVcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHRoaXMuX3BvaW50ID0gcC5zdWJ0cmFjdChtYXAuZ2V0UGl4ZWxPcmlnaW4oKSk7XG4gIFx0XHRcdHRoaXMuX3JhZGl1cyA9IGlzTmFOKGxuZ1IpID8gMCA6IHAueCAtIG1hcC5wcm9qZWN0KFtsYXQyLCBsbmcgLSBsbmdSXSkueDtcbiAgXHRcdFx0dGhpcy5fcmFkaXVzWSA9IHAueSAtIHRvcC55O1xuXG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHR2YXIgbGF0bG5nMiA9IGNycy51bnByb2plY3QoY3JzLnByb2plY3QodGhpcy5fbGF0bG5nKS5zdWJ0cmFjdChbdGhpcy5fbVJhZGl1cywgMF0pKTtcblxuICBcdFx0XHR0aGlzLl9wb2ludCA9IG1hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fbGF0bG5nKTtcbiAgXHRcdFx0dGhpcy5fcmFkaXVzID0gdGhpcy5fcG9pbnQueCAtIG1hcC5sYXRMbmdUb0xheWVyUG9pbnQobGF0bG5nMikueDtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5fdXBkYXRlQm91bmRzKCk7XG4gIFx0fVxuICB9KTtcblxuICAvLyBAZmFjdG9yeSBMLmNpcmNsZShsYXRsbmc6IExhdExuZywgb3B0aW9ucz86IENpcmNsZSBvcHRpb25zKVxuICAvLyBJbnN0YW50aWF0ZXMgYSBjaXJjbGUgb2JqZWN0IGdpdmVuIGEgZ2VvZ3JhcGhpY2FsIHBvaW50LCBhbmQgYW4gb3B0aW9ucyBvYmplY3RcbiAgLy8gd2hpY2ggY29udGFpbnMgdGhlIGNpcmNsZSByYWRpdXMuXG4gIC8vIEBhbHRlcm5hdGl2ZVxuICAvLyBAZmFjdG9yeSBMLmNpcmNsZShsYXRsbmc6IExhdExuZywgcmFkaXVzOiBOdW1iZXIsIG9wdGlvbnM/OiBDaXJjbGUgb3B0aW9ucylcbiAgLy8gT2Jzb2xldGUgd2F5IG9mIGluc3RhbnRpYXRpbmcgYSBjaXJjbGUsIGZvciBjb21wYXRpYmlsaXR5IHdpdGggMC43LnggY29kZS5cbiAgLy8gRG8gbm90IHVzZSBpbiBuZXcgYXBwbGljYXRpb25zIG9yIHBsdWdpbnMuXG4gIGZ1bmN0aW9uIGNpcmNsZShsYXRsbmcsIG9wdGlvbnMsIGxlZ2FjeU9wdGlvbnMpIHtcbiAgXHRyZXR1cm4gbmV3IENpcmNsZShsYXRsbmcsIG9wdGlvbnMsIGxlZ2FjeU9wdGlvbnMpO1xuICB9XG5cbiAgLypcbiAgICogQGNsYXNzIFBvbHlsaW5lXG4gICAqIEBha2EgTC5Qb2x5bGluZVxuICAgKiBAaW5oZXJpdHMgUGF0aFxuICAgKlxuICAgKiBBIGNsYXNzIGZvciBkcmF3aW5nIHBvbHlsaW5lIG92ZXJsYXlzIG9uIGEgbWFwLiBFeHRlbmRzIGBQYXRoYC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogYGBganNcbiAgICogLy8gY3JlYXRlIGEgcmVkIHBvbHlsaW5lIGZyb20gYW4gYXJyYXkgb2YgTGF0TG5nIHBvaW50c1xuICAgKiB2YXIgbGF0bG5ncyA9IFtcbiAgICogXHRbNDUuNTEsIC0xMjIuNjhdLFxuICAgKiBcdFszNy43NywgLTEyMi40M10sXG4gICAqIFx0WzM0LjA0LCAtMTE4LjJdXG4gICAqIF07XG4gICAqXG4gICAqIHZhciBwb2x5bGluZSA9IEwucG9seWxpbmUobGF0bG5ncywge2NvbG9yOiAncmVkJ30pLmFkZFRvKG1hcCk7XG4gICAqXG4gICAqIC8vIHpvb20gdGhlIG1hcCB0byB0aGUgcG9seWxpbmVcbiAgICogbWFwLmZpdEJvdW5kcyhwb2x5bGluZS5nZXRCb3VuZHMoKSk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBZb3UgY2FuIGFsc28gcGFzcyBhIG11bHRpLWRpbWVuc2lvbmFsIGFycmF5IHRvIHJlcHJlc2VudCBhIGBNdWx0aVBvbHlsaW5lYCBzaGFwZTpcbiAgICpcbiAgICogYGBganNcbiAgICogLy8gY3JlYXRlIGEgcmVkIHBvbHlsaW5lIGZyb20gYW4gYXJyYXkgb2YgYXJyYXlzIG9mIExhdExuZyBwb2ludHNcbiAgICogdmFyIGxhdGxuZ3MgPSBbXG4gICAqIFx0W1s0NS41MSwgLTEyMi42OF0sXG4gICAqIFx0IFszNy43NywgLTEyMi40M10sXG4gICAqIFx0IFszNC4wNCwgLTExOC4yXV0sXG4gICAqIFx0W1s0MC43OCwgLTczLjkxXSxcbiAgICogXHQgWzQxLjgzLCAtODcuNjJdLFxuICAgKiBcdCBbMzIuNzYsIC05Ni43Ml1dXG4gICAqIF07XG4gICAqIGBgYFxuICAgKi9cblxuXG4gIHZhciBQb2x5bGluZSA9IFBhdGguZXh0ZW5kKHtcblxuICBcdC8vIEBzZWN0aW9uXG4gIFx0Ly8gQGFrYSBQb2x5bGluZSBvcHRpb25zXG4gIFx0b3B0aW9uczoge1xuICBcdFx0Ly8gQG9wdGlvbiBzbW9vdGhGYWN0b3I6IE51bWJlciA9IDEuMFxuICBcdFx0Ly8gSG93IG11Y2ggdG8gc2ltcGxpZnkgdGhlIHBvbHlsaW5lIG9uIGVhY2ggem9vbSBsZXZlbC4gTW9yZSBtZWFuc1xuICBcdFx0Ly8gYmV0dGVyIHBlcmZvcm1hbmNlIGFuZCBzbW9vdGhlciBsb29rLCBhbmQgbGVzcyBtZWFucyBtb3JlIGFjY3VyYXRlIHJlcHJlc2VudGF0aW9uLlxuICBcdFx0c21vb3RoRmFjdG9yOiAxLjAsXG5cbiAgXHRcdC8vIEBvcHRpb24gbm9DbGlwOiBCb29sZWFuID0gZmFsc2VcbiAgXHRcdC8vIERpc2FibGUgcG9seWxpbmUgY2xpcHBpbmcuXG4gIFx0XHRub0NsaXA6IGZhbHNlXG4gIFx0fSxcblxuICBcdGluaXRpYWxpemU6IGZ1bmN0aW9uIChsYXRsbmdzLCBvcHRpb25zKSB7XG4gIFx0XHRzZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuICBcdFx0dGhpcy5fc2V0TGF0TG5ncyhsYXRsbmdzKTtcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCBnZXRMYXRMbmdzKCk6IExhdExuZ1tdXG4gIFx0Ly8gUmV0dXJucyBhbiBhcnJheSBvZiB0aGUgcG9pbnRzIGluIHRoZSBwYXRoLCBvciBuZXN0ZWQgYXJyYXlzIG9mIHBvaW50cyBpbiBjYXNlIG9mIG11bHRpLXBvbHlsaW5lLlxuICBcdGdldExhdExuZ3M6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLl9sYXRsbmdzO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIHNldExhdExuZ3MobGF0bG5nczogTGF0TG5nW10pOiB0aGlzXG4gIFx0Ly8gUmVwbGFjZXMgYWxsIHRoZSBwb2ludHMgaW4gdGhlIHBvbHlsaW5lIHdpdGggdGhlIGdpdmVuIGFycmF5IG9mIGdlb2dyYXBoaWNhbCBwb2ludHMuXG4gIFx0c2V0TGF0TG5nczogZnVuY3Rpb24gKGxhdGxuZ3MpIHtcbiAgXHRcdHRoaXMuX3NldExhdExuZ3MobGF0bG5ncyk7XG4gIFx0XHRyZXR1cm4gdGhpcy5yZWRyYXcoKTtcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCBpc0VtcHR5KCk6IEJvb2xlYW5cbiAgXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgUG9seWxpbmUgaGFzIG5vIExhdExuZ3MuXG4gIFx0aXNFbXB0eTogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuICF0aGlzLl9sYXRsbmdzLmxlbmd0aDtcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCBjbG9zZXN0TGF5ZXJQb2ludChwOiBQb2ludCk6IFBvaW50XG4gIFx0Ly8gUmV0dXJucyB0aGUgcG9pbnQgY2xvc2VzdCB0byBgcGAgb24gdGhlIFBvbHlsaW5lLlxuICBcdGNsb3Nlc3RMYXllclBvaW50OiBmdW5jdGlvbiAocCkge1xuICBcdFx0dmFyIG1pbkRpc3RhbmNlID0gSW5maW5pdHksXG4gIFx0XHQgICAgbWluUG9pbnQgPSBudWxsLFxuICBcdFx0ICAgIGNsb3Nlc3QgPSBfc3FDbG9zZXN0UG9pbnRPblNlZ21lbnQsXG4gIFx0XHQgICAgcDEsIHAyO1xuXG4gIFx0XHRmb3IgKHZhciBqID0gMCwgakxlbiA9IHRoaXMuX3BhcnRzLmxlbmd0aDsgaiA8IGpMZW47IGorKykge1xuICBcdFx0XHR2YXIgcG9pbnRzID0gdGhpcy5fcGFydHNbal07XG5cbiAgXHRcdFx0Zm9yICh2YXIgaSA9IDEsIGxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICBcdFx0XHRcdHAxID0gcG9pbnRzW2kgLSAxXTtcbiAgXHRcdFx0XHRwMiA9IHBvaW50c1tpXTtcblxuICBcdFx0XHRcdHZhciBzcURpc3QgPSBjbG9zZXN0KHAsIHAxLCBwMiwgdHJ1ZSk7XG5cbiAgXHRcdFx0XHRpZiAoc3FEaXN0IDwgbWluRGlzdGFuY2UpIHtcbiAgXHRcdFx0XHRcdG1pbkRpc3RhbmNlID0gc3FEaXN0O1xuICBcdFx0XHRcdFx0bWluUG9pbnQgPSBjbG9zZXN0KHAsIHAxLCBwMik7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0XHRpZiAobWluUG9pbnQpIHtcbiAgXHRcdFx0bWluUG9pbnQuZGlzdGFuY2UgPSBNYXRoLnNxcnQobWluRGlzdGFuY2UpO1xuICBcdFx0fVxuICBcdFx0cmV0dXJuIG1pblBvaW50O1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIGdldENlbnRlcigpOiBMYXRMbmdcbiAgXHQvLyBSZXR1cm5zIHRoZSBjZW50ZXIgKFtjZW50cm9pZF0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DZW50cm9pZCkpIG9mIHRoZSBwb2x5bGluZS5cbiAgXHRnZXRDZW50ZXI6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdC8vIHRocm93cyBlcnJvciB3aGVuIG5vdCB5ZXQgYWRkZWQgdG8gbWFwIGFzIHRoaXMgY2VudGVyIGNhbGN1bGF0aW9uIHJlcXVpcmVzIHByb2plY3RlZCBjb29yZGluYXRlc1xuICBcdFx0aWYgKCF0aGlzLl9tYXApIHtcbiAgXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdNdXN0IGFkZCBsYXllciB0byBtYXAgYmVmb3JlIHVzaW5nIGdldENlbnRlcigpJyk7XG4gIFx0XHR9XG5cbiAgXHRcdHZhciBpLCBoYWxmRGlzdCwgc2VnRGlzdCwgZGlzdCwgcDEsIHAyLCByYXRpbyxcbiAgXHRcdCAgICBwb2ludHMgPSB0aGlzLl9yaW5nc1swXSxcbiAgXHRcdCAgICBsZW4gPSBwb2ludHMubGVuZ3RoO1xuXG4gIFx0XHRpZiAoIWxlbikgeyByZXR1cm4gbnVsbDsgfVxuXG4gIFx0XHQvLyBwb2x5bGluZSBjZW50cm9pZCBhbGdvcml0aG07IG9ubHkgdXNlcyB0aGUgZmlyc3QgcmluZyBpZiB0aGVyZSBhcmUgbXVsdGlwbGVcblxuICBcdFx0Zm9yIChpID0gMCwgaGFsZkRpc3QgPSAwOyBpIDwgbGVuIC0gMTsgaSsrKSB7XG4gIFx0XHRcdGhhbGZEaXN0ICs9IHBvaW50c1tpXS5kaXN0YW5jZVRvKHBvaW50c1tpICsgMV0pIC8gMjtcbiAgXHRcdH1cblxuICBcdFx0Ly8gVGhlIGxpbmUgaXMgc28gc21hbGwgaW4gdGhlIGN1cnJlbnQgdmlldyB0aGF0IGFsbCBwb2ludHMgYXJlIG9uIHRoZSBzYW1lIHBpeGVsLlxuICBcdFx0aWYgKGhhbGZEaXN0ID09PSAwKSB7XG4gIFx0XHRcdHJldHVybiB0aGlzLl9tYXAubGF5ZXJQb2ludFRvTGF0TG5nKHBvaW50c1swXSk7XG4gIFx0XHR9XG5cbiAgXHRcdGZvciAoaSA9IDAsIGRpc3QgPSAwOyBpIDwgbGVuIC0gMTsgaSsrKSB7XG4gIFx0XHRcdHAxID0gcG9pbnRzW2ldO1xuICBcdFx0XHRwMiA9IHBvaW50c1tpICsgMV07XG4gIFx0XHRcdHNlZ0Rpc3QgPSBwMS5kaXN0YW5jZVRvKHAyKTtcbiAgXHRcdFx0ZGlzdCArPSBzZWdEaXN0O1xuXG4gIFx0XHRcdGlmIChkaXN0ID4gaGFsZkRpc3QpIHtcbiAgXHRcdFx0XHRyYXRpbyA9IChkaXN0IC0gaGFsZkRpc3QpIC8gc2VnRGlzdDtcbiAgXHRcdFx0XHRyZXR1cm4gdGhpcy5fbWFwLmxheWVyUG9pbnRUb0xhdExuZyhbXG4gIFx0XHRcdFx0XHRwMi54IC0gcmF0aW8gKiAocDIueCAtIHAxLngpLFxuICBcdFx0XHRcdFx0cDIueSAtIHJhdGlvICogKHAyLnkgLSBwMS55KVxuICBcdFx0XHRcdF0pO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2QgZ2V0Qm91bmRzKCk6IExhdExuZ0JvdW5kc1xuICBcdC8vIFJldHVybnMgdGhlIGBMYXRMbmdCb3VuZHNgIG9mIHRoZSBwYXRoLlxuICBcdGdldEJvdW5kczogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMuX2JvdW5kcztcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCBhZGRMYXRMbmcobGF0bG5nOiBMYXRMbmcsIGxhdGxuZ3M/OiBMYXRMbmdbXSk6IHRoaXNcbiAgXHQvLyBBZGRzIGEgZ2l2ZW4gcG9pbnQgdG8gdGhlIHBvbHlsaW5lLiBCeSBkZWZhdWx0LCBhZGRzIHRvIHRoZSBmaXJzdCByaW5nIG9mXG4gIFx0Ly8gdGhlIHBvbHlsaW5lIGluIGNhc2Ugb2YgYSBtdWx0aS1wb2x5bGluZSwgYnV0IGNhbiBiZSBvdmVycmlkZGVuIGJ5IHBhc3NpbmdcbiAgXHQvLyBhIHNwZWNpZmljIHJpbmcgYXMgYSBMYXRMbmcgYXJyYXkgKHRoYXQgeW91IGNhbiBlYXJsaWVyIGFjY2VzcyB3aXRoIFtgZ2V0TGF0TG5nc2BdKCNwb2x5bGluZS1nZXRsYXRsbmdzKSkuXG4gIFx0YWRkTGF0TG5nOiBmdW5jdGlvbiAobGF0bG5nLCBsYXRsbmdzKSB7XG4gIFx0XHRsYXRsbmdzID0gbGF0bG5ncyB8fCB0aGlzLl9kZWZhdWx0U2hhcGUoKTtcbiAgXHRcdGxhdGxuZyA9IHRvTGF0TG5nKGxhdGxuZyk7XG4gIFx0XHRsYXRsbmdzLnB1c2gobGF0bG5nKTtcbiAgXHRcdHRoaXMuX2JvdW5kcy5leHRlbmQobGF0bG5nKTtcbiAgXHRcdHJldHVybiB0aGlzLnJlZHJhdygpO1xuICBcdH0sXG5cbiAgXHRfc2V0TGF0TG5nczogZnVuY3Rpb24gKGxhdGxuZ3MpIHtcbiAgXHRcdHRoaXMuX2JvdW5kcyA9IG5ldyBMYXRMbmdCb3VuZHMoKTtcbiAgXHRcdHRoaXMuX2xhdGxuZ3MgPSB0aGlzLl9jb252ZXJ0TGF0TG5ncyhsYXRsbmdzKTtcbiAgXHR9LFxuXG4gIFx0X2RlZmF1bHRTaGFwZTogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIGlzRmxhdCh0aGlzLl9sYXRsbmdzKSA/IHRoaXMuX2xhdGxuZ3MgOiB0aGlzLl9sYXRsbmdzWzBdO1xuICBcdH0sXG5cbiAgXHQvLyByZWN1cnNpdmVseSBjb252ZXJ0IGxhdGxuZ3MgaW5wdXQgaW50byBhY3R1YWwgTGF0TG5nIGluc3RhbmNlczsgY2FsY3VsYXRlIGJvdW5kcyBhbG9uZyB0aGUgd2F5XG4gIFx0X2NvbnZlcnRMYXRMbmdzOiBmdW5jdGlvbiAobGF0bG5ncykge1xuICBcdFx0dmFyIHJlc3VsdCA9IFtdLFxuICBcdFx0ICAgIGZsYXQgPSBpc0ZsYXQobGF0bG5ncyk7XG5cbiAgXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBsYXRsbmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gIFx0XHRcdGlmIChmbGF0KSB7XG4gIFx0XHRcdFx0cmVzdWx0W2ldID0gdG9MYXRMbmcobGF0bG5nc1tpXSk7XG4gIFx0XHRcdFx0dGhpcy5fYm91bmRzLmV4dGVuZChyZXN1bHRbaV0pO1xuICBcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdHJlc3VsdFtpXSA9IHRoaXMuX2NvbnZlcnRMYXRMbmdzKGxhdGxuZ3NbaV0pO1xuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiByZXN1bHQ7XG4gIFx0fSxcblxuICBcdF9wcm9qZWN0OiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgcHhCb3VuZHMgPSBuZXcgQm91bmRzKCk7XG4gIFx0XHR0aGlzLl9yaW5ncyA9IFtdO1xuICBcdFx0dGhpcy5fcHJvamVjdExhdGxuZ3ModGhpcy5fbGF0bG5ncywgdGhpcy5fcmluZ3MsIHB4Qm91bmRzKTtcblxuICBcdFx0aWYgKHRoaXMuX2JvdW5kcy5pc1ZhbGlkKCkgJiYgcHhCb3VuZHMuaXNWYWxpZCgpKSB7XG4gIFx0XHRcdHRoaXMuX3Jhd1B4Qm91bmRzID0gcHhCb3VuZHM7XG4gIFx0XHRcdHRoaXMuX3VwZGF0ZUJvdW5kcygpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfdXBkYXRlQm91bmRzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgdyA9IHRoaXMuX2NsaWNrVG9sZXJhbmNlKCksXG4gIFx0XHQgICAgcCA9IG5ldyBQb2ludCh3LCB3KTtcbiAgXHRcdHRoaXMuX3B4Qm91bmRzID0gbmV3IEJvdW5kcyhbXG4gIFx0XHRcdHRoaXMuX3Jhd1B4Qm91bmRzLm1pbi5zdWJ0cmFjdChwKSxcbiAgXHRcdFx0dGhpcy5fcmF3UHhCb3VuZHMubWF4LmFkZChwKVxuICBcdFx0XSk7XG4gIFx0fSxcblxuICBcdC8vIHJlY3Vyc2l2ZWx5IHR1cm5zIGxhdGxuZ3MgaW50byBhIHNldCBvZiByaW5ncyB3aXRoIHByb2plY3RlZCBjb29yZGluYXRlc1xuICBcdF9wcm9qZWN0TGF0bG5nczogZnVuY3Rpb24gKGxhdGxuZ3MsIHJlc3VsdCwgcHJvamVjdGVkQm91bmRzKSB7XG4gIFx0XHR2YXIgZmxhdCA9IGxhdGxuZ3NbMF0gaW5zdGFuY2VvZiBMYXRMbmcsXG4gIFx0XHQgICAgbGVuID0gbGF0bG5ncy5sZW5ndGgsXG4gIFx0XHQgICAgaSwgcmluZztcblxuICBcdFx0aWYgKGZsYXQpIHtcbiAgXHRcdFx0cmluZyA9IFtdO1xuICBcdFx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgXHRcdFx0XHRyaW5nW2ldID0gdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludChsYXRsbmdzW2ldKTtcbiAgXHRcdFx0XHRwcm9qZWN0ZWRCb3VuZHMuZXh0ZW5kKHJpbmdbaV0pO1xuICBcdFx0XHR9XG4gIFx0XHRcdHJlc3VsdC5wdXNoKHJpbmcpO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gIFx0XHRcdFx0dGhpcy5fcHJvamVjdExhdGxuZ3MobGF0bG5nc1tpXSwgcmVzdWx0LCBwcm9qZWN0ZWRCb3VuZHMpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdC8vIGNsaXAgcG9seWxpbmUgYnkgcmVuZGVyZXIgYm91bmRzIHNvIHRoYXQgd2UgaGF2ZSBsZXNzIHRvIHJlbmRlciBmb3IgcGVyZm9ybWFuY2VcbiAgXHRfY2xpcFBvaW50czogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIGJvdW5kcyA9IHRoaXMuX3JlbmRlcmVyLl9ib3VuZHM7XG5cbiAgXHRcdHRoaXMuX3BhcnRzID0gW107XG4gIFx0XHRpZiAoIXRoaXMuX3B4Qm91bmRzIHx8ICF0aGlzLl9weEJvdW5kcy5pbnRlcnNlY3RzKGJvdW5kcykpIHtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAodGhpcy5vcHRpb25zLm5vQ2xpcCkge1xuICBcdFx0XHR0aGlzLl9wYXJ0cyA9IHRoaXMuX3JpbmdzO1xuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdHZhciBwYXJ0cyA9IHRoaXMuX3BhcnRzLFxuICBcdFx0ICAgIGksIGosIGssIGxlbiwgbGVuMiwgc2VnbWVudCwgcG9pbnRzO1xuXG4gIFx0XHRmb3IgKGkgPSAwLCBrID0gMCwgbGVuID0gdGhpcy5fcmluZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgXHRcdFx0cG9pbnRzID0gdGhpcy5fcmluZ3NbaV07XG5cbiAgXHRcdFx0Zm9yIChqID0gMCwgbGVuMiA9IHBvaW50cy5sZW5ndGg7IGogPCBsZW4yIC0gMTsgaisrKSB7XG4gIFx0XHRcdFx0c2VnbWVudCA9IGNsaXBTZWdtZW50KHBvaW50c1tqXSwgcG9pbnRzW2ogKyAxXSwgYm91bmRzLCBqLCB0cnVlKTtcblxuICBcdFx0XHRcdGlmICghc2VnbWVudCkgeyBjb250aW51ZTsgfVxuXG4gIFx0XHRcdFx0cGFydHNba10gPSBwYXJ0c1trXSB8fCBbXTtcbiAgXHRcdFx0XHRwYXJ0c1trXS5wdXNoKHNlZ21lbnRbMF0pO1xuXG4gIFx0XHRcdFx0Ly8gaWYgc2VnbWVudCBnb2VzIG91dCBvZiBzY3JlZW4sIG9yIGl0J3MgdGhlIGxhc3Qgb25lLCBpdCdzIHRoZSBlbmQgb2YgdGhlIGxpbmUgcGFydFxuICBcdFx0XHRcdGlmICgoc2VnbWVudFsxXSAhPT0gcG9pbnRzW2ogKyAxXSkgfHwgKGogPT09IGxlbjIgLSAyKSkge1xuICBcdFx0XHRcdFx0cGFydHNba10ucHVzaChzZWdtZW50WzFdKTtcbiAgXHRcdFx0XHRcdGsrKztcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0Ly8gc2ltcGxpZnkgZWFjaCBjbGlwcGVkIHBhcnQgb2YgdGhlIHBvbHlsaW5lIGZvciBwZXJmb3JtYW5jZVxuICBcdF9zaW1wbGlmeVBvaW50czogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIHBhcnRzID0gdGhpcy5fcGFydHMsXG4gIFx0XHQgICAgdG9sZXJhbmNlID0gdGhpcy5vcHRpb25zLnNtb290aEZhY3RvcjtcblxuICBcdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHBhcnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gIFx0XHRcdHBhcnRzW2ldID0gc2ltcGxpZnkocGFydHNbaV0sIHRvbGVyYW5jZSk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICghdGhpcy5fbWFwKSB7IHJldHVybjsgfVxuXG4gIFx0XHR0aGlzLl9jbGlwUG9pbnRzKCk7XG4gIFx0XHR0aGlzLl9zaW1wbGlmeVBvaW50cygpO1xuICBcdFx0dGhpcy5fdXBkYXRlUGF0aCgpO1xuICBcdH0sXG5cbiAgXHRfdXBkYXRlUGF0aDogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5fcmVuZGVyZXIuX3VwZGF0ZVBvbHkodGhpcyk7XG4gIFx0fSxcblxuICBcdC8vIE5lZWRlZCBieSB0aGUgYENhbnZhc2AgcmVuZGVyZXIgZm9yIGludGVyYWN0aXZpdHlcbiAgXHRfY29udGFpbnNQb2ludDogZnVuY3Rpb24gKHAsIGNsb3NlZCkge1xuICBcdFx0dmFyIGksIGosIGssIGxlbiwgbGVuMiwgcGFydCxcbiAgXHRcdCAgICB3ID0gdGhpcy5fY2xpY2tUb2xlcmFuY2UoKTtcblxuICBcdFx0aWYgKCF0aGlzLl9weEJvdW5kcyB8fCAhdGhpcy5fcHhCb3VuZHMuY29udGFpbnMocCkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgXHRcdC8vIGhpdCBkZXRlY3Rpb24gZm9yIHBvbHlsaW5lc1xuICBcdFx0Zm9yIChpID0gMCwgbGVuID0gdGhpcy5fcGFydHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgXHRcdFx0cGFydCA9IHRoaXMuX3BhcnRzW2ldO1xuXG4gIFx0XHRcdGZvciAoaiA9IDAsIGxlbjIgPSBwYXJ0Lmxlbmd0aCwgayA9IGxlbjIgLSAxOyBqIDwgbGVuMjsgayA9IGorKykge1xuICBcdFx0XHRcdGlmICghY2xvc2VkICYmIChqID09PSAwKSkgeyBjb250aW51ZTsgfVxuXG4gIFx0XHRcdFx0aWYgKHBvaW50VG9TZWdtZW50RGlzdGFuY2UocCwgcGFydFtrXSwgcGFydFtqXSkgPD0gdykge1xuICBcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0XHRyZXR1cm4gZmFsc2U7XG4gIFx0fVxuICB9KTtcblxuICAvLyBAZmFjdG9yeSBMLnBvbHlsaW5lKGxhdGxuZ3M6IExhdExuZ1tdLCBvcHRpb25zPzogUG9seWxpbmUgb3B0aW9ucylcbiAgLy8gSW5zdGFudGlhdGVzIGEgcG9seWxpbmUgb2JqZWN0IGdpdmVuIGFuIGFycmF5IG9mIGdlb2dyYXBoaWNhbCBwb2ludHMgYW5kXG4gIC8vIG9wdGlvbmFsbHkgYW4gb3B0aW9ucyBvYmplY3QuIFlvdSBjYW4gY3JlYXRlIGEgYFBvbHlsaW5lYCBvYmplY3Qgd2l0aFxuICAvLyBtdWx0aXBsZSBzZXBhcmF0ZSBsaW5lcyAoYE11bHRpUG9seWxpbmVgKSBieSBwYXNzaW5nIGFuIGFycmF5IG9mIGFycmF5c1xuICAvLyBvZiBnZW9ncmFwaGljIHBvaW50cy5cbiAgZnVuY3Rpb24gcG9seWxpbmUobGF0bG5ncywgb3B0aW9ucykge1xuICBcdHJldHVybiBuZXcgUG9seWxpbmUobGF0bG5ncywgb3B0aW9ucyk7XG4gIH1cblxuICAvLyBSZXRyb2NvbXBhdC4gQWxsb3cgcGx1Z2lucyB0byBzdXBwb3J0IExlYWZsZXQgdmVyc2lvbnMgYmVmb3JlIGFuZCBhZnRlciAxLjEuXG4gIFBvbHlsaW5lLl9mbGF0ID0gX2ZsYXQ7XG5cbiAgLypcbiAgICogQGNsYXNzIFBvbHlnb25cbiAgICogQGFrYSBMLlBvbHlnb25cbiAgICogQGluaGVyaXRzIFBvbHlsaW5lXG4gICAqXG4gICAqIEEgY2xhc3MgZm9yIGRyYXdpbmcgcG9seWdvbiBvdmVybGF5cyBvbiBhIG1hcC4gRXh0ZW5kcyBgUG9seWxpbmVgLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgcG9pbnRzIHlvdSBwYXNzIHdoZW4gY3JlYXRpbmcgYSBwb2x5Z29uIHNob3VsZG4ndCBoYXZlIGFuIGFkZGl0aW9uYWwgbGFzdCBwb2ludCBlcXVhbCB0byB0aGUgZmlyc3Qgb25lIOKAlCBpdCdzIGJldHRlciB0byBmaWx0ZXIgb3V0IHN1Y2ggcG9pbnRzLlxuICAgKlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBgYGBqc1xuICAgKiAvLyBjcmVhdGUgYSByZWQgcG9seWdvbiBmcm9tIGFuIGFycmF5IG9mIExhdExuZyBwb2ludHNcbiAgICogdmFyIGxhdGxuZ3MgPSBbWzM3LCAtMTA5LjA1XSxbNDEsIC0xMDkuMDNdLFs0MSwgLTEwMi4wNV0sWzM3LCAtMTAyLjA0XV07XG4gICAqXG4gICAqIHZhciBwb2x5Z29uID0gTC5wb2x5Z29uKGxhdGxuZ3MsIHtjb2xvcjogJ3JlZCd9KS5hZGRUbyhtYXApO1xuICAgKlxuICAgKiAvLyB6b29tIHRoZSBtYXAgdG8gdGhlIHBvbHlnb25cbiAgICogbWFwLmZpdEJvdW5kcyhwb2x5Z29uLmdldEJvdW5kcygpKTtcbiAgICogYGBgXG4gICAqXG4gICAqIFlvdSBjYW4gYWxzbyBwYXNzIGFuIGFycmF5IG9mIGFycmF5cyBvZiBsYXRsbmdzLCB3aXRoIHRoZSBmaXJzdCBhcnJheSByZXByZXNlbnRpbmcgdGhlIG91dGVyIHNoYXBlIGFuZCB0aGUgb3RoZXIgYXJyYXlzIHJlcHJlc2VudGluZyBob2xlcyBpbiB0aGUgb3V0ZXIgc2hhcGU6XG4gICAqXG4gICAqIGBgYGpzXG4gICAqIHZhciBsYXRsbmdzID0gW1xuICAgKiAgIFtbMzcsIC0xMDkuMDVdLFs0MSwgLTEwOS4wM10sWzQxLCAtMTAyLjA1XSxbMzcsIC0xMDIuMDRdXSwgLy8gb3V0ZXIgcmluZ1xuICAgKiAgIFtbMzcuMjksIC0xMDguNThdLFs0MC43MSwgLTEwOC41OF0sWzQwLjcxLCAtMTAyLjUwXSxbMzcuMjksIC0xMDIuNTBdXSAvLyBob2xlXG4gICAqIF07XG4gICAqIGBgYFxuICAgKlxuICAgKiBBZGRpdGlvbmFsbHksIHlvdSBjYW4gcGFzcyBhIG11bHRpLWRpbWVuc2lvbmFsIGFycmF5IHRvIHJlcHJlc2VudCBhIE11bHRpUG9seWdvbiBzaGFwZS5cbiAgICpcbiAgICogYGBganNcbiAgICogdmFyIGxhdGxuZ3MgPSBbXG4gICAqICAgWyAvLyBmaXJzdCBwb2x5Z29uXG4gICAqICAgICBbWzM3LCAtMTA5LjA1XSxbNDEsIC0xMDkuMDNdLFs0MSwgLTEwMi4wNV0sWzM3LCAtMTAyLjA0XV0sIC8vIG91dGVyIHJpbmdcbiAgICogICAgIFtbMzcuMjksIC0xMDguNThdLFs0MC43MSwgLTEwOC41OF0sWzQwLjcxLCAtMTAyLjUwXSxbMzcuMjksIC0xMDIuNTBdXSAvLyBob2xlXG4gICAqICAgXSxcbiAgICogICBbIC8vIHNlY29uZCBwb2x5Z29uXG4gICAqICAgICBbWzQxLCAtMTExLjAzXSxbNDUsIC0xMTEuMDRdLFs0NSwgLTEwNC4wNV0sWzQxLCAtMTA0LjA1XV1cbiAgICogICBdXG4gICAqIF07XG4gICAqIGBgYFxuICAgKi9cblxuICB2YXIgUG9seWdvbiA9IFBvbHlsaW5lLmV4dGVuZCh7XG5cbiAgXHRvcHRpb25zOiB7XG4gIFx0XHRmaWxsOiB0cnVlXG4gIFx0fSxcblxuICBcdGlzRW1wdHk6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiAhdGhpcy5fbGF0bG5ncy5sZW5ndGggfHwgIXRoaXMuX2xhdGxuZ3NbMF0ubGVuZ3RoO1xuICBcdH0sXG5cbiAgXHRnZXRDZW50ZXI6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdC8vIHRocm93cyBlcnJvciB3aGVuIG5vdCB5ZXQgYWRkZWQgdG8gbWFwIGFzIHRoaXMgY2VudGVyIGNhbGN1bGF0aW9uIHJlcXVpcmVzIHByb2plY3RlZCBjb29yZGluYXRlc1xuICBcdFx0aWYgKCF0aGlzLl9tYXApIHtcbiAgXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdNdXN0IGFkZCBsYXllciB0byBtYXAgYmVmb3JlIHVzaW5nIGdldENlbnRlcigpJyk7XG4gIFx0XHR9XG5cbiAgXHRcdHZhciBpLCBqLCBwMSwgcDIsIGYsIGFyZWEsIHgsIHksIGNlbnRlcixcbiAgXHRcdCAgICBwb2ludHMgPSB0aGlzLl9yaW5nc1swXSxcbiAgXHRcdCAgICBsZW4gPSBwb2ludHMubGVuZ3RoO1xuXG4gIFx0XHRpZiAoIWxlbikgeyByZXR1cm4gbnVsbDsgfVxuXG4gIFx0XHQvLyBwb2x5Z29uIGNlbnRyb2lkIGFsZ29yaXRobTsgb25seSB1c2VzIHRoZSBmaXJzdCByaW5nIGlmIHRoZXJlIGFyZSBtdWx0aXBsZVxuXG4gIFx0XHRhcmVhID0geCA9IHkgPSAwO1xuXG4gIFx0XHRmb3IgKGkgPSAwLCBqID0gbGVuIC0gMTsgaSA8IGxlbjsgaiA9IGkrKykge1xuICBcdFx0XHRwMSA9IHBvaW50c1tpXTtcbiAgXHRcdFx0cDIgPSBwb2ludHNbal07XG5cbiAgXHRcdFx0ZiA9IHAxLnkgKiBwMi54IC0gcDIueSAqIHAxLng7XG4gIFx0XHRcdHggKz0gKHAxLnggKyBwMi54KSAqIGY7XG4gIFx0XHRcdHkgKz0gKHAxLnkgKyBwMi55KSAqIGY7XG4gIFx0XHRcdGFyZWEgKz0gZiAqIDM7XG4gIFx0XHR9XG5cbiAgXHRcdGlmIChhcmVhID09PSAwKSB7XG4gIFx0XHRcdC8vIFBvbHlnb24gaXMgc28gc21hbGwgdGhhdCBhbGwgcG9pbnRzIGFyZSBvbiBzYW1lIHBpeGVsLlxuICBcdFx0XHRjZW50ZXIgPSBwb2ludHNbMF07XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRjZW50ZXIgPSBbeCAvIGFyZWEsIHkgLyBhcmVhXTtcbiAgXHRcdH1cbiAgXHRcdHJldHVybiB0aGlzLl9tYXAubGF5ZXJQb2ludFRvTGF0TG5nKGNlbnRlcik7XG4gIFx0fSxcblxuICBcdF9jb252ZXJ0TGF0TG5nczogZnVuY3Rpb24gKGxhdGxuZ3MpIHtcbiAgXHRcdHZhciByZXN1bHQgPSBQb2x5bGluZS5wcm90b3R5cGUuX2NvbnZlcnRMYXRMbmdzLmNhbGwodGhpcywgbGF0bG5ncyksXG4gIFx0XHQgICAgbGVuID0gcmVzdWx0Lmxlbmd0aDtcblxuICBcdFx0Ly8gcmVtb3ZlIGxhc3QgcG9pbnQgaWYgaXQgZXF1YWxzIGZpcnN0IG9uZVxuICBcdFx0aWYgKGxlbiA+PSAyICYmIHJlc3VsdFswXSBpbnN0YW5jZW9mIExhdExuZyAmJiByZXN1bHRbMF0uZXF1YWxzKHJlc3VsdFtsZW4gLSAxXSkpIHtcbiAgXHRcdFx0cmVzdWx0LnBvcCgpO1xuICBcdFx0fVxuICBcdFx0cmV0dXJuIHJlc3VsdDtcbiAgXHR9LFxuXG4gIFx0X3NldExhdExuZ3M6IGZ1bmN0aW9uIChsYXRsbmdzKSB7XG4gIFx0XHRQb2x5bGluZS5wcm90b3R5cGUuX3NldExhdExuZ3MuY2FsbCh0aGlzLCBsYXRsbmdzKTtcbiAgXHRcdGlmIChpc0ZsYXQodGhpcy5fbGF0bG5ncykpIHtcbiAgXHRcdFx0dGhpcy5fbGF0bG5ncyA9IFt0aGlzLl9sYXRsbmdzXTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X2RlZmF1bHRTaGFwZTogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIGlzRmxhdCh0aGlzLl9sYXRsbmdzWzBdKSA/IHRoaXMuX2xhdGxuZ3NbMF0gOiB0aGlzLl9sYXRsbmdzWzBdWzBdO1xuICBcdH0sXG5cbiAgXHRfY2xpcFBvaW50czogZnVuY3Rpb24gKCkge1xuICBcdFx0Ly8gcG9seWdvbnMgbmVlZCBhIGRpZmZlcmVudCBjbGlwcGluZyBhbGdvcml0aG0gc28gd2UgcmVkZWZpbmUgdGhhdFxuXG4gIFx0XHR2YXIgYm91bmRzID0gdGhpcy5fcmVuZGVyZXIuX2JvdW5kcyxcbiAgXHRcdCAgICB3ID0gdGhpcy5vcHRpb25zLndlaWdodCxcbiAgXHRcdCAgICBwID0gbmV3IFBvaW50KHcsIHcpO1xuXG4gIFx0XHQvLyBpbmNyZWFzZSBjbGlwIHBhZGRpbmcgYnkgc3Ryb2tlIHdpZHRoIHRvIGF2b2lkIHN0cm9rZSBvbiBjbGlwIGVkZ2VzXG4gIFx0XHRib3VuZHMgPSBuZXcgQm91bmRzKGJvdW5kcy5taW4uc3VidHJhY3QocCksIGJvdW5kcy5tYXguYWRkKHApKTtcblxuICBcdFx0dGhpcy5fcGFydHMgPSBbXTtcbiAgXHRcdGlmICghdGhpcy5fcHhCb3VuZHMgfHwgIXRoaXMuX3B4Qm91bmRzLmludGVyc2VjdHMoYm91bmRzKSkge1xuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdGlmICh0aGlzLm9wdGlvbnMubm9DbGlwKSB7XG4gIFx0XHRcdHRoaXMuX3BhcnRzID0gdGhpcy5fcmluZ3M7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX3JpbmdzLmxlbmd0aCwgY2xpcHBlZDsgaSA8IGxlbjsgaSsrKSB7XG4gIFx0XHRcdGNsaXBwZWQgPSBjbGlwUG9seWdvbih0aGlzLl9yaW5nc1tpXSwgYm91bmRzLCB0cnVlKTtcbiAgXHRcdFx0aWYgKGNsaXBwZWQubGVuZ3RoKSB7XG4gIFx0XHRcdFx0dGhpcy5fcGFydHMucHVzaChjbGlwcGVkKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfdXBkYXRlUGF0aDogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5fcmVuZGVyZXIuX3VwZGF0ZVBvbHkodGhpcywgdHJ1ZSk7XG4gIFx0fSxcblxuICBcdC8vIE5lZWRlZCBieSB0aGUgYENhbnZhc2AgcmVuZGVyZXIgZm9yIGludGVyYWN0aXZpdHlcbiAgXHRfY29udGFpbnNQb2ludDogZnVuY3Rpb24gKHApIHtcbiAgXHRcdHZhciBpbnNpZGUgPSBmYWxzZSxcbiAgXHRcdCAgICBwYXJ0LCBwMSwgcDIsIGksIGosIGssIGxlbiwgbGVuMjtcblxuICBcdFx0aWYgKCF0aGlzLl9weEJvdW5kcyB8fCAhdGhpcy5fcHhCb3VuZHMuY29udGFpbnMocCkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgXHRcdC8vIHJheSBjYXN0aW5nIGFsZ29yaXRobSBmb3IgZGV0ZWN0aW5nIGlmIHBvaW50IGlzIGluIHBvbHlnb25cbiAgXHRcdGZvciAoaSA9IDAsIGxlbiA9IHRoaXMuX3BhcnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gIFx0XHRcdHBhcnQgPSB0aGlzLl9wYXJ0c1tpXTtcblxuICBcdFx0XHRmb3IgKGogPSAwLCBsZW4yID0gcGFydC5sZW5ndGgsIGsgPSBsZW4yIC0gMTsgaiA8IGxlbjI7IGsgPSBqKyspIHtcbiAgXHRcdFx0XHRwMSA9IHBhcnRbal07XG4gIFx0XHRcdFx0cDIgPSBwYXJ0W2tdO1xuXG4gIFx0XHRcdFx0aWYgKCgocDEueSA+IHAueSkgIT09IChwMi55ID4gcC55KSkgJiYgKHAueCA8IChwMi54IC0gcDEueCkgKiAocC55IC0gcDEueSkgLyAocDIueSAtIHAxLnkpICsgcDEueCkpIHtcbiAgXHRcdFx0XHRcdGluc2lkZSA9ICFpbnNpZGU7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdC8vIGFsc28gY2hlY2sgaWYgaXQncyBvbiBwb2x5Z29uIHN0cm9rZVxuICBcdFx0cmV0dXJuIGluc2lkZSB8fCBQb2x5bGluZS5wcm90b3R5cGUuX2NvbnRhaW5zUG9pbnQuY2FsbCh0aGlzLCBwLCB0cnVlKTtcbiAgXHR9XG5cbiAgfSk7XG5cblxuICAvLyBAZmFjdG9yeSBMLnBvbHlnb24obGF0bG5nczogTGF0TG5nW10sIG9wdGlvbnM/OiBQb2x5bGluZSBvcHRpb25zKVxuICBmdW5jdGlvbiBwb2x5Z29uKGxhdGxuZ3MsIG9wdGlvbnMpIHtcbiAgXHRyZXR1cm4gbmV3IFBvbHlnb24obGF0bG5ncywgb3B0aW9ucyk7XG4gIH1cblxuICAvKlxyXG4gICAqIEBjbGFzcyBHZW9KU09OXHJcbiAgICogQGFrYSBMLkdlb0pTT05cclxuICAgKiBAaW5oZXJpdHMgRmVhdHVyZUdyb3VwXHJcbiAgICpcclxuICAgKiBSZXByZXNlbnRzIGEgR2VvSlNPTiBvYmplY3Qgb3IgYW4gYXJyYXkgb2YgR2VvSlNPTiBvYmplY3RzLiBBbGxvd3MgeW91IHRvIHBhcnNlXHJcbiAgICogR2VvSlNPTiBkYXRhIGFuZCBkaXNwbGF5IGl0IG9uIHRoZSBtYXAuIEV4dGVuZHMgYEZlYXR1cmVHcm91cGAuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqXHJcbiAgICogYGBganNcclxuICAgKiBMLmdlb0pTT04oZGF0YSwge1xyXG4gICAqIFx0c3R5bGU6IGZ1bmN0aW9uIChmZWF0dXJlKSB7XHJcbiAgICogXHRcdHJldHVybiB7Y29sb3I6IGZlYXR1cmUucHJvcGVydGllcy5jb2xvcn07XHJcbiAgICogXHR9XHJcbiAgICogfSkuYmluZFBvcHVwKGZ1bmN0aW9uIChsYXllcikge1xyXG4gICAqIFx0cmV0dXJuIGxheWVyLmZlYXR1cmUucHJvcGVydGllcy5kZXNjcmlwdGlvbjtcclxuICAgKiB9KS5hZGRUbyhtYXApO1xyXG4gICAqIGBgYFxyXG4gICAqL1xyXG5cclxuICB2YXIgR2VvSlNPTiA9IEZlYXR1cmVHcm91cC5leHRlbmQoe1xyXG5cclxuICBcdC8qIEBzZWN0aW9uXHJcbiAgXHQgKiBAYWthIEdlb0pTT04gb3B0aW9uc1xyXG4gIFx0ICpcclxuICBcdCAqIEBvcHRpb24gcG9pbnRUb0xheWVyOiBGdW5jdGlvbiA9ICpcclxuICBcdCAqIEEgYEZ1bmN0aW9uYCBkZWZpbmluZyBob3cgR2VvSlNPTiBwb2ludHMgc3Bhd24gTGVhZmxldCBsYXllcnMuIEl0IGlzIGludGVybmFsbHlcclxuICBcdCAqIGNhbGxlZCB3aGVuIGRhdGEgaXMgYWRkZWQsIHBhc3NpbmcgdGhlIEdlb0pTT04gcG9pbnQgZmVhdHVyZSBhbmQgaXRzIGBMYXRMbmdgLlxyXG4gIFx0ICogVGhlIGRlZmF1bHQgaXMgdG8gc3Bhd24gYSBkZWZhdWx0IGBNYXJrZXJgOlxyXG4gIFx0ICogYGBganNcclxuICBcdCAqIGZ1bmN0aW9uKGdlb0pzb25Qb2ludCwgbGF0bG5nKSB7XHJcbiAgXHQgKiBcdHJldHVybiBMLm1hcmtlcihsYXRsbmcpO1xyXG4gIFx0ICogfVxyXG4gIFx0ICogYGBgXHJcbiAgXHQgKlxyXG4gIFx0ICogQG9wdGlvbiBzdHlsZTogRnVuY3Rpb24gPSAqXHJcbiAgXHQgKiBBIGBGdW5jdGlvbmAgZGVmaW5pbmcgdGhlIGBQYXRoIG9wdGlvbnNgIGZvciBzdHlsaW5nIEdlb0pTT04gbGluZXMgYW5kIHBvbHlnb25zLFxyXG4gIFx0ICogY2FsbGVkIGludGVybmFsbHkgd2hlbiBkYXRhIGlzIGFkZGVkLlxyXG4gIFx0ICogVGhlIGRlZmF1bHQgdmFsdWUgaXMgdG8gbm90IG92ZXJyaWRlIGFueSBkZWZhdWx0czpcclxuICBcdCAqIGBgYGpzXHJcbiAgXHQgKiBmdW5jdGlvbiAoZ2VvSnNvbkZlYXR1cmUpIHtcclxuICBcdCAqIFx0cmV0dXJuIHt9XHJcbiAgXHQgKiB9XHJcbiAgXHQgKiBgYGBcclxuICBcdCAqXHJcbiAgXHQgKiBAb3B0aW9uIG9uRWFjaEZlYXR1cmU6IEZ1bmN0aW9uID0gKlxyXG4gIFx0ICogQSBgRnVuY3Rpb25gIHRoYXQgd2lsbCBiZSBjYWxsZWQgb25jZSBmb3IgZWFjaCBjcmVhdGVkIGBGZWF0dXJlYCwgYWZ0ZXIgaXQgaGFzXHJcbiAgXHQgKiBiZWVuIGNyZWF0ZWQgYW5kIHN0eWxlZC4gVXNlZnVsIGZvciBhdHRhY2hpbmcgZXZlbnRzIGFuZCBwb3B1cHMgdG8gZmVhdHVyZXMuXHJcbiAgXHQgKiBUaGUgZGVmYXVsdCBpcyB0byBkbyBub3RoaW5nIHdpdGggdGhlIG5ld2x5IGNyZWF0ZWQgbGF5ZXJzOlxyXG4gIFx0ICogYGBganNcclxuICBcdCAqIGZ1bmN0aW9uIChmZWF0dXJlLCBsYXllcikge31cclxuICBcdCAqIGBgYFxyXG4gIFx0ICpcclxuICBcdCAqIEBvcHRpb24gZmlsdGVyOiBGdW5jdGlvbiA9ICpcclxuICBcdCAqIEEgYEZ1bmN0aW9uYCB0aGF0IHdpbGwgYmUgdXNlZCB0byBkZWNpZGUgd2hldGhlciB0byBpbmNsdWRlIGEgZmVhdHVyZSBvciBub3QuXHJcbiAgXHQgKiBUaGUgZGVmYXVsdCBpcyB0byBpbmNsdWRlIGFsbCBmZWF0dXJlczpcclxuICBcdCAqIGBgYGpzXHJcbiAgXHQgKiBmdW5jdGlvbiAoZ2VvSnNvbkZlYXR1cmUpIHtcclxuICBcdCAqIFx0cmV0dXJuIHRydWU7XHJcbiAgXHQgKiB9XHJcbiAgXHQgKiBgYGBcclxuICBcdCAqIE5vdGU6IGR5bmFtaWNhbGx5IGNoYW5naW5nIHRoZSBgZmlsdGVyYCBvcHRpb24gd2lsbCBoYXZlIGVmZmVjdCBvbmx5IG9uIG5ld2x5XHJcbiAgXHQgKiBhZGRlZCBkYXRhLiBJdCB3aWxsIF9ub3RfIHJlLWV2YWx1YXRlIGFscmVhZHkgaW5jbHVkZWQgZmVhdHVyZXMuXHJcbiAgXHQgKlxyXG4gIFx0ICogQG9wdGlvbiBjb29yZHNUb0xhdExuZzogRnVuY3Rpb24gPSAqXHJcbiAgXHQgKiBBIGBGdW5jdGlvbmAgdGhhdCB3aWxsIGJlIHVzZWQgZm9yIGNvbnZlcnRpbmcgR2VvSlNPTiBjb29yZGluYXRlcyB0byBgTGF0TG5nYHMuXHJcbiAgXHQgKiBUaGUgZGVmYXVsdCBpcyB0aGUgYGNvb3Jkc1RvTGF0TG5nYCBzdGF0aWMgbWV0aG9kLlxyXG4gIFx0ICpcclxuICBcdCAqIEBvcHRpb24gbWFya2Vyc0luaGVyaXRPcHRpb25zOiBCb29sZWFuID0gZmFsc2VcclxuICBcdCAqIFdoZXRoZXIgZGVmYXVsdCBNYXJrZXJzIGZvciBcIlBvaW50XCIgdHlwZSBGZWF0dXJlcyBpbmhlcml0IGZyb20gZ3JvdXAgb3B0aW9ucy5cclxuICBcdCAqL1xyXG5cclxuICBcdGluaXRpYWxpemU6IGZ1bmN0aW9uIChnZW9qc29uLCBvcHRpb25zKSB7XHJcbiAgXHRcdHNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG4gIFx0XHR0aGlzLl9sYXllcnMgPSB7fTtcclxuXHJcbiAgXHRcdGlmIChnZW9qc29uKSB7XHJcbiAgXHRcdFx0dGhpcy5hZGREYXRhKGdlb2pzb24pO1xyXG4gIFx0XHR9XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgYWRkRGF0YSggPEdlb0pTT04+IGRhdGEgKTogdGhpc1xyXG4gIFx0Ly8gQWRkcyBhIEdlb0pTT04gb2JqZWN0IHRvIHRoZSBsYXllci5cclxuICBcdGFkZERhdGE6IGZ1bmN0aW9uIChnZW9qc29uKSB7XHJcbiAgXHRcdHZhciBmZWF0dXJlcyA9IGlzQXJyYXkoZ2VvanNvbikgPyBnZW9qc29uIDogZ2VvanNvbi5mZWF0dXJlcyxcclxuICBcdFx0ICAgIGksIGxlbiwgZmVhdHVyZTtcclxuXHJcbiAgXHRcdGlmIChmZWF0dXJlcykge1xyXG4gIFx0XHRcdGZvciAoaSA9IDAsIGxlbiA9IGZlYXR1cmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgXHRcdFx0XHQvLyBvbmx5IGFkZCB0aGlzIGlmIGdlb21ldHJ5IG9yIGdlb21ldHJpZXMgYXJlIHNldCBhbmQgbm90IG51bGxcclxuICBcdFx0XHRcdGZlYXR1cmUgPSBmZWF0dXJlc1tpXTtcclxuICBcdFx0XHRcdGlmIChmZWF0dXJlLmdlb21ldHJpZXMgfHwgZmVhdHVyZS5nZW9tZXRyeSB8fCBmZWF0dXJlLmZlYXR1cmVzIHx8IGZlYXR1cmUuY29vcmRpbmF0ZXMpIHtcclxuICBcdFx0XHRcdFx0dGhpcy5hZGREYXRhKGZlYXR1cmUpO1xyXG4gIFx0XHRcdFx0fVxyXG4gIFx0XHRcdH1cclxuICBcdFx0XHRyZXR1cm4gdGhpcztcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XHJcblxyXG4gIFx0XHRpZiAob3B0aW9ucy5maWx0ZXIgJiYgIW9wdGlvbnMuZmlsdGVyKGdlb2pzb24pKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG4gIFx0XHR2YXIgbGF5ZXIgPSBnZW9tZXRyeVRvTGF5ZXIoZ2VvanNvbiwgb3B0aW9ucyk7XHJcbiAgXHRcdGlmICghbGF5ZXIpIHtcclxuICBcdFx0XHRyZXR1cm4gdGhpcztcclxuICBcdFx0fVxyXG4gIFx0XHRsYXllci5mZWF0dXJlID0gYXNGZWF0dXJlKGdlb2pzb24pO1xyXG5cclxuICBcdFx0bGF5ZXIuZGVmYXVsdE9wdGlvbnMgPSBsYXllci5vcHRpb25zO1xyXG4gIFx0XHR0aGlzLnJlc2V0U3R5bGUobGF5ZXIpO1xyXG5cclxuICBcdFx0aWYgKG9wdGlvbnMub25FYWNoRmVhdHVyZSkge1xyXG4gIFx0XHRcdG9wdGlvbnMub25FYWNoRmVhdHVyZShnZW9qc29uLCBsYXllcik7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHJldHVybiB0aGlzLmFkZExheWVyKGxheWVyKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCByZXNldFN0eWxlKCA8UGF0aD4gbGF5ZXI/ICk6IHRoaXNcclxuICBcdC8vIFJlc2V0cyB0aGUgZ2l2ZW4gdmVjdG9yIGxheWVyJ3Mgc3R5bGUgdG8gdGhlIG9yaWdpbmFsIEdlb0pTT04gc3R5bGUsIHVzZWZ1bCBmb3IgcmVzZXR0aW5nIHN0eWxlIGFmdGVyIGhvdmVyIGV2ZW50cy5cclxuICBcdC8vIElmIGBsYXllcmAgaXMgb21pdHRlZCwgdGhlIHN0eWxlIG9mIGFsbCBmZWF0dXJlcyBpbiB0aGUgY3VycmVudCBsYXllciBpcyByZXNldC5cclxuICBcdHJlc2V0U3R5bGU6IGZ1bmN0aW9uIChsYXllcikge1xyXG4gIFx0XHRpZiAobGF5ZXIgPT09IHVuZGVmaW5lZCkge1xyXG4gIFx0XHRcdHJldHVybiB0aGlzLmVhY2hMYXllcih0aGlzLnJlc2V0U3R5bGUsIHRoaXMpO1xyXG4gIFx0XHR9XHJcbiAgXHRcdC8vIHJlc2V0IGFueSBjdXN0b20gc3R5bGVzXHJcbiAgXHRcdGxheWVyLm9wdGlvbnMgPSBleHRlbmQoe30sIGxheWVyLmRlZmF1bHRPcHRpb25zKTtcclxuICBcdFx0dGhpcy5fc2V0TGF5ZXJTdHlsZShsYXllciwgdGhpcy5vcHRpb25zLnN0eWxlKTtcclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2Qgc2V0U3R5bGUoIDxGdW5jdGlvbj4gc3R5bGUgKTogdGhpc1xyXG4gIFx0Ly8gQ2hhbmdlcyBzdHlsZXMgb2YgR2VvSlNPTiB2ZWN0b3IgbGF5ZXJzIHdpdGggdGhlIGdpdmVuIHN0eWxlIGZ1bmN0aW9uLlxyXG4gIFx0c2V0U3R5bGU6IGZ1bmN0aW9uIChzdHlsZSkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5lYWNoTGF5ZXIoZnVuY3Rpb24gKGxheWVyKSB7XHJcbiAgXHRcdFx0dGhpcy5fc2V0TGF5ZXJTdHlsZShsYXllciwgc3R5bGUpO1xyXG4gIFx0XHR9LCB0aGlzKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X3NldExheWVyU3R5bGU6IGZ1bmN0aW9uIChsYXllciwgc3R5bGUpIHtcclxuICBcdFx0aWYgKGxheWVyLnNldFN0eWxlKSB7XHJcbiAgXHRcdFx0aWYgKHR5cGVvZiBzdHlsZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gIFx0XHRcdFx0c3R5bGUgPSBzdHlsZShsYXllci5mZWF0dXJlKTtcclxuICBcdFx0XHR9XHJcbiAgXHRcdFx0bGF5ZXIuc2V0U3R5bGUoc3R5bGUpO1xyXG4gIFx0XHR9XHJcbiAgXHR9XHJcbiAgfSk7XHJcblxyXG4gIC8vIEBzZWN0aW9uXHJcbiAgLy8gVGhlcmUgYXJlIHNldmVyYWwgc3RhdGljIGZ1bmN0aW9ucyB3aGljaCBjYW4gYmUgY2FsbGVkIHdpdGhvdXQgaW5zdGFudGlhdGluZyBMLkdlb0pTT046XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBnZW9tZXRyeVRvTGF5ZXIoZmVhdHVyZURhdGE6IE9iamVjdCwgb3B0aW9ucz86IEdlb0pTT04gb3B0aW9ucyk6IExheWVyXHJcbiAgLy8gQ3JlYXRlcyBhIGBMYXllcmAgZnJvbSBhIGdpdmVuIEdlb0pTT04gZmVhdHVyZS4gQ2FuIHVzZSBhIGN1c3RvbVxyXG4gIC8vIFtgcG9pbnRUb0xheWVyYF0oI2dlb2pzb24tcG9pbnR0b2xheWVyKSBhbmQvb3IgW2Bjb29yZHNUb0xhdExuZ2BdKCNnZW9qc29uLWNvb3Jkc3RvbGF0bG5nKVxyXG4gIC8vIGZ1bmN0aW9ucyBpZiBwcm92aWRlZCBhcyBvcHRpb25zLlxyXG4gIGZ1bmN0aW9uIGdlb21ldHJ5VG9MYXllcihnZW9qc29uLCBvcHRpb25zKSB7XHJcblxyXG4gIFx0dmFyIGdlb21ldHJ5ID0gZ2VvanNvbi50eXBlID09PSAnRmVhdHVyZScgPyBnZW9qc29uLmdlb21ldHJ5IDogZ2VvanNvbixcclxuICBcdCAgICBjb29yZHMgPSBnZW9tZXRyeSA/IGdlb21ldHJ5LmNvb3JkaW5hdGVzIDogbnVsbCxcclxuICBcdCAgICBsYXllcnMgPSBbXSxcclxuICBcdCAgICBwb2ludFRvTGF5ZXIgPSBvcHRpb25zICYmIG9wdGlvbnMucG9pbnRUb0xheWVyLFxyXG4gIFx0ICAgIF9jb29yZHNUb0xhdExuZyA9IG9wdGlvbnMgJiYgb3B0aW9ucy5jb29yZHNUb0xhdExuZyB8fCBjb29yZHNUb0xhdExuZyxcclxuICBcdCAgICBsYXRsbmcsIGxhdGxuZ3MsIGksIGxlbjtcclxuXHJcbiAgXHRpZiAoIWNvb3JkcyAmJiAhZ2VvbWV0cnkpIHtcclxuICBcdFx0cmV0dXJuIG51bGw7XHJcbiAgXHR9XHJcblxyXG4gIFx0c3dpdGNoIChnZW9tZXRyeS50eXBlKSB7XHJcbiAgXHRjYXNlICdQb2ludCc6XHJcbiAgXHRcdGxhdGxuZyA9IF9jb29yZHNUb0xhdExuZyhjb29yZHMpO1xyXG4gIFx0XHRyZXR1cm4gX3BvaW50VG9MYXllcihwb2ludFRvTGF5ZXIsIGdlb2pzb24sIGxhdGxuZywgb3B0aW9ucyk7XHJcblxyXG4gIFx0Y2FzZSAnTXVsdGlQb2ludCc6XHJcbiAgXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNvb3Jkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gIFx0XHRcdGxhdGxuZyA9IF9jb29yZHNUb0xhdExuZyhjb29yZHNbaV0pO1xyXG4gIFx0XHRcdGxheWVycy5wdXNoKF9wb2ludFRvTGF5ZXIocG9pbnRUb0xheWVyLCBnZW9qc29uLCBsYXRsbmcsIG9wdGlvbnMpKTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gbmV3IEZlYXR1cmVHcm91cChsYXllcnMpO1xyXG5cclxuICBcdGNhc2UgJ0xpbmVTdHJpbmcnOlxyXG4gIFx0Y2FzZSAnTXVsdGlMaW5lU3RyaW5nJzpcclxuICBcdFx0bGF0bG5ncyA9IGNvb3Jkc1RvTGF0TG5ncyhjb29yZHMsIGdlb21ldHJ5LnR5cGUgPT09ICdMaW5lU3RyaW5nJyA/IDAgOiAxLCBfY29vcmRzVG9MYXRMbmcpO1xyXG4gIFx0XHRyZXR1cm4gbmV3IFBvbHlsaW5lKGxhdGxuZ3MsIG9wdGlvbnMpO1xyXG5cclxuICBcdGNhc2UgJ1BvbHlnb24nOlxyXG4gIFx0Y2FzZSAnTXVsdGlQb2x5Z29uJzpcclxuICBcdFx0bGF0bG5ncyA9IGNvb3Jkc1RvTGF0TG5ncyhjb29yZHMsIGdlb21ldHJ5LnR5cGUgPT09ICdQb2x5Z29uJyA/IDEgOiAyLCBfY29vcmRzVG9MYXRMbmcpO1xyXG4gIFx0XHRyZXR1cm4gbmV3IFBvbHlnb24obGF0bG5ncywgb3B0aW9ucyk7XHJcblxyXG4gIFx0Y2FzZSAnR2VvbWV0cnlDb2xsZWN0aW9uJzpcclxuICBcdFx0Zm9yIChpID0gMCwgbGVuID0gZ2VvbWV0cnkuZ2VvbWV0cmllcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gIFx0XHRcdHZhciBsYXllciA9IGdlb21ldHJ5VG9MYXllcih7XHJcbiAgXHRcdFx0XHRnZW9tZXRyeTogZ2VvbWV0cnkuZ2VvbWV0cmllc1tpXSxcclxuICBcdFx0XHRcdHR5cGU6ICdGZWF0dXJlJyxcclxuICBcdFx0XHRcdHByb3BlcnRpZXM6IGdlb2pzb24ucHJvcGVydGllc1xyXG4gIFx0XHRcdH0sIG9wdGlvbnMpO1xyXG5cclxuICBcdFx0XHRpZiAobGF5ZXIpIHtcclxuICBcdFx0XHRcdGxheWVycy5wdXNoKGxheWVyKTtcclxuICBcdFx0XHR9XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIG5ldyBGZWF0dXJlR3JvdXAobGF5ZXJzKTtcclxuXHJcbiAgXHRkZWZhdWx0OlxyXG4gIFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgR2VvSlNPTiBvYmplY3QuJyk7XHJcbiAgXHR9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBfcG9pbnRUb0xheWVyKHBvaW50VG9MYXllckZuLCBnZW9qc29uLCBsYXRsbmcsIG9wdGlvbnMpIHtcclxuICBcdHJldHVybiBwb2ludFRvTGF5ZXJGbiA/XHJcbiAgXHRcdHBvaW50VG9MYXllckZuKGdlb2pzb24sIGxhdGxuZykgOlxyXG4gIFx0XHRuZXcgTWFya2VyKGxhdGxuZywgb3B0aW9ucyAmJiBvcHRpb25zLm1hcmtlcnNJbmhlcml0T3B0aW9ucyAmJiBvcHRpb25zKTtcclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBjb29yZHNUb0xhdExuZyhjb29yZHM6IEFycmF5KTogTGF0TG5nXHJcbiAgLy8gQ3JlYXRlcyBhIGBMYXRMbmdgIG9iamVjdCBmcm9tIGFuIGFycmF5IG9mIDIgbnVtYmVycyAobG9uZ2l0dWRlLCBsYXRpdHVkZSlcclxuICAvLyBvciAzIG51bWJlcnMgKGxvbmdpdHVkZSwgbGF0aXR1ZGUsIGFsdGl0dWRlKSB1c2VkIGluIEdlb0pTT04gZm9yIHBvaW50cy5cclxuICBmdW5jdGlvbiBjb29yZHNUb0xhdExuZyhjb29yZHMpIHtcclxuICBcdHJldHVybiBuZXcgTGF0TG5nKGNvb3Jkc1sxXSwgY29vcmRzWzBdLCBjb29yZHNbMl0pO1xyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGNvb3Jkc1RvTGF0TG5ncyhjb29yZHM6IEFycmF5LCBsZXZlbHNEZWVwPzogTnVtYmVyLCBjb29yZHNUb0xhdExuZz86IEZ1bmN0aW9uKTogQXJyYXlcclxuICAvLyBDcmVhdGVzIGEgbXVsdGlkaW1lbnNpb25hbCBhcnJheSBvZiBgTGF0TG5nYHMgZnJvbSBhIEdlb0pTT04gY29vcmRpbmF0ZXMgYXJyYXkuXHJcbiAgLy8gYGxldmVsc0RlZXBgIHNwZWNpZmllcyB0aGUgbmVzdGluZyBsZXZlbCAoMCBpcyBmb3IgYW4gYXJyYXkgb2YgcG9pbnRzLCAxIGZvciBhbiBhcnJheSBvZiBhcnJheXMgb2YgcG9pbnRzLCBldGMuLCAwIGJ5IGRlZmF1bHQpLlxyXG4gIC8vIENhbiB1c2UgYSBjdXN0b20gW2Bjb29yZHNUb0xhdExuZ2BdKCNnZW9qc29uLWNvb3Jkc3RvbGF0bG5nKSBmdW5jdGlvbi5cclxuICBmdW5jdGlvbiBjb29yZHNUb0xhdExuZ3MoY29vcmRzLCBsZXZlbHNEZWVwLCBfY29vcmRzVG9MYXRMbmcpIHtcclxuICBcdHZhciBsYXRsbmdzID0gW107XHJcblxyXG4gIFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvb3Jkcy5sZW5ndGgsIGxhdGxuZzsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgXHRcdGxhdGxuZyA9IGxldmVsc0RlZXAgP1xyXG4gIFx0XHRcdGNvb3Jkc1RvTGF0TG5ncyhjb29yZHNbaV0sIGxldmVsc0RlZXAgLSAxLCBfY29vcmRzVG9MYXRMbmcpIDpcclxuICBcdFx0XHQoX2Nvb3Jkc1RvTGF0TG5nIHx8IGNvb3Jkc1RvTGF0TG5nKShjb29yZHNbaV0pO1xyXG5cclxuICBcdFx0bGF0bG5ncy5wdXNoKGxhdGxuZyk7XHJcbiAgXHR9XHJcblxyXG4gIFx0cmV0dXJuIGxhdGxuZ3M7XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gbGF0TG5nVG9Db29yZHMobGF0bG5nOiBMYXRMbmcsIHByZWNpc2lvbj86IE51bWJlcik6IEFycmF5XHJcbiAgLy8gUmV2ZXJzZSBvZiBbYGNvb3Jkc1RvTGF0TG5nYF0oI2dlb2pzb24tY29vcmRzdG9sYXRsbmcpXHJcbiAgZnVuY3Rpb24gbGF0TG5nVG9Db29yZHMobGF0bG5nLCBwcmVjaXNpb24pIHtcclxuICBcdHByZWNpc2lvbiA9IHR5cGVvZiBwcmVjaXNpb24gPT09ICdudW1iZXInID8gcHJlY2lzaW9uIDogNjtcclxuICBcdHJldHVybiBsYXRsbmcuYWx0ICE9PSB1bmRlZmluZWQgP1xyXG4gIFx0XHRbZm9ybWF0TnVtKGxhdGxuZy5sbmcsIHByZWNpc2lvbiksIGZvcm1hdE51bShsYXRsbmcubGF0LCBwcmVjaXNpb24pLCBmb3JtYXROdW0obGF0bG5nLmFsdCwgcHJlY2lzaW9uKV0gOlxyXG4gIFx0XHRbZm9ybWF0TnVtKGxhdGxuZy5sbmcsIHByZWNpc2lvbiksIGZvcm1hdE51bShsYXRsbmcubGF0LCBwcmVjaXNpb24pXTtcclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBsYXRMbmdzVG9Db29yZHMobGF0bG5nczogQXJyYXksIGxldmVsc0RlZXA/OiBOdW1iZXIsIGNsb3NlZD86IEJvb2xlYW4pOiBBcnJheVxyXG4gIC8vIFJldmVyc2Ugb2YgW2Bjb29yZHNUb0xhdExuZ3NgXSgjZ2VvanNvbi1jb29yZHN0b2xhdGxuZ3MpXHJcbiAgLy8gYGNsb3NlZGAgZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBmaXJzdCBwb2ludCBzaG91bGQgYmUgYXBwZW5kZWQgdG8gdGhlIGVuZCBvZiB0aGUgYXJyYXkgdG8gY2xvc2UgdGhlIGZlYXR1cmUsIG9ubHkgdXNlZCB3aGVuIGBsZXZlbHNEZWVwYCBpcyAwLiBGYWxzZSBieSBkZWZhdWx0LlxyXG4gIGZ1bmN0aW9uIGxhdExuZ3NUb0Nvb3JkcyhsYXRsbmdzLCBsZXZlbHNEZWVwLCBjbG9zZWQsIHByZWNpc2lvbikge1xyXG4gIFx0dmFyIGNvb3JkcyA9IFtdO1xyXG5cclxuICBcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBsYXRsbmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgXHRcdGNvb3Jkcy5wdXNoKGxldmVsc0RlZXAgP1xyXG4gIFx0XHRcdGxhdExuZ3NUb0Nvb3JkcyhsYXRsbmdzW2ldLCBsZXZlbHNEZWVwIC0gMSwgY2xvc2VkLCBwcmVjaXNpb24pIDpcclxuICBcdFx0XHRsYXRMbmdUb0Nvb3JkcyhsYXRsbmdzW2ldLCBwcmVjaXNpb24pKTtcclxuICBcdH1cclxuXHJcbiAgXHRpZiAoIWxldmVsc0RlZXAgJiYgY2xvc2VkKSB7XHJcbiAgXHRcdGNvb3Jkcy5wdXNoKGNvb3Jkc1swXSk7XHJcbiAgXHR9XHJcblxyXG4gIFx0cmV0dXJuIGNvb3JkcztcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGdldEZlYXR1cmUobGF5ZXIsIG5ld0dlb21ldHJ5KSB7XHJcbiAgXHRyZXR1cm4gbGF5ZXIuZmVhdHVyZSA/XHJcbiAgXHRcdGV4dGVuZCh7fSwgbGF5ZXIuZmVhdHVyZSwge2dlb21ldHJ5OiBuZXdHZW9tZXRyeX0pIDpcclxuICBcdFx0YXNGZWF0dXJlKG5ld0dlb21ldHJ5KTtcclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBhc0ZlYXR1cmUoZ2VvanNvbjogT2JqZWN0KTogT2JqZWN0XHJcbiAgLy8gTm9ybWFsaXplIEdlb0pTT04gZ2VvbWV0cmllcy9mZWF0dXJlcyBpbnRvIEdlb0pTT04gZmVhdHVyZXMuXHJcbiAgZnVuY3Rpb24gYXNGZWF0dXJlKGdlb2pzb24pIHtcclxuICBcdGlmIChnZW9qc29uLnR5cGUgPT09ICdGZWF0dXJlJyB8fCBnZW9qc29uLnR5cGUgPT09ICdGZWF0dXJlQ29sbGVjdGlvbicpIHtcclxuICBcdFx0cmV0dXJuIGdlb2pzb247XHJcbiAgXHR9XHJcblxyXG4gIFx0cmV0dXJuIHtcclxuICBcdFx0dHlwZTogJ0ZlYXR1cmUnLFxyXG4gIFx0XHRwcm9wZXJ0aWVzOiB7fSxcclxuICBcdFx0Z2VvbWV0cnk6IGdlb2pzb25cclxuICBcdH07XHJcbiAgfVxyXG5cclxuICB2YXIgUG9pbnRUb0dlb0pTT04gPSB7XHJcbiAgXHR0b0dlb0pTT046IGZ1bmN0aW9uIChwcmVjaXNpb24pIHtcclxuICBcdFx0cmV0dXJuIGdldEZlYXR1cmUodGhpcywge1xyXG4gIFx0XHRcdHR5cGU6ICdQb2ludCcsXHJcbiAgXHRcdFx0Y29vcmRpbmF0ZXM6IGxhdExuZ1RvQ29vcmRzKHRoaXMuZ2V0TGF0TG5nKCksIHByZWNpc2lvbilcclxuICBcdFx0fSk7XHJcbiAgXHR9XHJcbiAgfTtcclxuXHJcbiAgLy8gQG5hbWVzcGFjZSBNYXJrZXJcclxuICAvLyBAc2VjdGlvbiBPdGhlciBtZXRob2RzXHJcbiAgLy8gQG1ldGhvZCB0b0dlb0pTT04ocHJlY2lzaW9uPzogTnVtYmVyKTogT2JqZWN0XHJcbiAgLy8gYHByZWNpc2lvbmAgaXMgdGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyBmb3IgY29vcmRpbmF0ZXMuXHJcbiAgLy8gVGhlIGRlZmF1bHQgdmFsdWUgaXMgNiBwbGFjZXMuXHJcbiAgLy8gUmV0dXJucyBhIFtgR2VvSlNPTmBdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR2VvSlNPTikgcmVwcmVzZW50YXRpb24gb2YgdGhlIG1hcmtlciAoYXMgYSBHZW9KU09OIGBQb2ludGAgRmVhdHVyZSkuXHJcbiAgTWFya2VyLmluY2x1ZGUoUG9pbnRUb0dlb0pTT04pO1xyXG5cclxuICAvLyBAbmFtZXNwYWNlIENpcmNsZU1hcmtlclxyXG4gIC8vIEBtZXRob2QgdG9HZW9KU09OKHByZWNpc2lvbj86IE51bWJlcik6IE9iamVjdFxyXG4gIC8vIGBwcmVjaXNpb25gIGlzIHRoZSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgZm9yIGNvb3JkaW5hdGVzLlxyXG4gIC8vIFRoZSBkZWZhdWx0IHZhbHVlIGlzIDYgcGxhY2VzLlxyXG4gIC8vIFJldHVybnMgYSBbYEdlb0pTT05gXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dlb0pTT04pIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjaXJjbGUgbWFya2VyIChhcyBhIEdlb0pTT04gYFBvaW50YCBGZWF0dXJlKS5cclxuICBDaXJjbGUuaW5jbHVkZShQb2ludFRvR2VvSlNPTik7XHJcbiAgQ2lyY2xlTWFya2VyLmluY2x1ZGUoUG9pbnRUb0dlb0pTT04pO1xyXG5cclxuXHJcbiAgLy8gQG5hbWVzcGFjZSBQb2x5bGluZVxyXG4gIC8vIEBtZXRob2QgdG9HZW9KU09OKHByZWNpc2lvbj86IE51bWJlcik6IE9iamVjdFxyXG4gIC8vIGBwcmVjaXNpb25gIGlzIHRoZSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgZm9yIGNvb3JkaW5hdGVzLlxyXG4gIC8vIFRoZSBkZWZhdWx0IHZhbHVlIGlzIDYgcGxhY2VzLlxyXG4gIC8vIFJldHVybnMgYSBbYEdlb0pTT05gXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dlb0pTT04pIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwb2x5bGluZSAoYXMgYSBHZW9KU09OIGBMaW5lU3RyaW5nYCBvciBgTXVsdGlMaW5lU3RyaW5nYCBGZWF0dXJlKS5cclxuICBQb2x5bGluZS5pbmNsdWRlKHtcclxuICBcdHRvR2VvSlNPTjogZnVuY3Rpb24gKHByZWNpc2lvbikge1xyXG4gIFx0XHR2YXIgbXVsdGkgPSAhaXNGbGF0KHRoaXMuX2xhdGxuZ3MpO1xyXG5cclxuICBcdFx0dmFyIGNvb3JkcyA9IGxhdExuZ3NUb0Nvb3Jkcyh0aGlzLl9sYXRsbmdzLCBtdWx0aSA/IDEgOiAwLCBmYWxzZSwgcHJlY2lzaW9uKTtcclxuXHJcbiAgXHRcdHJldHVybiBnZXRGZWF0dXJlKHRoaXMsIHtcclxuICBcdFx0XHR0eXBlOiAobXVsdGkgPyAnTXVsdGknIDogJycpICsgJ0xpbmVTdHJpbmcnLFxyXG4gIFx0XHRcdGNvb3JkaW5hdGVzOiBjb29yZHNcclxuICBcdFx0fSk7XHJcbiAgXHR9XHJcbiAgfSk7XHJcblxyXG4gIC8vIEBuYW1lc3BhY2UgUG9seWdvblxyXG4gIC8vIEBtZXRob2QgdG9HZW9KU09OKHByZWNpc2lvbj86IE51bWJlcik6IE9iamVjdFxyXG4gIC8vIGBwcmVjaXNpb25gIGlzIHRoZSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgZm9yIGNvb3JkaW5hdGVzLlxyXG4gIC8vIFRoZSBkZWZhdWx0IHZhbHVlIGlzIDYgcGxhY2VzLlxyXG4gIC8vIFJldHVybnMgYSBbYEdlb0pTT05gXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dlb0pTT04pIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwb2x5Z29uIChhcyBhIEdlb0pTT04gYFBvbHlnb25gIG9yIGBNdWx0aVBvbHlnb25gIEZlYXR1cmUpLlxyXG4gIFBvbHlnb24uaW5jbHVkZSh7XHJcbiAgXHR0b0dlb0pTT046IGZ1bmN0aW9uIChwcmVjaXNpb24pIHtcclxuICBcdFx0dmFyIGhvbGVzID0gIWlzRmxhdCh0aGlzLl9sYXRsbmdzKSxcclxuICBcdFx0ICAgIG11bHRpID0gaG9sZXMgJiYgIWlzRmxhdCh0aGlzLl9sYXRsbmdzWzBdKTtcclxuXHJcbiAgXHRcdHZhciBjb29yZHMgPSBsYXRMbmdzVG9Db29yZHModGhpcy5fbGF0bG5ncywgbXVsdGkgPyAyIDogaG9sZXMgPyAxIDogMCwgdHJ1ZSwgcHJlY2lzaW9uKTtcclxuXHJcbiAgXHRcdGlmICghaG9sZXMpIHtcclxuICBcdFx0XHRjb29yZHMgPSBbY29vcmRzXTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0cmV0dXJuIGdldEZlYXR1cmUodGhpcywge1xyXG4gIFx0XHRcdHR5cGU6IChtdWx0aSA/ICdNdWx0aScgOiAnJykgKyAnUG9seWdvbicsXHJcbiAgXHRcdFx0Y29vcmRpbmF0ZXM6IGNvb3Jkc1xyXG4gIFx0XHR9KTtcclxuICBcdH1cclxuICB9KTtcclxuXHJcblxyXG4gIC8vIEBuYW1lc3BhY2UgTGF5ZXJHcm91cFxyXG4gIExheWVyR3JvdXAuaW5jbHVkZSh7XHJcbiAgXHR0b011bHRpUG9pbnQ6IGZ1bmN0aW9uIChwcmVjaXNpb24pIHtcclxuICBcdFx0dmFyIGNvb3JkcyA9IFtdO1xyXG5cclxuICBcdFx0dGhpcy5lYWNoTGF5ZXIoZnVuY3Rpb24gKGxheWVyKSB7XHJcbiAgXHRcdFx0Y29vcmRzLnB1c2gobGF5ZXIudG9HZW9KU09OKHByZWNpc2lvbikuZ2VvbWV0cnkuY29vcmRpbmF0ZXMpO1xyXG4gIFx0XHR9KTtcclxuXHJcbiAgXHRcdHJldHVybiBnZXRGZWF0dXJlKHRoaXMsIHtcclxuICBcdFx0XHR0eXBlOiAnTXVsdGlQb2ludCcsXHJcbiAgXHRcdFx0Y29vcmRpbmF0ZXM6IGNvb3Jkc1xyXG4gIFx0XHR9KTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCB0b0dlb0pTT04ocHJlY2lzaW9uPzogTnVtYmVyKTogT2JqZWN0XHJcbiAgXHQvLyBgcHJlY2lzaW9uYCBpcyB0aGUgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIGZvciBjb29yZGluYXRlcy5cclxuICBcdC8vIFRoZSBkZWZhdWx0IHZhbHVlIGlzIDYgcGxhY2VzLlxyXG4gIFx0Ly8gUmV0dXJucyBhIFtgR2VvSlNPTmBdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR2VvSlNPTikgcmVwcmVzZW50YXRpb24gb2YgdGhlIGxheWVyIGdyb3VwIChhcyBhIEdlb0pTT04gYEZlYXR1cmVDb2xsZWN0aW9uYCwgYEdlb21ldHJ5Q29sbGVjdGlvbmAsIG9yIGBNdWx0aVBvaW50YCkuXHJcbiAgXHR0b0dlb0pTT046IGZ1bmN0aW9uIChwcmVjaXNpb24pIHtcclxuXHJcbiAgXHRcdHZhciB0eXBlID0gdGhpcy5mZWF0dXJlICYmIHRoaXMuZmVhdHVyZS5nZW9tZXRyeSAmJiB0aGlzLmZlYXR1cmUuZ2VvbWV0cnkudHlwZTtcclxuXHJcbiAgXHRcdGlmICh0eXBlID09PSAnTXVsdGlQb2ludCcpIHtcclxuICBcdFx0XHRyZXR1cm4gdGhpcy50b011bHRpUG9pbnQocHJlY2lzaW9uKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dmFyIGlzR2VvbWV0cnlDb2xsZWN0aW9uID0gdHlwZSA9PT0gJ0dlb21ldHJ5Q29sbGVjdGlvbicsXHJcbiAgXHRcdCAgICBqc29ucyA9IFtdO1xyXG5cclxuICBcdFx0dGhpcy5lYWNoTGF5ZXIoZnVuY3Rpb24gKGxheWVyKSB7XHJcbiAgXHRcdFx0aWYgKGxheWVyLnRvR2VvSlNPTikge1xyXG4gIFx0XHRcdFx0dmFyIGpzb24gPSBsYXllci50b0dlb0pTT04ocHJlY2lzaW9uKTtcclxuICBcdFx0XHRcdGlmIChpc0dlb21ldHJ5Q29sbGVjdGlvbikge1xyXG4gIFx0XHRcdFx0XHRqc29ucy5wdXNoKGpzb24uZ2VvbWV0cnkpO1xyXG4gIFx0XHRcdFx0fSBlbHNlIHtcclxuICBcdFx0XHRcdFx0dmFyIGZlYXR1cmUgPSBhc0ZlYXR1cmUoanNvbik7XHJcbiAgXHRcdFx0XHRcdC8vIFNxdWFzaCBuZXN0ZWQgZmVhdHVyZSBjb2xsZWN0aW9uc1xyXG4gIFx0XHRcdFx0XHRpZiAoZmVhdHVyZS50eXBlID09PSAnRmVhdHVyZUNvbGxlY3Rpb24nKSB7XHJcbiAgXHRcdFx0XHRcdFx0anNvbnMucHVzaC5hcHBseShqc29ucywgZmVhdHVyZS5mZWF0dXJlcyk7XHJcbiAgXHRcdFx0XHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0XHRcdFx0anNvbnMucHVzaChmZWF0dXJlKTtcclxuICBcdFx0XHRcdFx0fVxyXG4gIFx0XHRcdFx0fVxyXG4gIFx0XHRcdH1cclxuICBcdFx0fSk7XHJcblxyXG4gIFx0XHRpZiAoaXNHZW9tZXRyeUNvbGxlY3Rpb24pIHtcclxuICBcdFx0XHRyZXR1cm4gZ2V0RmVhdHVyZSh0aGlzLCB7XHJcbiAgXHRcdFx0XHRnZW9tZXRyaWVzOiBqc29ucyxcclxuICBcdFx0XHRcdHR5cGU6ICdHZW9tZXRyeUNvbGxlY3Rpb24nXHJcbiAgXHRcdFx0fSk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHJldHVybiB7XHJcbiAgXHRcdFx0dHlwZTogJ0ZlYXR1cmVDb2xsZWN0aW9uJyxcclxuICBcdFx0XHRmZWF0dXJlczoganNvbnNcclxuICBcdFx0fTtcclxuICBcdH1cclxuICB9KTtcclxuXHJcbiAgLy8gQG5hbWVzcGFjZSBHZW9KU09OXHJcbiAgLy8gQGZhY3RvcnkgTC5nZW9KU09OKGdlb2pzb24/OiBPYmplY3QsIG9wdGlvbnM/OiBHZW9KU09OIG9wdGlvbnMpXHJcbiAgLy8gQ3JlYXRlcyBhIEdlb0pTT04gbGF5ZXIuIE9wdGlvbmFsbHkgYWNjZXB0cyBhbiBvYmplY3QgaW5cclxuICAvLyBbR2VvSlNPTiBmb3JtYXRdKGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3OTQ2KSB0byBkaXNwbGF5IG9uIHRoZSBtYXBcclxuICAvLyAoeW91IGNhbiBhbHRlcm5hdGl2ZWx5IGFkZCBpdCBsYXRlciB3aXRoIGBhZGREYXRhYCBtZXRob2QpIGFuZCBhbiBgb3B0aW9uc2Agb2JqZWN0LlxyXG4gIGZ1bmN0aW9uIGdlb0pTT04oZ2VvanNvbiwgb3B0aW9ucykge1xyXG4gIFx0cmV0dXJuIG5ldyBHZW9KU09OKGdlb2pzb24sIG9wdGlvbnMpO1xyXG4gIH1cclxuXHJcbiAgLy8gQmFja3dhcmQgY29tcGF0aWJpbGl0eS5cclxuICB2YXIgZ2VvSnNvbiA9IGdlb0pTT047XG5cbiAgLypcclxuICAgKiBAY2xhc3MgSW1hZ2VPdmVybGF5XHJcbiAgICogQGFrYSBMLkltYWdlT3ZlcmxheVxyXG4gICAqIEBpbmhlcml0cyBJbnRlcmFjdGl2ZSBsYXllclxyXG4gICAqXHJcbiAgICogVXNlZCB0byBsb2FkIGFuZCBkaXNwbGF5IGEgc2luZ2xlIGltYWdlIG92ZXIgc3BlY2lmaWMgYm91bmRzIG9mIHRoZSBtYXAuIEV4dGVuZHMgYExheWVyYC5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICpcclxuICAgKiBgYGBqc1xyXG4gICAqIHZhciBpbWFnZVVybCA9ICdodHRwOi8vd3d3LmxpYi51dGV4YXMuZWR1L21hcHMvaGlzdG9yaWNhbC9uZXdhcmtfbmpfMTkyMi5qcGcnLFxyXG4gICAqIFx0aW1hZ2VCb3VuZHMgPSBbWzQwLjcxMjIxNiwgLTc0LjIyNjU1XSwgWzQwLjc3Mzk0MSwgLTc0LjEyNTQ0XV07XHJcbiAgICogTC5pbWFnZU92ZXJsYXkoaW1hZ2VVcmwsIGltYWdlQm91bmRzKS5hZGRUbyhtYXApO1xyXG4gICAqIGBgYFxyXG4gICAqL1xyXG5cclxuICB2YXIgSW1hZ2VPdmVybGF5ID0gTGF5ZXIuZXh0ZW5kKHtcclxuXHJcbiAgXHQvLyBAc2VjdGlvblxyXG4gIFx0Ly8gQGFrYSBJbWFnZU92ZXJsYXkgb3B0aW9uc1xyXG4gIFx0b3B0aW9uczoge1xyXG4gIFx0XHQvLyBAb3B0aW9uIG9wYWNpdHk6IE51bWJlciA9IDEuMFxyXG4gIFx0XHQvLyBUaGUgb3BhY2l0eSBvZiB0aGUgaW1hZ2Ugb3ZlcmxheS5cclxuICBcdFx0b3BhY2l0eTogMSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gYWx0OiBTdHJpbmcgPSAnJ1xyXG4gIFx0XHQvLyBUZXh0IGZvciB0aGUgYGFsdGAgYXR0cmlidXRlIG9mIHRoZSBpbWFnZSAodXNlZnVsIGZvciBhY2Nlc3NpYmlsaXR5KS5cclxuICBcdFx0YWx0OiAnJyxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gaW50ZXJhY3RpdmU6IEJvb2xlYW4gPSBmYWxzZVxyXG4gIFx0XHQvLyBJZiBgdHJ1ZWAsIHRoZSBpbWFnZSBvdmVybGF5IHdpbGwgZW1pdCBbbW91c2UgZXZlbnRzXSgjaW50ZXJhY3RpdmUtbGF5ZXIpIHdoZW4gY2xpY2tlZCBvciBob3ZlcmVkLlxyXG4gIFx0XHRpbnRlcmFjdGl2ZTogZmFsc2UsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIGNyb3NzT3JpZ2luOiBCb29sZWFufFN0cmluZyA9IGZhbHNlXHJcbiAgXHRcdC8vIFdoZXRoZXIgdGhlIGNyb3NzT3JpZ2luIGF0dHJpYnV0ZSB3aWxsIGJlIGFkZGVkIHRvIHRoZSBpbWFnZS5cclxuICBcdFx0Ly8gSWYgYSBTdHJpbmcgaXMgcHJvdmlkZWQsIHRoZSBpbWFnZSB3aWxsIGhhdmUgaXRzIGNyb3NzT3JpZ2luIGF0dHJpYnV0ZSBzZXQgdG8gdGhlIFN0cmluZyBwcm92aWRlZC4gVGhpcyBpcyBuZWVkZWQgaWYgeW91IHdhbnQgdG8gYWNjZXNzIGltYWdlIHBpeGVsIGRhdGEuXHJcbiAgXHRcdC8vIFJlZmVyIHRvIFtDT1JTIFNldHRpbmdzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0NPUlNfc2V0dGluZ3NfYXR0cmlidXRlcykgZm9yIHZhbGlkIFN0cmluZyB2YWx1ZXMuXHJcbiAgXHRcdGNyb3NzT3JpZ2luOiBmYWxzZSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gZXJyb3JPdmVybGF5VXJsOiBTdHJpbmcgPSAnJ1xyXG4gIFx0XHQvLyBVUkwgdG8gdGhlIG92ZXJsYXkgaW1hZ2UgdG8gc2hvdyBpbiBwbGFjZSBvZiB0aGUgb3ZlcmxheSB0aGF0IGZhaWxlZCB0byBsb2FkLlxyXG4gIFx0XHRlcnJvck92ZXJsYXlVcmw6ICcnLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiB6SW5kZXg6IE51bWJlciA9IDFcclxuICBcdFx0Ly8gVGhlIGV4cGxpY2l0IFt6SW5kZXhdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0NTUy9DU1NfUG9zaXRpb25pbmcvVW5kZXJzdGFuZGluZ196X2luZGV4KSBvZiB0aGUgb3ZlcmxheSBsYXllci5cclxuICBcdFx0ekluZGV4OiAxLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBjbGFzc05hbWU6IFN0cmluZyA9ICcnXHJcbiAgXHRcdC8vIEEgY3VzdG9tIGNsYXNzIG5hbWUgdG8gYXNzaWduIHRvIHRoZSBpbWFnZS4gRW1wdHkgYnkgZGVmYXVsdC5cclxuICBcdFx0Y2xhc3NOYW1lOiAnJ1xyXG4gIFx0fSxcclxuXHJcbiAgXHRpbml0aWFsaXplOiBmdW5jdGlvbiAodXJsLCBib3VuZHMsIG9wdGlvbnMpIHsgLy8gKFN0cmluZywgTGF0TG5nQm91bmRzLCBPYmplY3QpXHJcbiAgXHRcdHRoaXMuX3VybCA9IHVybDtcclxuICBcdFx0dGhpcy5fYm91bmRzID0gdG9MYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcbiAgXHRcdHNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcbiAgXHR9LFxyXG5cclxuICBcdG9uQWRkOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdGlmICghdGhpcy5faW1hZ2UpIHtcclxuICBcdFx0XHR0aGlzLl9pbml0SW1hZ2UoKTtcclxuXHJcbiAgXHRcdFx0aWYgKHRoaXMub3B0aW9ucy5vcGFjaXR5IDwgMSkge1xyXG4gIFx0XHRcdFx0dGhpcy5fdXBkYXRlT3BhY2l0eSgpO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0fVxyXG5cclxuICBcdFx0aWYgKHRoaXMub3B0aW9ucy5pbnRlcmFjdGl2ZSkge1xyXG4gIFx0XHRcdGFkZENsYXNzKHRoaXMuX2ltYWdlLCAnbGVhZmxldC1pbnRlcmFjdGl2ZScpO1xyXG4gIFx0XHRcdHRoaXMuYWRkSW50ZXJhY3RpdmVUYXJnZXQodGhpcy5faW1hZ2UpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR0aGlzLmdldFBhbmUoKS5hcHBlbmRDaGlsZCh0aGlzLl9pbWFnZSk7XHJcbiAgXHRcdHRoaXMuX3Jlc2V0KCk7XHJcbiAgXHR9LFxyXG5cclxuICBcdG9uUmVtb3ZlOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJlbW92ZSh0aGlzLl9pbWFnZSk7XHJcbiAgXHRcdGlmICh0aGlzLm9wdGlvbnMuaW50ZXJhY3RpdmUpIHtcclxuICBcdFx0XHR0aGlzLnJlbW92ZUludGVyYWN0aXZlVGFyZ2V0KHRoaXMuX2ltYWdlKTtcclxuICBcdFx0fVxyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHNldE9wYWNpdHkob3BhY2l0eTogTnVtYmVyKTogdGhpc1xyXG4gIFx0Ly8gU2V0cyB0aGUgb3BhY2l0eSBvZiB0aGUgb3ZlcmxheS5cclxuICBcdHNldE9wYWNpdHk6IGZ1bmN0aW9uIChvcGFjaXR5KSB7XHJcbiAgXHRcdHRoaXMub3B0aW9ucy5vcGFjaXR5ID0gb3BhY2l0eTtcclxuXHJcbiAgXHRcdGlmICh0aGlzLl9pbWFnZSkge1xyXG4gIFx0XHRcdHRoaXMuX3VwZGF0ZU9wYWNpdHkoKTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0c2V0U3R5bGU6IGZ1bmN0aW9uIChzdHlsZU9wdHMpIHtcclxuICBcdFx0aWYgKHN0eWxlT3B0cy5vcGFjaXR5KSB7XHJcbiAgXHRcdFx0dGhpcy5zZXRPcGFjaXR5KHN0eWxlT3B0cy5vcGFjaXR5KTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBicmluZ1RvRnJvbnQoKTogdGhpc1xyXG4gIFx0Ly8gQnJpbmdzIHRoZSBsYXllciB0byB0aGUgdG9wIG9mIGFsbCBvdmVybGF5cy5cclxuICBcdGJyaW5nVG9Gcm9udDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRpZiAodGhpcy5fbWFwKSB7XHJcbiAgXHRcdFx0dG9Gcm9udCh0aGlzLl9pbWFnZSk7XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgYnJpbmdUb0JhY2soKTogdGhpc1xyXG4gIFx0Ly8gQnJpbmdzIHRoZSBsYXllciB0byB0aGUgYm90dG9tIG9mIGFsbCBvdmVybGF5cy5cclxuICBcdGJyaW5nVG9CYWNrOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdGlmICh0aGlzLl9tYXApIHtcclxuICBcdFx0XHR0b0JhY2sodGhpcy5faW1hZ2UpO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHNldFVybCh1cmw6IFN0cmluZyk6IHRoaXNcclxuICBcdC8vIENoYW5nZXMgdGhlIFVSTCBvZiB0aGUgaW1hZ2UuXHJcbiAgXHRzZXRVcmw6IGZ1bmN0aW9uICh1cmwpIHtcclxuICBcdFx0dGhpcy5fdXJsID0gdXJsO1xyXG5cclxuICBcdFx0aWYgKHRoaXMuX2ltYWdlKSB7XHJcbiAgXHRcdFx0dGhpcy5faW1hZ2Uuc3JjID0gdXJsO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHNldEJvdW5kcyhib3VuZHM6IExhdExuZ0JvdW5kcyk6IHRoaXNcclxuICBcdC8vIFVwZGF0ZSB0aGUgYm91bmRzIHRoYXQgdGhpcyBJbWFnZU92ZXJsYXkgY292ZXJzXHJcbiAgXHRzZXRCb3VuZHM6IGZ1bmN0aW9uIChib3VuZHMpIHtcclxuICBcdFx0dGhpcy5fYm91bmRzID0gdG9MYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcbiAgXHRcdGlmICh0aGlzLl9tYXApIHtcclxuICBcdFx0XHR0aGlzLl9yZXNldCgpO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRnZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dmFyIGV2ZW50cyA9IHtcclxuICBcdFx0XHR6b29tOiB0aGlzLl9yZXNldCxcclxuICBcdFx0XHR2aWV3cmVzZXQ6IHRoaXMuX3Jlc2V0XHJcbiAgXHRcdH07XHJcblxyXG4gIFx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XHJcbiAgXHRcdFx0ZXZlbnRzLnpvb21hbmltID0gdGhpcy5fYW5pbWF0ZVpvb207XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHJldHVybiBldmVudHM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2Qgc2V0WkluZGV4KHZhbHVlOiBOdW1iZXIpOiB0aGlzXHJcbiAgXHQvLyBDaGFuZ2VzIHRoZSBbekluZGV4XSgjaW1hZ2VvdmVybGF5LXppbmRleCkgb2YgdGhlIGltYWdlIG92ZXJsYXkuXHJcbiAgXHRzZXRaSW5kZXg6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gIFx0XHR0aGlzLm9wdGlvbnMuekluZGV4ID0gdmFsdWU7XHJcbiAgXHRcdHRoaXMuX3VwZGF0ZVpJbmRleCgpO1xyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRCb3VuZHMoKTogTGF0TG5nQm91bmRzXHJcbiAgXHQvLyBHZXQgdGhlIGJvdW5kcyB0aGF0IHRoaXMgSW1hZ2VPdmVybGF5IGNvdmVyc1xyXG4gIFx0Z2V0Qm91bmRzOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLl9ib3VuZHM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0RWxlbWVudCgpOiBIVE1MRWxlbWVudFxyXG4gIFx0Ly8gUmV0dXJucyB0aGUgaW5zdGFuY2Ugb2YgW2BIVE1MSW1hZ2VFbGVtZW50YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0hUTUxJbWFnZUVsZW1lbnQpXHJcbiAgXHQvLyB1c2VkIGJ5IHRoaXMgb3ZlcmxheS5cclxuICBcdGdldEVsZW1lbnQ6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMuX2ltYWdlO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfaW5pdEltYWdlOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHZhciB3YXNFbGVtZW50U3VwcGxpZWQgPSB0aGlzLl91cmwudGFnTmFtZSA9PT0gJ0lNRyc7XHJcbiAgXHRcdHZhciBpbWcgPSB0aGlzLl9pbWFnZSA9IHdhc0VsZW1lbnRTdXBwbGllZCA/IHRoaXMuX3VybCA6IGNyZWF0ZSQxKCdpbWcnKTtcclxuXHJcbiAgXHRcdGFkZENsYXNzKGltZywgJ2xlYWZsZXQtaW1hZ2UtbGF5ZXInKTtcclxuICBcdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkgeyBhZGRDbGFzcyhpbWcsICdsZWFmbGV0LXpvb20tYW5pbWF0ZWQnKTsgfVxyXG4gIFx0XHRpZiAodGhpcy5vcHRpb25zLmNsYXNzTmFtZSkgeyBhZGRDbGFzcyhpbWcsIHRoaXMub3B0aW9ucy5jbGFzc05hbWUpOyB9XHJcblxyXG4gIFx0XHRpbWcub25zZWxlY3RzdGFydCA9IGZhbHNlRm47XHJcbiAgXHRcdGltZy5vbm1vdXNlbW92ZSA9IGZhbHNlRm47XHJcblxyXG4gIFx0XHQvLyBAZXZlbnQgbG9hZDogRXZlbnRcclxuICBcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgSW1hZ2VPdmVybGF5IGxheWVyIGhhcyBsb2FkZWQgaXRzIGltYWdlXHJcbiAgXHRcdGltZy5vbmxvYWQgPSBiaW5kKHRoaXMuZmlyZSwgdGhpcywgJ2xvYWQnKTtcclxuICBcdFx0aW1nLm9uZXJyb3IgPSBiaW5kKHRoaXMuX292ZXJsYXlPbkVycm9yLCB0aGlzLCAnZXJyb3InKTtcclxuXHJcbiAgXHRcdGlmICh0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW4gfHwgdGhpcy5vcHRpb25zLmNyb3NzT3JpZ2luID09PSAnJykge1xyXG4gIFx0XHRcdGltZy5jcm9zc09yaWdpbiA9IHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbiA9PT0gdHJ1ZSA/ICcnIDogdGhpcy5vcHRpb25zLmNyb3NzT3JpZ2luO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRpZiAodGhpcy5vcHRpb25zLnpJbmRleCkge1xyXG4gIFx0XHRcdHRoaXMuX3VwZGF0ZVpJbmRleCgpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRpZiAod2FzRWxlbWVudFN1cHBsaWVkKSB7XHJcbiAgXHRcdFx0dGhpcy5fdXJsID0gaW1nLnNyYztcclxuICBcdFx0XHRyZXR1cm47XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGltZy5zcmMgPSB0aGlzLl91cmw7XHJcbiAgXHRcdGltZy5hbHQgPSB0aGlzLm9wdGlvbnMuYWx0O1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfYW5pbWF0ZVpvb206IGZ1bmN0aW9uIChlKSB7XHJcbiAgXHRcdHZhciBzY2FsZSA9IHRoaXMuX21hcC5nZXRab29tU2NhbGUoZS56b29tKSxcclxuICBcdFx0ICAgIG9mZnNldCA9IHRoaXMuX21hcC5fbGF0TG5nQm91bmRzVG9OZXdMYXllckJvdW5kcyh0aGlzLl9ib3VuZHMsIGUuem9vbSwgZS5jZW50ZXIpLm1pbjtcclxuXHJcbiAgXHRcdHNldFRyYW5zZm9ybSh0aGlzLl9pbWFnZSwgb2Zmc2V0LCBzY2FsZSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9yZXNldDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR2YXIgaW1hZ2UgPSB0aGlzLl9pbWFnZSxcclxuICBcdFx0ICAgIGJvdW5kcyA9IG5ldyBCb3VuZHMoXHJcbiAgXHRcdCAgICAgICAgdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9ib3VuZHMuZ2V0Tm9ydGhXZXN0KCkpLFxyXG4gIFx0XHQgICAgICAgIHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fYm91bmRzLmdldFNvdXRoRWFzdCgpKSksXHJcbiAgXHRcdCAgICBzaXplID0gYm91bmRzLmdldFNpemUoKTtcclxuXHJcbiAgXHRcdHNldFBvc2l0aW9uKGltYWdlLCBib3VuZHMubWluKTtcclxuXHJcbiAgXHRcdGltYWdlLnN0eWxlLndpZHRoICA9IHNpemUueCArICdweCc7XHJcbiAgXHRcdGltYWdlLnN0eWxlLmhlaWdodCA9IHNpemUueSArICdweCc7XHJcbiAgXHR9LFxyXG5cclxuICBcdF91cGRhdGVPcGFjaXR5OiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHNldE9wYWNpdHkodGhpcy5faW1hZ2UsIHRoaXMub3B0aW9ucy5vcGFjaXR5KTtcclxuICBcdH0sXHJcblxyXG4gIFx0X3VwZGF0ZVpJbmRleDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRpZiAodGhpcy5faW1hZ2UgJiYgdGhpcy5vcHRpb25zLnpJbmRleCAhPT0gdW5kZWZpbmVkICYmIHRoaXMub3B0aW9ucy56SW5kZXggIT09IG51bGwpIHtcclxuICBcdFx0XHR0aGlzLl9pbWFnZS5zdHlsZS56SW5kZXggPSB0aGlzLm9wdGlvbnMuekluZGV4O1xyXG4gIFx0XHR9XHJcbiAgXHR9LFxyXG5cclxuICBcdF9vdmVybGF5T25FcnJvcjogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHQvLyBAZXZlbnQgZXJyb3I6IEV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIHdoZW4gdGhlIEltYWdlT3ZlcmxheSBsYXllciBmYWlscyB0byBsb2FkIGl0cyBpbWFnZVxyXG4gIFx0XHR0aGlzLmZpcmUoJ2Vycm9yJyk7XHJcblxyXG4gIFx0XHR2YXIgZXJyb3JVcmwgPSB0aGlzLm9wdGlvbnMuZXJyb3JPdmVybGF5VXJsO1xyXG4gIFx0XHRpZiAoZXJyb3JVcmwgJiYgdGhpcy5fdXJsICE9PSBlcnJvclVybCkge1xyXG4gIFx0XHRcdHRoaXMuX3VybCA9IGVycm9yVXJsO1xyXG4gIFx0XHRcdHRoaXMuX2ltYWdlLnNyYyA9IGVycm9yVXJsO1xyXG4gIFx0XHR9XHJcbiAgXHR9XHJcbiAgfSk7XHJcblxyXG4gIC8vIEBmYWN0b3J5IEwuaW1hZ2VPdmVybGF5KGltYWdlVXJsOiBTdHJpbmcsIGJvdW5kczogTGF0TG5nQm91bmRzLCBvcHRpb25zPzogSW1hZ2VPdmVybGF5IG9wdGlvbnMpXHJcbiAgLy8gSW5zdGFudGlhdGVzIGFuIGltYWdlIG92ZXJsYXkgb2JqZWN0IGdpdmVuIHRoZSBVUkwgb2YgdGhlIGltYWdlIGFuZCB0aGVcclxuICAvLyBnZW9ncmFwaGljYWwgYm91bmRzIGl0IGlzIHRpZWQgdG8uXHJcbiAgdmFyIGltYWdlT3ZlcmxheSA9IGZ1bmN0aW9uICh1cmwsIGJvdW5kcywgb3B0aW9ucykge1xyXG4gIFx0cmV0dXJuIG5ldyBJbWFnZU92ZXJsYXkodXJsLCBib3VuZHMsIG9wdGlvbnMpO1xyXG4gIH07XG5cbiAgLypcclxuICAgKiBAY2xhc3MgVmlkZW9PdmVybGF5XHJcbiAgICogQGFrYSBMLlZpZGVvT3ZlcmxheVxyXG4gICAqIEBpbmhlcml0cyBJbWFnZU92ZXJsYXlcclxuICAgKlxyXG4gICAqIFVzZWQgdG8gbG9hZCBhbmQgZGlzcGxheSBhIHZpZGVvIHBsYXllciBvdmVyIHNwZWNpZmljIGJvdW5kcyBvZiB0aGUgbWFwLiBFeHRlbmRzIGBJbWFnZU92ZXJsYXlgLlxyXG4gICAqXHJcbiAgICogQSB2aWRlbyBvdmVybGF5IHVzZXMgdGhlIFtgPHZpZGVvPmBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0hUTUwvRWxlbWVudC92aWRlbylcclxuICAgKiBIVE1MNSBlbGVtZW50LlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKlxyXG4gICAqIGBgYGpzXHJcbiAgICogdmFyIHZpZGVvVXJsID0gJ2h0dHBzOi8vd3d3Lm1hcGJveC5jb20vYml0ZXMvMDAxODgvcGF0cmljaWFfbmFzYS53ZWJtJyxcclxuICAgKiBcdHZpZGVvQm91bmRzID0gW1sgMzIsIC0xMzBdLCBbIDEzLCAtMTAwXV07XHJcbiAgICogTC52aWRlb092ZXJsYXkodmlkZW9VcmwsIHZpZGVvQm91bmRzICkuYWRkVG8obWFwKTtcclxuICAgKiBgYGBcclxuICAgKi9cclxuXHJcbiAgdmFyIFZpZGVvT3ZlcmxheSA9IEltYWdlT3ZlcmxheS5leHRlbmQoe1xyXG5cclxuICBcdC8vIEBzZWN0aW9uXHJcbiAgXHQvLyBAYWthIFZpZGVvT3ZlcmxheSBvcHRpb25zXHJcbiAgXHRvcHRpb25zOiB7XHJcbiAgXHRcdC8vIEBvcHRpb24gYXV0b3BsYXk6IEJvb2xlYW4gPSB0cnVlXHJcbiAgXHRcdC8vIFdoZXRoZXIgdGhlIHZpZGVvIHN0YXJ0cyBwbGF5aW5nIGF1dG9tYXRpY2FsbHkgd2hlbiBsb2FkZWQuXHJcbiAgXHRcdGF1dG9wbGF5OiB0cnVlLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBsb29wOiBCb29sZWFuID0gdHJ1ZVxyXG4gIFx0XHQvLyBXaGV0aGVyIHRoZSB2aWRlbyB3aWxsIGxvb3AgYmFjayB0byB0aGUgYmVnaW5uaW5nIHdoZW4gcGxheWVkLlxyXG4gIFx0XHRsb29wOiB0cnVlLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBrZWVwQXNwZWN0UmF0aW86IEJvb2xlYW4gPSB0cnVlXHJcbiAgXHRcdC8vIFdoZXRoZXIgdGhlIHZpZGVvIHdpbGwgc2F2ZSBhc3BlY3QgcmF0aW8gYWZ0ZXIgdGhlIHByb2plY3Rpb24uXHJcbiAgXHRcdC8vIFJlbGV2YW50IGZvciBzdXBwb3J0ZWQgYnJvd3NlcnMuIEJyb3dzZXIgY29tcGF0aWJpbGl0eS0gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL29iamVjdC1maXRcclxuICBcdFx0a2VlcEFzcGVjdFJhdGlvOiB0cnVlLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBtdXRlZDogQm9vbGVhbiA9IGZhbHNlXHJcbiAgXHRcdC8vIFdoZXRoZXIgdGhlIHZpZGVvIHN0YXJ0cyBvbiBtdXRlIHdoZW4gbG9hZGVkLlxyXG4gIFx0XHRtdXRlZDogZmFsc2VcclxuICBcdH0sXHJcblxyXG4gIFx0X2luaXRJbWFnZTogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR2YXIgd2FzRWxlbWVudFN1cHBsaWVkID0gdGhpcy5fdXJsLnRhZ05hbWUgPT09ICdWSURFTyc7XHJcbiAgXHRcdHZhciB2aWQgPSB0aGlzLl9pbWFnZSA9IHdhc0VsZW1lbnRTdXBwbGllZCA/IHRoaXMuX3VybCA6IGNyZWF0ZSQxKCd2aWRlbycpO1xyXG5cclxuICBcdFx0YWRkQ2xhc3ModmlkLCAnbGVhZmxldC1pbWFnZS1sYXllcicpO1xyXG4gIFx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7IGFkZENsYXNzKHZpZCwgJ2xlYWZsZXQtem9vbS1hbmltYXRlZCcpOyB9XHJcbiAgXHRcdGlmICh0aGlzLm9wdGlvbnMuY2xhc3NOYW1lKSB7IGFkZENsYXNzKHZpZCwgdGhpcy5vcHRpb25zLmNsYXNzTmFtZSk7IH1cclxuXHJcbiAgXHRcdHZpZC5vbnNlbGVjdHN0YXJ0ID0gZmFsc2VGbjtcclxuICBcdFx0dmlkLm9ubW91c2Vtb3ZlID0gZmFsc2VGbjtcclxuXHJcbiAgXHRcdC8vIEBldmVudCBsb2FkOiBFdmVudFxyXG4gIFx0XHQvLyBGaXJlZCB3aGVuIHRoZSB2aWRlbyBoYXMgZmluaXNoZWQgbG9hZGluZyB0aGUgZmlyc3QgZnJhbWVcclxuICBcdFx0dmlkLm9ubG9hZGVkZGF0YSA9IGJpbmQodGhpcy5maXJlLCB0aGlzLCAnbG9hZCcpO1xyXG5cclxuICBcdFx0aWYgKHdhc0VsZW1lbnRTdXBwbGllZCkge1xyXG4gIFx0XHRcdHZhciBzb3VyY2VFbGVtZW50cyA9IHZpZC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc291cmNlJyk7XHJcbiAgXHRcdFx0dmFyIHNvdXJjZXMgPSBbXTtcclxuICBcdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IHNvdXJjZUVsZW1lbnRzLmxlbmd0aDsgaisrKSB7XHJcbiAgXHRcdFx0XHRzb3VyY2VzLnB1c2goc291cmNlRWxlbWVudHNbal0uc3JjKTtcclxuICBcdFx0XHR9XHJcblxyXG4gIFx0XHRcdHRoaXMuX3VybCA9IChzb3VyY2VFbGVtZW50cy5sZW5ndGggPiAwKSA/IHNvdXJjZXMgOiBbdmlkLnNyY107XHJcbiAgXHRcdFx0cmV0dXJuO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRpZiAoIWlzQXJyYXkodGhpcy5fdXJsKSkgeyB0aGlzLl91cmwgPSBbdGhpcy5fdXJsXTsgfVxyXG5cclxuICBcdFx0aWYgKCF0aGlzLm9wdGlvbnMua2VlcEFzcGVjdFJhdGlvICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2aWQuc3R5bGUsICdvYmplY3RGaXQnKSkge1xyXG4gIFx0XHRcdHZpZC5zdHlsZVsnb2JqZWN0Rml0J10gPSAnZmlsbCc7XHJcbiAgXHRcdH1cclxuICBcdFx0dmlkLmF1dG9wbGF5ID0gISF0aGlzLm9wdGlvbnMuYXV0b3BsYXk7XHJcbiAgXHRcdHZpZC5sb29wID0gISF0aGlzLm9wdGlvbnMubG9vcDtcclxuICBcdFx0dmlkLm11dGVkID0gISF0aGlzLm9wdGlvbnMubXV0ZWQ7XHJcbiAgXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fdXJsLmxlbmd0aDsgaSsrKSB7XHJcbiAgXHRcdFx0dmFyIHNvdXJjZSA9IGNyZWF0ZSQxKCdzb3VyY2UnKTtcclxuICBcdFx0XHRzb3VyY2Uuc3JjID0gdGhpcy5fdXJsW2ldO1xyXG4gIFx0XHRcdHZpZC5hcHBlbmRDaGlsZChzb3VyY2UpO1xyXG4gIFx0XHR9XHJcbiAgXHR9XHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRFbGVtZW50KCk6IEhUTUxWaWRlb0VsZW1lbnRcclxuICBcdC8vIFJldHVybnMgdGhlIGluc3RhbmNlIG9mIFtgSFRNTFZpZGVvRWxlbWVudGBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9IVE1MVmlkZW9FbGVtZW50KVxyXG4gIFx0Ly8gdXNlZCBieSB0aGlzIG92ZXJsYXkuXHJcbiAgfSk7XHJcblxyXG5cclxuICAvLyBAZmFjdG9yeSBMLnZpZGVvT3ZlcmxheSh2aWRlbzogU3RyaW5nfEFycmF5fEhUTUxWaWRlb0VsZW1lbnQsIGJvdW5kczogTGF0TG5nQm91bmRzLCBvcHRpb25zPzogVmlkZW9PdmVybGF5IG9wdGlvbnMpXHJcbiAgLy8gSW5zdGFudGlhdGVzIGFuIGltYWdlIG92ZXJsYXkgb2JqZWN0IGdpdmVuIHRoZSBVUkwgb2YgdGhlIHZpZGVvIChvciBhcnJheSBvZiBVUkxzLCBvciBldmVuIGEgdmlkZW8gZWxlbWVudCkgYW5kIHRoZVxyXG4gIC8vIGdlb2dyYXBoaWNhbCBib3VuZHMgaXQgaXMgdGllZCB0by5cclxuXHJcbiAgZnVuY3Rpb24gdmlkZW9PdmVybGF5KHZpZGVvLCBib3VuZHMsIG9wdGlvbnMpIHtcclxuICBcdHJldHVybiBuZXcgVmlkZW9PdmVybGF5KHZpZGVvLCBib3VuZHMsIG9wdGlvbnMpO1xyXG4gIH1cblxuICAvKlxuICAgKiBAY2xhc3MgU1ZHT3ZlcmxheVxuICAgKiBAYWthIEwuU1ZHT3ZlcmxheVxuICAgKiBAaW5oZXJpdHMgSW1hZ2VPdmVybGF5XG4gICAqXG4gICAqIFVzZWQgdG8gbG9hZCwgZGlzcGxheSBhbmQgcHJvdmlkZSBET00gYWNjZXNzIHRvIGFuIFNWRyBmaWxlIG92ZXIgc3BlY2lmaWMgYm91bmRzIG9mIHRoZSBtYXAuIEV4dGVuZHMgYEltYWdlT3ZlcmxheWAuXG4gICAqXG4gICAqIEFuIFNWRyBvdmVybGF5IHVzZXMgdGhlIFtgPHN2Zz5gXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9TVkcvRWxlbWVudC9zdmcpIGVsZW1lbnQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIHZhciBzdmdFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgXCJzdmdcIik7XG4gICAqIHN2Z0VsZW1lbnQuc2V0QXR0cmlidXRlKCd4bWxucycsIFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIik7XG4gICAqIHN2Z0VsZW1lbnQuc2V0QXR0cmlidXRlKCd2aWV3Qm94JywgXCIwIDAgMjAwIDIwMFwiKTtcbiAgICogc3ZnRWxlbWVudC5pbm5lckhUTUwgPSAnPHJlY3Qgd2lkdGg9XCIyMDBcIiBoZWlnaHQ9XCIyMDBcIi8+PHJlY3QgeD1cIjc1XCIgeT1cIjIzXCIgd2lkdGg9XCI1MFwiIGhlaWdodD1cIjUwXCIgc3R5bGU9XCJmaWxsOnJlZFwiLz48cmVjdCB4PVwiNzVcIiB5PVwiMTIzXCIgd2lkdGg9XCI1MFwiIGhlaWdodD1cIjUwXCIgc3R5bGU9XCJmaWxsOiMwMDEzZmZcIi8+JztcbiAgICogdmFyIHN2Z0VsZW1lbnRCb3VuZHMgPSBbIFsgMzIsIC0xMzAgXSwgWyAxMywgLTEwMCBdIF07XG4gICAqIEwuc3ZnT3ZlcmxheShzdmdFbGVtZW50LCBzdmdFbGVtZW50Qm91bmRzKS5hZGRUbyhtYXApO1xuICAgKiBgYGBcbiAgICovXG5cbiAgdmFyIFNWR092ZXJsYXkgPSBJbWFnZU92ZXJsYXkuZXh0ZW5kKHtcbiAgXHRfaW5pdEltYWdlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgZWwgPSB0aGlzLl9pbWFnZSA9IHRoaXMuX3VybDtcblxuICBcdFx0YWRkQ2xhc3MoZWwsICdsZWFmbGV0LWltYWdlLWxheWVyJyk7XG4gIFx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7IGFkZENsYXNzKGVsLCAnbGVhZmxldC16b29tLWFuaW1hdGVkJyk7IH1cbiAgXHRcdGlmICh0aGlzLm9wdGlvbnMuY2xhc3NOYW1lKSB7IGFkZENsYXNzKGVsLCB0aGlzLm9wdGlvbnMuY2xhc3NOYW1lKTsgfVxuXG4gIFx0XHRlbC5vbnNlbGVjdHN0YXJ0ID0gZmFsc2VGbjtcbiAgXHRcdGVsLm9ubW91c2Vtb3ZlID0gZmFsc2VGbjtcbiAgXHR9XG5cbiAgXHQvLyBAbWV0aG9kIGdldEVsZW1lbnQoKTogU1ZHRWxlbWVudFxuICBcdC8vIFJldHVybnMgdGhlIGluc3RhbmNlIG9mIFtgU1ZHRWxlbWVudGBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9TVkdFbGVtZW50KVxuICBcdC8vIHVzZWQgYnkgdGhpcyBvdmVybGF5LlxuICB9KTtcblxuXG4gIC8vIEBmYWN0b3J5IEwuc3ZnT3ZlcmxheShzdmc6IFN0cmluZ3xTVkdFbGVtZW50LCBib3VuZHM6IExhdExuZ0JvdW5kcywgb3B0aW9ucz86IFNWR092ZXJsYXkgb3B0aW9ucylcbiAgLy8gSW5zdGFudGlhdGVzIGFuIGltYWdlIG92ZXJsYXkgb2JqZWN0IGdpdmVuIGFuIFNWRyBlbGVtZW50IGFuZCB0aGUgZ2VvZ3JhcGhpY2FsIGJvdW5kcyBpdCBpcyB0aWVkIHRvLlxuICAvLyBBIHZpZXdCb3ggYXR0cmlidXRlIGlzIHJlcXVpcmVkIG9uIHRoZSBTVkcgZWxlbWVudCB0byB6b29tIGluIGFuZCBvdXQgcHJvcGVybHkuXG5cbiAgZnVuY3Rpb24gc3ZnT3ZlcmxheShlbCwgYm91bmRzLCBvcHRpb25zKSB7XG4gIFx0cmV0dXJuIG5ldyBTVkdPdmVybGF5KGVsLCBib3VuZHMsIG9wdGlvbnMpO1xuICB9XG5cbiAgLypcclxuICAgKiBAY2xhc3MgRGl2T3ZlcmxheVxyXG4gICAqIEBpbmhlcml0cyBMYXllclxyXG4gICAqIEBha2EgTC5EaXZPdmVybGF5XHJcbiAgICogQmFzZSBtb2RlbCBmb3IgTC5Qb3B1cCBhbmQgTC5Ub29sdGlwLiBJbmhlcml0IGZyb20gaXQgZm9yIGN1c3RvbSBwb3B1cCBsaWtlIHBsdWdpbnMuXHJcbiAgICovXHJcblxyXG4gIC8vIEBuYW1lc3BhY2UgRGl2T3ZlcmxheVxyXG4gIHZhciBEaXZPdmVybGF5ID0gTGF5ZXIuZXh0ZW5kKHtcclxuXHJcbiAgXHQvLyBAc2VjdGlvblxyXG4gIFx0Ly8gQGFrYSBEaXZPdmVybGF5IG9wdGlvbnNcclxuICBcdG9wdGlvbnM6IHtcclxuICBcdFx0Ly8gQG9wdGlvbiBvZmZzZXQ6IFBvaW50ID0gUG9pbnQoMCwgNylcclxuICBcdFx0Ly8gVGhlIG9mZnNldCBvZiB0aGUgcG9wdXAgcG9zaXRpb24uIFVzZWZ1bCB0byBjb250cm9sIHRoZSBhbmNob3JcclxuICBcdFx0Ly8gb2YgdGhlIHBvcHVwIHdoZW4gb3BlbmluZyBpdCBvbiBzb21lIG92ZXJsYXlzLlxyXG4gIFx0XHRvZmZzZXQ6IFswLCA3XSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gY2xhc3NOYW1lOiBTdHJpbmcgPSAnJ1xyXG4gIFx0XHQvLyBBIGN1c3RvbSBDU1MgY2xhc3MgbmFtZSB0byBhc3NpZ24gdG8gdGhlIHBvcHVwLlxyXG4gIFx0XHRjbGFzc05hbWU6ICcnLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBwYW5lOiBTdHJpbmcgPSAncG9wdXBQYW5lJ1xyXG4gIFx0XHQvLyBgTWFwIHBhbmVgIHdoZXJlIHRoZSBwb3B1cCB3aWxsIGJlIGFkZGVkLlxyXG4gIFx0XHRwYW5lOiAncG9wdXBQYW5lJ1xyXG4gIFx0fSxcclxuXHJcbiAgXHRpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucywgc291cmNlKSB7XHJcbiAgXHRcdHNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG4gIFx0XHR0aGlzLl9zb3VyY2UgPSBzb3VyY2U7XHJcbiAgXHR9LFxyXG5cclxuICBcdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcbiAgXHRcdHRoaXMuX3pvb21BbmltYXRlZCA9IG1hcC5fem9vbUFuaW1hdGVkO1xyXG5cclxuICBcdFx0aWYgKCF0aGlzLl9jb250YWluZXIpIHtcclxuICBcdFx0XHR0aGlzLl9pbml0TGF5b3V0KCk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGlmIChtYXAuX2ZhZGVBbmltYXRlZCkge1xyXG4gIFx0XHRcdHNldE9wYWNpdHkodGhpcy5fY29udGFpbmVyLCAwKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX3JlbW92ZVRpbWVvdXQpO1xyXG4gIFx0XHR0aGlzLmdldFBhbmUoKS5hcHBlbmRDaGlsZCh0aGlzLl9jb250YWluZXIpO1xyXG4gIFx0XHR0aGlzLnVwZGF0ZSgpO1xyXG5cclxuICBcdFx0aWYgKG1hcC5fZmFkZUFuaW1hdGVkKSB7XHJcbiAgXHRcdFx0c2V0T3BhY2l0eSh0aGlzLl9jb250YWluZXIsIDEpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR0aGlzLmJyaW5nVG9Gcm9udCgpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xyXG4gIFx0XHRpZiAobWFwLl9mYWRlQW5pbWF0ZWQpIHtcclxuICBcdFx0XHRzZXRPcGFjaXR5KHRoaXMuX2NvbnRhaW5lciwgMCk7XHJcbiAgXHRcdFx0dGhpcy5fcmVtb3ZlVGltZW91dCA9IHNldFRpbWVvdXQoYmluZChyZW1vdmUsIHVuZGVmaW5lZCwgdGhpcy5fY29udGFpbmVyKSwgMjAwKTtcclxuICBcdFx0fSBlbHNlIHtcclxuICBcdFx0XHRyZW1vdmUodGhpcy5fY29udGFpbmVyKTtcclxuICBcdFx0fVxyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbmFtZXNwYWNlIFBvcHVwXHJcbiAgXHQvLyBAbWV0aG9kIGdldExhdExuZzogTGF0TG5nXHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBnZW9ncmFwaGljYWwgcG9pbnQgb2YgcG9wdXAuXHJcbiAgXHRnZXRMYXRMbmc6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMuX2xhdGxuZztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBzZXRMYXRMbmcobGF0bG5nOiBMYXRMbmcpOiB0aGlzXHJcbiAgXHQvLyBTZXRzIHRoZSBnZW9ncmFwaGljYWwgcG9pbnQgd2hlcmUgdGhlIHBvcHVwIHdpbGwgb3Blbi5cclxuICBcdHNldExhdExuZzogZnVuY3Rpb24gKGxhdGxuZykge1xyXG4gIFx0XHR0aGlzLl9sYXRsbmcgPSB0b0xhdExuZyhsYXRsbmcpO1xyXG4gIFx0XHRpZiAodGhpcy5fbWFwKSB7XHJcbiAgXHRcdFx0dGhpcy5fdXBkYXRlUG9zaXRpb24oKTtcclxuICBcdFx0XHR0aGlzLl9hZGp1c3RQYW4oKTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRDb250ZW50OiBTdHJpbmd8SFRNTEVsZW1lbnRcclxuICBcdC8vIFJldHVybnMgdGhlIGNvbnRlbnQgb2YgdGhlIHBvcHVwLlxyXG4gIFx0Z2V0Q29udGVudDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5fY29udGVudDtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBzZXRDb250ZW50KGh0bWxDb250ZW50OiBTdHJpbmd8SFRNTEVsZW1lbnR8RnVuY3Rpb24pOiB0aGlzXHJcbiAgXHQvLyBTZXRzIHRoZSBIVE1MIGNvbnRlbnQgb2YgdGhlIHBvcHVwLiBJZiBhIGZ1bmN0aW9uIGlzIHBhc3NlZCB0aGUgc291cmNlIGxheWVyIHdpbGwgYmUgcGFzc2VkIHRvIHRoZSBmdW5jdGlvbi4gVGhlIGZ1bmN0aW9uIHNob3VsZCByZXR1cm4gYSBgU3RyaW5nYCBvciBgSFRNTEVsZW1lbnRgIHRvIGJlIHVzZWQgaW4gdGhlIHBvcHVwLlxyXG4gIFx0c2V0Q29udGVudDogZnVuY3Rpb24gKGNvbnRlbnQpIHtcclxuICBcdFx0dGhpcy5fY29udGVudCA9IGNvbnRlbnQ7XHJcbiAgXHRcdHRoaXMudXBkYXRlKCk7XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldEVsZW1lbnQ6IFN0cmluZ3xIVE1MRWxlbWVudFxyXG4gIFx0Ly8gUmV0dXJucyB0aGUgSFRNTCBjb250YWluZXIgb2YgdGhlIHBvcHVwLlxyXG4gIFx0Z2V0RWxlbWVudDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5fY29udGFpbmVyO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHVwZGF0ZTogbnVsbFxyXG4gIFx0Ly8gVXBkYXRlcyB0aGUgcG9wdXAgY29udGVudCwgbGF5b3V0IGFuZCBwb3NpdGlvbi4gVXNlZnVsIGZvciB1cGRhdGluZyB0aGUgcG9wdXAgYWZ0ZXIgc29tZXRoaW5nIGluc2lkZSBjaGFuZ2VkLCBlLmcuIGltYWdlIGxvYWRlZC5cclxuICBcdHVwZGF0ZTogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRpZiAoIXRoaXMuX21hcCkgeyByZXR1cm47IH1cclxuXHJcbiAgXHRcdHRoaXMuX2NvbnRhaW5lci5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XHJcblxyXG4gIFx0XHR0aGlzLl91cGRhdGVDb250ZW50KCk7XHJcbiAgXHRcdHRoaXMuX3VwZGF0ZUxheW91dCgpO1xyXG4gIFx0XHR0aGlzLl91cGRhdGVQb3NpdGlvbigpO1xyXG5cclxuICBcdFx0dGhpcy5fY29udGFpbmVyLnN0eWxlLnZpc2liaWxpdHkgPSAnJztcclxuXHJcbiAgXHRcdHRoaXMuX2FkanVzdFBhbigpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRnZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dmFyIGV2ZW50cyA9IHtcclxuICBcdFx0XHR6b29tOiB0aGlzLl91cGRhdGVQb3NpdGlvbixcclxuICBcdFx0XHR2aWV3cmVzZXQ6IHRoaXMuX3VwZGF0ZVBvc2l0aW9uXHJcbiAgXHRcdH07XHJcblxyXG4gIFx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XHJcbiAgXHRcdFx0ZXZlbnRzLnpvb21hbmltID0gdGhpcy5fYW5pbWF0ZVpvb207XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIGV2ZW50cztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBpc09wZW46IEJvb2xlYW5cclxuICBcdC8vIFJldHVybnMgYHRydWVgIHdoZW4gdGhlIHBvcHVwIGlzIHZpc2libGUgb24gdGhlIG1hcC5cclxuICBcdGlzT3BlbjogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gISF0aGlzLl9tYXAgJiYgdGhpcy5fbWFwLmhhc0xheWVyKHRoaXMpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGJyaW5nVG9Gcm9udDogdGhpc1xyXG4gIFx0Ly8gQnJpbmdzIHRoaXMgcG9wdXAgaW4gZnJvbnQgb2Ygb3RoZXIgcG9wdXBzIChpbiB0aGUgc2FtZSBtYXAgcGFuZSkuXHJcbiAgXHRicmluZ1RvRnJvbnQ6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0aWYgKHRoaXMuX21hcCkge1xyXG4gIFx0XHRcdHRvRnJvbnQodGhpcy5fY29udGFpbmVyKTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBicmluZ1RvQmFjazogdGhpc1xyXG4gIFx0Ly8gQnJpbmdzIHRoaXMgcG9wdXAgdG8gdGhlIGJhY2sgb2Ygb3RoZXIgcG9wdXBzIChpbiB0aGUgc2FtZSBtYXAgcGFuZSkuXHJcbiAgXHRicmluZ1RvQmFjazogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRpZiAodGhpcy5fbWFwKSB7XHJcbiAgXHRcdFx0dG9CYWNrKHRoaXMuX2NvbnRhaW5lcik7XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9wcmVwYXJlT3BlbjogZnVuY3Rpb24gKHBhcmVudCwgbGF5ZXIsIGxhdGxuZykge1xyXG4gIFx0XHRpZiAoIShsYXllciBpbnN0YW5jZW9mIExheWVyKSkge1xyXG4gIFx0XHRcdGxhdGxuZyA9IGxheWVyO1xyXG4gIFx0XHRcdGxheWVyID0gcGFyZW50O1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRpZiAobGF5ZXIgaW5zdGFuY2VvZiBGZWF0dXJlR3JvdXApIHtcclxuICBcdFx0XHRmb3IgKHZhciBpZCBpbiBwYXJlbnQuX2xheWVycykge1xyXG4gIFx0XHRcdFx0bGF5ZXIgPSBwYXJlbnQuX2xheWVyc1tpZF07XHJcbiAgXHRcdFx0XHRicmVhaztcclxuICBcdFx0XHR9XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGlmICghbGF0bG5nKSB7XHJcbiAgXHRcdFx0aWYgKGxheWVyLmdldENlbnRlcikge1xyXG4gIFx0XHRcdFx0bGF0bG5nID0gbGF5ZXIuZ2V0Q2VudGVyKCk7XHJcbiAgXHRcdFx0fSBlbHNlIGlmIChsYXllci5nZXRMYXRMbmcpIHtcclxuICBcdFx0XHRcdGxhdGxuZyA9IGxheWVyLmdldExhdExuZygpO1xyXG4gIFx0XHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBnZXQgc291cmNlIGxheWVyIExhdExuZy4nKTtcclxuICBcdFx0XHR9XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdC8vIHNldCBvdmVybGF5IHNvdXJjZSB0byB0aGlzIGxheWVyXHJcbiAgXHRcdHRoaXMuX3NvdXJjZSA9IGxheWVyO1xyXG5cclxuICBcdFx0Ly8gdXBkYXRlIHRoZSBvdmVybGF5IChjb250ZW50LCBsYXlvdXQsIGVjdC4uLilcclxuICBcdFx0dGhpcy51cGRhdGUoKTtcclxuXHJcbiAgXHRcdHJldHVybiBsYXRsbmc7XHJcbiAgXHR9LFxyXG5cclxuICBcdF91cGRhdGVDb250ZW50OiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdGlmICghdGhpcy5fY29udGVudCkgeyByZXR1cm47IH1cclxuXHJcbiAgXHRcdHZhciBub2RlID0gdGhpcy5fY29udGVudE5vZGU7XHJcbiAgXHRcdHZhciBjb250ZW50ID0gKHR5cGVvZiB0aGlzLl9jb250ZW50ID09PSAnZnVuY3Rpb24nKSA/IHRoaXMuX2NvbnRlbnQodGhpcy5fc291cmNlIHx8IHRoaXMpIDogdGhpcy5fY29udGVudDtcclxuXHJcbiAgXHRcdGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcclxuICBcdFx0XHRub2RlLmlubmVySFRNTCA9IGNvbnRlbnQ7XHJcbiAgXHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0d2hpbGUgKG5vZGUuaGFzQ2hpbGROb2RlcygpKSB7XHJcbiAgXHRcdFx0XHRub2RlLnJlbW92ZUNoaWxkKG5vZGUuZmlyc3RDaGlsZCk7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHRcdG5vZGUuYXBwZW5kQ2hpbGQoY29udGVudCk7XHJcbiAgXHRcdH1cclxuICBcdFx0dGhpcy5maXJlKCdjb250ZW50dXBkYXRlJyk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF91cGRhdGVQb3NpdGlvbjogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRpZiAoIXRoaXMuX21hcCkgeyByZXR1cm47IH1cclxuXHJcbiAgXHRcdHZhciBwb3MgPSB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX2xhdGxuZyksXHJcbiAgXHRcdCAgICBvZmZzZXQgPSB0b1BvaW50KHRoaXMub3B0aW9ucy5vZmZzZXQpLFxyXG4gIFx0XHQgICAgYW5jaG9yID0gdGhpcy5fZ2V0QW5jaG9yKCk7XHJcblxyXG4gIFx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XHJcbiAgXHRcdFx0c2V0UG9zaXRpb24odGhpcy5fY29udGFpbmVyLCBwb3MuYWRkKGFuY2hvcikpO1xyXG4gIFx0XHR9IGVsc2Uge1xyXG4gIFx0XHRcdG9mZnNldCA9IG9mZnNldC5hZGQocG9zKS5hZGQoYW5jaG9yKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dmFyIGJvdHRvbSA9IHRoaXMuX2NvbnRhaW5lckJvdHRvbSA9IC1vZmZzZXQueSxcclxuICBcdFx0ICAgIGxlZnQgPSB0aGlzLl9jb250YWluZXJMZWZ0ID0gLU1hdGgucm91bmQodGhpcy5fY29udGFpbmVyV2lkdGggLyAyKSArIG9mZnNldC54O1xyXG5cclxuICBcdFx0Ly8gYm90dG9tIHBvc2l0aW9uIHRoZSBwb3B1cCBpbiBjYXNlIHRoZSBoZWlnaHQgb2YgdGhlIHBvcHVwIGNoYW5nZXMgKGltYWdlcyBsb2FkaW5nIGV0YylcclxuICBcdFx0dGhpcy5fY29udGFpbmVyLnN0eWxlLmJvdHRvbSA9IGJvdHRvbSArICdweCc7XHJcbiAgXHRcdHRoaXMuX2NvbnRhaW5lci5zdHlsZS5sZWZ0ID0gbGVmdCArICdweCc7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9nZXRBbmNob3I6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIFswLCAwXTtcclxuICBcdH1cclxuXHJcbiAgfSk7XG5cbiAgLypcclxuICAgKiBAY2xhc3MgUG9wdXBcclxuICAgKiBAaW5oZXJpdHMgRGl2T3ZlcmxheVxyXG4gICAqIEBha2EgTC5Qb3B1cFxyXG4gICAqIFVzZWQgdG8gb3BlbiBwb3B1cHMgaW4gY2VydGFpbiBwbGFjZXMgb2YgdGhlIG1hcC4gVXNlIFtNYXAub3BlblBvcHVwXSgjbWFwLW9wZW5wb3B1cCkgdG9cclxuICAgKiBvcGVuIHBvcHVwcyB3aGlsZSBtYWtpbmcgc3VyZSB0aGF0IG9ubHkgb25lIHBvcHVwIGlzIG9wZW4gYXQgb25lIHRpbWVcclxuICAgKiAocmVjb21tZW5kZWQgZm9yIHVzYWJpbGl0eSksIG9yIHVzZSBbTWFwLmFkZExheWVyXSgjbWFwLWFkZGxheWVyKSB0byBvcGVuIGFzIG1hbnkgYXMgeW91IHdhbnQuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqXHJcbiAgICogSWYgeW91IHdhbnQgdG8ganVzdCBiaW5kIGEgcG9wdXAgdG8gbWFya2VyIGNsaWNrIGFuZCB0aGVuIG9wZW4gaXQsIGl0J3MgcmVhbGx5IGVhc3k6XHJcbiAgICpcclxuICAgKiBgYGBqc1xyXG4gICAqIG1hcmtlci5iaW5kUG9wdXAocG9wdXBDb250ZW50KS5vcGVuUG9wdXAoKTtcclxuICAgKiBgYGBcclxuICAgKiBQYXRoIG92ZXJsYXlzIGxpa2UgcG9seWxpbmVzIGFsc28gaGF2ZSBhIGBiaW5kUG9wdXBgIG1ldGhvZC5cclxuICAgKiBIZXJlJ3MgYSBtb3JlIGNvbXBsaWNhdGVkIHdheSB0byBvcGVuIGEgcG9wdXAgb24gYSBtYXA6XHJcbiAgICpcclxuICAgKiBgYGBqc1xyXG4gICAqIHZhciBwb3B1cCA9IEwucG9wdXAoKVxyXG4gICAqIFx0LnNldExhdExuZyhsYXRsbmcpXHJcbiAgICogXHQuc2V0Q29udGVudCgnPHA+SGVsbG8gd29ybGQhPGJyIC8+VGhpcyBpcyBhIG5pY2UgcG9wdXAuPC9wPicpXHJcbiAgICogXHQub3Blbk9uKG1hcCk7XHJcbiAgICogYGBgXHJcbiAgICovXHJcblxyXG5cclxuICAvLyBAbmFtZXNwYWNlIFBvcHVwXHJcbiAgdmFyIFBvcHVwID0gRGl2T3ZlcmxheS5leHRlbmQoe1xyXG5cclxuICBcdC8vIEBzZWN0aW9uXHJcbiAgXHQvLyBAYWthIFBvcHVwIG9wdGlvbnNcclxuICBcdG9wdGlvbnM6IHtcclxuICBcdFx0Ly8gQG9wdGlvbiBtYXhXaWR0aDogTnVtYmVyID0gMzAwXHJcbiAgXHRcdC8vIE1heCB3aWR0aCBvZiB0aGUgcG9wdXAsIGluIHBpeGVscy5cclxuICBcdFx0bWF4V2lkdGg6IDMwMCxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gbWluV2lkdGg6IE51bWJlciA9IDUwXHJcbiAgXHRcdC8vIE1pbiB3aWR0aCBvZiB0aGUgcG9wdXAsIGluIHBpeGVscy5cclxuICBcdFx0bWluV2lkdGg6IDUwLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBtYXhIZWlnaHQ6IE51bWJlciA9IG51bGxcclxuICBcdFx0Ly8gSWYgc2V0LCBjcmVhdGVzIGEgc2Nyb2xsYWJsZSBjb250YWluZXIgb2YgdGhlIGdpdmVuIGhlaWdodFxyXG4gIFx0XHQvLyBpbnNpZGUgYSBwb3B1cCBpZiBpdHMgY29udGVudCBleGNlZWRzIGl0LlxyXG4gIFx0XHRtYXhIZWlnaHQ6IG51bGwsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIGF1dG9QYW46IEJvb2xlYW4gPSB0cnVlXHJcbiAgXHRcdC8vIFNldCBpdCB0byBgZmFsc2VgIGlmIHlvdSBkb24ndCB3YW50IHRoZSBtYXAgdG8gZG8gcGFubmluZyBhbmltYXRpb25cclxuICBcdFx0Ly8gdG8gZml0IHRoZSBvcGVuZWQgcG9wdXAuXHJcbiAgXHRcdGF1dG9QYW46IHRydWUsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIGF1dG9QYW5QYWRkaW5nVG9wTGVmdDogUG9pbnQgPSBudWxsXHJcbiAgXHRcdC8vIFRoZSBtYXJnaW4gYmV0d2VlbiB0aGUgcG9wdXAgYW5kIHRoZSB0b3AgbGVmdCBjb3JuZXIgb2YgdGhlIG1hcFxyXG4gIFx0XHQvLyB2aWV3IGFmdGVyIGF1dG9wYW5uaW5nIHdhcyBwZXJmb3JtZWQuXHJcbiAgXHRcdGF1dG9QYW5QYWRkaW5nVG9wTGVmdDogbnVsbCxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gYXV0b1BhblBhZGRpbmdCb3R0b21SaWdodDogUG9pbnQgPSBudWxsXHJcbiAgXHRcdC8vIFRoZSBtYXJnaW4gYmV0d2VlbiB0aGUgcG9wdXAgYW5kIHRoZSBib3R0b20gcmlnaHQgY29ybmVyIG9mIHRoZSBtYXBcclxuICBcdFx0Ly8gdmlldyBhZnRlciBhdXRvcGFubmluZyB3YXMgcGVyZm9ybWVkLlxyXG4gIFx0XHRhdXRvUGFuUGFkZGluZ0JvdHRvbVJpZ2h0OiBudWxsLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBhdXRvUGFuUGFkZGluZzogUG9pbnQgPSBQb2ludCg1LCA1KVxyXG4gIFx0XHQvLyBFcXVpdmFsZW50IG9mIHNldHRpbmcgYm90aCB0b3AgbGVmdCBhbmQgYm90dG9tIHJpZ2h0IGF1dG9wYW4gcGFkZGluZyB0byB0aGUgc2FtZSB2YWx1ZS5cclxuICBcdFx0YXV0b1BhblBhZGRpbmc6IFs1LCA1XSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24ga2VlcEluVmlldzogQm9vbGVhbiA9IGZhbHNlXHJcbiAgXHRcdC8vIFNldCBpdCB0byBgdHJ1ZWAgaWYgeW91IHdhbnQgdG8gcHJldmVudCB1c2VycyBmcm9tIHBhbm5pbmcgdGhlIHBvcHVwXHJcbiAgXHRcdC8vIG9mZiBvZiB0aGUgc2NyZWVuIHdoaWxlIGl0IGlzIG9wZW4uXHJcbiAgXHRcdGtlZXBJblZpZXc6IGZhbHNlLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBjbG9zZUJ1dHRvbjogQm9vbGVhbiA9IHRydWVcclxuICBcdFx0Ly8gQ29udHJvbHMgdGhlIHByZXNlbmNlIG9mIGEgY2xvc2UgYnV0dG9uIGluIHRoZSBwb3B1cC5cclxuICBcdFx0Y2xvc2VCdXR0b246IHRydWUsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIGF1dG9DbG9zZTogQm9vbGVhbiA9IHRydWVcclxuICBcdFx0Ly8gU2V0IGl0IHRvIGBmYWxzZWAgaWYgeW91IHdhbnQgdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHQgYmVoYXZpb3Igb2ZcclxuICBcdFx0Ly8gdGhlIHBvcHVwIGNsb3Npbmcgd2hlbiBhbm90aGVyIHBvcHVwIGlzIG9wZW5lZC5cclxuICBcdFx0YXV0b0Nsb3NlOiB0cnVlLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBjbG9zZU9uRXNjYXBlS2V5OiBCb29sZWFuID0gdHJ1ZVxyXG4gIFx0XHQvLyBTZXQgaXQgdG8gYGZhbHNlYCBpZiB5b3Ugd2FudCB0byBvdmVycmlkZSB0aGUgZGVmYXVsdCBiZWhhdmlvciBvZlxyXG4gIFx0XHQvLyB0aGUgRVNDIGtleSBmb3IgY2xvc2luZyBvZiB0aGUgcG9wdXAuXHJcbiAgXHRcdGNsb3NlT25Fc2NhcGVLZXk6IHRydWUsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIGNsb3NlT25DbGljazogQm9vbGVhbiA9ICpcclxuICBcdFx0Ly8gU2V0IGl0IGlmIHlvdSB3YW50IHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0IGJlaGF2aW9yIG9mIHRoZSBwb3B1cCBjbG9zaW5nIHdoZW4gdXNlciBjbGlja3NcclxuICBcdFx0Ly8gb24gdGhlIG1hcC4gRGVmYXVsdHMgdG8gdGhlIG1hcCdzIFtgY2xvc2VQb3B1cE9uQ2xpY2tgXSgjbWFwLWNsb3NlcG9wdXBvbmNsaWNrKSBvcHRpb24uXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIGNsYXNzTmFtZTogU3RyaW5nID0gJydcclxuICBcdFx0Ly8gQSBjdXN0b20gQ1NTIGNsYXNzIG5hbWUgdG8gYXNzaWduIHRvIHRoZSBwb3B1cC5cclxuICBcdFx0Y2xhc3NOYW1lOiAnJ1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbmFtZXNwYWNlIFBvcHVwXHJcbiAgXHQvLyBAbWV0aG9kIG9wZW5PbihtYXA6IE1hcCk6IHRoaXNcclxuICBcdC8vIEFkZHMgdGhlIHBvcHVwIHRvIHRoZSBtYXAgYW5kIGNsb3NlcyB0aGUgcHJldmlvdXMgb25lLiBUaGUgc2FtZSBhcyBgbWFwLm9wZW5Qb3B1cChwb3B1cClgLlxyXG4gIFx0b3Blbk9uOiBmdW5jdGlvbiAobWFwKSB7XHJcbiAgXHRcdG1hcC5vcGVuUG9wdXAodGhpcyk7XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xyXG4gIFx0XHREaXZPdmVybGF5LnByb3RvdHlwZS5vbkFkZC5jYWxsKHRoaXMsIG1hcCk7XHJcblxyXG4gIFx0XHQvLyBAbmFtZXNwYWNlIE1hcFxyXG4gIFx0XHQvLyBAc2VjdGlvbiBQb3B1cCBldmVudHNcclxuICBcdFx0Ly8gQGV2ZW50IHBvcHVwb3BlbjogUG9wdXBFdmVudFxyXG4gIFx0XHQvLyBGaXJlZCB3aGVuIGEgcG9wdXAgaXMgb3BlbmVkIGluIHRoZSBtYXBcclxuICBcdFx0bWFwLmZpcmUoJ3BvcHVwb3BlbicsIHtwb3B1cDogdGhpc30pO1xyXG5cclxuICBcdFx0aWYgKHRoaXMuX3NvdXJjZSkge1xyXG4gIFx0XHRcdC8vIEBuYW1lc3BhY2UgTGF5ZXJcclxuICBcdFx0XHQvLyBAc2VjdGlvbiBQb3B1cCBldmVudHNcclxuICBcdFx0XHQvLyBAZXZlbnQgcG9wdXBvcGVuOiBQb3B1cEV2ZW50XHJcbiAgXHRcdFx0Ly8gRmlyZWQgd2hlbiBhIHBvcHVwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgaXMgb3BlbmVkXHJcbiAgXHRcdFx0dGhpcy5fc291cmNlLmZpcmUoJ3BvcHVwb3BlbicsIHtwb3B1cDogdGhpc30sIHRydWUpO1xyXG4gIFx0XHRcdC8vIEZvciBub24tcGF0aCBsYXllcnMsIHdlIHRvZ2dsZSB0aGUgcG9wdXAgd2hlbiBjbGlja2luZ1xyXG4gIFx0XHRcdC8vIGFnYWluIHRoZSBsYXllciwgc28gcHJldmVudCB0aGUgbWFwIHRvIHJlb3BlbiBpdC5cclxuICBcdFx0XHRpZiAoISh0aGlzLl9zb3VyY2UgaW5zdGFuY2VvZiBQYXRoKSkge1xyXG4gIFx0XHRcdFx0dGhpcy5fc291cmNlLm9uKCdwcmVjbGljaycsIHN0b3BQcm9wYWdhdGlvbik7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHR9XHJcbiAgXHR9LFxyXG5cclxuICBcdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XHJcbiAgXHRcdERpdk92ZXJsYXkucHJvdG90eXBlLm9uUmVtb3ZlLmNhbGwodGhpcywgbWFwKTtcclxuXHJcbiAgXHRcdC8vIEBuYW1lc3BhY2UgTWFwXHJcbiAgXHRcdC8vIEBzZWN0aW9uIFBvcHVwIGV2ZW50c1xyXG4gIFx0XHQvLyBAZXZlbnQgcG9wdXBjbG9zZTogUG9wdXBFdmVudFxyXG4gIFx0XHQvLyBGaXJlZCB3aGVuIGEgcG9wdXAgaW4gdGhlIG1hcCBpcyBjbG9zZWRcclxuICBcdFx0bWFwLmZpcmUoJ3BvcHVwY2xvc2UnLCB7cG9wdXA6IHRoaXN9KTtcclxuXHJcbiAgXHRcdGlmICh0aGlzLl9zb3VyY2UpIHtcclxuICBcdFx0XHQvLyBAbmFtZXNwYWNlIExheWVyXHJcbiAgXHRcdFx0Ly8gQHNlY3Rpb24gUG9wdXAgZXZlbnRzXHJcbiAgXHRcdFx0Ly8gQGV2ZW50IHBvcHVwY2xvc2U6IFBvcHVwRXZlbnRcclxuICBcdFx0XHQvLyBGaXJlZCB3aGVuIGEgcG9wdXAgYm91bmQgdG8gdGhpcyBsYXllciBpcyBjbG9zZWRcclxuICBcdFx0XHR0aGlzLl9zb3VyY2UuZmlyZSgncG9wdXBjbG9zZScsIHtwb3B1cDogdGhpc30sIHRydWUpO1xyXG4gIFx0XHRcdGlmICghKHRoaXMuX3NvdXJjZSBpbnN0YW5jZW9mIFBhdGgpKSB7XHJcbiAgXHRcdFx0XHR0aGlzLl9zb3VyY2Uub2ZmKCdwcmVjbGljaycsIHN0b3BQcm9wYWdhdGlvbik7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHR9XHJcbiAgXHR9LFxyXG5cclxuICBcdGdldEV2ZW50czogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR2YXIgZXZlbnRzID0gRGl2T3ZlcmxheS5wcm90b3R5cGUuZ2V0RXZlbnRzLmNhbGwodGhpcyk7XHJcblxyXG4gIFx0XHRpZiAodGhpcy5vcHRpb25zLmNsb3NlT25DbGljayAhPT0gdW5kZWZpbmVkID8gdGhpcy5vcHRpb25zLmNsb3NlT25DbGljayA6IHRoaXMuX21hcC5vcHRpb25zLmNsb3NlUG9wdXBPbkNsaWNrKSB7XHJcbiAgXHRcdFx0ZXZlbnRzLnByZWNsaWNrID0gdGhpcy5fY2xvc2U7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGlmICh0aGlzLm9wdGlvbnMua2VlcEluVmlldykge1xyXG4gIFx0XHRcdGV2ZW50cy5tb3ZlZW5kID0gdGhpcy5fYWRqdXN0UGFuO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZXR1cm4gZXZlbnRzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfY2xvc2U6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0aWYgKHRoaXMuX21hcCkge1xyXG4gIFx0XHRcdHRoaXMuX21hcC5jbG9zZVBvcHVwKHRoaXMpO1xyXG4gIFx0XHR9XHJcbiAgXHR9LFxyXG5cclxuICBcdF9pbml0TGF5b3V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHZhciBwcmVmaXggPSAnbGVhZmxldC1wb3B1cCcsXHJcbiAgXHRcdCAgICBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIgPSBjcmVhdGUkMSgnZGl2JyxcclxuICBcdFx0XHRwcmVmaXggKyAnICcgKyAodGhpcy5vcHRpb25zLmNsYXNzTmFtZSB8fCAnJykgK1xyXG4gIFx0XHRcdCcgbGVhZmxldC16b29tLWFuaW1hdGVkJyk7XHJcblxyXG4gIFx0XHR2YXIgd3JhcHBlciA9IHRoaXMuX3dyYXBwZXIgPSBjcmVhdGUkMSgnZGl2JywgcHJlZml4ICsgJy1jb250ZW50LXdyYXBwZXInLCBjb250YWluZXIpO1xyXG4gIFx0XHR0aGlzLl9jb250ZW50Tm9kZSA9IGNyZWF0ZSQxKCdkaXYnLCBwcmVmaXggKyAnLWNvbnRlbnQnLCB3cmFwcGVyKTtcclxuXHJcbiAgXHRcdGRpc2FibGVDbGlja1Byb3BhZ2F0aW9uKGNvbnRhaW5lcik7XHJcbiAgXHRcdGRpc2FibGVTY3JvbGxQcm9wYWdhdGlvbih0aGlzLl9jb250ZW50Tm9kZSk7XHJcbiAgXHRcdG9uKGNvbnRhaW5lciwgJ2NvbnRleHRtZW51Jywgc3RvcFByb3BhZ2F0aW9uKTtcclxuXHJcbiAgXHRcdHRoaXMuX3RpcENvbnRhaW5lciA9IGNyZWF0ZSQxKCdkaXYnLCBwcmVmaXggKyAnLXRpcC1jb250YWluZXInLCBjb250YWluZXIpO1xyXG4gIFx0XHR0aGlzLl90aXAgPSBjcmVhdGUkMSgnZGl2JywgcHJlZml4ICsgJy10aXAnLCB0aGlzLl90aXBDb250YWluZXIpO1xyXG5cclxuICBcdFx0aWYgKHRoaXMub3B0aW9ucy5jbG9zZUJ1dHRvbikge1xyXG4gIFx0XHRcdHZhciBjbG9zZUJ1dHRvbiA9IHRoaXMuX2Nsb3NlQnV0dG9uID0gY3JlYXRlJDEoJ2EnLCBwcmVmaXggKyAnLWNsb3NlLWJ1dHRvbicsIGNvbnRhaW5lcik7XHJcbiAgXHRcdFx0Y2xvc2VCdXR0b24uaHJlZiA9ICcjY2xvc2UnO1xyXG4gIFx0XHRcdGNsb3NlQnV0dG9uLmlubmVySFRNTCA9ICcmIzIxNTsnO1xyXG5cclxuICBcdFx0XHRvbihjbG9zZUJ1dHRvbiwgJ2NsaWNrJywgdGhpcy5fb25DbG9zZUJ1dHRvbkNsaWNrLCB0aGlzKTtcclxuICBcdFx0fVxyXG4gIFx0fSxcclxuXHJcbiAgXHRfdXBkYXRlTGF5b3V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHZhciBjb250YWluZXIgPSB0aGlzLl9jb250ZW50Tm9kZSxcclxuICBcdFx0ICAgIHN0eWxlID0gY29udGFpbmVyLnN0eWxlO1xyXG5cclxuICBcdFx0c3R5bGUud2lkdGggPSAnJztcclxuICBcdFx0c3R5bGUud2hpdGVTcGFjZSA9ICdub3dyYXAnO1xyXG5cclxuICBcdFx0dmFyIHdpZHRoID0gY29udGFpbmVyLm9mZnNldFdpZHRoO1xyXG4gIFx0XHR3aWR0aCA9IE1hdGgubWluKHdpZHRoLCB0aGlzLm9wdGlvbnMubWF4V2lkdGgpO1xyXG4gIFx0XHR3aWR0aCA9IE1hdGgubWF4KHdpZHRoLCB0aGlzLm9wdGlvbnMubWluV2lkdGgpO1xyXG5cclxuICBcdFx0c3R5bGUud2lkdGggPSAod2lkdGggKyAxKSArICdweCc7XHJcbiAgXHRcdHN0eWxlLndoaXRlU3BhY2UgPSAnJztcclxuXHJcbiAgXHRcdHN0eWxlLmhlaWdodCA9ICcnO1xyXG5cclxuICBcdFx0dmFyIGhlaWdodCA9IGNvbnRhaW5lci5vZmZzZXRIZWlnaHQsXHJcbiAgXHRcdCAgICBtYXhIZWlnaHQgPSB0aGlzLm9wdGlvbnMubWF4SGVpZ2h0LFxyXG4gIFx0XHQgICAgc2Nyb2xsZWRDbGFzcyA9ICdsZWFmbGV0LXBvcHVwLXNjcm9sbGVkJztcclxuXHJcbiAgXHRcdGlmIChtYXhIZWlnaHQgJiYgaGVpZ2h0ID4gbWF4SGVpZ2h0KSB7XHJcbiAgXHRcdFx0c3R5bGUuaGVpZ2h0ID0gbWF4SGVpZ2h0ICsgJ3B4JztcclxuICBcdFx0XHRhZGRDbGFzcyhjb250YWluZXIsIHNjcm9sbGVkQ2xhc3MpO1xyXG4gIFx0XHR9IGVsc2Uge1xyXG4gIFx0XHRcdHJlbW92ZUNsYXNzKGNvbnRhaW5lciwgc2Nyb2xsZWRDbGFzcyk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMuX2NvbnRhaW5lcldpZHRoID0gdGhpcy5fY29udGFpbmVyLm9mZnNldFdpZHRoO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfYW5pbWF0ZVpvb206IGZ1bmN0aW9uIChlKSB7XHJcbiAgXHRcdHZhciBwb3MgPSB0aGlzLl9tYXAuX2xhdExuZ1RvTmV3TGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcsIGUuem9vbSwgZS5jZW50ZXIpLFxyXG4gIFx0XHQgICAgYW5jaG9yID0gdGhpcy5fZ2V0QW5jaG9yKCk7XHJcbiAgXHRcdHNldFBvc2l0aW9uKHRoaXMuX2NvbnRhaW5lciwgcG9zLmFkZChhbmNob3IpKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X2FkanVzdFBhbjogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRpZiAoIXRoaXMub3B0aW9ucy5hdXRvUGFuKSB7IHJldHVybjsgfVxyXG4gIFx0XHRpZiAodGhpcy5fbWFwLl9wYW5BbmltKSB7IHRoaXMuX21hcC5fcGFuQW5pbS5zdG9wKCk7IH1cclxuXHJcbiAgXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXHJcbiAgXHRcdCAgICBtYXJnaW5Cb3R0b20gPSBwYXJzZUludChnZXRTdHlsZSh0aGlzLl9jb250YWluZXIsICdtYXJnaW5Cb3R0b20nKSwgMTApIHx8IDAsXHJcbiAgXHRcdCAgICBjb250YWluZXJIZWlnaHQgPSB0aGlzLl9jb250YWluZXIub2Zmc2V0SGVpZ2h0ICsgbWFyZ2luQm90dG9tLFxyXG4gIFx0XHQgICAgY29udGFpbmVyV2lkdGggPSB0aGlzLl9jb250YWluZXJXaWR0aCxcclxuICBcdFx0ICAgIGxheWVyUG9zID0gbmV3IFBvaW50KHRoaXMuX2NvbnRhaW5lckxlZnQsIC1jb250YWluZXJIZWlnaHQgLSB0aGlzLl9jb250YWluZXJCb3R0b20pO1xyXG5cclxuICBcdFx0bGF5ZXJQb3MuX2FkZChnZXRQb3NpdGlvbih0aGlzLl9jb250YWluZXIpKTtcclxuXHJcbiAgXHRcdHZhciBjb250YWluZXJQb3MgPSBtYXAubGF5ZXJQb2ludFRvQ29udGFpbmVyUG9pbnQobGF5ZXJQb3MpLFxyXG4gIFx0XHQgICAgcGFkZGluZyA9IHRvUG9pbnQodGhpcy5vcHRpb25zLmF1dG9QYW5QYWRkaW5nKSxcclxuICBcdFx0ICAgIHBhZGRpbmdUTCA9IHRvUG9pbnQodGhpcy5vcHRpb25zLmF1dG9QYW5QYWRkaW5nVG9wTGVmdCB8fCBwYWRkaW5nKSxcclxuICBcdFx0ICAgIHBhZGRpbmdCUiA9IHRvUG9pbnQodGhpcy5vcHRpb25zLmF1dG9QYW5QYWRkaW5nQm90dG9tUmlnaHQgfHwgcGFkZGluZyksXHJcbiAgXHRcdCAgICBzaXplID0gbWFwLmdldFNpemUoKSxcclxuICBcdFx0ICAgIGR4ID0gMCxcclxuICBcdFx0ICAgIGR5ID0gMDtcclxuXHJcbiAgXHRcdGlmIChjb250YWluZXJQb3MueCArIGNvbnRhaW5lcldpZHRoICsgcGFkZGluZ0JSLnggPiBzaXplLngpIHsgLy8gcmlnaHRcclxuICBcdFx0XHRkeCA9IGNvbnRhaW5lclBvcy54ICsgY29udGFpbmVyV2lkdGggLSBzaXplLnggKyBwYWRkaW5nQlIueDtcclxuICBcdFx0fVxyXG4gIFx0XHRpZiAoY29udGFpbmVyUG9zLnggLSBkeCAtIHBhZGRpbmdUTC54IDwgMCkgeyAvLyBsZWZ0XHJcbiAgXHRcdFx0ZHggPSBjb250YWluZXJQb3MueCAtIHBhZGRpbmdUTC54O1xyXG4gIFx0XHR9XHJcbiAgXHRcdGlmIChjb250YWluZXJQb3MueSArIGNvbnRhaW5lckhlaWdodCArIHBhZGRpbmdCUi55ID4gc2l6ZS55KSB7IC8vIGJvdHRvbVxyXG4gIFx0XHRcdGR5ID0gY29udGFpbmVyUG9zLnkgKyBjb250YWluZXJIZWlnaHQgLSBzaXplLnkgKyBwYWRkaW5nQlIueTtcclxuICBcdFx0fVxyXG4gIFx0XHRpZiAoY29udGFpbmVyUG9zLnkgLSBkeSAtIHBhZGRpbmdUTC55IDwgMCkgeyAvLyB0b3BcclxuICBcdFx0XHRkeSA9IGNvbnRhaW5lclBvcy55IC0gcGFkZGluZ1RMLnk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdC8vIEBuYW1lc3BhY2UgTWFwXHJcbiAgXHRcdC8vIEBzZWN0aW9uIFBvcHVwIGV2ZW50c1xyXG4gIFx0XHQvLyBAZXZlbnQgYXV0b3BhbnN0YXJ0OiBFdmVudFxyXG4gIFx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXAgc3RhcnRzIGF1dG9wYW5uaW5nIHdoZW4gb3BlbmluZyBhIHBvcHVwLlxyXG4gIFx0XHRpZiAoZHggfHwgZHkpIHtcclxuICBcdFx0XHRtYXBcclxuICBcdFx0XHQgICAgLmZpcmUoJ2F1dG9wYW5zdGFydCcpXHJcbiAgXHRcdFx0ICAgIC5wYW5CeShbZHgsIGR5XSk7XHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0X29uQ2xvc2VCdXR0b25DbGljazogZnVuY3Rpb24gKGUpIHtcclxuICBcdFx0dGhpcy5fY2xvc2UoKTtcclxuICBcdFx0c3RvcChlKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X2dldEFuY2hvcjogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHQvLyBXaGVyZSBzaG91bGQgd2UgYW5jaG9yIHRoZSBwb3B1cCBvbiB0aGUgc291cmNlIGxheWVyP1xyXG4gIFx0XHRyZXR1cm4gdG9Qb2ludCh0aGlzLl9zb3VyY2UgJiYgdGhpcy5fc291cmNlLl9nZXRQb3B1cEFuY2hvciA/IHRoaXMuX3NvdXJjZS5fZ2V0UG9wdXBBbmNob3IoKSA6IFswLCAwXSk7XHJcbiAgXHR9XHJcblxyXG4gIH0pO1xyXG5cclxuICAvLyBAbmFtZXNwYWNlIFBvcHVwXHJcbiAgLy8gQGZhY3RvcnkgTC5wb3B1cChvcHRpb25zPzogUG9wdXAgb3B0aW9ucywgc291cmNlPzogTGF5ZXIpXHJcbiAgLy8gSW5zdGFudGlhdGVzIGEgYFBvcHVwYCBvYmplY3QgZ2l2ZW4gYW4gb3B0aW9uYWwgYG9wdGlvbnNgIG9iamVjdCB0aGF0IGRlc2NyaWJlcyBpdHMgYXBwZWFyYW5jZSBhbmQgbG9jYXRpb24gYW5kIGFuIG9wdGlvbmFsIGBzb3VyY2VgIG9iamVjdCB0aGF0IGlzIHVzZWQgdG8gdGFnIHRoZSBwb3B1cCB3aXRoIGEgcmVmZXJlbmNlIHRvIHRoZSBMYXllciB0byB3aGljaCBpdCByZWZlcnMuXHJcbiAgdmFyIHBvcHVwID0gZnVuY3Rpb24gKG9wdGlvbnMsIHNvdXJjZSkge1xyXG4gIFx0cmV0dXJuIG5ldyBQb3B1cChvcHRpb25zLCBzb3VyY2UpO1xyXG4gIH07XHJcblxyXG5cclxuICAvKiBAbmFtZXNwYWNlIE1hcFxyXG4gICAqIEBzZWN0aW9uIEludGVyYWN0aW9uIE9wdGlvbnNcclxuICAgKiBAb3B0aW9uIGNsb3NlUG9wdXBPbkNsaWNrOiBCb29sZWFuID0gdHJ1ZVxyXG4gICAqIFNldCBpdCB0byBgZmFsc2VgIGlmIHlvdSBkb24ndCB3YW50IHBvcHVwcyB0byBjbG9zZSB3aGVuIHVzZXIgY2xpY2tzIHRoZSBtYXAuXHJcbiAgICovXHJcbiAgTWFwLm1lcmdlT3B0aW9ucyh7XHJcbiAgXHRjbG9zZVBvcHVwT25DbGljazogdHJ1ZVxyXG4gIH0pO1xyXG5cclxuXHJcbiAgLy8gQG5hbWVzcGFjZSBNYXBcclxuICAvLyBAc2VjdGlvbiBNZXRob2RzIGZvciBMYXllcnMgYW5kIENvbnRyb2xzXHJcbiAgTWFwLmluY2x1ZGUoe1xyXG4gIFx0Ly8gQG1ldGhvZCBvcGVuUG9wdXAocG9wdXA6IFBvcHVwKTogdGhpc1xyXG4gIFx0Ly8gT3BlbnMgdGhlIHNwZWNpZmllZCBwb3B1cCB3aGlsZSBjbG9zaW5nIHRoZSBwcmV2aW91c2x5IG9wZW5lZCAodG8gbWFrZSBzdXJlIG9ubHkgb25lIGlzIG9wZW5lZCBhdCBvbmUgdGltZSBmb3IgdXNhYmlsaXR5KS5cclxuICBcdC8vIEBhbHRlcm5hdGl2ZVxyXG4gIFx0Ly8gQG1ldGhvZCBvcGVuUG9wdXAoY29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50LCBsYXRsbmc6IExhdExuZywgb3B0aW9ucz86IFBvcHVwIG9wdGlvbnMpOiB0aGlzXHJcbiAgXHQvLyBDcmVhdGVzIGEgcG9wdXAgd2l0aCB0aGUgc3BlY2lmaWVkIGNvbnRlbnQgYW5kIG9wdGlvbnMgYW5kIG9wZW5zIGl0IGluIHRoZSBnaXZlbiBwb2ludCBvbiBhIG1hcC5cclxuICBcdG9wZW5Qb3B1cDogZnVuY3Rpb24gKHBvcHVwLCBsYXRsbmcsIG9wdGlvbnMpIHtcclxuICBcdFx0aWYgKCEocG9wdXAgaW5zdGFuY2VvZiBQb3B1cCkpIHtcclxuICBcdFx0XHRwb3B1cCA9IG5ldyBQb3B1cChvcHRpb25zKS5zZXRDb250ZW50KHBvcHVwKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0aWYgKGxhdGxuZykge1xyXG4gIFx0XHRcdHBvcHVwLnNldExhdExuZyhsYXRsbmcpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRpZiAodGhpcy5oYXNMYXllcihwb3B1cCkpIHtcclxuICBcdFx0XHRyZXR1cm4gdGhpcztcclxuICBcdFx0fVxyXG5cclxuICBcdFx0aWYgKHRoaXMuX3BvcHVwICYmIHRoaXMuX3BvcHVwLm9wdGlvbnMuYXV0b0Nsb3NlKSB7XHJcbiAgXHRcdFx0dGhpcy5jbG9zZVBvcHVwKCk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMuX3BvcHVwID0gcG9wdXA7XHJcbiAgXHRcdHJldHVybiB0aGlzLmFkZExheWVyKHBvcHVwKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBjbG9zZVBvcHVwKHBvcHVwPzogUG9wdXApOiB0aGlzXHJcbiAgXHQvLyBDbG9zZXMgdGhlIHBvcHVwIHByZXZpb3VzbHkgb3BlbmVkIHdpdGggW29wZW5Qb3B1cF0oI21hcC1vcGVucG9wdXApIChvciB0aGUgZ2l2ZW4gb25lKS5cclxuICBcdGNsb3NlUG9wdXA6IGZ1bmN0aW9uIChwb3B1cCkge1xyXG4gIFx0XHRpZiAoIXBvcHVwIHx8IHBvcHVwID09PSB0aGlzLl9wb3B1cCkge1xyXG4gIFx0XHRcdHBvcHVwID0gdGhpcy5fcG9wdXA7XHJcbiAgXHRcdFx0dGhpcy5fcG9wdXAgPSBudWxsO1xyXG4gIFx0XHR9XHJcbiAgXHRcdGlmIChwb3B1cCkge1xyXG4gIFx0XHRcdHRoaXMucmVtb3ZlTGF5ZXIocG9wdXApO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fVxyXG4gIH0pO1xyXG5cclxuICAvKlxyXG4gICAqIEBuYW1lc3BhY2UgTGF5ZXJcclxuICAgKiBAc2VjdGlvbiBQb3B1cCBtZXRob2RzIGV4YW1wbGVcclxuICAgKlxyXG4gICAqIEFsbCBsYXllcnMgc2hhcmUgYSBzZXQgb2YgbWV0aG9kcyBjb252ZW5pZW50IGZvciBiaW5kaW5nIHBvcHVwcyB0byBpdC5cclxuICAgKlxyXG4gICAqIGBgYGpzXHJcbiAgICogdmFyIGxheWVyID0gTC5Qb2x5Z29uKGxhdGxuZ3MpLmJpbmRQb3B1cCgnSGkgVGhlcmUhJykuYWRkVG8obWFwKTtcclxuICAgKiBsYXllci5vcGVuUG9wdXAoKTtcclxuICAgKiBsYXllci5jbG9zZVBvcHVwKCk7XHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBQb3B1cHMgd2lsbCBhbHNvIGJlIGF1dG9tYXRpY2FsbHkgb3BlbmVkIHdoZW4gdGhlIGxheWVyIGlzIGNsaWNrZWQgb24gYW5kIGNsb3NlZCB3aGVuIHRoZSBsYXllciBpcyByZW1vdmVkIGZyb20gdGhlIG1hcCBvciBhbm90aGVyIHBvcHVwIGlzIG9wZW5lZC5cclxuICAgKi9cclxuXHJcbiAgLy8gQHNlY3Rpb24gUG9wdXAgbWV0aG9kc1xyXG4gIExheWVyLmluY2x1ZGUoe1xyXG5cclxuICBcdC8vIEBtZXRob2QgYmluZFBvcHVwKGNvbnRlbnQ6IFN0cmluZ3xIVE1MRWxlbWVudHxGdW5jdGlvbnxQb3B1cCwgb3B0aW9ucz86IFBvcHVwIG9wdGlvbnMpOiB0aGlzXHJcbiAgXHQvLyBCaW5kcyBhIHBvcHVwIHRvIHRoZSBsYXllciB3aXRoIHRoZSBwYXNzZWQgYGNvbnRlbnRgIGFuZCBzZXRzIHVwIHRoZVxyXG4gIFx0Ly8gbmVjZXNzYXJ5IGV2ZW50IGxpc3RlbmVycy4gSWYgYSBgRnVuY3Rpb25gIGlzIHBhc3NlZCBpdCB3aWxsIHJlY2VpdmVcclxuICBcdC8vIHRoZSBsYXllciBhcyB0aGUgZmlyc3QgYXJndW1lbnQgYW5kIHNob3VsZCByZXR1cm4gYSBgU3RyaW5nYCBvciBgSFRNTEVsZW1lbnRgLlxyXG4gIFx0YmluZFBvcHVwOiBmdW5jdGlvbiAoY29udGVudCwgb3B0aW9ucykge1xyXG5cclxuICBcdFx0aWYgKGNvbnRlbnQgaW5zdGFuY2VvZiBQb3B1cCkge1xyXG4gIFx0XHRcdHNldE9wdGlvbnMoY29udGVudCwgb3B0aW9ucyk7XHJcbiAgXHRcdFx0dGhpcy5fcG9wdXAgPSBjb250ZW50O1xyXG4gIFx0XHRcdGNvbnRlbnQuX3NvdXJjZSA9IHRoaXM7XHJcbiAgXHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0aWYgKCF0aGlzLl9wb3B1cCB8fCBvcHRpb25zKSB7XHJcbiAgXHRcdFx0XHR0aGlzLl9wb3B1cCA9IG5ldyBQb3B1cChvcHRpb25zLCB0aGlzKTtcclxuICBcdFx0XHR9XHJcbiAgXHRcdFx0dGhpcy5fcG9wdXAuc2V0Q29udGVudChjb250ZW50KTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0aWYgKCF0aGlzLl9wb3B1cEhhbmRsZXJzQWRkZWQpIHtcclxuICBcdFx0XHR0aGlzLm9uKHtcclxuICBcdFx0XHRcdGNsaWNrOiB0aGlzLl9vcGVuUG9wdXAsXHJcbiAgXHRcdFx0XHRrZXlwcmVzczogdGhpcy5fb25LZXlQcmVzcyxcclxuICBcdFx0XHRcdHJlbW92ZTogdGhpcy5jbG9zZVBvcHVwLFxyXG4gIFx0XHRcdFx0bW92ZTogdGhpcy5fbW92ZVBvcHVwXHJcbiAgXHRcdFx0fSk7XHJcbiAgXHRcdFx0dGhpcy5fcG9wdXBIYW5kbGVyc0FkZGVkID0gdHJ1ZTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgdW5iaW5kUG9wdXAoKTogdGhpc1xyXG4gIFx0Ly8gUmVtb3ZlcyB0aGUgcG9wdXAgcHJldmlvdXNseSBib3VuZCB3aXRoIGBiaW5kUG9wdXBgLlxyXG4gIFx0dW5iaW5kUG9wdXA6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0aWYgKHRoaXMuX3BvcHVwKSB7XHJcbiAgXHRcdFx0dGhpcy5vZmYoe1xyXG4gIFx0XHRcdFx0Y2xpY2s6IHRoaXMuX29wZW5Qb3B1cCxcclxuICBcdFx0XHRcdGtleXByZXNzOiB0aGlzLl9vbktleVByZXNzLFxyXG4gIFx0XHRcdFx0cmVtb3ZlOiB0aGlzLmNsb3NlUG9wdXAsXHJcbiAgXHRcdFx0XHRtb3ZlOiB0aGlzLl9tb3ZlUG9wdXBcclxuICBcdFx0XHR9KTtcclxuICBcdFx0XHR0aGlzLl9wb3B1cEhhbmRsZXJzQWRkZWQgPSBmYWxzZTtcclxuICBcdFx0XHR0aGlzLl9wb3B1cCA9IG51bGw7XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2Qgb3BlblBvcHVwKGxhdGxuZz86IExhdExuZyk6IHRoaXNcclxuICBcdC8vIE9wZW5zIHRoZSBib3VuZCBwb3B1cCBhdCB0aGUgc3BlY2lmaWVkIGBsYXRsbmdgIG9yIGF0IHRoZSBkZWZhdWx0IHBvcHVwIGFuY2hvciBpZiBubyBgbGF0bG5nYCBpcyBwYXNzZWQuXHJcbiAgXHRvcGVuUG9wdXA6IGZ1bmN0aW9uIChsYXllciwgbGF0bG5nKSB7XHJcbiAgXHRcdGlmICh0aGlzLl9wb3B1cCAmJiB0aGlzLl9tYXApIHtcclxuICBcdFx0XHRsYXRsbmcgPSB0aGlzLl9wb3B1cC5fcHJlcGFyZU9wZW4odGhpcywgbGF5ZXIsIGxhdGxuZyk7XHJcblxyXG4gIFx0XHRcdC8vIG9wZW4gdGhlIHBvcHVwIG9uIHRoZSBtYXBcclxuICBcdFx0XHR0aGlzLl9tYXAub3BlblBvcHVwKHRoaXMuX3BvcHVwLCBsYXRsbmcpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBjbG9zZVBvcHVwKCk6IHRoaXNcclxuICBcdC8vIENsb3NlcyB0aGUgcG9wdXAgYm91bmQgdG8gdGhpcyBsYXllciBpZiBpdCBpcyBvcGVuLlxyXG4gIFx0Y2xvc2VQb3B1cDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRpZiAodGhpcy5fcG9wdXApIHtcclxuICBcdFx0XHR0aGlzLl9wb3B1cC5fY2xvc2UoKTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCB0b2dnbGVQb3B1cCgpOiB0aGlzXHJcbiAgXHQvLyBPcGVucyBvciBjbG9zZXMgdGhlIHBvcHVwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgZGVwZW5kaW5nIG9uIGl0cyBjdXJyZW50IHN0YXRlLlxyXG4gIFx0dG9nZ2xlUG9wdXA6IGZ1bmN0aW9uICh0YXJnZXQpIHtcclxuICBcdFx0aWYgKHRoaXMuX3BvcHVwKSB7XHJcbiAgXHRcdFx0aWYgKHRoaXMuX3BvcHVwLl9tYXApIHtcclxuICBcdFx0XHRcdHRoaXMuY2xvc2VQb3B1cCgpO1xyXG4gIFx0XHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0XHR0aGlzLm9wZW5Qb3B1cCh0YXJnZXQpO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBpc1BvcHVwT3BlbigpOiBib29sZWFuXHJcbiAgXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcG9wdXAgYm91bmQgdG8gdGhpcyBsYXllciBpcyBjdXJyZW50bHkgb3Blbi5cclxuICBcdGlzUG9wdXBPcGVuOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiAodGhpcy5fcG9wdXAgPyB0aGlzLl9wb3B1cC5pc09wZW4oKSA6IGZhbHNlKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBzZXRQb3B1cENvbnRlbnQoY29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50fFBvcHVwKTogdGhpc1xyXG4gIFx0Ly8gU2V0cyB0aGUgY29udGVudCBvZiB0aGUgcG9wdXAgYm91bmQgdG8gdGhpcyBsYXllci5cclxuICBcdHNldFBvcHVwQ29udGVudDogZnVuY3Rpb24gKGNvbnRlbnQpIHtcclxuICBcdFx0aWYgKHRoaXMuX3BvcHVwKSB7XHJcbiAgXHRcdFx0dGhpcy5fcG9wdXAuc2V0Q29udGVudChjb250ZW50KTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRQb3B1cCgpOiBQb3B1cFxyXG4gIFx0Ly8gUmV0dXJucyB0aGUgcG9wdXAgYm91bmQgdG8gdGhpcyBsYXllci5cclxuICBcdGdldFBvcHVwOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLl9wb3B1cDtcclxuICBcdH0sXHJcblxyXG4gIFx0X29wZW5Qb3B1cDogZnVuY3Rpb24gKGUpIHtcclxuICBcdFx0dmFyIGxheWVyID0gZS5sYXllciB8fCBlLnRhcmdldDtcclxuXHJcbiAgXHRcdGlmICghdGhpcy5fcG9wdXApIHtcclxuICBcdFx0XHRyZXR1cm47XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGlmICghdGhpcy5fbWFwKSB7XHJcbiAgXHRcdFx0cmV0dXJuO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHQvLyBwcmV2ZW50IG1hcCBjbGlja1xyXG4gIFx0XHRzdG9wKGUpO1xyXG5cclxuICBcdFx0Ly8gaWYgdGhpcyBpbmhlcml0cyBmcm9tIFBhdGggaXRzIGEgdmVjdG9yIGFuZCB3ZSBjYW4ganVzdFxyXG4gIFx0XHQvLyBvcGVuIHRoZSBwb3B1cCBhdCB0aGUgbmV3IGxvY2F0aW9uXHJcbiAgXHRcdGlmIChsYXllciBpbnN0YW5jZW9mIFBhdGgpIHtcclxuICBcdFx0XHR0aGlzLm9wZW5Qb3B1cChlLmxheWVyIHx8IGUudGFyZ2V0LCBlLmxhdGxuZyk7XHJcbiAgXHRcdFx0cmV0dXJuO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHQvLyBvdGhlcndpc2UgdHJlYXQgaXQgbGlrZSBhIG1hcmtlciBhbmQgZmlndXJlIG91dFxyXG4gIFx0XHQvLyBpZiB3ZSBzaG91bGQgdG9nZ2xlIGl0IG9wZW4vY2xvc2VkXHJcbiAgXHRcdGlmICh0aGlzLl9tYXAuaGFzTGF5ZXIodGhpcy5fcG9wdXApICYmIHRoaXMuX3BvcHVwLl9zb3VyY2UgPT09IGxheWVyKSB7XHJcbiAgXHRcdFx0dGhpcy5jbG9zZVBvcHVwKCk7XHJcbiAgXHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0dGhpcy5vcGVuUG9wdXAobGF5ZXIsIGUubGF0bG5nKTtcclxuICBcdFx0fVxyXG4gIFx0fSxcclxuXHJcbiAgXHRfbW92ZVBvcHVwOiBmdW5jdGlvbiAoZSkge1xyXG4gIFx0XHR0aGlzLl9wb3B1cC5zZXRMYXRMbmcoZS5sYXRsbmcpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfb25LZXlQcmVzczogZnVuY3Rpb24gKGUpIHtcclxuICBcdFx0aWYgKGUub3JpZ2luYWxFdmVudC5rZXlDb2RlID09PSAxMykge1xyXG4gIFx0XHRcdHRoaXMuX29wZW5Qb3B1cChlKTtcclxuICBcdFx0fVxyXG4gIFx0fVxyXG4gIH0pO1xuXG4gIC8qXG4gICAqIEBjbGFzcyBUb29sdGlwXG4gICAqIEBpbmhlcml0cyBEaXZPdmVybGF5XG4gICAqIEBha2EgTC5Ub29sdGlwXG4gICAqIFVzZWQgdG8gZGlzcGxheSBzbWFsbCB0ZXh0cyBvbiB0b3Agb2YgbWFwIGxheWVycy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogYGBganNcbiAgICogbWFya2VyLmJpbmRUb29sdGlwKFwibXkgdG9vbHRpcCB0ZXh0XCIpLm9wZW5Ub29sdGlwKCk7XG4gICAqIGBgYFxuICAgKiBOb3RlIGFib3V0IHRvb2x0aXAgb2Zmc2V0LiBMZWFmbGV0IHRha2VzIHR3byBvcHRpb25zIGluIGNvbnNpZGVyYXRpb25cbiAgICogZm9yIGNvbXB1dGluZyB0b29sdGlwIG9mZnNldHRpbmc6XG4gICAqIC0gdGhlIGBvZmZzZXRgIFRvb2x0aXAgb3B0aW9uOiBpdCBkZWZhdWx0cyB0byBbMCwgMF0sIGFuZCBpdCdzIHNwZWNpZmljIHRvIG9uZSB0b29sdGlwLlxuICAgKiAgIEFkZCBhIHBvc2l0aXZlIHggb2Zmc2V0IHRvIG1vdmUgdGhlIHRvb2x0aXAgdG8gdGhlIHJpZ2h0LCBhbmQgYSBwb3NpdGl2ZSB5IG9mZnNldCB0b1xuICAgKiAgIG1vdmUgaXQgdG8gdGhlIGJvdHRvbS4gTmVnYXRpdmVzIHdpbGwgbW92ZSB0byB0aGUgbGVmdCBhbmQgdG9wLlxuICAgKiAtIHRoZSBgdG9vbHRpcEFuY2hvcmAgSWNvbiBvcHRpb246IHRoaXMgd2lsbCBvbmx5IGJlIGNvbnNpZGVyZWQgZm9yIE1hcmtlci4gWW91XG4gICAqICAgc2hvdWxkIGFkYXB0IHRoaXMgdmFsdWUgaWYgeW91IHVzZSBhIGN1c3RvbSBpY29uLlxuICAgKi9cblxuXG4gIC8vIEBuYW1lc3BhY2UgVG9vbHRpcFxuICB2YXIgVG9vbHRpcCA9IERpdk92ZXJsYXkuZXh0ZW5kKHtcblxuICBcdC8vIEBzZWN0aW9uXG4gIFx0Ly8gQGFrYSBUb29sdGlwIG9wdGlvbnNcbiAgXHRvcHRpb25zOiB7XG4gIFx0XHQvLyBAb3B0aW9uIHBhbmU6IFN0cmluZyA9ICd0b29sdGlwUGFuZSdcbiAgXHRcdC8vIGBNYXAgcGFuZWAgd2hlcmUgdGhlIHRvb2x0aXAgd2lsbCBiZSBhZGRlZC5cbiAgXHRcdHBhbmU6ICd0b29sdGlwUGFuZScsXG5cbiAgXHRcdC8vIEBvcHRpb24gb2Zmc2V0OiBQb2ludCA9IFBvaW50KDAsIDApXG4gIFx0XHQvLyBPcHRpb25hbCBvZmZzZXQgb2YgdGhlIHRvb2x0aXAgcG9zaXRpb24uXG4gIFx0XHRvZmZzZXQ6IFswLCAwXSxcblxuICBcdFx0Ly8gQG9wdGlvbiBkaXJlY3Rpb246IFN0cmluZyA9ICdhdXRvJ1xuICBcdFx0Ly8gRGlyZWN0aW9uIHdoZXJlIHRvIG9wZW4gdGhlIHRvb2x0aXAuIFBvc3NpYmxlIHZhbHVlcyBhcmU6IGByaWdodGAsIGBsZWZ0YCxcbiAgXHRcdC8vIGB0b3BgLCBgYm90dG9tYCwgYGNlbnRlcmAsIGBhdXRvYC5cbiAgXHRcdC8vIGBhdXRvYCB3aWxsIGR5bmFtaWNhbGx5IHN3aXRjaCBiZXR3ZWVuIGByaWdodGAgYW5kIGBsZWZ0YCBhY2NvcmRpbmcgdG8gdGhlIHRvb2x0aXBcbiAgXHRcdC8vIHBvc2l0aW9uIG9uIHRoZSBtYXAuXG4gIFx0XHRkaXJlY3Rpb246ICdhdXRvJyxcblxuICBcdFx0Ly8gQG9wdGlvbiBwZXJtYW5lbnQ6IEJvb2xlYW4gPSBmYWxzZVxuICBcdFx0Ly8gV2hldGhlciB0byBvcGVuIHRoZSB0b29sdGlwIHBlcm1hbmVudGx5IG9yIG9ubHkgb24gbW91c2VvdmVyLlxuICBcdFx0cGVybWFuZW50OiBmYWxzZSxcblxuICBcdFx0Ly8gQG9wdGlvbiBzdGlja3k6IEJvb2xlYW4gPSBmYWxzZVxuICBcdFx0Ly8gSWYgdHJ1ZSwgdGhlIHRvb2x0aXAgd2lsbCBmb2xsb3cgdGhlIG1vdXNlIGluc3RlYWQgb2YgYmVpbmcgZml4ZWQgYXQgdGhlIGZlYXR1cmUgY2VudGVyLlxuICBcdFx0c3RpY2t5OiBmYWxzZSxcblxuICBcdFx0Ly8gQG9wdGlvbiBpbnRlcmFjdGl2ZTogQm9vbGVhbiA9IGZhbHNlXG4gIFx0XHQvLyBJZiB0cnVlLCB0aGUgdG9vbHRpcCB3aWxsIGxpc3RlbiB0byB0aGUgZmVhdHVyZSBldmVudHMuXG4gIFx0XHRpbnRlcmFjdGl2ZTogZmFsc2UsXG5cbiAgXHRcdC8vIEBvcHRpb24gb3BhY2l0eTogTnVtYmVyID0gMC45XG4gIFx0XHQvLyBUb29sdGlwIGNvbnRhaW5lciBvcGFjaXR5LlxuICBcdFx0b3BhY2l0eTogMC45XG4gIFx0fSxcblxuICBcdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XG4gIFx0XHREaXZPdmVybGF5LnByb3RvdHlwZS5vbkFkZC5jYWxsKHRoaXMsIG1hcCk7XG4gIFx0XHR0aGlzLnNldE9wYWNpdHkodGhpcy5vcHRpb25zLm9wYWNpdHkpO1xuXG4gIFx0XHQvLyBAbmFtZXNwYWNlIE1hcFxuICBcdFx0Ly8gQHNlY3Rpb24gVG9vbHRpcCBldmVudHNcbiAgXHRcdC8vIEBldmVudCB0b29sdGlwb3BlbjogVG9vbHRpcEV2ZW50XG4gIFx0XHQvLyBGaXJlZCB3aGVuIGEgdG9vbHRpcCBpcyBvcGVuZWQgaW4gdGhlIG1hcC5cbiAgXHRcdG1hcC5maXJlKCd0b29sdGlwb3BlbicsIHt0b29sdGlwOiB0aGlzfSk7XG5cbiAgXHRcdGlmICh0aGlzLl9zb3VyY2UpIHtcbiAgXHRcdFx0Ly8gQG5hbWVzcGFjZSBMYXllclxuICBcdFx0XHQvLyBAc2VjdGlvbiBUb29sdGlwIGV2ZW50c1xuICBcdFx0XHQvLyBAZXZlbnQgdG9vbHRpcG9wZW46IFRvb2x0aXBFdmVudFxuICBcdFx0XHQvLyBGaXJlZCB3aGVuIGEgdG9vbHRpcCBib3VuZCB0byB0aGlzIGxheWVyIGlzIG9wZW5lZC5cbiAgXHRcdFx0dGhpcy5fc291cmNlLmZpcmUoJ3Rvb2x0aXBvcGVuJywge3Rvb2x0aXA6IHRoaXN9LCB0cnVlKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcbiAgXHRcdERpdk92ZXJsYXkucHJvdG90eXBlLm9uUmVtb3ZlLmNhbGwodGhpcywgbWFwKTtcblxuICBcdFx0Ly8gQG5hbWVzcGFjZSBNYXBcbiAgXHRcdC8vIEBzZWN0aW9uIFRvb2x0aXAgZXZlbnRzXG4gIFx0XHQvLyBAZXZlbnQgdG9vbHRpcGNsb3NlOiBUb29sdGlwRXZlbnRcbiAgXHRcdC8vIEZpcmVkIHdoZW4gYSB0b29sdGlwIGluIHRoZSBtYXAgaXMgY2xvc2VkLlxuICBcdFx0bWFwLmZpcmUoJ3Rvb2x0aXBjbG9zZScsIHt0b29sdGlwOiB0aGlzfSk7XG5cbiAgXHRcdGlmICh0aGlzLl9zb3VyY2UpIHtcbiAgXHRcdFx0Ly8gQG5hbWVzcGFjZSBMYXllclxuICBcdFx0XHQvLyBAc2VjdGlvbiBUb29sdGlwIGV2ZW50c1xuICBcdFx0XHQvLyBAZXZlbnQgdG9vbHRpcGNsb3NlOiBUb29sdGlwRXZlbnRcbiAgXHRcdFx0Ly8gRmlyZWQgd2hlbiBhIHRvb2x0aXAgYm91bmQgdG8gdGhpcyBsYXllciBpcyBjbG9zZWQuXG4gIFx0XHRcdHRoaXMuX3NvdXJjZS5maXJlKCd0b29sdGlwY2xvc2UnLCB7dG9vbHRpcDogdGhpc30sIHRydWUpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRnZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBldmVudHMgPSBEaXZPdmVybGF5LnByb3RvdHlwZS5nZXRFdmVudHMuY2FsbCh0aGlzKTtcblxuICBcdFx0aWYgKHRvdWNoICYmICF0aGlzLm9wdGlvbnMucGVybWFuZW50KSB7XG4gIFx0XHRcdGV2ZW50cy5wcmVjbGljayA9IHRoaXMuX2Nsb3NlO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gZXZlbnRzO1xuICBcdH0sXG5cbiAgXHRfY2xvc2U6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICh0aGlzLl9tYXApIHtcbiAgXHRcdFx0dGhpcy5fbWFwLmNsb3NlVG9vbHRpcCh0aGlzKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X2luaXRMYXlvdXQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBwcmVmaXggPSAnbGVhZmxldC10b29sdGlwJyxcbiAgXHRcdCAgICBjbGFzc05hbWUgPSBwcmVmaXggKyAnICcgKyAodGhpcy5vcHRpb25zLmNsYXNzTmFtZSB8fCAnJykgKyAnIGxlYWZsZXQtem9vbS0nICsgKHRoaXMuX3pvb21BbmltYXRlZCA/ICdhbmltYXRlZCcgOiAnaGlkZScpO1xuXG4gIFx0XHR0aGlzLl9jb250ZW50Tm9kZSA9IHRoaXMuX2NvbnRhaW5lciA9IGNyZWF0ZSQxKCdkaXYnLCBjbGFzc05hbWUpO1xuICBcdH0sXG5cbiAgXHRfdXBkYXRlTGF5b3V0OiBmdW5jdGlvbiAoKSB7fSxcblxuICBcdF9hZGp1c3RQYW46IGZ1bmN0aW9uICgpIHt9LFxuXG4gIFx0X3NldFBvc2l0aW9uOiBmdW5jdGlvbiAocG9zKSB7XG4gIFx0XHR2YXIgc3ViWCwgc3ViWSxcbiAgXHRcdCAgICBtYXAgPSB0aGlzLl9tYXAsXG4gIFx0XHQgICAgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyLFxuICBcdFx0ICAgIGNlbnRlclBvaW50ID0gbWFwLmxhdExuZ1RvQ29udGFpbmVyUG9pbnQobWFwLmdldENlbnRlcigpKSxcbiAgXHRcdCAgICB0b29sdGlwUG9pbnQgPSBtYXAubGF5ZXJQb2ludFRvQ29udGFpbmVyUG9pbnQocG9zKSxcbiAgXHRcdCAgICBkaXJlY3Rpb24gPSB0aGlzLm9wdGlvbnMuZGlyZWN0aW9uLFxuICBcdFx0ICAgIHRvb2x0aXBXaWR0aCA9IGNvbnRhaW5lci5vZmZzZXRXaWR0aCxcbiAgXHRcdCAgICB0b29sdGlwSGVpZ2h0ID0gY29udGFpbmVyLm9mZnNldEhlaWdodCxcbiAgXHRcdCAgICBvZmZzZXQgPSB0b1BvaW50KHRoaXMub3B0aW9ucy5vZmZzZXQpLFxuICBcdFx0ICAgIGFuY2hvciA9IHRoaXMuX2dldEFuY2hvcigpO1xuXG4gIFx0XHRpZiAoZGlyZWN0aW9uID09PSAndG9wJykge1xuICBcdFx0XHRzdWJYID0gdG9vbHRpcFdpZHRoIC8gMjtcbiAgXHRcdFx0c3ViWSA9IHRvb2x0aXBIZWlnaHQ7XG4gIFx0XHR9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gJ2JvdHRvbScpIHtcbiAgXHRcdFx0c3ViWCA9IHRvb2x0aXBXaWR0aCAvIDI7XG4gIFx0XHRcdHN1YlkgPSAwO1xuICBcdFx0fSBlbHNlIGlmIChkaXJlY3Rpb24gPT09ICdjZW50ZXInKSB7XG4gIFx0XHRcdHN1YlggPSB0b29sdGlwV2lkdGggLyAyO1xuICBcdFx0XHRzdWJZID0gdG9vbHRpcEhlaWdodCAvIDI7XG4gIFx0XHR9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gJ3JpZ2h0Jykge1xuICBcdFx0XHRzdWJYID0gMDtcbiAgXHRcdFx0c3ViWSA9IHRvb2x0aXBIZWlnaHQgLyAyO1xuICBcdFx0fSBlbHNlIGlmIChkaXJlY3Rpb24gPT09ICdsZWZ0Jykge1xuICBcdFx0XHRzdWJYID0gdG9vbHRpcFdpZHRoO1xuICBcdFx0XHRzdWJZID0gdG9vbHRpcEhlaWdodCAvIDI7XG4gIFx0XHR9IGVsc2UgaWYgKHRvb2x0aXBQb2ludC54IDwgY2VudGVyUG9pbnQueCkge1xuICBcdFx0XHRkaXJlY3Rpb24gPSAncmlnaHQnO1xuICBcdFx0XHRzdWJYID0gMDtcbiAgXHRcdFx0c3ViWSA9IHRvb2x0aXBIZWlnaHQgLyAyO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0ZGlyZWN0aW9uID0gJ2xlZnQnO1xuICBcdFx0XHRzdWJYID0gdG9vbHRpcFdpZHRoICsgKG9mZnNldC54ICsgYW5jaG9yLngpICogMjtcbiAgXHRcdFx0c3ViWSA9IHRvb2x0aXBIZWlnaHQgLyAyO1xuICBcdFx0fVxuXG4gIFx0XHRwb3MgPSBwb3Muc3VidHJhY3QodG9Qb2ludChzdWJYLCBzdWJZLCB0cnVlKSkuYWRkKG9mZnNldCkuYWRkKGFuY2hvcik7XG5cbiAgXHRcdHJlbW92ZUNsYXNzKGNvbnRhaW5lciwgJ2xlYWZsZXQtdG9vbHRpcC1yaWdodCcpO1xuICBcdFx0cmVtb3ZlQ2xhc3MoY29udGFpbmVyLCAnbGVhZmxldC10b29sdGlwLWxlZnQnKTtcbiAgXHRcdHJlbW92ZUNsYXNzKGNvbnRhaW5lciwgJ2xlYWZsZXQtdG9vbHRpcC10b3AnKTtcbiAgXHRcdHJlbW92ZUNsYXNzKGNvbnRhaW5lciwgJ2xlYWZsZXQtdG9vbHRpcC1ib3R0b20nKTtcbiAgXHRcdGFkZENsYXNzKGNvbnRhaW5lciwgJ2xlYWZsZXQtdG9vbHRpcC0nICsgZGlyZWN0aW9uKTtcbiAgXHRcdHNldFBvc2l0aW9uKGNvbnRhaW5lciwgcG9zKTtcbiAgXHR9LFxuXG4gIFx0X3VwZGF0ZVBvc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgcG9zID0gdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcpO1xuICBcdFx0dGhpcy5fc2V0UG9zaXRpb24ocG9zKTtcbiAgXHR9LFxuXG4gIFx0c2V0T3BhY2l0eTogZnVuY3Rpb24gKG9wYWNpdHkpIHtcbiAgXHRcdHRoaXMub3B0aW9ucy5vcGFjaXR5ID0gb3BhY2l0eTtcblxuICBcdFx0aWYgKHRoaXMuX2NvbnRhaW5lcikge1xuICBcdFx0XHRzZXRPcGFjaXR5KHRoaXMuX2NvbnRhaW5lciwgb3BhY2l0eSk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF9hbmltYXRlWm9vbTogZnVuY3Rpb24gKGUpIHtcbiAgXHRcdHZhciBwb3MgPSB0aGlzLl9tYXAuX2xhdExuZ1RvTmV3TGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcsIGUuem9vbSwgZS5jZW50ZXIpO1xuICBcdFx0dGhpcy5fc2V0UG9zaXRpb24ocG9zKTtcbiAgXHR9LFxuXG4gIFx0X2dldEFuY2hvcjogZnVuY3Rpb24gKCkge1xuICBcdFx0Ly8gV2hlcmUgc2hvdWxkIHdlIGFuY2hvciB0aGUgdG9vbHRpcCBvbiB0aGUgc291cmNlIGxheWVyP1xuICBcdFx0cmV0dXJuIHRvUG9pbnQodGhpcy5fc291cmNlICYmIHRoaXMuX3NvdXJjZS5fZ2V0VG9vbHRpcEFuY2hvciAmJiAhdGhpcy5vcHRpb25zLnN0aWNreSA/IHRoaXMuX3NvdXJjZS5fZ2V0VG9vbHRpcEFuY2hvcigpIDogWzAsIDBdKTtcbiAgXHR9XG5cbiAgfSk7XG5cbiAgLy8gQG5hbWVzcGFjZSBUb29sdGlwXG4gIC8vIEBmYWN0b3J5IEwudG9vbHRpcChvcHRpb25zPzogVG9vbHRpcCBvcHRpb25zLCBzb3VyY2U/OiBMYXllcilcbiAgLy8gSW5zdGFudGlhdGVzIGEgVG9vbHRpcCBvYmplY3QgZ2l2ZW4gYW4gb3B0aW9uYWwgYG9wdGlvbnNgIG9iamVjdCB0aGF0IGRlc2NyaWJlcyBpdHMgYXBwZWFyYW5jZSBhbmQgbG9jYXRpb24gYW5kIGFuIG9wdGlvbmFsIGBzb3VyY2VgIG9iamVjdCB0aGF0IGlzIHVzZWQgdG8gdGFnIHRoZSB0b29sdGlwIHdpdGggYSByZWZlcmVuY2UgdG8gdGhlIExheWVyIHRvIHdoaWNoIGl0IHJlZmVycy5cbiAgdmFyIHRvb2x0aXAgPSBmdW5jdGlvbiAob3B0aW9ucywgc291cmNlKSB7XG4gIFx0cmV0dXJuIG5ldyBUb29sdGlwKG9wdGlvbnMsIHNvdXJjZSk7XG4gIH07XG5cbiAgLy8gQG5hbWVzcGFjZSBNYXBcbiAgLy8gQHNlY3Rpb24gTWV0aG9kcyBmb3IgTGF5ZXJzIGFuZCBDb250cm9sc1xuICBNYXAuaW5jbHVkZSh7XG5cbiAgXHQvLyBAbWV0aG9kIG9wZW5Ub29sdGlwKHRvb2x0aXA6IFRvb2x0aXApOiB0aGlzXG4gIFx0Ly8gT3BlbnMgdGhlIHNwZWNpZmllZCB0b29sdGlwLlxuICBcdC8vIEBhbHRlcm5hdGl2ZVxuICBcdC8vIEBtZXRob2Qgb3BlblRvb2x0aXAoY29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50LCBsYXRsbmc6IExhdExuZywgb3B0aW9ucz86IFRvb2x0aXAgb3B0aW9ucyk6IHRoaXNcbiAgXHQvLyBDcmVhdGVzIGEgdG9vbHRpcCB3aXRoIHRoZSBzcGVjaWZpZWQgY29udGVudCBhbmQgb3B0aW9ucyBhbmQgb3BlbiBpdC5cbiAgXHRvcGVuVG9vbHRpcDogZnVuY3Rpb24gKHRvb2x0aXAsIGxhdGxuZywgb3B0aW9ucykge1xuICBcdFx0aWYgKCEodG9vbHRpcCBpbnN0YW5jZW9mIFRvb2x0aXApKSB7XG4gIFx0XHRcdHRvb2x0aXAgPSBuZXcgVG9vbHRpcChvcHRpb25zKS5zZXRDb250ZW50KHRvb2x0aXApO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAobGF0bG5nKSB7XG4gIFx0XHRcdHRvb2x0aXAuc2V0TGF0TG5nKGxhdGxuZyk7XG4gIFx0XHR9XG5cbiAgXHRcdGlmICh0aGlzLmhhc0xheWVyKHRvb2x0aXApKSB7XG4gIFx0XHRcdHJldHVybiB0aGlzO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gdGhpcy5hZGRMYXllcih0b29sdGlwKTtcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCBjbG9zZVRvb2x0aXAodG9vbHRpcD86IFRvb2x0aXApOiB0aGlzXG4gIFx0Ly8gQ2xvc2VzIHRoZSB0b29sdGlwIGdpdmVuIGFzIHBhcmFtZXRlci5cbiAgXHRjbG9zZVRvb2x0aXA6IGZ1bmN0aW9uICh0b29sdGlwKSB7XG4gIFx0XHRpZiAodG9vbHRpcCkge1xuICBcdFx0XHR0aGlzLnJlbW92ZUxheWVyKHRvb2x0aXApO1xuICBcdFx0fVxuICBcdFx0cmV0dXJuIHRoaXM7XG4gIFx0fVxuXG4gIH0pO1xuXG4gIC8qXG4gICAqIEBuYW1lc3BhY2UgTGF5ZXJcbiAgICogQHNlY3Rpb24gVG9vbHRpcCBtZXRob2RzIGV4YW1wbGVcbiAgICpcbiAgICogQWxsIGxheWVycyBzaGFyZSBhIHNldCBvZiBtZXRob2RzIGNvbnZlbmllbnQgZm9yIGJpbmRpbmcgdG9vbHRpcHMgdG8gaXQuXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIHZhciBsYXllciA9IEwuUG9seWdvbihsYXRsbmdzKS5iaW5kVG9vbHRpcCgnSGkgVGhlcmUhJykuYWRkVG8obWFwKTtcbiAgICogbGF5ZXIub3BlblRvb2x0aXAoKTtcbiAgICogbGF5ZXIuY2xvc2VUb29sdGlwKCk7XG4gICAqIGBgYFxuICAgKi9cblxuICAvLyBAc2VjdGlvbiBUb29sdGlwIG1ldGhvZHNcbiAgTGF5ZXIuaW5jbHVkZSh7XG5cbiAgXHQvLyBAbWV0aG9kIGJpbmRUb29sdGlwKGNvbnRlbnQ6IFN0cmluZ3xIVE1MRWxlbWVudHxGdW5jdGlvbnxUb29sdGlwLCBvcHRpb25zPzogVG9vbHRpcCBvcHRpb25zKTogdGhpc1xuICBcdC8vIEJpbmRzIGEgdG9vbHRpcCB0byB0aGUgbGF5ZXIgd2l0aCB0aGUgcGFzc2VkIGBjb250ZW50YCBhbmQgc2V0cyB1cCB0aGVcbiAgXHQvLyBuZWNlc3NhcnkgZXZlbnQgbGlzdGVuZXJzLiBJZiBhIGBGdW5jdGlvbmAgaXMgcGFzc2VkIGl0IHdpbGwgcmVjZWl2ZVxuICBcdC8vIHRoZSBsYXllciBhcyB0aGUgZmlyc3QgYXJndW1lbnQgYW5kIHNob3VsZCByZXR1cm4gYSBgU3RyaW5nYCBvciBgSFRNTEVsZW1lbnRgLlxuICBcdGJpbmRUb29sdGlwOiBmdW5jdGlvbiAoY29udGVudCwgb3B0aW9ucykge1xuXG4gIFx0XHRpZiAoY29udGVudCBpbnN0YW5jZW9mIFRvb2x0aXApIHtcbiAgXHRcdFx0c2V0T3B0aW9ucyhjb250ZW50LCBvcHRpb25zKTtcbiAgXHRcdFx0dGhpcy5fdG9vbHRpcCA9IGNvbnRlbnQ7XG4gIFx0XHRcdGNvbnRlbnQuX3NvdXJjZSA9IHRoaXM7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRpZiAoIXRoaXMuX3Rvb2x0aXAgfHwgb3B0aW9ucykge1xuICBcdFx0XHRcdHRoaXMuX3Rvb2x0aXAgPSBuZXcgVG9vbHRpcChvcHRpb25zLCB0aGlzKTtcbiAgXHRcdFx0fVxuICBcdFx0XHR0aGlzLl90b29sdGlwLnNldENvbnRlbnQoY29udGVudCk7XG5cbiAgXHRcdH1cblxuICBcdFx0dGhpcy5faW5pdFRvb2x0aXBJbnRlcmFjdGlvbnMoKTtcblxuICBcdFx0aWYgKHRoaXMuX3Rvb2x0aXAub3B0aW9ucy5wZXJtYW5lbnQgJiYgdGhpcy5fbWFwICYmIHRoaXMuX21hcC5oYXNMYXllcih0aGlzKSkge1xuICBcdFx0XHR0aGlzLm9wZW5Ub29sdGlwKCk7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiB0aGlzO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIHVuYmluZFRvb2x0aXAoKTogdGhpc1xuICBcdC8vIFJlbW92ZXMgdGhlIHRvb2x0aXAgcHJldmlvdXNseSBib3VuZCB3aXRoIGBiaW5kVG9vbHRpcGAuXG4gIFx0dW5iaW5kVG9vbHRpcDogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKHRoaXMuX3Rvb2x0aXApIHtcbiAgXHRcdFx0dGhpcy5faW5pdFRvb2x0aXBJbnRlcmFjdGlvbnModHJ1ZSk7XG4gIFx0XHRcdHRoaXMuY2xvc2VUb29sdGlwKCk7XG4gIFx0XHRcdHRoaXMuX3Rvb2x0aXAgPSBudWxsO1xuICBcdFx0fVxuICBcdFx0cmV0dXJuIHRoaXM7XG4gIFx0fSxcblxuICBcdF9pbml0VG9vbHRpcEludGVyYWN0aW9uczogZnVuY3Rpb24gKHJlbW92ZSQkMSkge1xuICBcdFx0aWYgKCFyZW1vdmUkJDEgJiYgdGhpcy5fdG9vbHRpcEhhbmRsZXJzQWRkZWQpIHsgcmV0dXJuOyB9XG4gIFx0XHR2YXIgb25PZmYgPSByZW1vdmUkJDEgPyAnb2ZmJyA6ICdvbicsXG4gIFx0XHQgICAgZXZlbnRzID0ge1xuICBcdFx0XHRyZW1vdmU6IHRoaXMuY2xvc2VUb29sdGlwLFxuICBcdFx0XHRtb3ZlOiB0aGlzLl9tb3ZlVG9vbHRpcFxuICBcdFx0ICAgIH07XG4gIFx0XHRpZiAoIXRoaXMuX3Rvb2x0aXAub3B0aW9ucy5wZXJtYW5lbnQpIHtcbiAgXHRcdFx0ZXZlbnRzLm1vdXNlb3ZlciA9IHRoaXMuX29wZW5Ub29sdGlwO1xuICBcdFx0XHRldmVudHMubW91c2VvdXQgPSB0aGlzLmNsb3NlVG9vbHRpcDtcbiAgXHRcdFx0aWYgKHRoaXMuX3Rvb2x0aXAub3B0aW9ucy5zdGlja3kpIHtcbiAgXHRcdFx0XHRldmVudHMubW91c2Vtb3ZlID0gdGhpcy5fbW92ZVRvb2x0aXA7XG4gIFx0XHRcdH1cbiAgXHRcdFx0aWYgKHRvdWNoKSB7XG4gIFx0XHRcdFx0ZXZlbnRzLmNsaWNrID0gdGhpcy5fb3BlblRvb2x0aXA7XG4gIFx0XHRcdH1cbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdGV2ZW50cy5hZGQgPSB0aGlzLl9vcGVuVG9vbHRpcDtcbiAgXHRcdH1cbiAgXHRcdHRoaXNbb25PZmZdKGV2ZW50cyk7XG4gIFx0XHR0aGlzLl90b29sdGlwSGFuZGxlcnNBZGRlZCA9ICFyZW1vdmUkJDE7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2Qgb3BlblRvb2x0aXAobGF0bG5nPzogTGF0TG5nKTogdGhpc1xuICBcdC8vIE9wZW5zIHRoZSBib3VuZCB0b29sdGlwIGF0IHRoZSBzcGVjaWZpZWQgYGxhdGxuZ2Agb3IgYXQgdGhlIGRlZmF1bHQgdG9vbHRpcCBhbmNob3IgaWYgbm8gYGxhdGxuZ2AgaXMgcGFzc2VkLlxuICBcdG9wZW5Ub29sdGlwOiBmdW5jdGlvbiAobGF5ZXIsIGxhdGxuZykge1xuICBcdFx0aWYgKHRoaXMuX3Rvb2x0aXAgJiYgdGhpcy5fbWFwKSB7XG4gIFx0XHRcdGxhdGxuZyA9IHRoaXMuX3Rvb2x0aXAuX3ByZXBhcmVPcGVuKHRoaXMsIGxheWVyLCBsYXRsbmcpO1xuXG4gIFx0XHRcdC8vIG9wZW4gdGhlIHRvb2x0aXAgb24gdGhlIG1hcFxuICBcdFx0XHR0aGlzLl9tYXAub3BlblRvb2x0aXAodGhpcy5fdG9vbHRpcCwgbGF0bG5nKTtcblxuICBcdFx0XHQvLyBUb29sdGlwIGNvbnRhaW5lciBtYXkgbm90IGJlIGRlZmluZWQgaWYgbm90IHBlcm1hbmVudCBhbmQgbmV2ZXJcbiAgXHRcdFx0Ly8gb3BlbmVkLlxuICBcdFx0XHRpZiAodGhpcy5fdG9vbHRpcC5vcHRpb25zLmludGVyYWN0aXZlICYmIHRoaXMuX3Rvb2x0aXAuX2NvbnRhaW5lcikge1xuICBcdFx0XHRcdGFkZENsYXNzKHRoaXMuX3Rvb2x0aXAuX2NvbnRhaW5lciwgJ2xlYWZsZXQtY2xpY2thYmxlJyk7XG4gIFx0XHRcdFx0dGhpcy5hZGRJbnRlcmFjdGl2ZVRhcmdldCh0aGlzLl90b29sdGlwLl9jb250YWluZXIpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiB0aGlzO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIGNsb3NlVG9vbHRpcCgpOiB0aGlzXG4gIFx0Ly8gQ2xvc2VzIHRoZSB0b29sdGlwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgaWYgaXQgaXMgb3Blbi5cbiAgXHRjbG9zZVRvb2x0aXA6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICh0aGlzLl90b29sdGlwKSB7XG4gIFx0XHRcdHRoaXMuX3Rvb2x0aXAuX2Nsb3NlKCk7XG4gIFx0XHRcdGlmICh0aGlzLl90b29sdGlwLm9wdGlvbnMuaW50ZXJhY3RpdmUgJiYgdGhpcy5fdG9vbHRpcC5fY29udGFpbmVyKSB7XG4gIFx0XHRcdFx0cmVtb3ZlQ2xhc3ModGhpcy5fdG9vbHRpcC5fY29udGFpbmVyLCAnbGVhZmxldC1jbGlja2FibGUnKTtcbiAgXHRcdFx0XHR0aGlzLnJlbW92ZUludGVyYWN0aXZlVGFyZ2V0KHRoaXMuX3Rvb2x0aXAuX2NvbnRhaW5lcik7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHRcdHJldHVybiB0aGlzO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIHRvZ2dsZVRvb2x0aXAoKTogdGhpc1xuICBcdC8vIE9wZW5zIG9yIGNsb3NlcyB0aGUgdG9vbHRpcCBib3VuZCB0byB0aGlzIGxheWVyIGRlcGVuZGluZyBvbiBpdHMgY3VycmVudCBzdGF0ZS5cbiAgXHR0b2dnbGVUb29sdGlwOiBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gIFx0XHRpZiAodGhpcy5fdG9vbHRpcCkge1xuICBcdFx0XHRpZiAodGhpcy5fdG9vbHRpcC5fbWFwKSB7XG4gIFx0XHRcdFx0dGhpcy5jbG9zZVRvb2x0aXAoKTtcbiAgXHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHR0aGlzLm9wZW5Ub29sdGlwKHRhcmdldCk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHRcdHJldHVybiB0aGlzO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIGlzVG9vbHRpcE9wZW4oKTogYm9vbGVhblxuICBcdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSB0b29sdGlwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgaXMgY3VycmVudGx5IG9wZW4uXG4gIFx0aXNUb29sdGlwT3BlbjogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMuX3Rvb2x0aXAuaXNPcGVuKCk7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2Qgc2V0VG9vbHRpcENvbnRlbnQoY29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50fFRvb2x0aXApOiB0aGlzXG4gIFx0Ly8gU2V0cyB0aGUgY29udGVudCBvZiB0aGUgdG9vbHRpcCBib3VuZCB0byB0aGlzIGxheWVyLlxuICBcdHNldFRvb2x0aXBDb250ZW50OiBmdW5jdGlvbiAoY29udGVudCkge1xuICBcdFx0aWYgKHRoaXMuX3Rvb2x0aXApIHtcbiAgXHRcdFx0dGhpcy5fdG9vbHRpcC5zZXRDb250ZW50KGNvbnRlbnQpO1xuICBcdFx0fVxuICBcdFx0cmV0dXJuIHRoaXM7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2QgZ2V0VG9vbHRpcCgpOiBUb29sdGlwXG4gIFx0Ly8gUmV0dXJucyB0aGUgdG9vbHRpcCBib3VuZCB0byB0aGlzIGxheWVyLlxuICBcdGdldFRvb2x0aXA6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLl90b29sdGlwO1xuICBcdH0sXG5cbiAgXHRfb3BlblRvb2x0aXA6IGZ1bmN0aW9uIChlKSB7XG4gIFx0XHR2YXIgbGF5ZXIgPSBlLmxheWVyIHx8IGUudGFyZ2V0O1xuXG4gIFx0XHRpZiAoIXRoaXMuX3Rvb2x0aXAgfHwgIXRoaXMuX21hcCkge1xuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG4gIFx0XHR0aGlzLm9wZW5Ub29sdGlwKGxheWVyLCB0aGlzLl90b29sdGlwLm9wdGlvbnMuc3RpY2t5ID8gZS5sYXRsbmcgOiB1bmRlZmluZWQpO1xuICBcdH0sXG5cbiAgXHRfbW92ZVRvb2x0aXA6IGZ1bmN0aW9uIChlKSB7XG4gIFx0XHR2YXIgbGF0bG5nID0gZS5sYXRsbmcsIGNvbnRhaW5lclBvaW50LCBsYXllclBvaW50O1xuICBcdFx0aWYgKHRoaXMuX3Rvb2x0aXAub3B0aW9ucy5zdGlja3kgJiYgZS5vcmlnaW5hbEV2ZW50KSB7XG4gIFx0XHRcdGNvbnRhaW5lclBvaW50ID0gdGhpcy5fbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUub3JpZ2luYWxFdmVudCk7XG4gIFx0XHRcdGxheWVyUG9pbnQgPSB0aGlzLl9tYXAuY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQoY29udGFpbmVyUG9pbnQpO1xuICBcdFx0XHRsYXRsbmcgPSB0aGlzLl9tYXAubGF5ZXJQb2ludFRvTGF0TG5nKGxheWVyUG9pbnQpO1xuICBcdFx0fVxuICBcdFx0dGhpcy5fdG9vbHRpcC5zZXRMYXRMbmcobGF0bG5nKTtcbiAgXHR9XG4gIH0pO1xuXG4gIC8qXG4gICAqIEBjbGFzcyBEaXZJY29uXG4gICAqIEBha2EgTC5EaXZJY29uXG4gICAqIEBpbmhlcml0cyBJY29uXG4gICAqXG4gICAqIFJlcHJlc2VudHMgYSBsaWdodHdlaWdodCBpY29uIGZvciBtYXJrZXJzIHRoYXQgdXNlcyBhIHNpbXBsZSBgPGRpdj5gXG4gICAqIGVsZW1lbnQgaW5zdGVhZCBvZiBhbiBpbWFnZS4gSW5oZXJpdHMgZnJvbSBgSWNvbmAgYnV0IGlnbm9yZXMgdGhlIGBpY29uVXJsYCBhbmQgc2hhZG93IG9wdGlvbnMuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIHZhciBteUljb24gPSBMLmRpdkljb24oe2NsYXNzTmFtZTogJ215LWRpdi1pY29uJ30pO1xuICAgKiAvLyB5b3UgY2FuIHNldCAubXktZGl2LWljb24gc3R5bGVzIGluIENTU1xuICAgKlxuICAgKiBMLm1hcmtlcihbNTAuNTA1LCAzMC41N10sIHtpY29uOiBteUljb259KS5hZGRUbyhtYXApO1xuICAgKiBgYGBcbiAgICpcbiAgICogQnkgZGVmYXVsdCwgaXQgaGFzIGEgJ2xlYWZsZXQtZGl2LWljb24nIENTUyBjbGFzcyBhbmQgaXMgc3R5bGVkIGFzIGEgbGl0dGxlIHdoaXRlIHNxdWFyZSB3aXRoIGEgc2hhZG93LlxuICAgKi9cblxuICB2YXIgRGl2SWNvbiA9IEljb24uZXh0ZW5kKHtcbiAgXHRvcHRpb25zOiB7XG4gIFx0XHQvLyBAc2VjdGlvblxuICBcdFx0Ly8gQGFrYSBEaXZJY29uIG9wdGlvbnNcbiAgXHRcdGljb25TaXplOiBbMTIsIDEyXSwgLy8gYWxzbyBjYW4gYmUgc2V0IHRocm91Z2ggQ1NTXG5cbiAgXHRcdC8vIGljb25BbmNob3I6IChQb2ludCksXG4gIFx0XHQvLyBwb3B1cEFuY2hvcjogKFBvaW50KSxcblxuICBcdFx0Ly8gQG9wdGlvbiBodG1sOiBTdHJpbmd8SFRNTEVsZW1lbnQgPSAnJ1xuICBcdFx0Ly8gQ3VzdG9tIEhUTUwgY29kZSB0byBwdXQgaW5zaWRlIHRoZSBkaXYgZWxlbWVudCwgZW1wdHkgYnkgZGVmYXVsdC4gQWx0ZXJuYXRpdmVseSxcbiAgXHRcdC8vIGFuIGluc3RhbmNlIG9mIGBIVE1MRWxlbWVudGAuXG4gIFx0XHRodG1sOiBmYWxzZSxcblxuICBcdFx0Ly8gQG9wdGlvbiBiZ1BvczogUG9pbnQgPSBbMCwgMF1cbiAgXHRcdC8vIE9wdGlvbmFsIHJlbGF0aXZlIHBvc2l0aW9uIG9mIHRoZSBiYWNrZ3JvdW5kLCBpbiBwaXhlbHNcbiAgXHRcdGJnUG9zOiBudWxsLFxuXG4gIFx0XHRjbGFzc05hbWU6ICdsZWFmbGV0LWRpdi1pY29uJ1xuICBcdH0sXG5cbiAgXHRjcmVhdGVJY29uOiBmdW5jdGlvbiAob2xkSWNvbikge1xuICBcdFx0dmFyIGRpdiA9IChvbGRJY29uICYmIG9sZEljb24udGFnTmFtZSA9PT0gJ0RJVicpID8gb2xkSWNvbiA6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLFxuICBcdFx0ICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cbiAgXHRcdGlmIChvcHRpb25zLmh0bWwgaW5zdGFuY2VvZiBFbGVtZW50KSB7XG4gIFx0XHRcdGVtcHR5KGRpdik7XG4gIFx0XHRcdGRpdi5hcHBlbmRDaGlsZChvcHRpb25zLmh0bWwpO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0ZGl2LmlubmVySFRNTCA9IG9wdGlvbnMuaHRtbCAhPT0gZmFsc2UgPyBvcHRpb25zLmh0bWwgOiAnJztcbiAgXHRcdH1cblxuICBcdFx0aWYgKG9wdGlvbnMuYmdQb3MpIHtcbiAgXHRcdFx0dmFyIGJnUG9zID0gdG9Qb2ludChvcHRpb25zLmJnUG9zKTtcbiAgXHRcdFx0ZGl2LnN0eWxlLmJhY2tncm91bmRQb3NpdGlvbiA9ICgtYmdQb3MueCkgKyAncHggJyArICgtYmdQb3MueSkgKyAncHgnO1xuICBcdFx0fVxuICBcdFx0dGhpcy5fc2V0SWNvblN0eWxlcyhkaXYsICdpY29uJyk7XG5cbiAgXHRcdHJldHVybiBkaXY7XG4gIFx0fSxcblxuICBcdGNyZWF0ZVNoYWRvdzogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuICB9KTtcblxuICAvLyBAZmFjdG9yeSBMLmRpdkljb24ob3B0aW9uczogRGl2SWNvbiBvcHRpb25zKVxuICAvLyBDcmVhdGVzIGEgYERpdkljb25gIGluc3RhbmNlIHdpdGggdGhlIGdpdmVuIG9wdGlvbnMuXG4gIGZ1bmN0aW9uIGRpdkljb24ob3B0aW9ucykge1xuICBcdHJldHVybiBuZXcgRGl2SWNvbihvcHRpb25zKTtcbiAgfVxuXG4gIEljb24uRGVmYXVsdCA9IEljb25EZWZhdWx0O1xuXG4gIC8qXG4gICAqIEBjbGFzcyBHcmlkTGF5ZXJcbiAgICogQGluaGVyaXRzIExheWVyXG4gICAqIEBha2EgTC5HcmlkTGF5ZXJcbiAgICpcbiAgICogR2VuZXJpYyBjbGFzcyBmb3IgaGFuZGxpbmcgYSB0aWxlZCBncmlkIG9mIEhUTUwgZWxlbWVudHMuIFRoaXMgaXMgdGhlIGJhc2UgY2xhc3MgZm9yIGFsbCB0aWxlIGxheWVycyBhbmQgcmVwbGFjZXMgYFRpbGVMYXllci5DYW52YXNgLlxuICAgKiBHcmlkTGF5ZXIgY2FuIGJlIGV4dGVuZGVkIHRvIGNyZWF0ZSBhIHRpbGVkIGdyaWQgb2YgSFRNTCBlbGVtZW50cyBsaWtlIGA8Y2FudmFzPmAsIGA8aW1nPmAgb3IgYDxkaXY+YC4gR3JpZExheWVyIHdpbGwgaGFuZGxlIGNyZWF0aW5nIGFuZCBhbmltYXRpbmcgdGhlc2UgRE9NIGVsZW1lbnRzIGZvciB5b3UuXG4gICAqXG4gICAqXG4gICAqIEBzZWN0aW9uIFN5bmNocm9ub3VzIHVzYWdlXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIFRvIGNyZWF0ZSBhIGN1c3RvbSBsYXllciwgZXh0ZW5kIEdyaWRMYXllciBhbmQgaW1wbGVtZW50IHRoZSBgY3JlYXRlVGlsZSgpYCBtZXRob2QsIHdoaWNoIHdpbGwgYmUgcGFzc2VkIGEgYFBvaW50YCBvYmplY3Qgd2l0aCB0aGUgYHhgLCBgeWAsIGFuZCBgemAgKHpvb20gbGV2ZWwpIGNvb3JkaW5hdGVzIHRvIGRyYXcgeW91ciB0aWxlLlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiB2YXIgQ2FudmFzTGF5ZXIgPSBMLkdyaWRMYXllci5leHRlbmQoe1xuICAgKiAgICAgY3JlYXRlVGlsZTogZnVuY3Rpb24oY29vcmRzKXtcbiAgICogICAgICAgICAvLyBjcmVhdGUgYSA8Y2FudmFzPiBlbGVtZW50IGZvciBkcmF3aW5nXG4gICAqICAgICAgICAgdmFyIHRpbGUgPSBMLkRvbVV0aWwuY3JlYXRlKCdjYW52YXMnLCAnbGVhZmxldC10aWxlJyk7XG4gICAqXG4gICAqICAgICAgICAgLy8gc2V0dXAgdGlsZSB3aWR0aCBhbmQgaGVpZ2h0IGFjY29yZGluZyB0byB0aGUgb3B0aW9uc1xuICAgKiAgICAgICAgIHZhciBzaXplID0gdGhpcy5nZXRUaWxlU2l6ZSgpO1xuICAgKiAgICAgICAgIHRpbGUud2lkdGggPSBzaXplLng7XG4gICAqICAgICAgICAgdGlsZS5oZWlnaHQgPSBzaXplLnk7XG4gICAqXG4gICAqICAgICAgICAgLy8gZ2V0IGEgY2FudmFzIGNvbnRleHQgYW5kIGRyYXcgc29tZXRoaW5nIG9uIGl0IHVzaW5nIGNvb3Jkcy54LCBjb29yZHMueSBhbmQgY29vcmRzLnpcbiAgICogICAgICAgICB2YXIgY3R4ID0gdGlsZS5nZXRDb250ZXh0KCcyZCcpO1xuICAgKlxuICAgKiAgICAgICAgIC8vIHJldHVybiB0aGUgdGlsZSBzbyBpdCBjYW4gYmUgcmVuZGVyZWQgb24gc2NyZWVuXG4gICAqICAgICAgICAgcmV0dXJuIHRpbGU7XG4gICAqICAgICB9XG4gICAqIH0pO1xuICAgKiBgYGBcbiAgICpcbiAgICogQHNlY3Rpb24gQXN5bmNocm9ub3VzIHVzYWdlXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIFRpbGUgY3JlYXRpb24gY2FuIGFsc28gYmUgYXN5bmNocm9ub3VzLCB0aGlzIGlzIHVzZWZ1bCB3aGVuIHVzaW5nIGEgdGhpcmQtcGFydHkgZHJhd2luZyBsaWJyYXJ5LiBPbmNlIHRoZSB0aWxlIGlzIGZpbmlzaGVkIGRyYXdpbmcgaXQgY2FuIGJlIHBhc3NlZCB0byB0aGUgYGRvbmUoKWAgY2FsbGJhY2suXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIHZhciBDYW52YXNMYXllciA9IEwuR3JpZExheWVyLmV4dGVuZCh7XG4gICAqICAgICBjcmVhdGVUaWxlOiBmdW5jdGlvbihjb29yZHMsIGRvbmUpe1xuICAgKiAgICAgICAgIHZhciBlcnJvcjtcbiAgICpcbiAgICogICAgICAgICAvLyBjcmVhdGUgYSA8Y2FudmFzPiBlbGVtZW50IGZvciBkcmF3aW5nXG4gICAqICAgICAgICAgdmFyIHRpbGUgPSBMLkRvbVV0aWwuY3JlYXRlKCdjYW52YXMnLCAnbGVhZmxldC10aWxlJyk7XG4gICAqXG4gICAqICAgICAgICAgLy8gc2V0dXAgdGlsZSB3aWR0aCBhbmQgaGVpZ2h0IGFjY29yZGluZyB0byB0aGUgb3B0aW9uc1xuICAgKiAgICAgICAgIHZhciBzaXplID0gdGhpcy5nZXRUaWxlU2l6ZSgpO1xuICAgKiAgICAgICAgIHRpbGUud2lkdGggPSBzaXplLng7XG4gICAqICAgICAgICAgdGlsZS5oZWlnaHQgPSBzaXplLnk7XG4gICAqXG4gICAqICAgICAgICAgLy8gZHJhdyBzb21ldGhpbmcgYXN5bmNocm9ub3VzbHkgYW5kIHBhc3MgdGhlIHRpbGUgdG8gdGhlIGRvbmUoKSBjYWxsYmFja1xuICAgKiAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAqICAgICAgICAgICAgIGRvbmUoZXJyb3IsIHRpbGUpO1xuICAgKiAgICAgICAgIH0sIDEwMDApO1xuICAgKlxuICAgKiAgICAgICAgIHJldHVybiB0aWxlO1xuICAgKiAgICAgfVxuICAgKiB9KTtcbiAgICogYGBgXG4gICAqXG4gICAqIEBzZWN0aW9uXG4gICAqL1xuXG5cbiAgdmFyIEdyaWRMYXllciA9IExheWVyLmV4dGVuZCh7XG5cbiAgXHQvLyBAc2VjdGlvblxuICBcdC8vIEBha2EgR3JpZExheWVyIG9wdGlvbnNcbiAgXHRvcHRpb25zOiB7XG4gIFx0XHQvLyBAb3B0aW9uIHRpbGVTaXplOiBOdW1iZXJ8UG9pbnQgPSAyNTZcbiAgXHRcdC8vIFdpZHRoIGFuZCBoZWlnaHQgb2YgdGlsZXMgaW4gdGhlIGdyaWQuIFVzZSBhIG51bWJlciBpZiB3aWR0aCBhbmQgaGVpZ2h0IGFyZSBlcXVhbCwgb3IgYEwucG9pbnQod2lkdGgsIGhlaWdodClgIG90aGVyd2lzZS5cbiAgXHRcdHRpbGVTaXplOiAyNTYsXG5cbiAgXHRcdC8vIEBvcHRpb24gb3BhY2l0eTogTnVtYmVyID0gMS4wXG4gIFx0XHQvLyBPcGFjaXR5IG9mIHRoZSB0aWxlcy4gQ2FuIGJlIHVzZWQgaW4gdGhlIGBjcmVhdGVUaWxlKClgIGZ1bmN0aW9uLlxuICBcdFx0b3BhY2l0eTogMSxcblxuICBcdFx0Ly8gQG9wdGlvbiB1cGRhdGVXaGVuSWRsZTogQm9vbGVhbiA9IChkZXBlbmRzKVxuICBcdFx0Ly8gTG9hZCBuZXcgdGlsZXMgb25seSB3aGVuIHBhbm5pbmcgZW5kcy5cbiAgXHRcdC8vIGB0cnVlYCBieSBkZWZhdWx0IG9uIG1vYmlsZSBicm93c2VycywgaW4gb3JkZXIgdG8gYXZvaWQgdG9vIG1hbnkgcmVxdWVzdHMgYW5kIGtlZXAgc21vb3RoIG5hdmlnYXRpb24uXG4gIFx0XHQvLyBgZmFsc2VgIG90aGVyd2lzZSBpbiBvcmRlciB0byBkaXNwbGF5IG5ldyB0aWxlcyBfZHVyaW5nXyBwYW5uaW5nLCBzaW5jZSBpdCBpcyBlYXN5IHRvIHBhbiBvdXRzaWRlIHRoZVxuICBcdFx0Ly8gW2BrZWVwQnVmZmVyYF0oI2dyaWRsYXllci1rZWVwYnVmZmVyKSBvcHRpb24gaW4gZGVza3RvcCBicm93c2Vycy5cbiAgXHRcdHVwZGF0ZVdoZW5JZGxlOiBtb2JpbGUsXG5cbiAgXHRcdC8vIEBvcHRpb24gdXBkYXRlV2hlblpvb21pbmc6IEJvb2xlYW4gPSB0cnVlXG4gIFx0XHQvLyBCeSBkZWZhdWx0LCBhIHNtb290aCB6b29tIGFuaW1hdGlvbiAoZHVyaW5nIGEgW3RvdWNoIHpvb21dKCNtYXAtdG91Y2h6b29tKSBvciBhIFtgZmx5VG8oKWBdKCNtYXAtZmx5dG8pKSB3aWxsIHVwZGF0ZSBncmlkIGxheWVycyBldmVyeSBpbnRlZ2VyIHpvb20gbGV2ZWwuIFNldHRpbmcgdGhpcyBvcHRpb24gdG8gYGZhbHNlYCB3aWxsIHVwZGF0ZSB0aGUgZ3JpZCBsYXllciBvbmx5IHdoZW4gdGhlIHNtb290aCBhbmltYXRpb24gZW5kcy5cbiAgXHRcdHVwZGF0ZVdoZW5ab29taW5nOiB0cnVlLFxuXG4gIFx0XHQvLyBAb3B0aW9uIHVwZGF0ZUludGVydmFsOiBOdW1iZXIgPSAyMDBcbiAgXHRcdC8vIFRpbGVzIHdpbGwgbm90IHVwZGF0ZSBtb3JlIHRoYW4gb25jZSBldmVyeSBgdXBkYXRlSW50ZXJ2YWxgIG1pbGxpc2Vjb25kcyB3aGVuIHBhbm5pbmcuXG4gIFx0XHR1cGRhdGVJbnRlcnZhbDogMjAwLFxuXG4gIFx0XHQvLyBAb3B0aW9uIHpJbmRleDogTnVtYmVyID0gMVxuICBcdFx0Ly8gVGhlIGV4cGxpY2l0IHpJbmRleCBvZiB0aGUgdGlsZSBsYXllci5cbiAgXHRcdHpJbmRleDogMSxcblxuICBcdFx0Ly8gQG9wdGlvbiBib3VuZHM6IExhdExuZ0JvdW5kcyA9IHVuZGVmaW5lZFxuICBcdFx0Ly8gSWYgc2V0LCB0aWxlcyB3aWxsIG9ubHkgYmUgbG9hZGVkIGluc2lkZSB0aGUgc2V0IGBMYXRMbmdCb3VuZHNgLlxuICBcdFx0Ym91bmRzOiBudWxsLFxuXG4gIFx0XHQvLyBAb3B0aW9uIG1pblpvb206IE51bWJlciA9IDBcbiAgXHRcdC8vIFRoZSBtaW5pbXVtIHpvb20gbGV2ZWwgZG93biB0byB3aGljaCB0aGlzIGxheWVyIHdpbGwgYmUgZGlzcGxheWVkIChpbmNsdXNpdmUpLlxuICBcdFx0bWluWm9vbTogMCxcblxuICBcdFx0Ly8gQG9wdGlvbiBtYXhab29tOiBOdW1iZXIgPSB1bmRlZmluZWRcbiAgXHRcdC8vIFRoZSBtYXhpbXVtIHpvb20gbGV2ZWwgdXAgdG8gd2hpY2ggdGhpcyBsYXllciB3aWxsIGJlIGRpc3BsYXllZCAoaW5jbHVzaXZlKS5cbiAgXHRcdG1heFpvb206IHVuZGVmaW5lZCxcblxuICBcdFx0Ly8gQG9wdGlvbiBtYXhOYXRpdmVab29tOiBOdW1iZXIgPSB1bmRlZmluZWRcbiAgXHRcdC8vIE1heGltdW0gem9vbSBudW1iZXIgdGhlIHRpbGUgc291cmNlIGhhcyBhdmFpbGFibGUuIElmIGl0IGlzIHNwZWNpZmllZCxcbiAgXHRcdC8vIHRoZSB0aWxlcyBvbiBhbGwgem9vbSBsZXZlbHMgaGlnaGVyIHRoYW4gYG1heE5hdGl2ZVpvb21gIHdpbGwgYmUgbG9hZGVkXG4gIFx0XHQvLyBmcm9tIGBtYXhOYXRpdmVab29tYCBsZXZlbCBhbmQgYXV0by1zY2FsZWQuXG4gIFx0XHRtYXhOYXRpdmVab29tOiB1bmRlZmluZWQsXG5cbiAgXHRcdC8vIEBvcHRpb24gbWluTmF0aXZlWm9vbTogTnVtYmVyID0gdW5kZWZpbmVkXG4gIFx0XHQvLyBNaW5pbXVtIHpvb20gbnVtYmVyIHRoZSB0aWxlIHNvdXJjZSBoYXMgYXZhaWxhYmxlLiBJZiBpdCBpcyBzcGVjaWZpZWQsXG4gIFx0XHQvLyB0aGUgdGlsZXMgb24gYWxsIHpvb20gbGV2ZWxzIGxvd2VyIHRoYW4gYG1pbk5hdGl2ZVpvb21gIHdpbGwgYmUgbG9hZGVkXG4gIFx0XHQvLyBmcm9tIGBtaW5OYXRpdmVab29tYCBsZXZlbCBhbmQgYXV0by1zY2FsZWQuXG4gIFx0XHRtaW5OYXRpdmVab29tOiB1bmRlZmluZWQsXG5cbiAgXHRcdC8vIEBvcHRpb24gbm9XcmFwOiBCb29sZWFuID0gZmFsc2VcbiAgXHRcdC8vIFdoZXRoZXIgdGhlIGxheWVyIGlzIHdyYXBwZWQgYXJvdW5kIHRoZSBhbnRpbWVyaWRpYW4uIElmIGB0cnVlYCwgdGhlXG4gIFx0XHQvLyBHcmlkTGF5ZXIgd2lsbCBvbmx5IGJlIGRpc3BsYXllZCBvbmNlIGF0IGxvdyB6b29tIGxldmVscy4gSGFzIG5vXG4gIFx0XHQvLyBlZmZlY3Qgd2hlbiB0aGUgW21hcCBDUlNdKCNtYXAtY3JzKSBkb2Vzbid0IHdyYXAgYXJvdW5kLiBDYW4gYmUgdXNlZFxuICBcdFx0Ly8gaW4gY29tYmluYXRpb24gd2l0aCBbYGJvdW5kc2BdKCNncmlkbGF5ZXItYm91bmRzKSB0byBwcmV2ZW50IHJlcXVlc3RpbmdcbiAgXHRcdC8vIHRpbGVzIG91dHNpZGUgdGhlIENSUyBsaW1pdHMuXG4gIFx0XHRub1dyYXA6IGZhbHNlLFxuXG4gIFx0XHQvLyBAb3B0aW9uIHBhbmU6IFN0cmluZyA9ICd0aWxlUGFuZSdcbiAgXHRcdC8vIGBNYXAgcGFuZWAgd2hlcmUgdGhlIGdyaWQgbGF5ZXIgd2lsbCBiZSBhZGRlZC5cbiAgXHRcdHBhbmU6ICd0aWxlUGFuZScsXG5cbiAgXHRcdC8vIEBvcHRpb24gY2xhc3NOYW1lOiBTdHJpbmcgPSAnJ1xuICBcdFx0Ly8gQSBjdXN0b20gY2xhc3MgbmFtZSB0byBhc3NpZ24gdG8gdGhlIHRpbGUgbGF5ZXIuIEVtcHR5IGJ5IGRlZmF1bHQuXG4gIFx0XHRjbGFzc05hbWU6ICcnLFxuXG4gIFx0XHQvLyBAb3B0aW9uIGtlZXBCdWZmZXI6IE51bWJlciA9IDJcbiAgXHRcdC8vIFdoZW4gcGFubmluZyB0aGUgbWFwLCBrZWVwIHRoaXMgbWFueSByb3dzIGFuZCBjb2x1bW5zIG9mIHRpbGVzIGJlZm9yZSB1bmxvYWRpbmcgdGhlbS5cbiAgXHRcdGtlZXBCdWZmZXI6IDJcbiAgXHR9LFxuXG4gIFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgXHRcdHNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG4gIFx0fSxcblxuICBcdG9uQWRkOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLl9pbml0Q29udGFpbmVyKCk7XG5cbiAgXHRcdHRoaXMuX2xldmVscyA9IHt9O1xuICBcdFx0dGhpcy5fdGlsZXMgPSB7fTtcblxuICBcdFx0dGhpcy5fcmVzZXRWaWV3KCk7XG4gIFx0XHR0aGlzLl91cGRhdGUoKTtcbiAgXHR9LFxuXG4gIFx0YmVmb3JlQWRkOiBmdW5jdGlvbiAobWFwKSB7XG4gIFx0XHRtYXAuX2FkZFpvb21MaW1pdCh0aGlzKTtcbiAgXHR9LFxuXG4gIFx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcbiAgXHRcdHRoaXMuX3JlbW92ZUFsbFRpbGVzKCk7XG4gIFx0XHRyZW1vdmUodGhpcy5fY29udGFpbmVyKTtcbiAgXHRcdG1hcC5fcmVtb3ZlWm9vbUxpbWl0KHRoaXMpO1xuICBcdFx0dGhpcy5fY29udGFpbmVyID0gbnVsbDtcbiAgXHRcdHRoaXMuX3RpbGVab29tID0gdW5kZWZpbmVkO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIGJyaW5nVG9Gcm9udDogdGhpc1xuICBcdC8vIEJyaW5ncyB0aGUgdGlsZSBsYXllciB0byB0aGUgdG9wIG9mIGFsbCB0aWxlIGxheWVycy5cbiAgXHRicmluZ1RvRnJvbnQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICh0aGlzLl9tYXApIHtcbiAgXHRcdFx0dG9Gcm9udCh0aGlzLl9jb250YWluZXIpO1xuICBcdFx0XHR0aGlzLl9zZXRBdXRvWkluZGV4KE1hdGgubWF4KTtcbiAgXHRcdH1cbiAgXHRcdHJldHVybiB0aGlzO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIGJyaW5nVG9CYWNrOiB0aGlzXG4gIFx0Ly8gQnJpbmdzIHRoZSB0aWxlIGxheWVyIHRvIHRoZSBib3R0b20gb2YgYWxsIHRpbGUgbGF5ZXJzLlxuICBcdGJyaW5nVG9CYWNrOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAodGhpcy5fbWFwKSB7XG4gIFx0XHRcdHRvQmFjayh0aGlzLl9jb250YWluZXIpO1xuICBcdFx0XHR0aGlzLl9zZXRBdXRvWkluZGV4KE1hdGgubWluKTtcbiAgXHRcdH1cbiAgXHRcdHJldHVybiB0aGlzO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIGdldENvbnRhaW5lcjogSFRNTEVsZW1lbnRcbiAgXHQvLyBSZXR1cm5zIHRoZSBIVE1MIGVsZW1lbnQgdGhhdCBjb250YWlucyB0aGUgdGlsZXMgZm9yIHRoaXMgbGF5ZXIuXG4gIFx0Z2V0Q29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5fY29udGFpbmVyO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIHNldE9wYWNpdHkob3BhY2l0eTogTnVtYmVyKTogdGhpc1xuICBcdC8vIENoYW5nZXMgdGhlIFtvcGFjaXR5XSgjZ3JpZGxheWVyLW9wYWNpdHkpIG9mIHRoZSBncmlkIGxheWVyLlxuICBcdHNldE9wYWNpdHk6IGZ1bmN0aW9uIChvcGFjaXR5KSB7XG4gIFx0XHR0aGlzLm9wdGlvbnMub3BhY2l0eSA9IG9wYWNpdHk7XG4gIFx0XHR0aGlzLl91cGRhdGVPcGFjaXR5KCk7XG4gIFx0XHRyZXR1cm4gdGhpcztcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCBzZXRaSW5kZXgoekluZGV4OiBOdW1iZXIpOiB0aGlzXG4gIFx0Ly8gQ2hhbmdlcyB0aGUgW3pJbmRleF0oI2dyaWRsYXllci16aW5kZXgpIG9mIHRoZSBncmlkIGxheWVyLlxuICBcdHNldFpJbmRleDogZnVuY3Rpb24gKHpJbmRleCkge1xuICBcdFx0dGhpcy5vcHRpb25zLnpJbmRleCA9IHpJbmRleDtcbiAgXHRcdHRoaXMuX3VwZGF0ZVpJbmRleCgpO1xuXG4gIFx0XHRyZXR1cm4gdGhpcztcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCBpc0xvYWRpbmc6IEJvb2xlYW5cbiAgXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiBhbnkgdGlsZSBpbiB0aGUgZ3JpZCBsYXllciBoYXMgbm90IGZpbmlzaGVkIGxvYWRpbmcuXG4gIFx0aXNMb2FkaW5nOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5fbG9hZGluZztcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCByZWRyYXc6IHRoaXNcbiAgXHQvLyBDYXVzZXMgdGhlIGxheWVyIHRvIGNsZWFyIGFsbCB0aGUgdGlsZXMgYW5kIHJlcXVlc3QgdGhlbSBhZ2Fpbi5cbiAgXHRyZWRyYXc6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICh0aGlzLl9tYXApIHtcbiAgXHRcdFx0dGhpcy5fcmVtb3ZlQWxsVGlsZXMoKTtcbiAgXHRcdFx0dGhpcy5fdXBkYXRlKCk7XG4gIFx0XHR9XG4gIFx0XHRyZXR1cm4gdGhpcztcbiAgXHR9LFxuXG4gIFx0Z2V0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgZXZlbnRzID0ge1xuICBcdFx0XHR2aWV3cHJlcmVzZXQ6IHRoaXMuX2ludmFsaWRhdGVBbGwsXG4gIFx0XHRcdHZpZXdyZXNldDogdGhpcy5fcmVzZXRWaWV3LFxuICBcdFx0XHR6b29tOiB0aGlzLl9yZXNldFZpZXcsXG4gIFx0XHRcdG1vdmVlbmQ6IHRoaXMuX29uTW92ZUVuZFxuICBcdFx0fTtcblxuICBcdFx0aWYgKCF0aGlzLm9wdGlvbnMudXBkYXRlV2hlbklkbGUpIHtcbiAgXHRcdFx0Ly8gdXBkYXRlIHRpbGVzIG9uIG1vdmUsIGJ1dCBub3QgbW9yZSBvZnRlbiB0aGFuIG9uY2UgcGVyIGdpdmVuIGludGVydmFsXG4gIFx0XHRcdGlmICghdGhpcy5fb25Nb3ZlKSB7XG4gIFx0XHRcdFx0dGhpcy5fb25Nb3ZlID0gdGhyb3R0bGUodGhpcy5fb25Nb3ZlRW5kLCB0aGlzLm9wdGlvbnMudXBkYXRlSW50ZXJ2YWwsIHRoaXMpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0ZXZlbnRzLm1vdmUgPSB0aGlzLl9vbk1vdmU7XG4gIFx0XHR9XG5cbiAgXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcbiAgXHRcdFx0ZXZlbnRzLnpvb21hbmltID0gdGhpcy5fYW5pbWF0ZVpvb207XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiBldmVudHM7XG4gIFx0fSxcblxuICBcdC8vIEBzZWN0aW9uIEV4dGVuc2lvbiBtZXRob2RzXG4gIFx0Ly8gTGF5ZXJzIGV4dGVuZGluZyBgR3JpZExheWVyYCBzaGFsbCByZWltcGxlbWVudCB0aGUgZm9sbG93aW5nIG1ldGhvZC5cbiAgXHQvLyBAbWV0aG9kIGNyZWF0ZVRpbGUoY29vcmRzOiBPYmplY3QsIGRvbmU/OiBGdW5jdGlvbik6IEhUTUxFbGVtZW50XG4gIFx0Ly8gQ2FsbGVkIG9ubHkgaW50ZXJuYWxseSwgbXVzdCBiZSBvdmVycmlkZGVuIGJ5IGNsYXNzZXMgZXh0ZW5kaW5nIGBHcmlkTGF5ZXJgLlxuICBcdC8vIFJldHVybnMgdGhlIGBIVE1MRWxlbWVudGAgY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW4gYGNvb3Jkc2AuIElmIHRoZSBgZG9uZWAgY2FsbGJhY2tcbiAgXHQvLyBpcyBzcGVjaWZpZWQsIGl0IG11c3QgYmUgY2FsbGVkIHdoZW4gdGhlIHRpbGUgaGFzIGZpbmlzaGVkIGxvYWRpbmcgYW5kIGRyYXdpbmcuXG4gIFx0Y3JlYXRlVGlsZTogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBcdH0sXG5cbiAgXHQvLyBAc2VjdGlvblxuICBcdC8vIEBtZXRob2QgZ2V0VGlsZVNpemU6IFBvaW50XG4gIFx0Ly8gTm9ybWFsaXplcyB0aGUgW3RpbGVTaXplIG9wdGlvbl0oI2dyaWRsYXllci10aWxlc2l6ZSkgaW50byBhIHBvaW50LiBVc2VkIGJ5IHRoZSBgY3JlYXRlVGlsZSgpYCBtZXRob2QuXG4gIFx0Z2V0VGlsZVNpemU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBzID0gdGhpcy5vcHRpb25zLnRpbGVTaXplO1xuICBcdFx0cmV0dXJuIHMgaW5zdGFuY2VvZiBQb2ludCA/IHMgOiBuZXcgUG9pbnQocywgcyk7XG4gIFx0fSxcblxuICBcdF91cGRhdGVaSW5kZXg6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICh0aGlzLl9jb250YWluZXIgJiYgdGhpcy5vcHRpb25zLnpJbmRleCAhPT0gdW5kZWZpbmVkICYmIHRoaXMub3B0aW9ucy56SW5kZXggIT09IG51bGwpIHtcbiAgXHRcdFx0dGhpcy5fY29udGFpbmVyLnN0eWxlLnpJbmRleCA9IHRoaXMub3B0aW9ucy56SW5kZXg7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF9zZXRBdXRvWkluZGV4OiBmdW5jdGlvbiAoY29tcGFyZSkge1xuICBcdFx0Ly8gZ28gdGhyb3VnaCBhbGwgb3RoZXIgbGF5ZXJzIG9mIHRoZSBzYW1lIHBhbmUsIHNldCB6SW5kZXggdG8gbWF4ICsgMSAoZnJvbnQpIG9yIG1pbiAtIDEgKGJhY2spXG5cbiAgXHRcdHZhciBsYXllcnMgPSB0aGlzLmdldFBhbmUoKS5jaGlsZHJlbixcbiAgXHRcdCAgICBlZGdlWkluZGV4ID0gLWNvbXBhcmUoLUluZmluaXR5LCBJbmZpbml0eSk7IC8vIC1JbmZpbml0eSBmb3IgbWF4LCBJbmZpbml0eSBmb3IgbWluXG5cbiAgXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBsYXllcnMubGVuZ3RoLCB6SW5kZXg7IGkgPCBsZW47IGkrKykge1xuXG4gIFx0XHRcdHpJbmRleCA9IGxheWVyc1tpXS5zdHlsZS56SW5kZXg7XG5cbiAgXHRcdFx0aWYgKGxheWVyc1tpXSAhPT0gdGhpcy5fY29udGFpbmVyICYmIHpJbmRleCkge1xuICBcdFx0XHRcdGVkZ2VaSW5kZXggPSBjb21wYXJlKGVkZ2VaSW5kZXgsICt6SW5kZXgpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdGlmIChpc0Zpbml0ZShlZGdlWkluZGV4KSkge1xuICBcdFx0XHR0aGlzLm9wdGlvbnMuekluZGV4ID0gZWRnZVpJbmRleCArIGNvbXBhcmUoLTEsIDEpO1xuICBcdFx0XHR0aGlzLl91cGRhdGVaSW5kZXgoKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X3VwZGF0ZU9wYWNpdHk6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICghdGhpcy5fbWFwKSB7IHJldHVybjsgfVxuXG4gIFx0XHQvLyBJRSBkb2Vzbid0IGluaGVyaXQgZmlsdGVyIG9wYWNpdHkgcHJvcGVybHksIHNvIHdlJ3JlIGZvcmNlZCB0byBzZXQgaXQgb24gdGlsZXNcbiAgXHRcdGlmIChpZWx0OSkgeyByZXR1cm47IH1cblxuICBcdFx0c2V0T3BhY2l0eSh0aGlzLl9jb250YWluZXIsIHRoaXMub3B0aW9ucy5vcGFjaXR5KTtcblxuICBcdFx0dmFyIG5vdyA9ICtuZXcgRGF0ZSgpLFxuICBcdFx0ICAgIG5leHRGcmFtZSA9IGZhbHNlLFxuICBcdFx0ICAgIHdpbGxQcnVuZSA9IGZhbHNlO1xuXG4gIFx0XHRmb3IgKHZhciBrZXkgaW4gdGhpcy5fdGlsZXMpIHtcbiAgXHRcdFx0dmFyIHRpbGUgPSB0aGlzLl90aWxlc1trZXldO1xuICBcdFx0XHRpZiAoIXRpbGUuY3VycmVudCB8fCAhdGlsZS5sb2FkZWQpIHsgY29udGludWU7IH1cblxuICBcdFx0XHR2YXIgZmFkZSA9IE1hdGgubWluKDEsIChub3cgLSB0aWxlLmxvYWRlZCkgLyAyMDApO1xuXG4gIFx0XHRcdHNldE9wYWNpdHkodGlsZS5lbCwgZmFkZSk7XG4gIFx0XHRcdGlmIChmYWRlIDwgMSkge1xuICBcdFx0XHRcdG5leHRGcmFtZSA9IHRydWU7XG4gIFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0aWYgKHRpbGUuYWN0aXZlKSB7XG4gIFx0XHRcdFx0XHR3aWxsUHJ1bmUgPSB0cnVlO1xuICBcdFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0XHR0aGlzLl9vbk9wYXF1ZVRpbGUodGlsZSk7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHRcdHRpbGUuYWN0aXZlID0gdHJ1ZTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHRpZiAod2lsbFBydW5lICYmICF0aGlzLl9ub1BydW5lKSB7IHRoaXMuX3BydW5lVGlsZXMoKTsgfVxuXG4gIFx0XHRpZiAobmV4dEZyYW1lKSB7XG4gIFx0XHRcdGNhbmNlbEFuaW1GcmFtZSh0aGlzLl9mYWRlRnJhbWUpO1xuICBcdFx0XHR0aGlzLl9mYWRlRnJhbWUgPSByZXF1ZXN0QW5pbUZyYW1lKHRoaXMuX3VwZGF0ZU9wYWNpdHksIHRoaXMpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfb25PcGFxdWVUaWxlOiBmYWxzZUZuLFxuXG4gIFx0X2luaXRDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICh0aGlzLl9jb250YWluZXIpIHsgcmV0dXJuOyB9XG5cbiAgXHRcdHRoaXMuX2NvbnRhaW5lciA9IGNyZWF0ZSQxKCdkaXYnLCAnbGVhZmxldC1sYXllciAnICsgKHRoaXMub3B0aW9ucy5jbGFzc05hbWUgfHwgJycpKTtcbiAgXHRcdHRoaXMuX3VwZGF0ZVpJbmRleCgpO1xuXG4gIFx0XHRpZiAodGhpcy5vcHRpb25zLm9wYWNpdHkgPCAxKSB7XG4gIFx0XHRcdHRoaXMuX3VwZGF0ZU9wYWNpdHkoKTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5nZXRQYW5lKCkuYXBwZW5kQ2hpbGQodGhpcy5fY29udGFpbmVyKTtcbiAgXHR9LFxuXG4gIFx0X3VwZGF0ZUxldmVsczogZnVuY3Rpb24gKCkge1xuXG4gIFx0XHR2YXIgem9vbSA9IHRoaXMuX3RpbGVab29tLFxuICBcdFx0ICAgIG1heFpvb20gPSB0aGlzLm9wdGlvbnMubWF4Wm9vbTtcblxuICBcdFx0aWYgKHpvb20gPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG5cbiAgXHRcdGZvciAodmFyIHogaW4gdGhpcy5fbGV2ZWxzKSB7XG4gIFx0XHRcdHogPSBOdW1iZXIoeik7XG4gIFx0XHRcdGlmICh0aGlzLl9sZXZlbHNbel0uZWwuY2hpbGRyZW4ubGVuZ3RoIHx8IHogPT09IHpvb20pIHtcbiAgXHRcdFx0XHR0aGlzLl9sZXZlbHNbel0uZWwuc3R5bGUuekluZGV4ID0gbWF4Wm9vbSAtIE1hdGguYWJzKHpvb20gLSB6KTtcbiAgXHRcdFx0XHR0aGlzLl9vblVwZGF0ZUxldmVsKHopO1xuICBcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdHJlbW92ZSh0aGlzLl9sZXZlbHNbel0uZWwpO1xuICBcdFx0XHRcdHRoaXMuX3JlbW92ZVRpbGVzQXRab29tKHopO1xuICBcdFx0XHRcdHRoaXMuX29uUmVtb3ZlTGV2ZWwoeik7XG4gIFx0XHRcdFx0ZGVsZXRlIHRoaXMuX2xldmVsc1t6XTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHR2YXIgbGV2ZWwgPSB0aGlzLl9sZXZlbHNbem9vbV0sXG4gIFx0XHQgICAgbWFwID0gdGhpcy5fbWFwO1xuXG4gIFx0XHRpZiAoIWxldmVsKSB7XG4gIFx0XHRcdGxldmVsID0gdGhpcy5fbGV2ZWxzW3pvb21dID0ge307XG5cbiAgXHRcdFx0bGV2ZWwuZWwgPSBjcmVhdGUkMSgnZGl2JywgJ2xlYWZsZXQtdGlsZS1jb250YWluZXIgbGVhZmxldC16b29tLWFuaW1hdGVkJywgdGhpcy5fY29udGFpbmVyKTtcbiAgXHRcdFx0bGV2ZWwuZWwuc3R5bGUuekluZGV4ID0gbWF4Wm9vbTtcblxuICBcdFx0XHRsZXZlbC5vcmlnaW4gPSBtYXAucHJvamVjdChtYXAudW5wcm9qZWN0KG1hcC5nZXRQaXhlbE9yaWdpbigpKSwgem9vbSkucm91bmQoKTtcbiAgXHRcdFx0bGV2ZWwuem9vbSA9IHpvb207XG5cbiAgXHRcdFx0dGhpcy5fc2V0Wm9vbVRyYW5zZm9ybShsZXZlbCwgbWFwLmdldENlbnRlcigpLCBtYXAuZ2V0Wm9vbSgpKTtcblxuICBcdFx0XHQvLyBmb3JjZSB0aGUgYnJvd3NlciB0byBjb25zaWRlciB0aGUgbmV3bHkgYWRkZWQgZWxlbWVudCBmb3IgdHJhbnNpdGlvblxuICBcdFx0XHRmYWxzZUZuKGxldmVsLmVsLm9mZnNldFdpZHRoKTtcblxuICBcdFx0XHR0aGlzLl9vbkNyZWF0ZUxldmVsKGxldmVsKTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5fbGV2ZWwgPSBsZXZlbDtcblxuICBcdFx0cmV0dXJuIGxldmVsO1xuICBcdH0sXG5cbiAgXHRfb25VcGRhdGVMZXZlbDogZmFsc2VGbixcblxuICBcdF9vblJlbW92ZUxldmVsOiBmYWxzZUZuLFxuXG4gIFx0X29uQ3JlYXRlTGV2ZWw6IGZhbHNlRm4sXG5cbiAgXHRfcHJ1bmVUaWxlczogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKCF0aGlzLl9tYXApIHtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHR2YXIga2V5LCB0aWxlO1xuXG4gIFx0XHR2YXIgem9vbSA9IHRoaXMuX21hcC5nZXRab29tKCk7XG4gIFx0XHRpZiAoem9vbSA+IHRoaXMub3B0aW9ucy5tYXhab29tIHx8XG4gIFx0XHRcdHpvb20gPCB0aGlzLm9wdGlvbnMubWluWm9vbSkge1xuICBcdFx0XHR0aGlzLl9yZW1vdmVBbGxUaWxlcygpO1xuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdGZvciAoa2V5IGluIHRoaXMuX3RpbGVzKSB7XG4gIFx0XHRcdHRpbGUgPSB0aGlzLl90aWxlc1trZXldO1xuICBcdFx0XHR0aWxlLnJldGFpbiA9IHRpbGUuY3VycmVudDtcbiAgXHRcdH1cblxuICBcdFx0Zm9yIChrZXkgaW4gdGhpcy5fdGlsZXMpIHtcbiAgXHRcdFx0dGlsZSA9IHRoaXMuX3RpbGVzW2tleV07XG4gIFx0XHRcdGlmICh0aWxlLmN1cnJlbnQgJiYgIXRpbGUuYWN0aXZlKSB7XG4gIFx0XHRcdFx0dmFyIGNvb3JkcyA9IHRpbGUuY29vcmRzO1xuICBcdFx0XHRcdGlmICghdGhpcy5fcmV0YWluUGFyZW50KGNvb3Jkcy54LCBjb29yZHMueSwgY29vcmRzLnosIGNvb3Jkcy56IC0gNSkpIHtcbiAgXHRcdFx0XHRcdHRoaXMuX3JldGFpbkNoaWxkcmVuKGNvb3Jkcy54LCBjb29yZHMueSwgY29vcmRzLnosIGNvb3Jkcy56ICsgMik7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdGZvciAoa2V5IGluIHRoaXMuX3RpbGVzKSB7XG4gIFx0XHRcdGlmICghdGhpcy5fdGlsZXNba2V5XS5yZXRhaW4pIHtcbiAgXHRcdFx0XHR0aGlzLl9yZW1vdmVUaWxlKGtleSk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X3JlbW92ZVRpbGVzQXRab29tOiBmdW5jdGlvbiAoem9vbSkge1xuICBcdFx0Zm9yICh2YXIga2V5IGluIHRoaXMuX3RpbGVzKSB7XG4gIFx0XHRcdGlmICh0aGlzLl90aWxlc1trZXldLmNvb3Jkcy56ICE9PSB6b29tKSB7XG4gIFx0XHRcdFx0Y29udGludWU7XG4gIFx0XHRcdH1cbiAgXHRcdFx0dGhpcy5fcmVtb3ZlVGlsZShrZXkpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfcmVtb3ZlQWxsVGlsZXM6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGZvciAodmFyIGtleSBpbiB0aGlzLl90aWxlcykge1xuICBcdFx0XHR0aGlzLl9yZW1vdmVUaWxlKGtleSk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF9pbnZhbGlkYXRlQWxsOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRmb3IgKHZhciB6IGluIHRoaXMuX2xldmVscykge1xuICBcdFx0XHRyZW1vdmUodGhpcy5fbGV2ZWxzW3pdLmVsKTtcbiAgXHRcdFx0dGhpcy5fb25SZW1vdmVMZXZlbChOdW1iZXIoeikpO1xuICBcdFx0XHRkZWxldGUgdGhpcy5fbGV2ZWxzW3pdO1xuICBcdFx0fVxuICBcdFx0dGhpcy5fcmVtb3ZlQWxsVGlsZXMoKTtcblxuICBcdFx0dGhpcy5fdGlsZVpvb20gPSB1bmRlZmluZWQ7XG4gIFx0fSxcblxuICBcdF9yZXRhaW5QYXJlbnQ6IGZ1bmN0aW9uICh4LCB5LCB6LCBtaW5ab29tKSB7XG4gIFx0XHR2YXIgeDIgPSBNYXRoLmZsb29yKHggLyAyKSxcbiAgXHRcdCAgICB5MiA9IE1hdGguZmxvb3IoeSAvIDIpLFxuICBcdFx0ICAgIHoyID0geiAtIDEsXG4gIFx0XHQgICAgY29vcmRzMiA9IG5ldyBQb2ludCgreDIsICt5Mik7XG4gIFx0XHRjb29yZHMyLnogPSArejI7XG5cbiAgXHRcdHZhciBrZXkgPSB0aGlzLl90aWxlQ29vcmRzVG9LZXkoY29vcmRzMiksXG4gIFx0XHQgICAgdGlsZSA9IHRoaXMuX3RpbGVzW2tleV07XG5cbiAgXHRcdGlmICh0aWxlICYmIHRpbGUuYWN0aXZlKSB7XG4gIFx0XHRcdHRpbGUucmV0YWluID0gdHJ1ZTtcbiAgXHRcdFx0cmV0dXJuIHRydWU7XG5cbiAgXHRcdH0gZWxzZSBpZiAodGlsZSAmJiB0aWxlLmxvYWRlZCkge1xuICBcdFx0XHR0aWxlLnJldGFpbiA9IHRydWU7XG4gIFx0XHR9XG5cbiAgXHRcdGlmICh6MiA+IG1pblpvb20pIHtcbiAgXHRcdFx0cmV0dXJuIHRoaXMuX3JldGFpblBhcmVudCh4MiwgeTIsIHoyLCBtaW5ab29tKTtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIGZhbHNlO1xuICBcdH0sXG5cbiAgXHRfcmV0YWluQ2hpbGRyZW46IGZ1bmN0aW9uICh4LCB5LCB6LCBtYXhab29tKSB7XG5cbiAgXHRcdGZvciAodmFyIGkgPSAyICogeDsgaSA8IDIgKiB4ICsgMjsgaSsrKSB7XG4gIFx0XHRcdGZvciAodmFyIGogPSAyICogeTsgaiA8IDIgKiB5ICsgMjsgaisrKSB7XG5cbiAgXHRcdFx0XHR2YXIgY29vcmRzID0gbmV3IFBvaW50KGksIGopO1xuICBcdFx0XHRcdGNvb3Jkcy56ID0geiArIDE7XG5cbiAgXHRcdFx0XHR2YXIga2V5ID0gdGhpcy5fdGlsZUNvb3Jkc1RvS2V5KGNvb3JkcyksXG4gIFx0XHRcdFx0ICAgIHRpbGUgPSB0aGlzLl90aWxlc1trZXldO1xuXG4gIFx0XHRcdFx0aWYgKHRpbGUgJiYgdGlsZS5hY3RpdmUpIHtcbiAgXHRcdFx0XHRcdHRpbGUucmV0YWluID0gdHJ1ZTtcbiAgXHRcdFx0XHRcdGNvbnRpbnVlO1xuXG4gIFx0XHRcdFx0fSBlbHNlIGlmICh0aWxlICYmIHRpbGUubG9hZGVkKSB7XG4gIFx0XHRcdFx0XHR0aWxlLnJldGFpbiA9IHRydWU7XG4gIFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0aWYgKHogKyAxIDwgbWF4Wm9vbSkge1xuICBcdFx0XHRcdFx0dGhpcy5fcmV0YWluQ2hpbGRyZW4oaSwgaiwgeiArIDEsIG1heFpvb20pO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfcmVzZXRWaWV3OiBmdW5jdGlvbiAoZSkge1xuICBcdFx0dmFyIGFuaW1hdGluZyA9IGUgJiYgKGUucGluY2ggfHwgZS5mbHlUbyk7XG4gIFx0XHR0aGlzLl9zZXRWaWV3KHRoaXMuX21hcC5nZXRDZW50ZXIoKSwgdGhpcy5fbWFwLmdldFpvb20oKSwgYW5pbWF0aW5nLCBhbmltYXRpbmcpO1xuICBcdH0sXG5cbiAgXHRfYW5pbWF0ZVpvb206IGZ1bmN0aW9uIChlKSB7XG4gIFx0XHR0aGlzLl9zZXRWaWV3KGUuY2VudGVyLCBlLnpvb20sIHRydWUsIGUubm9VcGRhdGUpO1xuICBcdH0sXG5cbiAgXHRfY2xhbXBab29tOiBmdW5jdGlvbiAoem9vbSkge1xuICBcdFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cbiAgXHRcdGlmICh1bmRlZmluZWQgIT09IG9wdGlvbnMubWluTmF0aXZlWm9vbSAmJiB6b29tIDwgb3B0aW9ucy5taW5OYXRpdmVab29tKSB7XG4gIFx0XHRcdHJldHVybiBvcHRpb25zLm1pbk5hdGl2ZVpvb207XG4gIFx0XHR9XG5cbiAgXHRcdGlmICh1bmRlZmluZWQgIT09IG9wdGlvbnMubWF4TmF0aXZlWm9vbSAmJiBvcHRpb25zLm1heE5hdGl2ZVpvb20gPCB6b29tKSB7XG4gIFx0XHRcdHJldHVybiBvcHRpb25zLm1heE5hdGl2ZVpvb207XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiB6b29tO1xuICBcdH0sXG5cbiAgXHRfc2V0VmlldzogZnVuY3Rpb24gKGNlbnRlciwgem9vbSwgbm9QcnVuZSwgbm9VcGRhdGUpIHtcbiAgXHRcdHZhciB0aWxlWm9vbSA9IE1hdGgucm91bmQoem9vbSk7XG4gIFx0XHRpZiAoKHRoaXMub3B0aW9ucy5tYXhab29tICE9PSB1bmRlZmluZWQgJiYgdGlsZVpvb20gPiB0aGlzLm9wdGlvbnMubWF4Wm9vbSkgfHxcbiAgXHRcdCAgICAodGhpcy5vcHRpb25zLm1pblpvb20gIT09IHVuZGVmaW5lZCAmJiB0aWxlWm9vbSA8IHRoaXMub3B0aW9ucy5taW5ab29tKSkge1xuICBcdFx0XHR0aWxlWm9vbSA9IHVuZGVmaW5lZDtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHRpbGVab29tID0gdGhpcy5fY2xhbXBab29tKHRpbGVab29tKTtcbiAgXHRcdH1cblxuICBcdFx0dmFyIHRpbGVab29tQ2hhbmdlZCA9IHRoaXMub3B0aW9ucy51cGRhdGVXaGVuWm9vbWluZyAmJiAodGlsZVpvb20gIT09IHRoaXMuX3RpbGVab29tKTtcblxuICBcdFx0aWYgKCFub1VwZGF0ZSB8fCB0aWxlWm9vbUNoYW5nZWQpIHtcblxuICBcdFx0XHR0aGlzLl90aWxlWm9vbSA9IHRpbGVab29tO1xuXG4gIFx0XHRcdGlmICh0aGlzLl9hYm9ydExvYWRpbmcpIHtcbiAgXHRcdFx0XHR0aGlzLl9hYm9ydExvYWRpbmcoKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHRoaXMuX3VwZGF0ZUxldmVscygpO1xuICBcdFx0XHR0aGlzLl9yZXNldEdyaWQoKTtcblxuICBcdFx0XHRpZiAodGlsZVpvb20gIT09IHVuZGVmaW5lZCkge1xuICBcdFx0XHRcdHRoaXMuX3VwZGF0ZShjZW50ZXIpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0aWYgKCFub1BydW5lKSB7XG4gIFx0XHRcdFx0dGhpcy5fcHJ1bmVUaWxlcygpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0Ly8gRmxhZyB0byBwcmV2ZW50IF91cGRhdGVPcGFjaXR5IGZyb20gcHJ1bmluZyB0aWxlcyBkdXJpbmdcbiAgXHRcdFx0Ly8gYSB6b29tIGFuaW0gb3IgYSBwaW5jaCBnZXN0dXJlXG4gIFx0XHRcdHRoaXMuX25vUHJ1bmUgPSAhIW5vUHJ1bmU7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMuX3NldFpvb21UcmFuc2Zvcm1zKGNlbnRlciwgem9vbSk7XG4gIFx0fSxcblxuICBcdF9zZXRab29tVHJhbnNmb3JtczogZnVuY3Rpb24gKGNlbnRlciwgem9vbSkge1xuICBcdFx0Zm9yICh2YXIgaSBpbiB0aGlzLl9sZXZlbHMpIHtcbiAgXHRcdFx0dGhpcy5fc2V0Wm9vbVRyYW5zZm9ybSh0aGlzLl9sZXZlbHNbaV0sIGNlbnRlciwgem9vbSk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF9zZXRab29tVHJhbnNmb3JtOiBmdW5jdGlvbiAobGV2ZWwsIGNlbnRlciwgem9vbSkge1xuICBcdFx0dmFyIHNjYWxlID0gdGhpcy5fbWFwLmdldFpvb21TY2FsZSh6b29tLCBsZXZlbC56b29tKSxcbiAgXHRcdCAgICB0cmFuc2xhdGUgPSBsZXZlbC5vcmlnaW4ubXVsdGlwbHlCeShzY2FsZSlcbiAgXHRcdCAgICAgICAgLnN1YnRyYWN0KHRoaXMuX21hcC5fZ2V0TmV3UGl4ZWxPcmlnaW4oY2VudGVyLCB6b29tKSkucm91bmQoKTtcblxuICBcdFx0aWYgKGFueTNkKSB7XG4gIFx0XHRcdHNldFRyYW5zZm9ybShsZXZlbC5lbCwgdHJhbnNsYXRlLCBzY2FsZSk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRzZXRQb3NpdGlvbihsZXZlbC5lbCwgdHJhbnNsYXRlKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X3Jlc2V0R3JpZDogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcbiAgXHRcdCAgICBjcnMgPSBtYXAub3B0aW9ucy5jcnMsXG4gIFx0XHQgICAgdGlsZVNpemUgPSB0aGlzLl90aWxlU2l6ZSA9IHRoaXMuZ2V0VGlsZVNpemUoKSxcbiAgXHRcdCAgICB0aWxlWm9vbSA9IHRoaXMuX3RpbGVab29tO1xuXG4gIFx0XHR2YXIgYm91bmRzID0gdGhpcy5fbWFwLmdldFBpeGVsV29ybGRCb3VuZHModGhpcy5fdGlsZVpvb20pO1xuICBcdFx0aWYgKGJvdW5kcykge1xuICBcdFx0XHR0aGlzLl9nbG9iYWxUaWxlUmFuZ2UgPSB0aGlzLl9weEJvdW5kc1RvVGlsZVJhbmdlKGJvdW5kcyk7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMuX3dyYXBYID0gY3JzLndyYXBMbmcgJiYgIXRoaXMub3B0aW9ucy5ub1dyYXAgJiYgW1xuICBcdFx0XHRNYXRoLmZsb29yKG1hcC5wcm9qZWN0KFswLCBjcnMud3JhcExuZ1swXV0sIHRpbGVab29tKS54IC8gdGlsZVNpemUueCksXG4gIFx0XHRcdE1hdGguY2VpbChtYXAucHJvamVjdChbMCwgY3JzLndyYXBMbmdbMV1dLCB0aWxlWm9vbSkueCAvIHRpbGVTaXplLnkpXG4gIFx0XHRdO1xuICBcdFx0dGhpcy5fd3JhcFkgPSBjcnMud3JhcExhdCAmJiAhdGhpcy5vcHRpb25zLm5vV3JhcCAmJiBbXG4gIFx0XHRcdE1hdGguZmxvb3IobWFwLnByb2plY3QoW2Nycy53cmFwTGF0WzBdLCAwXSwgdGlsZVpvb20pLnkgLyB0aWxlU2l6ZS54KSxcbiAgXHRcdFx0TWF0aC5jZWlsKG1hcC5wcm9qZWN0KFtjcnMud3JhcExhdFsxXSwgMF0sIHRpbGVab29tKS55IC8gdGlsZVNpemUueSlcbiAgXHRcdF07XG4gIFx0fSxcblxuICBcdF9vbk1vdmVFbmQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICghdGhpcy5fbWFwIHx8IHRoaXMuX21hcC5fYW5pbWF0aW5nWm9vbSkgeyByZXR1cm47IH1cblxuICBcdFx0dGhpcy5fdXBkYXRlKCk7XG4gIFx0fSxcblxuICBcdF9nZXRUaWxlZFBpeGVsQm91bmRzOiBmdW5jdGlvbiAoY2VudGVyKSB7XG4gIFx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuICBcdFx0ICAgIG1hcFpvb20gPSBtYXAuX2FuaW1hdGluZ1pvb20gPyBNYXRoLm1heChtYXAuX2FuaW1hdGVUb1pvb20sIG1hcC5nZXRab29tKCkpIDogbWFwLmdldFpvb20oKSxcbiAgXHRcdCAgICBzY2FsZSA9IG1hcC5nZXRab29tU2NhbGUobWFwWm9vbSwgdGhpcy5fdGlsZVpvb20pLFxuICBcdFx0ICAgIHBpeGVsQ2VudGVyID0gbWFwLnByb2plY3QoY2VudGVyLCB0aGlzLl90aWxlWm9vbSkuZmxvb3IoKSxcbiAgXHRcdCAgICBoYWxmU2l6ZSA9IG1hcC5nZXRTaXplKCkuZGl2aWRlQnkoc2NhbGUgKiAyKTtcblxuICBcdFx0cmV0dXJuIG5ldyBCb3VuZHMocGl4ZWxDZW50ZXIuc3VidHJhY3QoaGFsZlNpemUpLCBwaXhlbENlbnRlci5hZGQoaGFsZlNpemUpKTtcbiAgXHR9LFxuXG4gIFx0Ly8gUHJpdmF0ZSBtZXRob2QgdG8gbG9hZCB0aWxlcyBpbiB0aGUgZ3JpZCdzIGFjdGl2ZSB6b29tIGxldmVsIGFjY29yZGluZyB0byBtYXAgYm91bmRzXG4gIFx0X3VwZGF0ZTogZnVuY3Rpb24gKGNlbnRlcikge1xuICBcdFx0dmFyIG1hcCA9IHRoaXMuX21hcDtcbiAgXHRcdGlmICghbWFwKSB7IHJldHVybjsgfVxuICBcdFx0dmFyIHpvb20gPSB0aGlzLl9jbGFtcFpvb20obWFwLmdldFpvb20oKSk7XG5cbiAgXHRcdGlmIChjZW50ZXIgPT09IHVuZGVmaW5lZCkgeyBjZW50ZXIgPSBtYXAuZ2V0Q2VudGVyKCk7IH1cbiAgXHRcdGlmICh0aGlzLl90aWxlWm9vbSA9PT0gdW5kZWZpbmVkKSB7IHJldHVybjsgfVx0Ly8gaWYgb3V0IG9mIG1pbnpvb20vbWF4em9vbVxuXG4gIFx0XHR2YXIgcGl4ZWxCb3VuZHMgPSB0aGlzLl9nZXRUaWxlZFBpeGVsQm91bmRzKGNlbnRlciksXG4gIFx0XHQgICAgdGlsZVJhbmdlID0gdGhpcy5fcHhCb3VuZHNUb1RpbGVSYW5nZShwaXhlbEJvdW5kcyksXG4gIFx0XHQgICAgdGlsZUNlbnRlciA9IHRpbGVSYW5nZS5nZXRDZW50ZXIoKSxcbiAgXHRcdCAgICBxdWV1ZSA9IFtdLFxuICBcdFx0ICAgIG1hcmdpbiA9IHRoaXMub3B0aW9ucy5rZWVwQnVmZmVyLFxuICBcdFx0ICAgIG5vUHJ1bmVSYW5nZSA9IG5ldyBCb3VuZHModGlsZVJhbmdlLmdldEJvdHRvbUxlZnQoKS5zdWJ0cmFjdChbbWFyZ2luLCAtbWFyZ2luXSksXG4gIFx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aWxlUmFuZ2UuZ2V0VG9wUmlnaHQoKS5hZGQoW21hcmdpbiwgLW1hcmdpbl0pKTtcblxuICBcdFx0Ly8gU2FuaXR5IGNoZWNrOiBwYW5pYyBpZiB0aGUgdGlsZSByYW5nZSBjb250YWlucyBJbmZpbml0eSBzb21ld2hlcmUuXG4gIFx0XHRpZiAoIShpc0Zpbml0ZSh0aWxlUmFuZ2UubWluLngpICYmXG4gIFx0XHQgICAgICBpc0Zpbml0ZSh0aWxlUmFuZ2UubWluLnkpICYmXG4gIFx0XHQgICAgICBpc0Zpbml0ZSh0aWxlUmFuZ2UubWF4LngpICYmXG4gIFx0XHQgICAgICBpc0Zpbml0ZSh0aWxlUmFuZ2UubWF4LnkpKSkgeyB0aHJvdyBuZXcgRXJyb3IoJ0F0dGVtcHRlZCB0byBsb2FkIGFuIGluZmluaXRlIG51bWJlciBvZiB0aWxlcycpOyB9XG5cbiAgXHRcdGZvciAodmFyIGtleSBpbiB0aGlzLl90aWxlcykge1xuICBcdFx0XHR2YXIgYyA9IHRoaXMuX3RpbGVzW2tleV0uY29vcmRzO1xuICBcdFx0XHRpZiAoYy56ICE9PSB0aGlzLl90aWxlWm9vbSB8fCAhbm9QcnVuZVJhbmdlLmNvbnRhaW5zKG5ldyBQb2ludChjLngsIGMueSkpKSB7XG4gIFx0XHRcdFx0dGhpcy5fdGlsZXNba2V5XS5jdXJyZW50ID0gZmFsc2U7XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0Ly8gX3VwZGF0ZSBqdXN0IGxvYWRzIG1vcmUgdGlsZXMuIElmIHRoZSB0aWxlIHpvb20gbGV2ZWwgZGlmZmVycyB0b28gbXVjaFxuICBcdFx0Ly8gZnJvbSB0aGUgbWFwJ3MsIGxldCBfc2V0VmlldyByZXNldCBsZXZlbHMgYW5kIHBydW5lIG9sZCB0aWxlcy5cbiAgXHRcdGlmIChNYXRoLmFicyh6b29tIC0gdGhpcy5fdGlsZVpvb20pID4gMSkgeyB0aGlzLl9zZXRWaWV3KGNlbnRlciwgem9vbSk7IHJldHVybjsgfVxuXG4gIFx0XHQvLyBjcmVhdGUgYSBxdWV1ZSBvZiBjb29yZGluYXRlcyB0byBsb2FkIHRpbGVzIGZyb21cbiAgXHRcdGZvciAodmFyIGogPSB0aWxlUmFuZ2UubWluLnk7IGogPD0gdGlsZVJhbmdlLm1heC55OyBqKyspIHtcbiAgXHRcdFx0Zm9yICh2YXIgaSA9IHRpbGVSYW5nZS5taW4ueDsgaSA8PSB0aWxlUmFuZ2UubWF4Lng7IGkrKykge1xuICBcdFx0XHRcdHZhciBjb29yZHMgPSBuZXcgUG9pbnQoaSwgaik7XG4gIFx0XHRcdFx0Y29vcmRzLnogPSB0aGlzLl90aWxlWm9vbTtcblxuICBcdFx0XHRcdGlmICghdGhpcy5faXNWYWxpZFRpbGUoY29vcmRzKSkgeyBjb250aW51ZTsgfVxuXG4gIFx0XHRcdFx0dmFyIHRpbGUgPSB0aGlzLl90aWxlc1t0aGlzLl90aWxlQ29vcmRzVG9LZXkoY29vcmRzKV07XG4gIFx0XHRcdFx0aWYgKHRpbGUpIHtcbiAgXHRcdFx0XHRcdHRpbGUuY3VycmVudCA9IHRydWU7XG4gIFx0XHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRcdHF1ZXVlLnB1c2goY29vcmRzKTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0Ly8gc29ydCB0aWxlIHF1ZXVlIHRvIGxvYWQgdGlsZXMgaW4gb3JkZXIgb2YgdGhlaXIgZGlzdGFuY2UgdG8gY2VudGVyXG4gIFx0XHRxdWV1ZS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gIFx0XHRcdHJldHVybiBhLmRpc3RhbmNlVG8odGlsZUNlbnRlcikgLSBiLmRpc3RhbmNlVG8odGlsZUNlbnRlcik7XG4gIFx0XHR9KTtcblxuICBcdFx0aWYgKHF1ZXVlLmxlbmd0aCAhPT0gMCkge1xuICBcdFx0XHQvLyBpZiBpdCdzIHRoZSBmaXJzdCBiYXRjaCBvZiB0aWxlcyB0byBsb2FkXG4gIFx0XHRcdGlmICghdGhpcy5fbG9hZGluZykge1xuICBcdFx0XHRcdHRoaXMuX2xvYWRpbmcgPSB0cnVlO1xuICBcdFx0XHRcdC8vIEBldmVudCBsb2FkaW5nOiBFdmVudFxuICBcdFx0XHRcdC8vIEZpcmVkIHdoZW4gdGhlIGdyaWQgbGF5ZXIgc3RhcnRzIGxvYWRpbmcgdGlsZXMuXG4gIFx0XHRcdFx0dGhpcy5maXJlKCdsb2FkaW5nJyk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHQvLyBjcmVhdGUgRE9NIGZyYWdtZW50IHRvIGFwcGVuZCB0aWxlcyBpbiBvbmUgYmF0Y2hcbiAgXHRcdFx0dmFyIGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXG4gIFx0XHRcdGZvciAoaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICBcdFx0XHRcdHRoaXMuX2FkZFRpbGUocXVldWVbaV0sIGZyYWdtZW50KTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHRoaXMuX2xldmVsLmVsLmFwcGVuZENoaWxkKGZyYWdtZW50KTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X2lzVmFsaWRUaWxlOiBmdW5jdGlvbiAoY29vcmRzKSB7XG4gIFx0XHR2YXIgY3JzID0gdGhpcy5fbWFwLm9wdGlvbnMuY3JzO1xuXG4gIFx0XHRpZiAoIWNycy5pbmZpbml0ZSkge1xuICBcdFx0XHQvLyBkb24ndCBsb2FkIHRpbGUgaWYgaXQncyBvdXQgb2YgYm91bmRzIGFuZCBub3Qgd3JhcHBlZFxuICBcdFx0XHR2YXIgYm91bmRzID0gdGhpcy5fZ2xvYmFsVGlsZVJhbmdlO1xuICBcdFx0XHRpZiAoKCFjcnMud3JhcExuZyAmJiAoY29vcmRzLnggPCBib3VuZHMubWluLnggfHwgY29vcmRzLnggPiBib3VuZHMubWF4LngpKSB8fFxuICBcdFx0XHQgICAgKCFjcnMud3JhcExhdCAmJiAoY29vcmRzLnkgPCBib3VuZHMubWluLnkgfHwgY29vcmRzLnkgPiBib3VuZHMubWF4LnkpKSkgeyByZXR1cm4gZmFsc2U7IH1cbiAgXHRcdH1cblxuICBcdFx0aWYgKCF0aGlzLm9wdGlvbnMuYm91bmRzKSB7IHJldHVybiB0cnVlOyB9XG5cbiAgXHRcdC8vIGRvbid0IGxvYWQgdGlsZSBpZiBpdCBkb2Vzbid0IGludGVyc2VjdCB0aGUgYm91bmRzIGluIG9wdGlvbnNcbiAgXHRcdHZhciB0aWxlQm91bmRzID0gdGhpcy5fdGlsZUNvb3Jkc1RvQm91bmRzKGNvb3Jkcyk7XG4gIFx0XHRyZXR1cm4gdG9MYXRMbmdCb3VuZHModGhpcy5vcHRpb25zLmJvdW5kcykub3ZlcmxhcHModGlsZUJvdW5kcyk7XG4gIFx0fSxcblxuICBcdF9rZXlUb0JvdW5kczogZnVuY3Rpb24gKGtleSkge1xuICBcdFx0cmV0dXJuIHRoaXMuX3RpbGVDb29yZHNUb0JvdW5kcyh0aGlzLl9rZXlUb1RpbGVDb29yZHMoa2V5KSk7XG4gIFx0fSxcblxuICBcdF90aWxlQ29vcmRzVG9Od1NlOiBmdW5jdGlvbiAoY29vcmRzKSB7XG4gIFx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuICBcdFx0ICAgIHRpbGVTaXplID0gdGhpcy5nZXRUaWxlU2l6ZSgpLFxuICBcdFx0ICAgIG53UG9pbnQgPSBjb29yZHMuc2NhbGVCeSh0aWxlU2l6ZSksXG4gIFx0XHQgICAgc2VQb2ludCA9IG53UG9pbnQuYWRkKHRpbGVTaXplKSxcbiAgXHRcdCAgICBudyA9IG1hcC51bnByb2plY3QobndQb2ludCwgY29vcmRzLnopLFxuICBcdFx0ICAgIHNlID0gbWFwLnVucHJvamVjdChzZVBvaW50LCBjb29yZHMueik7XG4gIFx0XHRyZXR1cm4gW253LCBzZV07XG4gIFx0fSxcblxuICBcdC8vIGNvbnZlcnRzIHRpbGUgY29vcmRpbmF0ZXMgdG8gaXRzIGdlb2dyYXBoaWNhbCBib3VuZHNcbiAgXHRfdGlsZUNvb3Jkc1RvQm91bmRzOiBmdW5jdGlvbiAoY29vcmRzKSB7XG4gIFx0XHR2YXIgYnAgPSB0aGlzLl90aWxlQ29vcmRzVG9Od1NlKGNvb3JkcyksXG4gIFx0XHQgICAgYm91bmRzID0gbmV3IExhdExuZ0JvdW5kcyhicFswXSwgYnBbMV0pO1xuXG4gIFx0XHRpZiAoIXRoaXMub3B0aW9ucy5ub1dyYXApIHtcbiAgXHRcdFx0Ym91bmRzID0gdGhpcy5fbWFwLndyYXBMYXRMbmdCb3VuZHMoYm91bmRzKTtcbiAgXHRcdH1cbiAgXHRcdHJldHVybiBib3VuZHM7XG4gIFx0fSxcbiAgXHQvLyBjb252ZXJ0cyB0aWxlIGNvb3JkaW5hdGVzIHRvIGtleSBmb3IgdGhlIHRpbGUgY2FjaGVcbiAgXHRfdGlsZUNvb3Jkc1RvS2V5OiBmdW5jdGlvbiAoY29vcmRzKSB7XG4gIFx0XHRyZXR1cm4gY29vcmRzLnggKyAnOicgKyBjb29yZHMueSArICc6JyArIGNvb3Jkcy56O1xuICBcdH0sXG5cbiAgXHQvLyBjb252ZXJ0cyB0aWxlIGNhY2hlIGtleSB0byBjb29yZGluYXRlc1xuICBcdF9rZXlUb1RpbGVDb29yZHM6IGZ1bmN0aW9uIChrZXkpIHtcbiAgXHRcdHZhciBrID0ga2V5LnNwbGl0KCc6JyksXG4gIFx0XHQgICAgY29vcmRzID0gbmV3IFBvaW50KCtrWzBdLCAra1sxXSk7XG4gIFx0XHRjb29yZHMueiA9ICtrWzJdO1xuICBcdFx0cmV0dXJuIGNvb3JkcztcbiAgXHR9LFxuXG4gIFx0X3JlbW92ZVRpbGU6IGZ1bmN0aW9uIChrZXkpIHtcbiAgXHRcdHZhciB0aWxlID0gdGhpcy5fdGlsZXNba2V5XTtcbiAgXHRcdGlmICghdGlsZSkgeyByZXR1cm47IH1cblxuICBcdFx0cmVtb3ZlKHRpbGUuZWwpO1xuXG4gIFx0XHRkZWxldGUgdGhpcy5fdGlsZXNba2V5XTtcblxuICBcdFx0Ly8gQGV2ZW50IHRpbGV1bmxvYWQ6IFRpbGVFdmVudFxuICBcdFx0Ly8gRmlyZWQgd2hlbiBhIHRpbGUgaXMgcmVtb3ZlZCAoZS5nLiB3aGVuIGEgdGlsZSBnb2VzIG9mZiB0aGUgc2NyZWVuKS5cbiAgXHRcdHRoaXMuZmlyZSgndGlsZXVubG9hZCcsIHtcbiAgXHRcdFx0dGlsZTogdGlsZS5lbCxcbiAgXHRcdFx0Y29vcmRzOiB0aGlzLl9rZXlUb1RpbGVDb29yZHMoa2V5KVxuICBcdFx0fSk7XG4gIFx0fSxcblxuICBcdF9pbml0VGlsZTogZnVuY3Rpb24gKHRpbGUpIHtcbiAgXHRcdGFkZENsYXNzKHRpbGUsICdsZWFmbGV0LXRpbGUnKTtcblxuICBcdFx0dmFyIHRpbGVTaXplID0gdGhpcy5nZXRUaWxlU2l6ZSgpO1xuICBcdFx0dGlsZS5zdHlsZS53aWR0aCA9IHRpbGVTaXplLnggKyAncHgnO1xuICBcdFx0dGlsZS5zdHlsZS5oZWlnaHQgPSB0aWxlU2l6ZS55ICsgJ3B4JztcblxuICBcdFx0dGlsZS5vbnNlbGVjdHN0YXJ0ID0gZmFsc2VGbjtcbiAgXHRcdHRpbGUub25tb3VzZW1vdmUgPSBmYWxzZUZuO1xuXG4gIFx0XHQvLyB1cGRhdGUgb3BhY2l0eSBvbiB0aWxlcyBpbiBJRTctOCBiZWNhdXNlIG9mIGZpbHRlciBpbmhlcml0YW5jZSBwcm9ibGVtc1xuICBcdFx0aWYgKGllbHQ5ICYmIHRoaXMub3B0aW9ucy5vcGFjaXR5IDwgMSkge1xuICBcdFx0XHRzZXRPcGFjaXR5KHRpbGUsIHRoaXMub3B0aW9ucy5vcGFjaXR5KTtcbiAgXHRcdH1cblxuICBcdFx0Ly8gd2l0aG91dCB0aGlzIGhhY2ssIHRpbGVzIGRpc2FwcGVhciBhZnRlciB6b29tIG9uIENocm9tZSBmb3IgQW5kcm9pZFxuICBcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL0xlYWZsZXQvTGVhZmxldC9pc3N1ZXMvMjA3OFxuICBcdFx0aWYgKGFuZHJvaWQgJiYgIWFuZHJvaWQyMykge1xuICBcdFx0XHR0aWxlLnN0eWxlLldlYmtpdEJhY2tmYWNlVmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfYWRkVGlsZTogZnVuY3Rpb24gKGNvb3JkcywgY29udGFpbmVyKSB7XG4gIFx0XHR2YXIgdGlsZVBvcyA9IHRoaXMuX2dldFRpbGVQb3MoY29vcmRzKSxcbiAgXHRcdCAgICBrZXkgPSB0aGlzLl90aWxlQ29vcmRzVG9LZXkoY29vcmRzKTtcblxuICBcdFx0dmFyIHRpbGUgPSB0aGlzLmNyZWF0ZVRpbGUodGhpcy5fd3JhcENvb3Jkcyhjb29yZHMpLCBiaW5kKHRoaXMuX3RpbGVSZWFkeSwgdGhpcywgY29vcmRzKSk7XG5cbiAgXHRcdHRoaXMuX2luaXRUaWxlKHRpbGUpO1xuXG4gIFx0XHQvLyBpZiBjcmVhdGVUaWxlIGlzIGRlZmluZWQgd2l0aCBhIHNlY29uZCBhcmd1bWVudCAoXCJkb25lXCIgY2FsbGJhY2spLFxuICBcdFx0Ly8gd2Uga25vdyB0aGF0IHRpbGUgaXMgYXN5bmMgYW5kIHdpbGwgYmUgcmVhZHkgbGF0ZXI7IG90aGVyd2lzZVxuICBcdFx0aWYgKHRoaXMuY3JlYXRlVGlsZS5sZW5ndGggPCAyKSB7XG4gIFx0XHRcdC8vIG1hcmsgdGlsZSBhcyByZWFkeSwgYnV0IGRlbGF5IG9uZSBmcmFtZSBmb3Igb3BhY2l0eSBhbmltYXRpb24gdG8gaGFwcGVuXG4gIFx0XHRcdHJlcXVlc3RBbmltRnJhbWUoYmluZCh0aGlzLl90aWxlUmVhZHksIHRoaXMsIGNvb3JkcywgbnVsbCwgdGlsZSkpO1xuICBcdFx0fVxuXG4gIFx0XHRzZXRQb3NpdGlvbih0aWxlLCB0aWxlUG9zKTtcblxuICBcdFx0Ly8gc2F2ZSB0aWxlIGluIGNhY2hlXG4gIFx0XHR0aGlzLl90aWxlc1trZXldID0ge1xuICBcdFx0XHRlbDogdGlsZSxcbiAgXHRcdFx0Y29vcmRzOiBjb29yZHMsXG4gIFx0XHRcdGN1cnJlbnQ6IHRydWVcbiAgXHRcdH07XG5cbiAgXHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aWxlKTtcbiAgXHRcdC8vIEBldmVudCB0aWxlbG9hZHN0YXJ0OiBUaWxlRXZlbnRcbiAgXHRcdC8vIEZpcmVkIHdoZW4gYSB0aWxlIGlzIHJlcXVlc3RlZCBhbmQgc3RhcnRzIGxvYWRpbmcuXG4gIFx0XHR0aGlzLmZpcmUoJ3RpbGVsb2Fkc3RhcnQnLCB7XG4gIFx0XHRcdHRpbGU6IHRpbGUsXG4gIFx0XHRcdGNvb3JkczogY29vcmRzXG4gIFx0XHR9KTtcbiAgXHR9LFxuXG4gIFx0X3RpbGVSZWFkeTogZnVuY3Rpb24gKGNvb3JkcywgZXJyLCB0aWxlKSB7XG4gIFx0XHRpZiAoZXJyKSB7XG4gIFx0XHRcdC8vIEBldmVudCB0aWxlZXJyb3I6IFRpbGVFcnJvckV2ZW50XG4gIFx0XHRcdC8vIEZpcmVkIHdoZW4gdGhlcmUgaXMgYW4gZXJyb3IgbG9hZGluZyBhIHRpbGUuXG4gIFx0XHRcdHRoaXMuZmlyZSgndGlsZWVycm9yJywge1xuICBcdFx0XHRcdGVycm9yOiBlcnIsXG4gIFx0XHRcdFx0dGlsZTogdGlsZSxcbiAgXHRcdFx0XHRjb29yZHM6IGNvb3Jkc1xuICBcdFx0XHR9KTtcbiAgXHRcdH1cblxuICBcdFx0dmFyIGtleSA9IHRoaXMuX3RpbGVDb29yZHNUb0tleShjb29yZHMpO1xuXG4gIFx0XHR0aWxlID0gdGhpcy5fdGlsZXNba2V5XTtcbiAgXHRcdGlmICghdGlsZSkgeyByZXR1cm47IH1cblxuICBcdFx0dGlsZS5sb2FkZWQgPSArbmV3IERhdGUoKTtcbiAgXHRcdGlmICh0aGlzLl9tYXAuX2ZhZGVBbmltYXRlZCkge1xuICBcdFx0XHRzZXRPcGFjaXR5KHRpbGUuZWwsIDApO1xuICBcdFx0XHRjYW5jZWxBbmltRnJhbWUodGhpcy5fZmFkZUZyYW1lKTtcbiAgXHRcdFx0dGhpcy5fZmFkZUZyYW1lID0gcmVxdWVzdEFuaW1GcmFtZSh0aGlzLl91cGRhdGVPcGFjaXR5LCB0aGlzKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHRpbGUuYWN0aXZlID0gdHJ1ZTtcbiAgXHRcdFx0dGhpcy5fcHJ1bmVUaWxlcygpO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAoIWVycikge1xuICBcdFx0XHRhZGRDbGFzcyh0aWxlLmVsLCAnbGVhZmxldC10aWxlLWxvYWRlZCcpO1xuXG4gIFx0XHRcdC8vIEBldmVudCB0aWxlbG9hZDogVGlsZUV2ZW50XG4gIFx0XHRcdC8vIEZpcmVkIHdoZW4gYSB0aWxlIGxvYWRzLlxuICBcdFx0XHR0aGlzLmZpcmUoJ3RpbGVsb2FkJywge1xuICBcdFx0XHRcdHRpbGU6IHRpbGUuZWwsXG4gIFx0XHRcdFx0Y29vcmRzOiBjb29yZHNcbiAgXHRcdFx0fSk7XG4gIFx0XHR9XG5cbiAgXHRcdGlmICh0aGlzLl9ub1RpbGVzVG9Mb2FkKCkpIHtcbiAgXHRcdFx0dGhpcy5fbG9hZGluZyA9IGZhbHNlO1xuICBcdFx0XHQvLyBAZXZlbnQgbG9hZDogRXZlbnRcbiAgXHRcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgZ3JpZCBsYXllciBsb2FkZWQgYWxsIHZpc2libGUgdGlsZXMuXG4gIFx0XHRcdHRoaXMuZmlyZSgnbG9hZCcpO1xuXG4gIFx0XHRcdGlmIChpZWx0OSB8fCAhdGhpcy5fbWFwLl9mYWRlQW5pbWF0ZWQpIHtcbiAgXHRcdFx0XHRyZXF1ZXN0QW5pbUZyYW1lKHRoaXMuX3BydW5lVGlsZXMsIHRoaXMpO1xuICBcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdC8vIFdhaXQgYSBiaXQgbW9yZSB0aGFuIDAuMiBzZWNzICh0aGUgZHVyYXRpb24gb2YgdGhlIHRpbGUgZmFkZS1pbilcbiAgXHRcdFx0XHQvLyB0byB0cmlnZ2VyIGEgcHJ1bmluZy5cbiAgXHRcdFx0XHRzZXRUaW1lb3V0KGJpbmQodGhpcy5fcHJ1bmVUaWxlcywgdGhpcyksIDI1MCk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X2dldFRpbGVQb3M6IGZ1bmN0aW9uIChjb29yZHMpIHtcbiAgXHRcdHJldHVybiBjb29yZHMuc2NhbGVCeSh0aGlzLmdldFRpbGVTaXplKCkpLnN1YnRyYWN0KHRoaXMuX2xldmVsLm9yaWdpbik7XG4gIFx0fSxcblxuICBcdF93cmFwQ29vcmRzOiBmdW5jdGlvbiAoY29vcmRzKSB7XG4gIFx0XHR2YXIgbmV3Q29vcmRzID0gbmV3IFBvaW50KFxuICBcdFx0XHR0aGlzLl93cmFwWCA/IHdyYXBOdW0oY29vcmRzLngsIHRoaXMuX3dyYXBYKSA6IGNvb3Jkcy54LFxuICBcdFx0XHR0aGlzLl93cmFwWSA/IHdyYXBOdW0oY29vcmRzLnksIHRoaXMuX3dyYXBZKSA6IGNvb3Jkcy55KTtcbiAgXHRcdG5ld0Nvb3Jkcy56ID0gY29vcmRzLno7XG4gIFx0XHRyZXR1cm4gbmV3Q29vcmRzO1xuICBcdH0sXG5cbiAgXHRfcHhCb3VuZHNUb1RpbGVSYW5nZTogZnVuY3Rpb24gKGJvdW5kcykge1xuICBcdFx0dmFyIHRpbGVTaXplID0gdGhpcy5nZXRUaWxlU2l6ZSgpO1xuICBcdFx0cmV0dXJuIG5ldyBCb3VuZHMoXG4gIFx0XHRcdGJvdW5kcy5taW4udW5zY2FsZUJ5KHRpbGVTaXplKS5mbG9vcigpLFxuICBcdFx0XHRib3VuZHMubWF4LnVuc2NhbGVCeSh0aWxlU2l6ZSkuY2VpbCgpLnN1YnRyYWN0KFsxLCAxXSkpO1xuICBcdH0sXG5cbiAgXHRfbm9UaWxlc1RvTG9hZDogZnVuY3Rpb24gKCkge1xuICBcdFx0Zm9yICh2YXIga2V5IGluIHRoaXMuX3RpbGVzKSB7XG4gIFx0XHRcdGlmICghdGhpcy5fdGlsZXNba2V5XS5sb2FkZWQpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIFx0XHR9XG4gIFx0XHRyZXR1cm4gdHJ1ZTtcbiAgXHR9XG4gIH0pO1xuXG4gIC8vIEBmYWN0b3J5IEwuZ3JpZExheWVyKG9wdGlvbnM/OiBHcmlkTGF5ZXIgb3B0aW9ucylcbiAgLy8gQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBHcmlkTGF5ZXIgd2l0aCB0aGUgc3VwcGxpZWQgb3B0aW9ucy5cbiAgZnVuY3Rpb24gZ3JpZExheWVyKG9wdGlvbnMpIHtcbiAgXHRyZXR1cm4gbmV3IEdyaWRMYXllcihvcHRpb25zKTtcbiAgfVxuXG4gIC8qXHJcbiAgICogQGNsYXNzIFRpbGVMYXllclxyXG4gICAqIEBpbmhlcml0cyBHcmlkTGF5ZXJcclxuICAgKiBAYWthIEwuVGlsZUxheWVyXHJcbiAgICogVXNlZCB0byBsb2FkIGFuZCBkaXNwbGF5IHRpbGUgbGF5ZXJzIG9uIHRoZSBtYXAuIE5vdGUgdGhhdCBtb3N0IHRpbGUgc2VydmVycyByZXF1aXJlIGF0dHJpYnV0aW9uLCB3aGljaCB5b3UgY2FuIHNldCB1bmRlciBgTGF5ZXJgLiBFeHRlbmRzIGBHcmlkTGF5ZXJgLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKlxyXG4gICAqIGBgYGpzXHJcbiAgICogTC50aWxlTGF5ZXIoJ2h0dHBzOi8ve3N9LnRpbGUub3BlbnN0cmVldG1hcC5vcmcve3p9L3t4fS97eX0ucG5nP3tmb299Jywge2ZvbzogJ2JhcicsIGF0dHJpYnV0aW9uOiAnTWFwIGRhdGEgJmNvcHk7IDxhIGhyZWY9XCJodHRwczovL3d3dy5vcGVuc3RyZWV0bWFwLm9yZy9cIj5PcGVuU3RyZWV0TWFwPC9hPiBjb250cmlidXRvcnMsIDxhIGhyZWY9XCJodHRwczovL2NyZWF0aXZlY29tbW9ucy5vcmcvbGljZW5zZXMvYnktc2EvMi4wL1wiPkNDLUJZLVNBPC9hPid9KS5hZGRUbyhtYXApO1xyXG4gICAqIGBgYFxyXG4gICAqXHJcbiAgICogQHNlY3Rpb24gVVJMIHRlbXBsYXRlXHJcbiAgICogQGV4YW1wbGVcclxuICAgKlxyXG4gICAqIEEgc3RyaW5nIG9mIHRoZSBmb2xsb3dpbmcgZm9ybTpcclxuICAgKlxyXG4gICAqIGBgYFxyXG4gICAqICdodHRwOi8ve3N9LnNvbWVkb21haW4uY29tL2JsYWJsYS97en0ve3h9L3t5fXtyfS5wbmcnXHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBge3N9YCBtZWFucyBvbmUgb2YgdGhlIGF2YWlsYWJsZSBzdWJkb21haW5zICh1c2VkIHNlcXVlbnRpYWxseSB0byBoZWxwIHdpdGggYnJvd3NlciBwYXJhbGxlbCByZXF1ZXN0cyBwZXIgZG9tYWluIGxpbWl0YXRpb247IHN1YmRvbWFpbiB2YWx1ZXMgYXJlIHNwZWNpZmllZCBpbiBvcHRpb25zOyBgYWAsIGBiYCBvciBgY2AgYnkgZGVmYXVsdCwgY2FuIGJlIG9taXR0ZWQpLCBge3p9YCDigJQgem9vbSBsZXZlbCwgYHt4fWAgYW5kIGB7eX1gIOKAlCB0aWxlIGNvb3JkaW5hdGVzLiBge3J9YCBjYW4gYmUgdXNlZCB0byBhZGQgXCImY29tbWF0OzJ4XCIgdG8gdGhlIFVSTCB0byBsb2FkIHJldGluYSB0aWxlcy5cclxuICAgKlxyXG4gICAqIFlvdSBjYW4gdXNlIGN1c3RvbSBrZXlzIGluIHRoZSB0ZW1wbGF0ZSwgd2hpY2ggd2lsbCBiZSBbZXZhbHVhdGVkXSgjdXRpbC10ZW1wbGF0ZSkgZnJvbSBUaWxlTGF5ZXIgb3B0aW9ucywgbGlrZSB0aGlzOlxyXG4gICAqXHJcbiAgICogYGBgXHJcbiAgICogTC50aWxlTGF5ZXIoJ2h0dHA6Ly97c30uc29tZWRvbWFpbi5jb20ve2Zvb30ve3p9L3t4fS97eX0ucG5nJywge2ZvbzogJ2Jhcid9KTtcclxuICAgKiBgYGBcclxuICAgKi9cclxuXHJcblxyXG4gIHZhciBUaWxlTGF5ZXIgPSBHcmlkTGF5ZXIuZXh0ZW5kKHtcclxuXHJcbiAgXHQvLyBAc2VjdGlvblxyXG4gIFx0Ly8gQGFrYSBUaWxlTGF5ZXIgb3B0aW9uc1xyXG4gIFx0b3B0aW9uczoge1xyXG4gIFx0XHQvLyBAb3B0aW9uIG1pblpvb206IE51bWJlciA9IDBcclxuICBcdFx0Ly8gVGhlIG1pbmltdW0gem9vbSBsZXZlbCBkb3duIHRvIHdoaWNoIHRoaXMgbGF5ZXIgd2lsbCBiZSBkaXNwbGF5ZWQgKGluY2x1c2l2ZSkuXHJcbiAgXHRcdG1pblpvb206IDAsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIG1heFpvb206IE51bWJlciA9IDE4XHJcbiAgXHRcdC8vIFRoZSBtYXhpbXVtIHpvb20gbGV2ZWwgdXAgdG8gd2hpY2ggdGhpcyBsYXllciB3aWxsIGJlIGRpc3BsYXllZCAoaW5jbHVzaXZlKS5cclxuICBcdFx0bWF4Wm9vbTogMTgsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIHN1YmRvbWFpbnM6IFN0cmluZ3xTdHJpbmdbXSA9ICdhYmMnXHJcbiAgXHRcdC8vIFN1YmRvbWFpbnMgb2YgdGhlIHRpbGUgc2VydmljZS4gQ2FuIGJlIHBhc3NlZCBpbiB0aGUgZm9ybSBvZiBvbmUgc3RyaW5nICh3aGVyZSBlYWNoIGxldHRlciBpcyBhIHN1YmRvbWFpbiBuYW1lKSBvciBhbiBhcnJheSBvZiBzdHJpbmdzLlxyXG4gIFx0XHRzdWJkb21haW5zOiAnYWJjJyxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gZXJyb3JUaWxlVXJsOiBTdHJpbmcgPSAnJ1xyXG4gIFx0XHQvLyBVUkwgdG8gdGhlIHRpbGUgaW1hZ2UgdG8gc2hvdyBpbiBwbGFjZSBvZiB0aGUgdGlsZSB0aGF0IGZhaWxlZCB0byBsb2FkLlxyXG4gIFx0XHRlcnJvclRpbGVVcmw6ICcnLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiB6b29tT2Zmc2V0OiBOdW1iZXIgPSAwXHJcbiAgXHRcdC8vIFRoZSB6b29tIG51bWJlciB1c2VkIGluIHRpbGUgVVJMcyB3aWxsIGJlIG9mZnNldCB3aXRoIHRoaXMgdmFsdWUuXHJcbiAgXHRcdHpvb21PZmZzZXQ6IDAsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIHRtczogQm9vbGVhbiA9IGZhbHNlXHJcbiAgXHRcdC8vIElmIGB0cnVlYCwgaW52ZXJzZXMgWSBheGlzIG51bWJlcmluZyBmb3IgdGlsZXMgKHR1cm4gdGhpcyBvbiBmb3IgW1RNU10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVGlsZV9NYXBfU2VydmljZSkgc2VydmljZXMpLlxyXG4gIFx0XHR0bXM6IGZhbHNlLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiB6b29tUmV2ZXJzZTogQm9vbGVhbiA9IGZhbHNlXHJcbiAgXHRcdC8vIElmIHNldCB0byB0cnVlLCB0aGUgem9vbSBudW1iZXIgdXNlZCBpbiB0aWxlIFVSTHMgd2lsbCBiZSByZXZlcnNlZCAoYG1heFpvb20gLSB6b29tYCBpbnN0ZWFkIG9mIGB6b29tYClcclxuICBcdFx0em9vbVJldmVyc2U6IGZhbHNlLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBkZXRlY3RSZXRpbmE6IEJvb2xlYW4gPSBmYWxzZVxyXG4gIFx0XHQvLyBJZiBgdHJ1ZWAgYW5kIHVzZXIgaXMgb24gYSByZXRpbmEgZGlzcGxheSwgaXQgd2lsbCByZXF1ZXN0IGZvdXIgdGlsZXMgb2YgaGFsZiB0aGUgc3BlY2lmaWVkIHNpemUgYW5kIGEgYmlnZ2VyIHpvb20gbGV2ZWwgaW4gcGxhY2Ugb2Ygb25lIHRvIHV0aWxpemUgdGhlIGhpZ2ggcmVzb2x1dGlvbi5cclxuICBcdFx0ZGV0ZWN0UmV0aW5hOiBmYWxzZSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gY3Jvc3NPcmlnaW46IEJvb2xlYW58U3RyaW5nID0gZmFsc2VcclxuICBcdFx0Ly8gV2hldGhlciB0aGUgY3Jvc3NPcmlnaW4gYXR0cmlidXRlIHdpbGwgYmUgYWRkZWQgdG8gdGhlIHRpbGVzLlxyXG4gIFx0XHQvLyBJZiBhIFN0cmluZyBpcyBwcm92aWRlZCwgYWxsIHRpbGVzIHdpbGwgaGF2ZSB0aGVpciBjcm9zc09yaWdpbiBhdHRyaWJ1dGUgc2V0IHRvIHRoZSBTdHJpbmcgcHJvdmlkZWQuIFRoaXMgaXMgbmVlZGVkIGlmIHlvdSB3YW50IHRvIGFjY2VzcyB0aWxlIHBpeGVsIGRhdGEuXHJcbiAgXHRcdC8vIFJlZmVyIHRvIFtDT1JTIFNldHRpbmdzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0NPUlNfc2V0dGluZ3NfYXR0cmlidXRlcykgZm9yIHZhbGlkIFN0cmluZyB2YWx1ZXMuXHJcbiAgXHRcdGNyb3NzT3JpZ2luOiBmYWxzZVxyXG4gIFx0fSxcclxuXHJcbiAgXHRpbml0aWFsaXplOiBmdW5jdGlvbiAodXJsLCBvcHRpb25zKSB7XHJcblxyXG4gIFx0XHR0aGlzLl91cmwgPSB1cmw7XHJcblxyXG4gIFx0XHRvcHRpb25zID0gc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcbiAgXHRcdC8vIGRldGVjdGluZyByZXRpbmEgZGlzcGxheXMsIGFkanVzdGluZyB0aWxlU2l6ZSBhbmQgem9vbSBsZXZlbHNcclxuICBcdFx0aWYgKG9wdGlvbnMuZGV0ZWN0UmV0aW5hICYmIHJldGluYSAmJiBvcHRpb25zLm1heFpvb20gPiAwKSB7XHJcblxyXG4gIFx0XHRcdG9wdGlvbnMudGlsZVNpemUgPSBNYXRoLmZsb29yKG9wdGlvbnMudGlsZVNpemUgLyAyKTtcclxuXHJcbiAgXHRcdFx0aWYgKCFvcHRpb25zLnpvb21SZXZlcnNlKSB7XHJcbiAgXHRcdFx0XHRvcHRpb25zLnpvb21PZmZzZXQrKztcclxuICBcdFx0XHRcdG9wdGlvbnMubWF4Wm9vbS0tO1xyXG4gIFx0XHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0XHRvcHRpb25zLnpvb21PZmZzZXQtLTtcclxuICBcdFx0XHRcdG9wdGlvbnMubWluWm9vbSsrO1xyXG4gIFx0XHRcdH1cclxuXHJcbiAgXHRcdFx0b3B0aW9ucy5taW5ab29tID0gTWF0aC5tYXgoMCwgb3B0aW9ucy5taW5ab29tKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0aWYgKHR5cGVvZiBvcHRpb25zLnN1YmRvbWFpbnMgPT09ICdzdHJpbmcnKSB7XHJcbiAgXHRcdFx0b3B0aW9ucy5zdWJkb21haW5zID0gb3B0aW9ucy5zdWJkb21haW5zLnNwbGl0KCcnKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0Ly8gZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9MZWFmbGV0L0xlYWZsZXQvaXNzdWVzLzEzN1xyXG4gIFx0XHRpZiAoIWFuZHJvaWQpIHtcclxuICBcdFx0XHR0aGlzLm9uKCd0aWxldW5sb2FkJywgdGhpcy5fb25UaWxlUmVtb3ZlKTtcclxuICBcdFx0fVxyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHNldFVybCh1cmw6IFN0cmluZywgbm9SZWRyYXc/OiBCb29sZWFuKTogdGhpc1xyXG4gIFx0Ly8gVXBkYXRlcyB0aGUgbGF5ZXIncyBVUkwgdGVtcGxhdGUgYW5kIHJlZHJhd3MgaXQgKHVubGVzcyBgbm9SZWRyYXdgIGlzIHNldCB0byBgdHJ1ZWApLlxyXG4gIFx0Ly8gSWYgdGhlIFVSTCBkb2VzIG5vdCBjaGFuZ2UsIHRoZSBsYXllciB3aWxsIG5vdCBiZSByZWRyYXduIHVubGVzc1xyXG4gIFx0Ly8gdGhlIG5vUmVkcmF3IHBhcmFtZXRlciBpcyBzZXQgdG8gZmFsc2UuXHJcbiAgXHRzZXRVcmw6IGZ1bmN0aW9uICh1cmwsIG5vUmVkcmF3KSB7XHJcbiAgXHRcdGlmICh0aGlzLl91cmwgPT09IHVybCAmJiBub1JlZHJhdyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgXHRcdFx0bm9SZWRyYXcgPSB0cnVlO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR0aGlzLl91cmwgPSB1cmw7XHJcblxyXG4gIFx0XHRpZiAoIW5vUmVkcmF3KSB7XHJcbiAgXHRcdFx0dGhpcy5yZWRyYXcoKTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBjcmVhdGVUaWxlKGNvb3JkczogT2JqZWN0LCBkb25lPzogRnVuY3Rpb24pOiBIVE1MRWxlbWVudFxyXG4gIFx0Ly8gQ2FsbGVkIG9ubHkgaW50ZXJuYWxseSwgb3ZlcnJpZGVzIEdyaWRMYXllcidzIFtgY3JlYXRlVGlsZSgpYF0oI2dyaWRsYXllci1jcmVhdGV0aWxlKVxyXG4gIFx0Ly8gdG8gcmV0dXJuIGFuIGA8aW1nPmAgSFRNTCBlbGVtZW50IHdpdGggdGhlIGFwcHJvcHJpYXRlIGltYWdlIFVSTCBnaXZlbiBgY29vcmRzYC4gVGhlIGBkb25lYFxyXG4gIFx0Ly8gY2FsbGJhY2sgaXMgY2FsbGVkIHdoZW4gdGhlIHRpbGUgaGFzIGJlZW4gbG9hZGVkLlxyXG4gIFx0Y3JlYXRlVGlsZTogZnVuY3Rpb24gKGNvb3JkcywgZG9uZSkge1xyXG4gIFx0XHR2YXIgdGlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xyXG5cclxuICBcdFx0b24odGlsZSwgJ2xvYWQnLCBiaW5kKHRoaXMuX3RpbGVPbkxvYWQsIHRoaXMsIGRvbmUsIHRpbGUpKTtcclxuICBcdFx0b24odGlsZSwgJ2Vycm9yJywgYmluZCh0aGlzLl90aWxlT25FcnJvciwgdGhpcywgZG9uZSwgdGlsZSkpO1xyXG5cclxuICBcdFx0aWYgKHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbiB8fCB0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW4gPT09ICcnKSB7XHJcbiAgXHRcdFx0dGlsZS5jcm9zc09yaWdpbiA9IHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbiA9PT0gdHJ1ZSA/ICcnIDogdGhpcy5vcHRpb25zLmNyb3NzT3JpZ2luO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHQvKlxyXG4gIFx0XHQgQWx0IHRhZyBpcyBzZXQgdG8gZW1wdHkgc3RyaW5nIHRvIGtlZXAgc2NyZWVuIHJlYWRlcnMgZnJvbSByZWFkaW5nIFVSTCBhbmQgZm9yIGNvbXBsaWFuY2UgcmVhc29uc1xyXG4gIFx0XHQgaHR0cDovL3d3dy53My5vcmcvVFIvV0NBRzIwLVRFQ0hTL0g2N1xyXG4gIFx0XHQqL1xyXG4gIFx0XHR0aWxlLmFsdCA9ICcnO1xyXG5cclxuICBcdFx0LypcclxuICBcdFx0IFNldCByb2xlPVwicHJlc2VudGF0aW9uXCIgdG8gZm9yY2Ugc2NyZWVuIHJlYWRlcnMgdG8gaWdub3JlIHRoaXNcclxuICBcdFx0IGh0dHBzOi8vd3d3LnczLm9yZy9UUi93YWktYXJpYS9yb2xlcyN0ZXh0YWx0ZXJuYXRpdmVjb21wdXRhdGlvblxyXG4gIFx0XHQqL1xyXG4gIFx0XHR0aWxlLnNldEF0dHJpYnV0ZSgncm9sZScsICdwcmVzZW50YXRpb24nKTtcclxuXHJcbiAgXHRcdHRpbGUuc3JjID0gdGhpcy5nZXRUaWxlVXJsKGNvb3Jkcyk7XHJcblxyXG4gIFx0XHRyZXR1cm4gdGlsZTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQHNlY3Rpb24gRXh0ZW5zaW9uIG1ldGhvZHNcclxuICBcdC8vIEB1bmluaGVyaXRhYmxlXHJcbiAgXHQvLyBMYXllcnMgZXh0ZW5kaW5nIGBUaWxlTGF5ZXJgIG1pZ2h0IHJlaW1wbGVtZW50IHRoZSBmb2xsb3dpbmcgbWV0aG9kLlxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRUaWxlVXJsKGNvb3JkczogT2JqZWN0KTogU3RyaW5nXHJcbiAgXHQvLyBDYWxsZWQgb25seSBpbnRlcm5hbGx5LCByZXR1cm5zIHRoZSBVUkwgZm9yIGEgdGlsZSBnaXZlbiBpdHMgY29vcmRpbmF0ZXMuXHJcbiAgXHQvLyBDbGFzc2VzIGV4dGVuZGluZyBgVGlsZUxheWVyYCBjYW4gb3ZlcnJpZGUgdGhpcyBmdW5jdGlvbiB0byBwcm92aWRlIGN1c3RvbSB0aWxlIFVSTCBuYW1pbmcgc2NoZW1lcy5cclxuICBcdGdldFRpbGVVcmw6IGZ1bmN0aW9uIChjb29yZHMpIHtcclxuICBcdFx0dmFyIGRhdGEgPSB7XHJcbiAgXHRcdFx0cjogcmV0aW5hID8gJ0AyeCcgOiAnJyxcclxuICBcdFx0XHRzOiB0aGlzLl9nZXRTdWJkb21haW4oY29vcmRzKSxcclxuICBcdFx0XHR4OiBjb29yZHMueCxcclxuICBcdFx0XHR5OiBjb29yZHMueSxcclxuICBcdFx0XHR6OiB0aGlzLl9nZXRab29tRm9yVXJsKClcclxuICBcdFx0fTtcclxuICBcdFx0aWYgKHRoaXMuX21hcCAmJiAhdGhpcy5fbWFwLm9wdGlvbnMuY3JzLmluZmluaXRlKSB7XHJcbiAgXHRcdFx0dmFyIGludmVydGVkWSA9IHRoaXMuX2dsb2JhbFRpbGVSYW5nZS5tYXgueSAtIGNvb3Jkcy55O1xyXG4gIFx0XHRcdGlmICh0aGlzLm9wdGlvbnMudG1zKSB7XHJcbiAgXHRcdFx0XHRkYXRhWyd5J10gPSBpbnZlcnRlZFk7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHRcdGRhdGFbJy15J10gPSBpbnZlcnRlZFk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHJldHVybiB0ZW1wbGF0ZSh0aGlzLl91cmwsIGV4dGVuZChkYXRhLCB0aGlzLm9wdGlvbnMpKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X3RpbGVPbkxvYWQ6IGZ1bmN0aW9uIChkb25lLCB0aWxlKSB7XHJcbiAgXHRcdC8vIEZvciBodHRwczovL2dpdGh1Yi5jb20vTGVhZmxldC9MZWFmbGV0L2lzc3Vlcy8zMzMyXHJcbiAgXHRcdGlmIChpZWx0OSkge1xyXG4gIFx0XHRcdHNldFRpbWVvdXQoYmluZChkb25lLCB0aGlzLCBudWxsLCB0aWxlKSwgMCk7XHJcbiAgXHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0ZG9uZShudWxsLCB0aWxlKTtcclxuICBcdFx0fVxyXG4gIFx0fSxcclxuXHJcbiAgXHRfdGlsZU9uRXJyb3I6IGZ1bmN0aW9uIChkb25lLCB0aWxlLCBlKSB7XHJcbiAgXHRcdHZhciBlcnJvclVybCA9IHRoaXMub3B0aW9ucy5lcnJvclRpbGVVcmw7XHJcbiAgXHRcdGlmIChlcnJvclVybCAmJiB0aWxlLmdldEF0dHJpYnV0ZSgnc3JjJykgIT09IGVycm9yVXJsKSB7XHJcbiAgXHRcdFx0dGlsZS5zcmMgPSBlcnJvclVybDtcclxuICBcdFx0fVxyXG4gIFx0XHRkb25lKGUsIHRpbGUpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfb25UaWxlUmVtb3ZlOiBmdW5jdGlvbiAoZSkge1xyXG4gIFx0XHRlLnRpbGUub25sb2FkID0gbnVsbDtcclxuICBcdH0sXHJcblxyXG4gIFx0X2dldFpvb21Gb3JVcmw6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dmFyIHpvb20gPSB0aGlzLl90aWxlWm9vbSxcclxuICBcdFx0bWF4Wm9vbSA9IHRoaXMub3B0aW9ucy5tYXhab29tLFxyXG4gIFx0XHR6b29tUmV2ZXJzZSA9IHRoaXMub3B0aW9ucy56b29tUmV2ZXJzZSxcclxuICBcdFx0em9vbU9mZnNldCA9IHRoaXMub3B0aW9ucy56b29tT2Zmc2V0O1xyXG5cclxuICBcdFx0aWYgKHpvb21SZXZlcnNlKSB7XHJcbiAgXHRcdFx0em9vbSA9IG1heFpvb20gLSB6b29tO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZXR1cm4gem9vbSArIHpvb21PZmZzZXQ7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9nZXRTdWJkb21haW46IGZ1bmN0aW9uICh0aWxlUG9pbnQpIHtcclxuICBcdFx0dmFyIGluZGV4ID0gTWF0aC5hYnModGlsZVBvaW50LnggKyB0aWxlUG9pbnQueSkgJSB0aGlzLm9wdGlvbnMuc3ViZG9tYWlucy5sZW5ndGg7XHJcbiAgXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuc3ViZG9tYWluc1tpbmRleF07XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIHN0b3BzIGxvYWRpbmcgYWxsIHRpbGVzIGluIHRoZSBiYWNrZ3JvdW5kIGxheWVyXHJcbiAgXHRfYWJvcnRMb2FkaW5nOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHZhciBpLCB0aWxlO1xyXG4gIFx0XHRmb3IgKGkgaW4gdGhpcy5fdGlsZXMpIHtcclxuICBcdFx0XHRpZiAodGhpcy5fdGlsZXNbaV0uY29vcmRzLnogIT09IHRoaXMuX3RpbGVab29tKSB7XHJcbiAgXHRcdFx0XHR0aWxlID0gdGhpcy5fdGlsZXNbaV0uZWw7XHJcblxyXG4gIFx0XHRcdFx0dGlsZS5vbmxvYWQgPSBmYWxzZUZuO1xyXG4gIFx0XHRcdFx0dGlsZS5vbmVycm9yID0gZmFsc2VGbjtcclxuXHJcbiAgXHRcdFx0XHRpZiAoIXRpbGUuY29tcGxldGUpIHtcclxuICBcdFx0XHRcdFx0dGlsZS5zcmMgPSBlbXB0eUltYWdlVXJsO1xyXG4gIFx0XHRcdFx0XHRyZW1vdmUodGlsZSk7XHJcbiAgXHRcdFx0XHRcdGRlbGV0ZSB0aGlzLl90aWxlc1tpXTtcclxuICBcdFx0XHRcdH1cclxuICBcdFx0XHR9XHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0X3JlbW92ZVRpbGU6IGZ1bmN0aW9uIChrZXkpIHtcclxuICBcdFx0dmFyIHRpbGUgPSB0aGlzLl90aWxlc1trZXldO1xyXG4gIFx0XHRpZiAoIXRpbGUpIHsgcmV0dXJuOyB9XHJcblxyXG4gIFx0XHQvLyBDYW5jZWxzIGFueSBwZW5kaW5nIGh0dHAgcmVxdWVzdHMgYXNzb2NpYXRlZCB3aXRoIHRoZSB0aWxlXHJcbiAgXHRcdC8vIHVubGVzcyB3ZSdyZSBvbiBBbmRyb2lkJ3Mgc3RvY2sgYnJvd3NlcixcclxuICBcdFx0Ly8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9MZWFmbGV0L0xlYWZsZXQvaXNzdWVzLzEzN1xyXG4gIFx0XHRpZiAoIWFuZHJvaWRTdG9jaykge1xyXG4gIFx0XHRcdHRpbGUuZWwuc2V0QXR0cmlidXRlKCdzcmMnLCBlbXB0eUltYWdlVXJsKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0cmV0dXJuIEdyaWRMYXllci5wcm90b3R5cGUuX3JlbW92ZVRpbGUuY2FsbCh0aGlzLCBrZXkpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfdGlsZVJlYWR5OiBmdW5jdGlvbiAoY29vcmRzLCBlcnIsIHRpbGUpIHtcclxuICBcdFx0aWYgKCF0aGlzLl9tYXAgfHwgKHRpbGUgJiYgdGlsZS5nZXRBdHRyaWJ1dGUoJ3NyYycpID09PSBlbXB0eUltYWdlVXJsKSkge1xyXG4gIFx0XHRcdHJldHVybjtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0cmV0dXJuIEdyaWRMYXllci5wcm90b3R5cGUuX3RpbGVSZWFkeS5jYWxsKHRoaXMsIGNvb3JkcywgZXJyLCB0aWxlKTtcclxuICBcdH1cclxuICB9KTtcclxuXHJcblxyXG4gIC8vIEBmYWN0b3J5IEwudGlsZWxheWVyKHVybFRlbXBsYXRlOiBTdHJpbmcsIG9wdGlvbnM/OiBUaWxlTGF5ZXIgb3B0aW9ucylcclxuICAvLyBJbnN0YW50aWF0ZXMgYSB0aWxlIGxheWVyIG9iamVjdCBnaXZlbiBhIGBVUkwgdGVtcGxhdGVgIGFuZCBvcHRpb25hbGx5IGFuIG9wdGlvbnMgb2JqZWN0LlxyXG5cclxuICBmdW5jdGlvbiB0aWxlTGF5ZXIodXJsLCBvcHRpb25zKSB7XHJcbiAgXHRyZXR1cm4gbmV3IFRpbGVMYXllcih1cmwsIG9wdGlvbnMpO1xyXG4gIH1cblxuICAvKlxyXG4gICAqIEBjbGFzcyBUaWxlTGF5ZXIuV01TXHJcbiAgICogQGluaGVyaXRzIFRpbGVMYXllclxyXG4gICAqIEBha2EgTC5UaWxlTGF5ZXIuV01TXHJcbiAgICogVXNlZCB0byBkaXNwbGF5IFtXTVNdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1dlYl9NYXBfU2VydmljZSkgc2VydmljZXMgYXMgdGlsZSBsYXllcnMgb24gdGhlIG1hcC4gRXh0ZW5kcyBgVGlsZUxheWVyYC5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICpcclxuICAgKiBgYGBqc1xyXG4gICAqIHZhciBuZXhyYWQgPSBMLnRpbGVMYXllci53bXMoXCJodHRwOi8vbWVzb25ldC5hZ3Jvbi5pYXN0YXRlLmVkdS9jZ2ktYmluL3dtcy9uZXhyYWQvbjByLmNnaVwiLCB7XHJcbiAgICogXHRsYXllcnM6ICduZXhyYWQtbjByLTkwMDkxMycsXHJcbiAgICogXHRmb3JtYXQ6ICdpbWFnZS9wbmcnLFxyXG4gICAqIFx0dHJhbnNwYXJlbnQ6IHRydWUsXHJcbiAgICogXHRhdHRyaWJ1dGlvbjogXCJXZWF0aGVyIGRhdGEgwqkgMjAxMiBJRU0gTmV4cmFkXCJcclxuICAgKiB9KTtcclxuICAgKiBgYGBcclxuICAgKi9cclxuXHJcbiAgdmFyIFRpbGVMYXllcldNUyA9IFRpbGVMYXllci5leHRlbmQoe1xyXG5cclxuICBcdC8vIEBzZWN0aW9uXHJcbiAgXHQvLyBAYWthIFRpbGVMYXllci5XTVMgb3B0aW9uc1xyXG4gIFx0Ly8gSWYgYW55IGN1c3RvbSBvcHRpb25zIG5vdCBkb2N1bWVudGVkIGhlcmUgYXJlIHVzZWQsIHRoZXkgd2lsbCBiZSBzZW50IHRvIHRoZVxyXG4gIFx0Ly8gV01TIHNlcnZlciBhcyBleHRyYSBwYXJhbWV0ZXJzIGluIGVhY2ggcmVxdWVzdCBVUkwuIFRoaXMgY2FuIGJlIHVzZWZ1bCBmb3JcclxuICBcdC8vIFtub24tc3RhbmRhcmQgdmVuZG9yIFdNUyBwYXJhbWV0ZXJzXShodHRwOi8vZG9jcy5nZW9zZXJ2ZXIub3JnL3N0YWJsZS9lbi91c2VyL3NlcnZpY2VzL3dtcy92ZW5kb3IuaHRtbCkuXHJcbiAgXHRkZWZhdWx0V21zUGFyYW1zOiB7XHJcbiAgXHRcdHNlcnZpY2U6ICdXTVMnLFxyXG4gIFx0XHRyZXF1ZXN0OiAnR2V0TWFwJyxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gbGF5ZXJzOiBTdHJpbmcgPSAnJ1xyXG4gIFx0XHQvLyAqKihyZXF1aXJlZCkqKiBDb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBXTVMgbGF5ZXJzIHRvIHNob3cuXHJcbiAgXHRcdGxheWVyczogJycsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIHN0eWxlczogU3RyaW5nID0gJydcclxuICBcdFx0Ly8gQ29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgV01TIHN0eWxlcy5cclxuICBcdFx0c3R5bGVzOiAnJyxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gZm9ybWF0OiBTdHJpbmcgPSAnaW1hZ2UvanBlZydcclxuICBcdFx0Ly8gV01TIGltYWdlIGZvcm1hdCAodXNlIGAnaW1hZ2UvcG5nJ2AgZm9yIGxheWVycyB3aXRoIHRyYW5zcGFyZW5jeSkuXHJcbiAgXHRcdGZvcm1hdDogJ2ltYWdlL2pwZWcnLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiB0cmFuc3BhcmVudDogQm9vbGVhbiA9IGZhbHNlXHJcbiAgXHRcdC8vIElmIGB0cnVlYCwgdGhlIFdNUyBzZXJ2aWNlIHdpbGwgcmV0dXJuIGltYWdlcyB3aXRoIHRyYW5zcGFyZW5jeS5cclxuICBcdFx0dHJhbnNwYXJlbnQ6IGZhbHNlLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiB2ZXJzaW9uOiBTdHJpbmcgPSAnMS4xLjEnXHJcbiAgXHRcdC8vIFZlcnNpb24gb2YgdGhlIFdNUyBzZXJ2aWNlIHRvIHVzZVxyXG4gIFx0XHR2ZXJzaW9uOiAnMS4xLjEnXHJcbiAgXHR9LFxyXG5cclxuICBcdG9wdGlvbnM6IHtcclxuICBcdFx0Ly8gQG9wdGlvbiBjcnM6IENSUyA9IG51bGxcclxuICBcdFx0Ly8gQ29vcmRpbmF0ZSBSZWZlcmVuY2UgU3lzdGVtIHRvIHVzZSBmb3IgdGhlIFdNUyByZXF1ZXN0cywgZGVmYXVsdHMgdG9cclxuICBcdFx0Ly8gbWFwIENSUy4gRG9uJ3QgY2hhbmdlIHRoaXMgaWYgeW91J3JlIG5vdCBzdXJlIHdoYXQgaXQgbWVhbnMuXHJcbiAgXHRcdGNyczogbnVsbCxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gdXBwZXJjYXNlOiBCb29sZWFuID0gZmFsc2VcclxuICBcdFx0Ly8gSWYgYHRydWVgLCBXTVMgcmVxdWVzdCBwYXJhbWV0ZXIga2V5cyB3aWxsIGJlIHVwcGVyY2FzZS5cclxuICBcdFx0dXBwZXJjYXNlOiBmYWxzZVxyXG4gIFx0fSxcclxuXHJcbiAgXHRpbml0aWFsaXplOiBmdW5jdGlvbiAodXJsLCBvcHRpb25zKSB7XHJcblxyXG4gIFx0XHR0aGlzLl91cmwgPSB1cmw7XHJcblxyXG4gIFx0XHR2YXIgd21zUGFyYW1zID0gZXh0ZW5kKHt9LCB0aGlzLmRlZmF1bHRXbXNQYXJhbXMpO1xyXG5cclxuICBcdFx0Ly8gYWxsIGtleXMgdGhhdCBhcmUgbm90IFRpbGVMYXllciBvcHRpb25zIGdvIHRvIFdNUyBwYXJhbXNcclxuICBcdFx0Zm9yICh2YXIgaSBpbiBvcHRpb25zKSB7XHJcbiAgXHRcdFx0aWYgKCEoaSBpbiB0aGlzLm9wdGlvbnMpKSB7XHJcbiAgXHRcdFx0XHR3bXNQYXJhbXNbaV0gPSBvcHRpb25zW2ldO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0fVxyXG5cclxuICBcdFx0b3B0aW9ucyA9IHNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG4gIFx0XHR2YXIgcmVhbFJldGluYSA9IG9wdGlvbnMuZGV0ZWN0UmV0aW5hICYmIHJldGluYSA/IDIgOiAxO1xyXG4gIFx0XHR2YXIgdGlsZVNpemUgPSB0aGlzLmdldFRpbGVTaXplKCk7XHJcbiAgXHRcdHdtc1BhcmFtcy53aWR0aCA9IHRpbGVTaXplLnggKiByZWFsUmV0aW5hO1xyXG4gIFx0XHR3bXNQYXJhbXMuaGVpZ2h0ID0gdGlsZVNpemUueSAqIHJlYWxSZXRpbmE7XHJcblxyXG4gIFx0XHR0aGlzLndtc1BhcmFtcyA9IHdtc1BhcmFtcztcclxuICBcdH0sXHJcblxyXG4gIFx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuXHJcbiAgXHRcdHRoaXMuX2NycyA9IHRoaXMub3B0aW9ucy5jcnMgfHwgbWFwLm9wdGlvbnMuY3JzO1xyXG4gIFx0XHR0aGlzLl93bXNWZXJzaW9uID0gcGFyc2VGbG9hdCh0aGlzLndtc1BhcmFtcy52ZXJzaW9uKTtcclxuXHJcbiAgXHRcdHZhciBwcm9qZWN0aW9uS2V5ID0gdGhpcy5fd21zVmVyc2lvbiA+PSAxLjMgPyAnY3JzJyA6ICdzcnMnO1xyXG4gIFx0XHR0aGlzLndtc1BhcmFtc1twcm9qZWN0aW9uS2V5XSA9IHRoaXMuX2Nycy5jb2RlO1xyXG5cclxuICBcdFx0VGlsZUxheWVyLnByb3RvdHlwZS5vbkFkZC5jYWxsKHRoaXMsIG1hcCk7XHJcbiAgXHR9LFxyXG5cclxuICBcdGdldFRpbGVVcmw6IGZ1bmN0aW9uIChjb29yZHMpIHtcclxuXHJcbiAgXHRcdHZhciB0aWxlQm91bmRzID0gdGhpcy5fdGlsZUNvb3Jkc1RvTndTZShjb29yZHMpLFxyXG4gIFx0XHQgICAgY3JzID0gdGhpcy5fY3JzLFxyXG4gIFx0XHQgICAgYm91bmRzID0gdG9Cb3VuZHMoY3JzLnByb2plY3QodGlsZUJvdW5kc1swXSksIGNycy5wcm9qZWN0KHRpbGVCb3VuZHNbMV0pKSxcclxuICBcdFx0ICAgIG1pbiA9IGJvdW5kcy5taW4sXHJcbiAgXHRcdCAgICBtYXggPSBib3VuZHMubWF4LFxyXG4gIFx0XHQgICAgYmJveCA9ICh0aGlzLl93bXNWZXJzaW9uID49IDEuMyAmJiB0aGlzLl9jcnMgPT09IEVQU0c0MzI2ID9cclxuICBcdFx0ICAgIFttaW4ueSwgbWluLngsIG1heC55LCBtYXgueF0gOlxyXG4gIFx0XHQgICAgW21pbi54LCBtaW4ueSwgbWF4LngsIG1heC55XSkuam9pbignLCcpLFxyXG4gIFx0XHQgICAgdXJsID0gVGlsZUxheWVyLnByb3RvdHlwZS5nZXRUaWxlVXJsLmNhbGwodGhpcywgY29vcmRzKTtcclxuICBcdFx0cmV0dXJuIHVybCArXHJcbiAgXHRcdFx0Z2V0UGFyYW1TdHJpbmcodGhpcy53bXNQYXJhbXMsIHVybCwgdGhpcy5vcHRpb25zLnVwcGVyY2FzZSkgK1xyXG4gIFx0XHRcdCh0aGlzLm9wdGlvbnMudXBwZXJjYXNlID8gJyZCQk9YPScgOiAnJmJib3g9JykgKyBiYm94O1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHNldFBhcmFtcyhwYXJhbXM6IE9iamVjdCwgbm9SZWRyYXc/OiBCb29sZWFuKTogdGhpc1xyXG4gIFx0Ly8gTWVyZ2VzIGFuIG9iamVjdCB3aXRoIHRoZSBuZXcgcGFyYW1ldGVycyBhbmQgcmUtcmVxdWVzdHMgdGlsZXMgb24gdGhlIGN1cnJlbnQgc2NyZWVuICh1bmxlc3MgYG5vUmVkcmF3YCB3YXMgc2V0IHRvIHRydWUpLlxyXG4gIFx0c2V0UGFyYW1zOiBmdW5jdGlvbiAocGFyYW1zLCBub1JlZHJhdykge1xyXG5cclxuICBcdFx0ZXh0ZW5kKHRoaXMud21zUGFyYW1zLCBwYXJhbXMpO1xyXG5cclxuICBcdFx0aWYgKCFub1JlZHJhdykge1xyXG4gIFx0XHRcdHRoaXMucmVkcmF3KCk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fVxyXG4gIH0pO1xyXG5cclxuXHJcbiAgLy8gQGZhY3RvcnkgTC50aWxlTGF5ZXIud21zKGJhc2VVcmw6IFN0cmluZywgb3B0aW9uczogVGlsZUxheWVyLldNUyBvcHRpb25zKVxyXG4gIC8vIEluc3RhbnRpYXRlcyBhIFdNUyB0aWxlIGxheWVyIG9iamVjdCBnaXZlbiBhIGJhc2UgVVJMIG9mIHRoZSBXTVMgc2VydmljZSBhbmQgYSBXTVMgcGFyYW1ldGVycy9vcHRpb25zIG9iamVjdC5cclxuICBmdW5jdGlvbiB0aWxlTGF5ZXJXTVModXJsLCBvcHRpb25zKSB7XHJcbiAgXHRyZXR1cm4gbmV3IFRpbGVMYXllcldNUyh1cmwsIG9wdGlvbnMpO1xyXG4gIH1cblxuICBUaWxlTGF5ZXIuV01TID0gVGlsZUxheWVyV01TO1xuICB0aWxlTGF5ZXIud21zID0gdGlsZUxheWVyV01TO1xuXG4gIC8qXG4gICAqIEBjbGFzcyBSZW5kZXJlclxuICAgKiBAaW5oZXJpdHMgTGF5ZXJcbiAgICogQGFrYSBMLlJlbmRlcmVyXG4gICAqXG4gICAqIEJhc2UgY2xhc3MgZm9yIHZlY3RvciByZW5kZXJlciBpbXBsZW1lbnRhdGlvbnMgKGBTVkdgLCBgQ2FudmFzYCkuIEhhbmRsZXMgdGhlXG4gICAqIERPTSBjb250YWluZXIgb2YgdGhlIHJlbmRlcmVyLCBpdHMgYm91bmRzLCBhbmQgaXRzIHpvb20gYW5pbWF0aW9uLlxuICAgKlxuICAgKiBBIGBSZW5kZXJlcmAgd29ya3MgYXMgYW4gaW1wbGljaXQgbGF5ZXIgZ3JvdXAgZm9yIGFsbCBgUGF0aGBzIC0gdGhlIHJlbmRlcmVyXG4gICAqIGl0c2VsZiBjYW4gYmUgYWRkZWQgb3IgcmVtb3ZlZCB0byB0aGUgbWFwLiBBbGwgcGF0aHMgdXNlIGEgcmVuZGVyZXIsIHdoaWNoIGNhblxuICAgKiBiZSBpbXBsaWNpdCAodGhlIG1hcCB3aWxsIGRlY2lkZSB0aGUgdHlwZSBvZiByZW5kZXJlciBhbmQgdXNlIGl0IGF1dG9tYXRpY2FsbHkpXG4gICAqIG9yIGV4cGxpY2l0ICh1c2luZyB0aGUgW2ByZW5kZXJlcmBdKCNwYXRoLXJlbmRlcmVyKSBvcHRpb24gb2YgdGhlIHBhdGgpLlxuICAgKlxuICAgKiBEbyBub3QgdXNlIHRoaXMgY2xhc3MgZGlyZWN0bHksIHVzZSBgU1ZHYCBhbmQgYENhbnZhc2AgaW5zdGVhZC5cbiAgICpcbiAgICogQGV2ZW50IHVwZGF0ZTogRXZlbnRcbiAgICogRmlyZWQgd2hlbiB0aGUgcmVuZGVyZXIgdXBkYXRlcyBpdHMgYm91bmRzLCBjZW50ZXIgYW5kIHpvb20sIGZvciBleGFtcGxlIHdoZW5cbiAgICogaXRzIG1hcCBoYXMgbW92ZWRcbiAgICovXG5cbiAgdmFyIFJlbmRlcmVyID0gTGF5ZXIuZXh0ZW5kKHtcblxuICBcdC8vIEBzZWN0aW9uXG4gIFx0Ly8gQGFrYSBSZW5kZXJlciBvcHRpb25zXG4gIFx0b3B0aW9uczoge1xuICBcdFx0Ly8gQG9wdGlvbiBwYWRkaW5nOiBOdW1iZXIgPSAwLjFcbiAgXHRcdC8vIEhvdyBtdWNoIHRvIGV4dGVuZCB0aGUgY2xpcCBhcmVhIGFyb3VuZCB0aGUgbWFwIHZpZXcgKHJlbGF0aXZlIHRvIGl0cyBzaXplKVxuICBcdFx0Ly8gZS5nLiAwLjEgd291bGQgYmUgMTAlIG9mIG1hcCB2aWV3IGluIGVhY2ggZGlyZWN0aW9uXG4gIFx0XHRwYWRkaW5nOiAwLjEsXG5cbiAgXHRcdC8vIEBvcHRpb24gdG9sZXJhbmNlOiBOdW1iZXIgPSAwXG4gIFx0XHQvLyBIb3cgbXVjaCB0byBleHRlbmQgY2xpY2sgdG9sZXJhbmNlIHJvdW5kIGEgcGF0aC9vYmplY3Qgb24gdGhlIG1hcFxuICBcdFx0dG9sZXJhbmNlIDogMFxuICBcdH0sXG5cbiAgXHRpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICBcdFx0c2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcbiAgXHRcdHN0YW1wKHRoaXMpO1xuICBcdFx0dGhpcy5fbGF5ZXJzID0gdGhpcy5fbGF5ZXJzIHx8IHt9O1xuICBcdH0sXG5cbiAgXHRvbkFkZDogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKCF0aGlzLl9jb250YWluZXIpIHtcbiAgXHRcdFx0dGhpcy5faW5pdENvbnRhaW5lcigpOyAvLyBkZWZpbmVkIGJ5IHJlbmRlcmVyIGltcGxlbWVudGF0aW9uc1xuXG4gIFx0XHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcbiAgXHRcdFx0XHRhZGRDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LXpvb20tYW5pbWF0ZWQnKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHR0aGlzLmdldFBhbmUoKS5hcHBlbmRDaGlsZCh0aGlzLl9jb250YWluZXIpO1xuICBcdFx0dGhpcy5fdXBkYXRlKCk7XG4gIFx0XHR0aGlzLm9uKCd1cGRhdGUnLCB0aGlzLl91cGRhdGVQYXRocywgdGhpcyk7XG4gIFx0fSxcblxuICBcdG9uUmVtb3ZlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLm9mZigndXBkYXRlJywgdGhpcy5fdXBkYXRlUGF0aHMsIHRoaXMpO1xuICBcdFx0dGhpcy5fZGVzdHJveUNvbnRhaW5lcigpO1xuICBcdH0sXG5cbiAgXHRnZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBldmVudHMgPSB7XG4gIFx0XHRcdHZpZXdyZXNldDogdGhpcy5fcmVzZXQsXG4gIFx0XHRcdHpvb206IHRoaXMuX29uWm9vbSxcbiAgXHRcdFx0bW92ZWVuZDogdGhpcy5fdXBkYXRlLFxuICBcdFx0XHR6b29tZW5kOiB0aGlzLl9vblpvb21FbmRcbiAgXHRcdH07XG4gIFx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XG4gIFx0XHRcdGV2ZW50cy56b29tYW5pbSA9IHRoaXMuX29uQW5pbVpvb207XG4gIFx0XHR9XG4gIFx0XHRyZXR1cm4gZXZlbnRzO1xuICBcdH0sXG5cbiAgXHRfb25BbmltWm9vbTogZnVuY3Rpb24gKGV2KSB7XG4gIFx0XHR0aGlzLl91cGRhdGVUcmFuc2Zvcm0oZXYuY2VudGVyLCBldi56b29tKTtcbiAgXHR9LFxuXG4gIFx0X29uWm9vbTogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5fdXBkYXRlVHJhbnNmb3JtKHRoaXMuX21hcC5nZXRDZW50ZXIoKSwgdGhpcy5fbWFwLmdldFpvb20oKSk7XG4gIFx0fSxcblxuICBcdF91cGRhdGVUcmFuc2Zvcm06IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20pIHtcbiAgXHRcdHZhciBzY2FsZSA9IHRoaXMuX21hcC5nZXRab29tU2NhbGUoem9vbSwgdGhpcy5fem9vbSksXG4gIFx0XHQgICAgcG9zaXRpb24gPSBnZXRQb3NpdGlvbih0aGlzLl9jb250YWluZXIpLFxuICBcdFx0ICAgIHZpZXdIYWxmID0gdGhpcy5fbWFwLmdldFNpemUoKS5tdWx0aXBseUJ5KDAuNSArIHRoaXMub3B0aW9ucy5wYWRkaW5nKSxcbiAgXHRcdCAgICBjdXJyZW50Q2VudGVyUG9pbnQgPSB0aGlzLl9tYXAucHJvamVjdCh0aGlzLl9jZW50ZXIsIHpvb20pLFxuICBcdFx0ICAgIGRlc3RDZW50ZXJQb2ludCA9IHRoaXMuX21hcC5wcm9qZWN0KGNlbnRlciwgem9vbSksXG4gIFx0XHQgICAgY2VudGVyT2Zmc2V0ID0gZGVzdENlbnRlclBvaW50LnN1YnRyYWN0KGN1cnJlbnRDZW50ZXJQb2ludCksXG5cbiAgXHRcdCAgICB0b3BMZWZ0T2Zmc2V0ID0gdmlld0hhbGYubXVsdGlwbHlCeSgtc2NhbGUpLmFkZChwb3NpdGlvbikuYWRkKHZpZXdIYWxmKS5zdWJ0cmFjdChjZW50ZXJPZmZzZXQpO1xuXG4gIFx0XHRpZiAoYW55M2QpIHtcbiAgXHRcdFx0c2V0VHJhbnNmb3JtKHRoaXMuX2NvbnRhaW5lciwgdG9wTGVmdE9mZnNldCwgc2NhbGUpO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0c2V0UG9zaXRpb24odGhpcy5fY29udGFpbmVyLCB0b3BMZWZ0T2Zmc2V0KTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X3Jlc2V0OiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLl91cGRhdGUoKTtcbiAgXHRcdHRoaXMuX3VwZGF0ZVRyYW5zZm9ybSh0aGlzLl9jZW50ZXIsIHRoaXMuX3pvb20pO1xuXG4gIFx0XHRmb3IgKHZhciBpZCBpbiB0aGlzLl9sYXllcnMpIHtcbiAgXHRcdFx0dGhpcy5fbGF5ZXJzW2lkXS5fcmVzZXQoKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X29uWm9vbUVuZDogZnVuY3Rpb24gKCkge1xuICBcdFx0Zm9yICh2YXIgaWQgaW4gdGhpcy5fbGF5ZXJzKSB7XG4gIFx0XHRcdHRoaXMuX2xheWVyc1tpZF0uX3Byb2plY3QoKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X3VwZGF0ZVBhdGhzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRmb3IgKHZhciBpZCBpbiB0aGlzLl9sYXllcnMpIHtcbiAgXHRcdFx0dGhpcy5fbGF5ZXJzW2lkXS5fdXBkYXRlKCk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdC8vIFVwZGF0ZSBwaXhlbCBib3VuZHMgb2YgcmVuZGVyZXIgY29udGFpbmVyIChmb3IgcG9zaXRpb25pbmcvc2l6aW5nL2NsaXBwaW5nIGxhdGVyKVxuICBcdFx0Ly8gU3ViY2xhc3NlcyBhcmUgcmVzcG9uc2libGUgb2YgZmlyaW5nIHRoZSAndXBkYXRlJyBldmVudC5cbiAgXHRcdHZhciBwID0gdGhpcy5vcHRpb25zLnBhZGRpbmcsXG4gIFx0XHQgICAgc2l6ZSA9IHRoaXMuX21hcC5nZXRTaXplKCksXG4gIFx0XHQgICAgbWluID0gdGhpcy5fbWFwLmNvbnRhaW5lclBvaW50VG9MYXllclBvaW50KHNpemUubXVsdGlwbHlCeSgtcCkpLnJvdW5kKCk7XG5cbiAgXHRcdHRoaXMuX2JvdW5kcyA9IG5ldyBCb3VuZHMobWluLCBtaW4uYWRkKHNpemUubXVsdGlwbHlCeSgxICsgcCAqIDIpKS5yb3VuZCgpKTtcblxuICBcdFx0dGhpcy5fY2VudGVyID0gdGhpcy5fbWFwLmdldENlbnRlcigpO1xuICBcdFx0dGhpcy5fem9vbSA9IHRoaXMuX21hcC5nZXRab29tKCk7XG4gIFx0fVxuICB9KTtcblxuICAvKlxuICAgKiBAY2xhc3MgQ2FudmFzXG4gICAqIEBpbmhlcml0cyBSZW5kZXJlclxuICAgKiBAYWthIEwuQ2FudmFzXG4gICAqXG4gICAqIEFsbG93cyB2ZWN0b3IgbGF5ZXJzIHRvIGJlIGRpc3BsYXllZCB3aXRoIFtgPGNhbnZhcz5gXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvQ2FudmFzX0FQSSkuXG4gICAqIEluaGVyaXRzIGBSZW5kZXJlcmAuXG4gICAqXG4gICAqIER1ZSB0byBbdGVjaG5pY2FsIGxpbWl0YXRpb25zXShodHRwOi8vY2FuaXVzZS5jb20vI3NlYXJjaD1jYW52YXMpLCBDYW52YXMgaXMgbm90XG4gICAqIGF2YWlsYWJsZSBpbiBhbGwgd2ViIGJyb3dzZXJzLCBub3RhYmx5IElFOCwgYW5kIG92ZXJsYXBwaW5nIGdlb21ldHJpZXMgbWlnaHRcbiAgICogbm90IGRpc3BsYXkgcHJvcGVybHkgaW4gc29tZSBlZGdlIGNhc2VzLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBVc2UgQ2FudmFzIGJ5IGRlZmF1bHQgZm9yIGFsbCBwYXRocyBpbiB0aGUgbWFwOlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiB2YXIgbWFwID0gTC5tYXAoJ21hcCcsIHtcbiAgICogXHRyZW5kZXJlcjogTC5jYW52YXMoKVxuICAgKiB9KTtcbiAgICogYGBgXG4gICAqXG4gICAqIFVzZSBhIENhbnZhcyByZW5kZXJlciB3aXRoIGV4dHJhIHBhZGRpbmcgZm9yIHNwZWNpZmljIHZlY3RvciBnZW9tZXRyaWVzOlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiB2YXIgbWFwID0gTC5tYXAoJ21hcCcpO1xuICAgKiB2YXIgbXlSZW5kZXJlciA9IEwuY2FudmFzKHsgcGFkZGluZzogMC41IH0pO1xuICAgKiB2YXIgbGluZSA9IEwucG9seWxpbmUoIGNvb3JkaW5hdGVzLCB7IHJlbmRlcmVyOiBteVJlbmRlcmVyIH0gKTtcbiAgICogdmFyIGNpcmNsZSA9IEwuY2lyY2xlKCBjZW50ZXIsIHsgcmVuZGVyZXI6IG15UmVuZGVyZXIgfSApO1xuICAgKiBgYGBcbiAgICovXG5cbiAgdmFyIENhbnZhcyA9IFJlbmRlcmVyLmV4dGVuZCh7XG4gIFx0Z2V0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgZXZlbnRzID0gUmVuZGVyZXIucHJvdG90eXBlLmdldEV2ZW50cy5jYWxsKHRoaXMpO1xuICBcdFx0ZXZlbnRzLnZpZXdwcmVyZXNldCA9IHRoaXMuX29uVmlld1ByZVJlc2V0O1xuICBcdFx0cmV0dXJuIGV2ZW50cztcbiAgXHR9LFxuXG4gIFx0X29uVmlld1ByZVJlc2V0OiBmdW5jdGlvbiAoKSB7XG4gIFx0XHQvLyBTZXQgYSBmbGFnIHNvIHRoYXQgYSB2aWV3cHJlcmVzZXQrbW92ZWVuZCt2aWV3cmVzZXQgb25seSB1cGRhdGVzJnJlZHJhd3Mgb25jZVxuICBcdFx0dGhpcy5fcG9zdHBvbmVVcGRhdGVQYXRocyA9IHRydWU7XG4gIFx0fSxcblxuICBcdG9uQWRkOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRSZW5kZXJlci5wcm90b3R5cGUub25BZGQuY2FsbCh0aGlzKTtcblxuICBcdFx0Ly8gUmVkcmF3IHZlY3RvcnMgc2luY2UgY2FudmFzIGlzIGNsZWFyZWQgdXBvbiByZW1vdmFsLFxuICBcdFx0Ly8gaW4gY2FzZSBvZiByZW1vdmluZyB0aGUgcmVuZGVyZXIgaXRzZWxmIGZyb20gdGhlIG1hcC5cbiAgXHRcdHRoaXMuX2RyYXcoKTtcbiAgXHR9LFxuXG4gIFx0X2luaXRDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcblxuICBcdFx0b24oY29udGFpbmVyLCAnbW91c2Vtb3ZlJywgdGhpcy5fb25Nb3VzZU1vdmUsIHRoaXMpO1xuICBcdFx0b24oY29udGFpbmVyLCAnY2xpY2sgZGJsY2xpY2sgbW91c2Vkb3duIG1vdXNldXAgY29udGV4dG1lbnUnLCB0aGlzLl9vbkNsaWNrLCB0aGlzKTtcbiAgXHRcdG9uKGNvbnRhaW5lciwgJ21vdXNlb3V0JywgdGhpcy5faGFuZGxlTW91c2VPdXQsIHRoaXMpO1xuXG4gIFx0XHR0aGlzLl9jdHggPSBjb250YWluZXIuZ2V0Q29udGV4dCgnMmQnKTtcbiAgXHR9LFxuXG4gIFx0X2Rlc3Ryb3lDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGNhbmNlbEFuaW1GcmFtZSh0aGlzLl9yZWRyYXdSZXF1ZXN0KTtcbiAgXHRcdGRlbGV0ZSB0aGlzLl9jdHg7XG4gIFx0XHRyZW1vdmUodGhpcy5fY29udGFpbmVyKTtcbiAgXHRcdG9mZih0aGlzLl9jb250YWluZXIpO1xuICBcdFx0ZGVsZXRlIHRoaXMuX2NvbnRhaW5lcjtcbiAgXHR9LFxuXG4gIFx0X3VwZGF0ZVBhdGhzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAodGhpcy5fcG9zdHBvbmVVcGRhdGVQYXRocykgeyByZXR1cm47IH1cblxuICBcdFx0dmFyIGxheWVyO1xuICBcdFx0dGhpcy5fcmVkcmF3Qm91bmRzID0gbnVsbDtcbiAgXHRcdGZvciAodmFyIGlkIGluIHRoaXMuX2xheWVycykge1xuICBcdFx0XHRsYXllciA9IHRoaXMuX2xheWVyc1tpZF07XG4gIFx0XHRcdGxheWVyLl91cGRhdGUoKTtcbiAgXHRcdH1cbiAgXHRcdHRoaXMuX3JlZHJhdygpO1xuICBcdH0sXG5cbiAgXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAodGhpcy5fbWFwLl9hbmltYXRpbmdab29tICYmIHRoaXMuX2JvdW5kcykgeyByZXR1cm47IH1cblxuICBcdFx0UmVuZGVyZXIucHJvdG90eXBlLl91cGRhdGUuY2FsbCh0aGlzKTtcblxuICBcdFx0dmFyIGIgPSB0aGlzLl9ib3VuZHMsXG4gIFx0XHQgICAgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyLFxuICBcdFx0ICAgIHNpemUgPSBiLmdldFNpemUoKSxcbiAgXHRcdCAgICBtID0gcmV0aW5hID8gMiA6IDE7XG5cbiAgXHRcdHNldFBvc2l0aW9uKGNvbnRhaW5lciwgYi5taW4pO1xuXG4gIFx0XHQvLyBzZXQgY2FudmFzIHNpemUgKGFsc28gY2xlYXJpbmcgaXQpOyB1c2UgZG91YmxlIHNpemUgb24gcmV0aW5hXG4gIFx0XHRjb250YWluZXIud2lkdGggPSBtICogc2l6ZS54O1xuICBcdFx0Y29udGFpbmVyLmhlaWdodCA9IG0gKiBzaXplLnk7XG4gIFx0XHRjb250YWluZXIuc3R5bGUud2lkdGggPSBzaXplLnggKyAncHgnO1xuICBcdFx0Y29udGFpbmVyLnN0eWxlLmhlaWdodCA9IHNpemUueSArICdweCc7XG5cbiAgXHRcdGlmIChyZXRpbmEpIHtcbiAgXHRcdFx0dGhpcy5fY3R4LnNjYWxlKDIsIDIpO1xuICBcdFx0fVxuXG4gIFx0XHQvLyB0cmFuc2xhdGUgc28gd2UgdXNlIHRoZSBzYW1lIHBhdGggY29vcmRpbmF0ZXMgYWZ0ZXIgY2FudmFzIGVsZW1lbnQgbW92ZXNcbiAgXHRcdHRoaXMuX2N0eC50cmFuc2xhdGUoLWIubWluLngsIC1iLm1pbi55KTtcblxuICBcdFx0Ly8gVGVsbCBwYXRocyB0byByZWRyYXcgdGhlbXNlbHZlc1xuICBcdFx0dGhpcy5maXJlKCd1cGRhdGUnKTtcbiAgXHR9LFxuXG4gIFx0X3Jlc2V0OiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRSZW5kZXJlci5wcm90b3R5cGUuX3Jlc2V0LmNhbGwodGhpcyk7XG5cbiAgXHRcdGlmICh0aGlzLl9wb3N0cG9uZVVwZGF0ZVBhdGhzKSB7XG4gIFx0XHRcdHRoaXMuX3Bvc3Rwb25lVXBkYXRlUGF0aHMgPSBmYWxzZTtcbiAgXHRcdFx0dGhpcy5fdXBkYXRlUGF0aHMoKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X2luaXRQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgXHRcdHRoaXMuX3VwZGF0ZURhc2hBcnJheShsYXllcik7XG4gIFx0XHR0aGlzLl9sYXllcnNbc3RhbXAobGF5ZXIpXSA9IGxheWVyO1xuXG4gIFx0XHR2YXIgb3JkZXIgPSBsYXllci5fb3JkZXIgPSB7XG4gIFx0XHRcdGxheWVyOiBsYXllcixcbiAgXHRcdFx0cHJldjogdGhpcy5fZHJhd0xhc3QsXG4gIFx0XHRcdG5leHQ6IG51bGxcbiAgXHRcdH07XG4gIFx0XHRpZiAodGhpcy5fZHJhd0xhc3QpIHsgdGhpcy5fZHJhd0xhc3QubmV4dCA9IG9yZGVyOyB9XG4gIFx0XHR0aGlzLl9kcmF3TGFzdCA9IG9yZGVyO1xuICBcdFx0dGhpcy5fZHJhd0ZpcnN0ID0gdGhpcy5fZHJhd0ZpcnN0IHx8IHRoaXMuX2RyYXdMYXN0O1xuICBcdH0sXG5cbiAgXHRfYWRkUGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG4gIFx0XHR0aGlzLl9yZXF1ZXN0UmVkcmF3KGxheWVyKTtcbiAgXHR9LFxuXG4gIFx0X3JlbW92ZVBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuICBcdFx0dmFyIG9yZGVyID0gbGF5ZXIuX29yZGVyO1xuICBcdFx0dmFyIG5leHQgPSBvcmRlci5uZXh0O1xuICBcdFx0dmFyIHByZXYgPSBvcmRlci5wcmV2O1xuXG4gIFx0XHRpZiAobmV4dCkge1xuICBcdFx0XHRuZXh0LnByZXYgPSBwcmV2O1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0dGhpcy5fZHJhd0xhc3QgPSBwcmV2O1xuICBcdFx0fVxuICBcdFx0aWYgKHByZXYpIHtcbiAgXHRcdFx0cHJldi5uZXh0ID0gbmV4dDtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHRoaXMuX2RyYXdGaXJzdCA9IG5leHQ7XG4gIFx0XHR9XG5cbiAgXHRcdGRlbGV0ZSBsYXllci5fb3JkZXI7XG5cbiAgXHRcdGRlbGV0ZSB0aGlzLl9sYXllcnNbc3RhbXAobGF5ZXIpXTtcblxuICBcdFx0dGhpcy5fcmVxdWVzdFJlZHJhdyhsYXllcik7XG4gIFx0fSxcblxuICBcdF91cGRhdGVQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgXHRcdC8vIFJlZHJhdyB0aGUgdW5pb24gb2YgdGhlIGxheWVyJ3Mgb2xkIHBpeGVsXG4gIFx0XHQvLyBib3VuZHMgYW5kIHRoZSBuZXcgcGl4ZWwgYm91bmRzLlxuICBcdFx0dGhpcy5fZXh0ZW5kUmVkcmF3Qm91bmRzKGxheWVyKTtcbiAgXHRcdGxheWVyLl9wcm9qZWN0KCk7XG4gIFx0XHRsYXllci5fdXBkYXRlKCk7XG4gIFx0XHQvLyBUaGUgcmVkcmF3IHdpbGwgZXh0ZW5kIHRoZSByZWRyYXcgYm91bmRzXG4gIFx0XHQvLyB3aXRoIHRoZSBuZXcgcGl4ZWwgYm91bmRzLlxuICBcdFx0dGhpcy5fcmVxdWVzdFJlZHJhdyhsYXllcik7XG4gIFx0fSxcblxuICBcdF91cGRhdGVTdHlsZTogZnVuY3Rpb24gKGxheWVyKSB7XG4gIFx0XHR0aGlzLl91cGRhdGVEYXNoQXJyYXkobGF5ZXIpO1xuICBcdFx0dGhpcy5fcmVxdWVzdFJlZHJhdyhsYXllcik7XG4gIFx0fSxcblxuICBcdF91cGRhdGVEYXNoQXJyYXk6IGZ1bmN0aW9uIChsYXllcikge1xuICBcdFx0aWYgKHR5cGVvZiBsYXllci5vcHRpb25zLmRhc2hBcnJheSA9PT0gJ3N0cmluZycpIHtcbiAgXHRcdFx0dmFyIHBhcnRzID0gbGF5ZXIub3B0aW9ucy5kYXNoQXJyYXkuc3BsaXQoL1ssIF0rLyksXG4gIFx0XHRcdCAgICBkYXNoQXJyYXkgPSBbXSxcbiAgXHRcdFx0ICAgIGRhc2hWYWx1ZSxcbiAgXHRcdFx0ICAgIGk7XG4gIFx0XHRcdGZvciAoaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xuICBcdFx0XHRcdGRhc2hWYWx1ZSA9IE51bWJlcihwYXJ0c1tpXSk7XG4gIFx0XHRcdFx0Ly8gSWdub3JlIGRhc2ggYXJyYXkgY29udGFpbmluZyBpbnZhbGlkIGxlbmd0aHNcbiAgXHRcdFx0XHRpZiAoaXNOYU4oZGFzaFZhbHVlKSkgeyByZXR1cm47IH1cbiAgXHRcdFx0XHRkYXNoQXJyYXkucHVzaChkYXNoVmFsdWUpO1xuICBcdFx0XHR9XG4gIFx0XHRcdGxheWVyLm9wdGlvbnMuX2Rhc2hBcnJheSA9IGRhc2hBcnJheTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdGxheWVyLm9wdGlvbnMuX2Rhc2hBcnJheSA9IGxheWVyLm9wdGlvbnMuZGFzaEFycmF5O1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfcmVxdWVzdFJlZHJhdzogZnVuY3Rpb24gKGxheWVyKSB7XG4gIFx0XHRpZiAoIXRoaXMuX21hcCkgeyByZXR1cm47IH1cblxuICBcdFx0dGhpcy5fZXh0ZW5kUmVkcmF3Qm91bmRzKGxheWVyKTtcbiAgXHRcdHRoaXMuX3JlZHJhd1JlcXVlc3QgPSB0aGlzLl9yZWRyYXdSZXF1ZXN0IHx8IHJlcXVlc3RBbmltRnJhbWUodGhpcy5fcmVkcmF3LCB0aGlzKTtcbiAgXHR9LFxuXG4gIFx0X2V4dGVuZFJlZHJhd0JvdW5kczogZnVuY3Rpb24gKGxheWVyKSB7XG4gIFx0XHRpZiAobGF5ZXIuX3B4Qm91bmRzKSB7XG4gIFx0XHRcdHZhciBwYWRkaW5nID0gKGxheWVyLm9wdGlvbnMud2VpZ2h0IHx8IDApICsgMTtcbiAgXHRcdFx0dGhpcy5fcmVkcmF3Qm91bmRzID0gdGhpcy5fcmVkcmF3Qm91bmRzIHx8IG5ldyBCb3VuZHMoKTtcbiAgXHRcdFx0dGhpcy5fcmVkcmF3Qm91bmRzLmV4dGVuZChsYXllci5fcHhCb3VuZHMubWluLnN1YnRyYWN0KFtwYWRkaW5nLCBwYWRkaW5nXSkpO1xuICBcdFx0XHR0aGlzLl9yZWRyYXdCb3VuZHMuZXh0ZW5kKGxheWVyLl9weEJvdW5kcy5tYXguYWRkKFtwYWRkaW5nLCBwYWRkaW5nXSkpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfcmVkcmF3OiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLl9yZWRyYXdSZXF1ZXN0ID0gbnVsbDtcblxuICBcdFx0aWYgKHRoaXMuX3JlZHJhd0JvdW5kcykge1xuICBcdFx0XHR0aGlzLl9yZWRyYXdCb3VuZHMubWluLl9mbG9vcigpO1xuICBcdFx0XHR0aGlzLl9yZWRyYXdCb3VuZHMubWF4Ll9jZWlsKCk7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMuX2NsZWFyKCk7IC8vIGNsZWFyIGxheWVycyBpbiByZWRyYXcgYm91bmRzXG4gIFx0XHR0aGlzLl9kcmF3KCk7IC8vIGRyYXcgbGF5ZXJzXG5cbiAgXHRcdHRoaXMuX3JlZHJhd0JvdW5kcyA9IG51bGw7XG4gIFx0fSxcblxuICBcdF9jbGVhcjogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIGJvdW5kcyA9IHRoaXMuX3JlZHJhd0JvdW5kcztcbiAgXHRcdGlmIChib3VuZHMpIHtcbiAgXHRcdFx0dmFyIHNpemUgPSBib3VuZHMuZ2V0U2l6ZSgpO1xuICBcdFx0XHR0aGlzLl9jdHguY2xlYXJSZWN0KGJvdW5kcy5taW4ueCwgYm91bmRzLm1pbi55LCBzaXplLngsIHNpemUueSk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHR0aGlzLl9jdHguc2F2ZSgpO1xuICBcdFx0XHR0aGlzLl9jdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICBcdFx0XHR0aGlzLl9jdHguY2xlYXJSZWN0KDAsIDAsIHRoaXMuX2NvbnRhaW5lci53aWR0aCwgdGhpcy5fY29udGFpbmVyLmhlaWdodCk7XG4gIFx0XHRcdHRoaXMuX2N0eC5yZXN0b3JlKCk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF9kcmF3OiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgbGF5ZXIsIGJvdW5kcyA9IHRoaXMuX3JlZHJhd0JvdW5kcztcbiAgXHRcdHRoaXMuX2N0eC5zYXZlKCk7XG4gIFx0XHRpZiAoYm91bmRzKSB7XG4gIFx0XHRcdHZhciBzaXplID0gYm91bmRzLmdldFNpemUoKTtcbiAgXHRcdFx0dGhpcy5fY3R4LmJlZ2luUGF0aCgpO1xuICBcdFx0XHR0aGlzLl9jdHgucmVjdChib3VuZHMubWluLngsIGJvdW5kcy5taW4ueSwgc2l6ZS54LCBzaXplLnkpO1xuICBcdFx0XHR0aGlzLl9jdHguY2xpcCgpO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLl9kcmF3aW5nID0gdHJ1ZTtcblxuICBcdFx0Zm9yICh2YXIgb3JkZXIgPSB0aGlzLl9kcmF3Rmlyc3Q7IG9yZGVyOyBvcmRlciA9IG9yZGVyLm5leHQpIHtcbiAgXHRcdFx0bGF5ZXIgPSBvcmRlci5sYXllcjtcbiAgXHRcdFx0aWYgKCFib3VuZHMgfHwgKGxheWVyLl9weEJvdW5kcyAmJiBsYXllci5fcHhCb3VuZHMuaW50ZXJzZWN0cyhib3VuZHMpKSkge1xuICBcdFx0XHRcdGxheWVyLl91cGRhdGVQYXRoKCk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0dGhpcy5fZHJhd2luZyA9IGZhbHNlO1xuXG4gIFx0XHR0aGlzLl9jdHgucmVzdG9yZSgpOyAgLy8gUmVzdG9yZSBzdGF0ZSBiZWZvcmUgY2xpcHBpbmcuXG4gIFx0fSxcblxuICBcdF91cGRhdGVQb2x5OiBmdW5jdGlvbiAobGF5ZXIsIGNsb3NlZCkge1xuICBcdFx0aWYgKCF0aGlzLl9kcmF3aW5nKSB7IHJldHVybjsgfVxuXG4gIFx0XHR2YXIgaSwgaiwgbGVuMiwgcCxcbiAgXHRcdCAgICBwYXJ0cyA9IGxheWVyLl9wYXJ0cyxcbiAgXHRcdCAgICBsZW4gPSBwYXJ0cy5sZW5ndGgsXG4gIFx0XHQgICAgY3R4ID0gdGhpcy5fY3R4O1xuXG4gIFx0XHRpZiAoIWxlbikgeyByZXR1cm47IH1cblxuICBcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXG4gIFx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgXHRcdFx0Zm9yIChqID0gMCwgbGVuMiA9IHBhcnRzW2ldLmxlbmd0aDsgaiA8IGxlbjI7IGorKykge1xuICBcdFx0XHRcdHAgPSBwYXJ0c1tpXVtqXTtcbiAgXHRcdFx0XHRjdHhbaiA/ICdsaW5lVG8nIDogJ21vdmVUbyddKHAueCwgcC55KTtcbiAgXHRcdFx0fVxuICBcdFx0XHRpZiAoY2xvc2VkKSB7XG4gIFx0XHRcdFx0Y3R4LmNsb3NlUGF0aCgpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMuX2ZpbGxTdHJva2UoY3R4LCBsYXllcik7XG5cbiAgXHRcdC8vIFRPRE8gb3B0aW1pemF0aW9uOiAxIGZpbGwvc3Ryb2tlIGZvciBhbGwgZmVhdHVyZXMgd2l0aCBlcXVhbCBzdHlsZSBpbnN0ZWFkIG9mIDEgZm9yIGVhY2ggZmVhdHVyZVxuICBcdH0sXG5cbiAgXHRfdXBkYXRlQ2lyY2xlOiBmdW5jdGlvbiAobGF5ZXIpIHtcblxuICBcdFx0aWYgKCF0aGlzLl9kcmF3aW5nIHx8IGxheWVyLl9lbXB0eSgpKSB7IHJldHVybjsgfVxuXG4gIFx0XHR2YXIgcCA9IGxheWVyLl9wb2ludCxcbiAgXHRcdCAgICBjdHggPSB0aGlzLl9jdHgsXG4gIFx0XHQgICAgciA9IE1hdGgubWF4KE1hdGgucm91bmQobGF5ZXIuX3JhZGl1cyksIDEpLFxuICBcdFx0ICAgIHMgPSAoTWF0aC5tYXgoTWF0aC5yb3VuZChsYXllci5fcmFkaXVzWSksIDEpIHx8IHIpIC8gcjtcblxuICBcdFx0aWYgKHMgIT09IDEpIHtcbiAgXHRcdFx0Y3R4LnNhdmUoKTtcbiAgXHRcdFx0Y3R4LnNjYWxlKDEsIHMpO1xuICBcdFx0fVxuXG4gIFx0XHRjdHguYmVnaW5QYXRoKCk7XG4gIFx0XHRjdHguYXJjKHAueCwgcC55IC8gcywgciwgMCwgTWF0aC5QSSAqIDIsIGZhbHNlKTtcblxuICBcdFx0aWYgKHMgIT09IDEpIHtcbiAgXHRcdFx0Y3R4LnJlc3RvcmUoKTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5fZmlsbFN0cm9rZShjdHgsIGxheWVyKTtcbiAgXHR9LFxuXG4gIFx0X2ZpbGxTdHJva2U6IGZ1bmN0aW9uIChjdHgsIGxheWVyKSB7XG4gIFx0XHR2YXIgb3B0aW9ucyA9IGxheWVyLm9wdGlvbnM7XG5cbiAgXHRcdGlmIChvcHRpb25zLmZpbGwpIHtcbiAgXHRcdFx0Y3R4Lmdsb2JhbEFscGhhID0gb3B0aW9ucy5maWxsT3BhY2l0eTtcbiAgXHRcdFx0Y3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMuZmlsbENvbG9yIHx8IG9wdGlvbnMuY29sb3I7XG4gIFx0XHRcdGN0eC5maWxsKG9wdGlvbnMuZmlsbFJ1bGUgfHwgJ2V2ZW5vZGQnKTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKG9wdGlvbnMuc3Ryb2tlICYmIG9wdGlvbnMud2VpZ2h0ICE9PSAwKSB7XG4gIFx0XHRcdGlmIChjdHguc2V0TGluZURhc2gpIHtcbiAgXHRcdFx0XHRjdHguc2V0TGluZURhc2gobGF5ZXIub3B0aW9ucyAmJiBsYXllci5vcHRpb25zLl9kYXNoQXJyYXkgfHwgW10pO1xuICBcdFx0XHR9XG4gIFx0XHRcdGN0eC5nbG9iYWxBbHBoYSA9IG9wdGlvbnMub3BhY2l0eTtcbiAgXHRcdFx0Y3R4LmxpbmVXaWR0aCA9IG9wdGlvbnMud2VpZ2h0O1xuICBcdFx0XHRjdHguc3Ryb2tlU3R5bGUgPSBvcHRpb25zLmNvbG9yO1xuICBcdFx0XHRjdHgubGluZUNhcCA9IG9wdGlvbnMubGluZUNhcDtcbiAgXHRcdFx0Y3R4LmxpbmVKb2luID0gb3B0aW9ucy5saW5lSm9pbjtcbiAgXHRcdFx0Y3R4LnN0cm9rZSgpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHQvLyBDYW52YXMgb2J2aW91c2x5IGRvZXNuJ3QgaGF2ZSBtb3VzZSBldmVudHMgZm9yIGluZGl2aWR1YWwgZHJhd24gb2JqZWN0cyxcbiAgXHQvLyBzbyB3ZSBlbXVsYXRlIHRoYXQgYnkgY2FsY3VsYXRpbmcgd2hhdCdzIHVuZGVyIHRoZSBtb3VzZSBvbiBtb3VzZW1vdmUvY2xpY2sgbWFudWFsbHlcblxuICBcdF9vbkNsaWNrOiBmdW5jdGlvbiAoZSkge1xuICBcdFx0dmFyIHBvaW50ID0gdGhpcy5fbWFwLm1vdXNlRXZlbnRUb0xheWVyUG9pbnQoZSksIGxheWVyLCBjbGlja2VkTGF5ZXI7XG5cbiAgXHRcdGZvciAodmFyIG9yZGVyID0gdGhpcy5fZHJhd0ZpcnN0OyBvcmRlcjsgb3JkZXIgPSBvcmRlci5uZXh0KSB7XG4gIFx0XHRcdGxheWVyID0gb3JkZXIubGF5ZXI7XG4gIFx0XHRcdGlmIChsYXllci5vcHRpb25zLmludGVyYWN0aXZlICYmIGxheWVyLl9jb250YWluc1BvaW50KHBvaW50KSkge1xuICBcdFx0XHRcdGlmICghKGUudHlwZSA9PT0gJ2NsaWNrJyB8fCBlLnR5cGUgIT09ICdwcmVjbGljaycpIHx8ICF0aGlzLl9tYXAuX2RyYWdnYWJsZU1vdmVkKGxheWVyKSkge1xuICBcdFx0XHRcdFx0Y2xpY2tlZExheWVyID0gbGF5ZXI7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0XHRpZiAoY2xpY2tlZExheWVyKSAge1xuICBcdFx0XHRmYWtlU3RvcChlKTtcbiAgXHRcdFx0dGhpcy5fZmlyZUV2ZW50KFtjbGlja2VkTGF5ZXJdLCBlKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X29uTW91c2VNb3ZlOiBmdW5jdGlvbiAoZSkge1xuICBcdFx0aWYgKCF0aGlzLl9tYXAgfHwgdGhpcy5fbWFwLmRyYWdnaW5nLm1vdmluZygpIHx8IHRoaXMuX21hcC5fYW5pbWF0aW5nWm9vbSkgeyByZXR1cm47IH1cblxuICBcdFx0dmFyIHBvaW50ID0gdGhpcy5fbWFwLm1vdXNlRXZlbnRUb0xheWVyUG9pbnQoZSk7XG4gIFx0XHR0aGlzLl9oYW5kbGVNb3VzZUhvdmVyKGUsIHBvaW50KTtcbiAgXHR9LFxuXG5cbiAgXHRfaGFuZGxlTW91c2VPdXQ6IGZ1bmN0aW9uIChlKSB7XG4gIFx0XHR2YXIgbGF5ZXIgPSB0aGlzLl9ob3ZlcmVkTGF5ZXI7XG4gIFx0XHRpZiAobGF5ZXIpIHtcbiAgXHRcdFx0Ly8gaWYgd2UncmUgbGVhdmluZyB0aGUgbGF5ZXIsIGZpcmUgbW91c2VvdXRcbiAgXHRcdFx0cmVtb3ZlQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC1pbnRlcmFjdGl2ZScpO1xuICBcdFx0XHR0aGlzLl9maXJlRXZlbnQoW2xheWVyXSwgZSwgJ21vdXNlb3V0Jyk7XG4gIFx0XHRcdHRoaXMuX2hvdmVyZWRMYXllciA9IG51bGw7XG4gIFx0XHRcdHRoaXMuX21vdXNlSG92ZXJUaHJvdHRsZWQgPSBmYWxzZTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X2hhbmRsZU1vdXNlSG92ZXI6IGZ1bmN0aW9uIChlLCBwb2ludCkge1xuICBcdFx0aWYgKHRoaXMuX21vdXNlSG92ZXJUaHJvdHRsZWQpIHtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHR2YXIgbGF5ZXIsIGNhbmRpZGF0ZUhvdmVyZWRMYXllcjtcblxuICBcdFx0Zm9yICh2YXIgb3JkZXIgPSB0aGlzLl9kcmF3Rmlyc3Q7IG9yZGVyOyBvcmRlciA9IG9yZGVyLm5leHQpIHtcbiAgXHRcdFx0bGF5ZXIgPSBvcmRlci5sYXllcjtcbiAgXHRcdFx0aWYgKGxheWVyLm9wdGlvbnMuaW50ZXJhY3RpdmUgJiYgbGF5ZXIuX2NvbnRhaW5zUG9pbnQocG9pbnQpKSB7XG4gIFx0XHRcdFx0Y2FuZGlkYXRlSG92ZXJlZExheWVyID0gbGF5ZXI7XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0aWYgKGNhbmRpZGF0ZUhvdmVyZWRMYXllciAhPT0gdGhpcy5faG92ZXJlZExheWVyKSB7XG4gIFx0XHRcdHRoaXMuX2hhbmRsZU1vdXNlT3V0KGUpO1xuXG4gIFx0XHRcdGlmIChjYW5kaWRhdGVIb3ZlcmVkTGF5ZXIpIHtcbiAgXHRcdFx0XHRhZGRDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWludGVyYWN0aXZlJyk7IC8vIGNoYW5nZSBjdXJzb3JcbiAgXHRcdFx0XHR0aGlzLl9maXJlRXZlbnQoW2NhbmRpZGF0ZUhvdmVyZWRMYXllcl0sIGUsICdtb3VzZW92ZXInKTtcbiAgXHRcdFx0XHR0aGlzLl9ob3ZlcmVkTGF5ZXIgPSBjYW5kaWRhdGVIb3ZlcmVkTGF5ZXI7XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0aWYgKHRoaXMuX2hvdmVyZWRMYXllcikge1xuICBcdFx0XHR0aGlzLl9maXJlRXZlbnQoW3RoaXMuX2hvdmVyZWRMYXllcl0sIGUpO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLl9tb3VzZUhvdmVyVGhyb3R0bGVkID0gdHJ1ZTtcbiAgXHRcdHNldFRpbWVvdXQoYmluZChmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdHRoaXMuX21vdXNlSG92ZXJUaHJvdHRsZWQgPSBmYWxzZTtcbiAgXHRcdH0sIHRoaXMpLCAzMik7XG4gIFx0fSxcblxuICBcdF9maXJlRXZlbnQ6IGZ1bmN0aW9uIChsYXllcnMsIGUsIHR5cGUpIHtcbiAgXHRcdHRoaXMuX21hcC5fZmlyZURPTUV2ZW50KGUsIHR5cGUgfHwgZS50eXBlLCBsYXllcnMpO1xuICBcdH0sXG5cbiAgXHRfYnJpbmdUb0Zyb250OiBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgXHRcdHZhciBvcmRlciA9IGxheWVyLl9vcmRlcjtcblxuICBcdFx0aWYgKCFvcmRlcikgeyByZXR1cm47IH1cblxuICBcdFx0dmFyIG5leHQgPSBvcmRlci5uZXh0O1xuICBcdFx0dmFyIHByZXYgPSBvcmRlci5wcmV2O1xuXG4gIFx0XHRpZiAobmV4dCkge1xuICBcdFx0XHRuZXh0LnByZXYgPSBwcmV2O1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0Ly8gQWxyZWFkeSBsYXN0XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cbiAgXHRcdGlmIChwcmV2KSB7XG4gIFx0XHRcdHByZXYubmV4dCA9IG5leHQ7XG4gIFx0XHR9IGVsc2UgaWYgKG5leHQpIHtcbiAgXHRcdFx0Ly8gVXBkYXRlIGZpcnN0IGVudHJ5IHVubGVzcyB0aGlzIGlzIHRoZVxuICBcdFx0XHQvLyBzaW5nbGUgZW50cnlcbiAgXHRcdFx0dGhpcy5fZHJhd0ZpcnN0ID0gbmV4dDtcbiAgXHRcdH1cblxuICBcdFx0b3JkZXIucHJldiA9IHRoaXMuX2RyYXdMYXN0O1xuICBcdFx0dGhpcy5fZHJhd0xhc3QubmV4dCA9IG9yZGVyO1xuXG4gIFx0XHRvcmRlci5uZXh0ID0gbnVsbDtcbiAgXHRcdHRoaXMuX2RyYXdMYXN0ID0gb3JkZXI7XG5cbiAgXHRcdHRoaXMuX3JlcXVlc3RSZWRyYXcobGF5ZXIpO1xuICBcdH0sXG5cbiAgXHRfYnJpbmdUb0JhY2s6IGZ1bmN0aW9uIChsYXllcikge1xuICBcdFx0dmFyIG9yZGVyID0gbGF5ZXIuX29yZGVyO1xuXG4gIFx0XHRpZiAoIW9yZGVyKSB7IHJldHVybjsgfVxuXG4gIFx0XHR2YXIgbmV4dCA9IG9yZGVyLm5leHQ7XG4gIFx0XHR2YXIgcHJldiA9IG9yZGVyLnByZXY7XG5cbiAgXHRcdGlmIChwcmV2KSB7XG4gIFx0XHRcdHByZXYubmV4dCA9IG5leHQ7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHQvLyBBbHJlYWR5IGZpcnN0XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cbiAgXHRcdGlmIChuZXh0KSB7XG4gIFx0XHRcdG5leHQucHJldiA9IHByZXY7XG4gIFx0XHR9IGVsc2UgaWYgKHByZXYpIHtcbiAgXHRcdFx0Ly8gVXBkYXRlIGxhc3QgZW50cnkgdW5sZXNzIHRoaXMgaXMgdGhlXG4gIFx0XHRcdC8vIHNpbmdsZSBlbnRyeVxuICBcdFx0XHR0aGlzLl9kcmF3TGFzdCA9IHByZXY7XG4gIFx0XHR9XG5cbiAgXHRcdG9yZGVyLnByZXYgPSBudWxsO1xuXG4gIFx0XHRvcmRlci5uZXh0ID0gdGhpcy5fZHJhd0ZpcnN0O1xuICBcdFx0dGhpcy5fZHJhd0ZpcnN0LnByZXYgPSBvcmRlcjtcbiAgXHRcdHRoaXMuX2RyYXdGaXJzdCA9IG9yZGVyO1xuXG4gIFx0XHR0aGlzLl9yZXF1ZXN0UmVkcmF3KGxheWVyKTtcbiAgXHR9XG4gIH0pO1xuXG4gIC8vIEBmYWN0b3J5IEwuY2FudmFzKG9wdGlvbnM/OiBSZW5kZXJlciBvcHRpb25zKVxuICAvLyBDcmVhdGVzIGEgQ2FudmFzIHJlbmRlcmVyIHdpdGggdGhlIGdpdmVuIG9wdGlvbnMuXG4gIGZ1bmN0aW9uIGNhbnZhcyQxKG9wdGlvbnMpIHtcbiAgXHRyZXR1cm4gY2FudmFzID8gbmV3IENhbnZhcyhvcHRpb25zKSA6IG51bGw7XG4gIH1cblxuICAvKlxuICAgKiBUaGFua3MgdG8gRG1pdHJ5IEJhcmFub3Zza3kgYW5kIGhpcyBSYXBoYWVsIGxpYnJhcnkgZm9yIGluc3BpcmF0aW9uIVxuICAgKi9cblxuXG4gIHZhciB2bWxDcmVhdGUgPSAoZnVuY3Rpb24gKCkge1xuICBcdHRyeSB7XG4gIFx0XHRkb2N1bWVudC5uYW1lc3BhY2VzLmFkZCgnbHZtbCcsICd1cm46c2NoZW1hcy1taWNyb3NvZnQtY29tOnZtbCcpO1xuICBcdFx0cmV0dXJuIGZ1bmN0aW9uIChuYW1lKSB7XG4gIFx0XHRcdHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCc8bHZtbDonICsgbmFtZSArICcgY2xhc3M9XCJsdm1sXCI+Jyk7XG4gIFx0XHR9O1xuICBcdH0gY2F0Y2ggKGUpIHtcbiAgXHRcdHJldHVybiBmdW5jdGlvbiAobmFtZSkge1xuICBcdFx0XHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnPCcgKyBuYW1lICsgJyB4bWxucz1cInVybjpzY2hlbWFzLW1pY3Jvc29mdC5jb206dm1sXCIgY2xhc3M9XCJsdm1sXCI+Jyk7XG4gIFx0XHR9O1xuICBcdH1cbiAgfSkoKTtcblxuXG4gIC8qXG4gICAqIEBjbGFzcyBTVkdcbiAgICpcbiAgICpcbiAgICogVk1MIHdhcyBkZXByZWNhdGVkIGluIDIwMTIsIHdoaWNoIG1lYW5zIFZNTCBmdW5jdGlvbmFsaXR5IGV4aXN0cyBvbmx5IGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICAgKiB3aXRoIG9sZCB2ZXJzaW9ucyBvZiBJbnRlcm5ldCBFeHBsb3Jlci5cbiAgICovXG5cbiAgLy8gbWl4aW4gdG8gcmVkZWZpbmUgc29tZSBTVkcgbWV0aG9kcyB0byBoYW5kbGUgVk1MIHN5bnRheCB3aGljaCBpcyBzaW1pbGFyIGJ1dCB3aXRoIHNvbWUgZGlmZmVyZW5jZXNcbiAgdmFyIHZtbE1peGluID0ge1xuXG4gIFx0X2luaXRDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMuX2NvbnRhaW5lciA9IGNyZWF0ZSQxKCdkaXYnLCAnbGVhZmxldC12bWwtY29udGFpbmVyJyk7XG4gIFx0fSxcblxuICBcdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICh0aGlzLl9tYXAuX2FuaW1hdGluZ1pvb20pIHsgcmV0dXJuOyB9XG4gIFx0XHRSZW5kZXJlci5wcm90b3R5cGUuX3VwZGF0ZS5jYWxsKHRoaXMpO1xuICBcdFx0dGhpcy5maXJlKCd1cGRhdGUnKTtcbiAgXHR9LFxuXG4gIFx0X2luaXRQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgXHRcdHZhciBjb250YWluZXIgPSBsYXllci5fY29udGFpbmVyID0gdm1sQ3JlYXRlKCdzaGFwZScpO1xuXG4gIFx0XHRhZGRDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LXZtbC1zaGFwZSAnICsgKHRoaXMub3B0aW9ucy5jbGFzc05hbWUgfHwgJycpKTtcblxuICBcdFx0Y29udGFpbmVyLmNvb3Jkc2l6ZSA9ICcxIDEnO1xuXG4gIFx0XHRsYXllci5fcGF0aCA9IHZtbENyZWF0ZSgncGF0aCcpO1xuICBcdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKGxheWVyLl9wYXRoKTtcblxuICBcdFx0dGhpcy5fdXBkYXRlU3R5bGUobGF5ZXIpO1xuICBcdFx0dGhpcy5fbGF5ZXJzW3N0YW1wKGxheWVyKV0gPSBsYXllcjtcbiAgXHR9LFxuXG4gIFx0X2FkZFBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuICBcdFx0dmFyIGNvbnRhaW5lciA9IGxheWVyLl9jb250YWluZXI7XG4gIFx0XHR0aGlzLl9jb250YWluZXIuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcblxuICBcdFx0aWYgKGxheWVyLm9wdGlvbnMuaW50ZXJhY3RpdmUpIHtcbiAgXHRcdFx0bGF5ZXIuYWRkSW50ZXJhY3RpdmVUYXJnZXQoY29udGFpbmVyKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X3JlbW92ZVBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuICBcdFx0dmFyIGNvbnRhaW5lciA9IGxheWVyLl9jb250YWluZXI7XG4gIFx0XHRyZW1vdmUoY29udGFpbmVyKTtcbiAgXHRcdGxheWVyLnJlbW92ZUludGVyYWN0aXZlVGFyZ2V0KGNvbnRhaW5lcik7XG4gIFx0XHRkZWxldGUgdGhpcy5fbGF5ZXJzW3N0YW1wKGxheWVyKV07XG4gIFx0fSxcblxuICBcdF91cGRhdGVTdHlsZTogZnVuY3Rpb24gKGxheWVyKSB7XG4gIFx0XHR2YXIgc3Ryb2tlID0gbGF5ZXIuX3N0cm9rZSxcbiAgXHRcdCAgICBmaWxsID0gbGF5ZXIuX2ZpbGwsXG4gIFx0XHQgICAgb3B0aW9ucyA9IGxheWVyLm9wdGlvbnMsXG4gIFx0XHQgICAgY29udGFpbmVyID0gbGF5ZXIuX2NvbnRhaW5lcjtcblxuICBcdFx0Y29udGFpbmVyLnN0cm9rZWQgPSAhIW9wdGlvbnMuc3Ryb2tlO1xuICBcdFx0Y29udGFpbmVyLmZpbGxlZCA9ICEhb3B0aW9ucy5maWxsO1xuXG4gIFx0XHRpZiAob3B0aW9ucy5zdHJva2UpIHtcbiAgXHRcdFx0aWYgKCFzdHJva2UpIHtcbiAgXHRcdFx0XHRzdHJva2UgPSBsYXllci5fc3Ryb2tlID0gdm1sQ3JlYXRlKCdzdHJva2UnKTtcbiAgXHRcdFx0fVxuICBcdFx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQoc3Ryb2tlKTtcbiAgXHRcdFx0c3Ryb2tlLndlaWdodCA9IG9wdGlvbnMud2VpZ2h0ICsgJ3B4JztcbiAgXHRcdFx0c3Ryb2tlLmNvbG9yID0gb3B0aW9ucy5jb2xvcjtcbiAgXHRcdFx0c3Ryb2tlLm9wYWNpdHkgPSBvcHRpb25zLm9wYWNpdHk7XG5cbiAgXHRcdFx0aWYgKG9wdGlvbnMuZGFzaEFycmF5KSB7XG4gIFx0XHRcdFx0c3Ryb2tlLmRhc2hTdHlsZSA9IGlzQXJyYXkob3B0aW9ucy5kYXNoQXJyYXkpID9cbiAgXHRcdFx0XHQgICAgb3B0aW9ucy5kYXNoQXJyYXkuam9pbignICcpIDpcbiAgXHRcdFx0XHQgICAgb3B0aW9ucy5kYXNoQXJyYXkucmVwbGFjZSgvKCAqLCAqKS9nLCAnICcpO1xuICBcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdHN0cm9rZS5kYXNoU3R5bGUgPSAnJztcbiAgXHRcdFx0fVxuICBcdFx0XHRzdHJva2UuZW5kY2FwID0gb3B0aW9ucy5saW5lQ2FwLnJlcGxhY2UoJ2J1dHQnLCAnZmxhdCcpO1xuICBcdFx0XHRzdHJva2Uuam9pbnN0eWxlID0gb3B0aW9ucy5saW5lSm9pbjtcblxuICBcdFx0fSBlbHNlIGlmIChzdHJva2UpIHtcbiAgXHRcdFx0Y29udGFpbmVyLnJlbW92ZUNoaWxkKHN0cm9rZSk7XG4gIFx0XHRcdGxheWVyLl9zdHJva2UgPSBudWxsO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAob3B0aW9ucy5maWxsKSB7XG4gIFx0XHRcdGlmICghZmlsbCkge1xuICBcdFx0XHRcdGZpbGwgPSBsYXllci5fZmlsbCA9IHZtbENyZWF0ZSgnZmlsbCcpO1xuICBcdFx0XHR9XG4gIFx0XHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChmaWxsKTtcbiAgXHRcdFx0ZmlsbC5jb2xvciA9IG9wdGlvbnMuZmlsbENvbG9yIHx8IG9wdGlvbnMuY29sb3I7XG4gIFx0XHRcdGZpbGwub3BhY2l0eSA9IG9wdGlvbnMuZmlsbE9wYWNpdHk7XG5cbiAgXHRcdH0gZWxzZSBpZiAoZmlsbCkge1xuICBcdFx0XHRjb250YWluZXIucmVtb3ZlQ2hpbGQoZmlsbCk7XG4gIFx0XHRcdGxheWVyLl9maWxsID0gbnVsbDtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X3VwZGF0ZUNpcmNsZTogZnVuY3Rpb24gKGxheWVyKSB7XG4gIFx0XHR2YXIgcCA9IGxheWVyLl9wb2ludC5yb3VuZCgpLFxuICBcdFx0ICAgIHIgPSBNYXRoLnJvdW5kKGxheWVyLl9yYWRpdXMpLFxuICBcdFx0ICAgIHIyID0gTWF0aC5yb3VuZChsYXllci5fcmFkaXVzWSB8fCByKTtcblxuICBcdFx0dGhpcy5fc2V0UGF0aChsYXllciwgbGF5ZXIuX2VtcHR5KCkgPyAnTTAgMCcgOlxuICBcdFx0XHQnQUwgJyArIHAueCArICcsJyArIHAueSArICcgJyArIHIgKyAnLCcgKyByMiArICcgMCwnICsgKDY1NTM1ICogMzYwKSk7XG4gIFx0fSxcblxuICBcdF9zZXRQYXRoOiBmdW5jdGlvbiAobGF5ZXIsIHBhdGgpIHtcbiAgXHRcdGxheWVyLl9wYXRoLnYgPSBwYXRoO1xuICBcdH0sXG5cbiAgXHRfYnJpbmdUb0Zyb250OiBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgXHRcdHRvRnJvbnQobGF5ZXIuX2NvbnRhaW5lcik7XG4gIFx0fSxcblxuICBcdF9icmluZ1RvQmFjazogZnVuY3Rpb24gKGxheWVyKSB7XG4gIFx0XHR0b0JhY2sobGF5ZXIuX2NvbnRhaW5lcik7XG4gIFx0fVxuICB9O1xuXG4gIHZhciBjcmVhdGUkMiA9IHZtbCA/IHZtbENyZWF0ZSA6IHN2Z0NyZWF0ZTtcblxuICAvKlxuICAgKiBAY2xhc3MgU1ZHXG4gICAqIEBpbmhlcml0cyBSZW5kZXJlclxuICAgKiBAYWthIEwuU1ZHXG4gICAqXG4gICAqIEFsbG93cyB2ZWN0b3IgbGF5ZXJzIHRvIGJlIGRpc3BsYXllZCB3aXRoIFtTVkddKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL1NWRykuXG4gICAqIEluaGVyaXRzIGBSZW5kZXJlcmAuXG4gICAqXG4gICAqIER1ZSB0byBbdGVjaG5pY2FsIGxpbWl0YXRpb25zXShodHRwOi8vY2FuaXVzZS5jb20vI3NlYXJjaD1zdmcpLCBTVkcgaXMgbm90XG4gICAqIGF2YWlsYWJsZSBpbiBhbGwgd2ViIGJyb3dzZXJzLCBub3RhYmx5IEFuZHJvaWQgMi54IGFuZCAzLnguXG4gICAqXG4gICAqIEFsdGhvdWdoIFNWRyBpcyBub3QgYXZhaWxhYmxlIG9uIElFNyBhbmQgSUU4LCB0aGVzZSBicm93c2VycyBzdXBwb3J0XG4gICAqIFtWTUxdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1ZlY3Rvcl9NYXJrdXBfTGFuZ3VhZ2UpXG4gICAqIChhIG5vdyBkZXByZWNhdGVkIHRlY2hub2xvZ3kpLCBhbmQgdGhlIFNWRyByZW5kZXJlciB3aWxsIGZhbGwgYmFjayB0byBWTUwgaW5cbiAgICogdGhpcyBjYXNlLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBVc2UgU1ZHIGJ5IGRlZmF1bHQgZm9yIGFsbCBwYXRocyBpbiB0aGUgbWFwOlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiB2YXIgbWFwID0gTC5tYXAoJ21hcCcsIHtcbiAgICogXHRyZW5kZXJlcjogTC5zdmcoKVxuICAgKiB9KTtcbiAgICogYGBgXG4gICAqXG4gICAqIFVzZSBhIFNWRyByZW5kZXJlciB3aXRoIGV4dHJhIHBhZGRpbmcgZm9yIHNwZWNpZmljIHZlY3RvciBnZW9tZXRyaWVzOlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiB2YXIgbWFwID0gTC5tYXAoJ21hcCcpO1xuICAgKiB2YXIgbXlSZW5kZXJlciA9IEwuc3ZnKHsgcGFkZGluZzogMC41IH0pO1xuICAgKiB2YXIgbGluZSA9IEwucG9seWxpbmUoIGNvb3JkaW5hdGVzLCB7IHJlbmRlcmVyOiBteVJlbmRlcmVyIH0gKTtcbiAgICogdmFyIGNpcmNsZSA9IEwuY2lyY2xlKCBjZW50ZXIsIHsgcmVuZGVyZXI6IG15UmVuZGVyZXIgfSApO1xuICAgKiBgYGBcbiAgICovXG5cbiAgdmFyIFNWRyA9IFJlbmRlcmVyLmV4dGVuZCh7XG5cbiAgXHRnZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBldmVudHMgPSBSZW5kZXJlci5wcm90b3R5cGUuZ2V0RXZlbnRzLmNhbGwodGhpcyk7XG4gIFx0XHRldmVudHMuem9vbXN0YXJ0ID0gdGhpcy5fb25ab29tU3RhcnQ7XG4gIFx0XHRyZXR1cm4gZXZlbnRzO1xuICBcdH0sXG5cbiAgXHRfaW5pdENvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5fY29udGFpbmVyID0gY3JlYXRlJDIoJ3N2ZycpO1xuXG4gIFx0XHQvLyBtYWtlcyBpdCBwb3NzaWJsZSB0byBjbGljayB0aHJvdWdoIHN2ZyByb290OyB3ZSdsbCByZXNldCBpdCBiYWNrIGluIGluZGl2aWR1YWwgcGF0aHNcbiAgXHRcdHRoaXMuX2NvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ3BvaW50ZXItZXZlbnRzJywgJ25vbmUnKTtcblxuICBcdFx0dGhpcy5fcm9vdEdyb3VwID0gY3JlYXRlJDIoJ2cnKTtcbiAgXHRcdHRoaXMuX2NvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLl9yb290R3JvdXApO1xuICBcdH0sXG5cbiAgXHRfZGVzdHJveUNvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xuICBcdFx0cmVtb3ZlKHRoaXMuX2NvbnRhaW5lcik7XG4gIFx0XHRvZmYodGhpcy5fY29udGFpbmVyKTtcbiAgXHRcdGRlbGV0ZSB0aGlzLl9jb250YWluZXI7XG4gIFx0XHRkZWxldGUgdGhpcy5fcm9vdEdyb3VwO1xuICBcdFx0ZGVsZXRlIHRoaXMuX3N2Z1NpemU7XG4gIFx0fSxcblxuICBcdF9vblpvb21TdGFydDogZnVuY3Rpb24gKCkge1xuICBcdFx0Ly8gRHJhZy10aGVuLXBpbmNoIGludGVyYWN0aW9ucyBtaWdodCBtZXNzIHVwIHRoZSBjZW50ZXIgYW5kIHpvb20uXG4gIFx0XHQvLyBJbiB0aGlzIGNhc2UsIHRoZSBlYXNpZXN0IHdheSB0byBwcmV2ZW50IHRoaXMgaXMgcmUtZG8gdGhlIHJlbmRlcmVyXG4gIFx0XHQvLyAgIGJvdW5kcyBhbmQgcGFkZGluZyB3aGVuIHRoZSB6b29taW5nIHN0YXJ0cy5cbiAgXHRcdHRoaXMuX3VwZGF0ZSgpO1xuICBcdH0sXG5cbiAgXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAodGhpcy5fbWFwLl9hbmltYXRpbmdab29tICYmIHRoaXMuX2JvdW5kcykgeyByZXR1cm47IH1cblxuICBcdFx0UmVuZGVyZXIucHJvdG90eXBlLl91cGRhdGUuY2FsbCh0aGlzKTtcblxuICBcdFx0dmFyIGIgPSB0aGlzLl9ib3VuZHMsXG4gIFx0XHQgICAgc2l6ZSA9IGIuZ2V0U2l6ZSgpLFxuICBcdFx0ICAgIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lcjtcblxuICBcdFx0Ly8gc2V0IHNpemUgb2Ygc3ZnLWNvbnRhaW5lciBpZiBjaGFuZ2VkXG4gIFx0XHRpZiAoIXRoaXMuX3N2Z1NpemUgfHwgIXRoaXMuX3N2Z1NpemUuZXF1YWxzKHNpemUpKSB7XG4gIFx0XHRcdHRoaXMuX3N2Z1NpemUgPSBzaXplO1xuICBcdFx0XHRjb250YWluZXIuc2V0QXR0cmlidXRlKCd3aWR0aCcsIHNpemUueCk7XG4gIFx0XHRcdGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIHNpemUueSk7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIG1vdmVtZW50OiB1cGRhdGUgY29udGFpbmVyIHZpZXdCb3ggc28gdGhhdCB3ZSBkb24ndCBoYXZlIHRvIGNoYW5nZSBjb29yZGluYXRlcyBvZiBpbmRpdmlkdWFsIGxheWVyc1xuICBcdFx0c2V0UG9zaXRpb24oY29udGFpbmVyLCBiLm1pbik7XG4gIFx0XHRjb250YWluZXIuc2V0QXR0cmlidXRlKCd2aWV3Qm94JywgW2IubWluLngsIGIubWluLnksIHNpemUueCwgc2l6ZS55XS5qb2luKCcgJykpO1xuXG4gIFx0XHR0aGlzLmZpcmUoJ3VwZGF0ZScpO1xuICBcdH0sXG5cbiAgXHQvLyBtZXRob2RzIGJlbG93IGFyZSBjYWxsZWQgYnkgdmVjdG9yIGxheWVycyBpbXBsZW1lbnRhdGlvbnNcblxuICBcdF9pbml0UGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG4gIFx0XHR2YXIgcGF0aCA9IGxheWVyLl9wYXRoID0gY3JlYXRlJDIoJ3BhdGgnKTtcblxuICBcdFx0Ly8gQG5hbWVzcGFjZSBQYXRoXG4gIFx0XHQvLyBAb3B0aW9uIGNsYXNzTmFtZTogU3RyaW5nID0gbnVsbFxuICBcdFx0Ly8gQ3VzdG9tIGNsYXNzIG5hbWUgc2V0IG9uIGFuIGVsZW1lbnQuIE9ubHkgZm9yIFNWRyByZW5kZXJlci5cbiAgXHRcdGlmIChsYXllci5vcHRpb25zLmNsYXNzTmFtZSkge1xuICBcdFx0XHRhZGRDbGFzcyhwYXRoLCBsYXllci5vcHRpb25zLmNsYXNzTmFtZSk7XG4gIFx0XHR9XG5cbiAgXHRcdGlmIChsYXllci5vcHRpb25zLmludGVyYWN0aXZlKSB7XG4gIFx0XHRcdGFkZENsYXNzKHBhdGgsICdsZWFmbGV0LWludGVyYWN0aXZlJyk7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMuX3VwZGF0ZVN0eWxlKGxheWVyKTtcbiAgXHRcdHRoaXMuX2xheWVyc1tzdGFtcChsYXllcildID0gbGF5ZXI7XG4gIFx0fSxcblxuICBcdF9hZGRQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgXHRcdGlmICghdGhpcy5fcm9vdEdyb3VwKSB7IHRoaXMuX2luaXRDb250YWluZXIoKTsgfVxuICBcdFx0dGhpcy5fcm9vdEdyb3VwLmFwcGVuZENoaWxkKGxheWVyLl9wYXRoKTtcbiAgXHRcdGxheWVyLmFkZEludGVyYWN0aXZlVGFyZ2V0KGxheWVyLl9wYXRoKTtcbiAgXHR9LFxuXG4gIFx0X3JlbW92ZVBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuICBcdFx0cmVtb3ZlKGxheWVyLl9wYXRoKTtcbiAgXHRcdGxheWVyLnJlbW92ZUludGVyYWN0aXZlVGFyZ2V0KGxheWVyLl9wYXRoKTtcbiAgXHRcdGRlbGV0ZSB0aGlzLl9sYXllcnNbc3RhbXAobGF5ZXIpXTtcbiAgXHR9LFxuXG4gIFx0X3VwZGF0ZVBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuICBcdFx0bGF5ZXIuX3Byb2plY3QoKTtcbiAgXHRcdGxheWVyLl91cGRhdGUoKTtcbiAgXHR9LFxuXG4gIFx0X3VwZGF0ZVN0eWxlOiBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgXHRcdHZhciBwYXRoID0gbGF5ZXIuX3BhdGgsXG4gIFx0XHQgICAgb3B0aW9ucyA9IGxheWVyLm9wdGlvbnM7XG5cbiAgXHRcdGlmICghcGF0aCkgeyByZXR1cm47IH1cblxuICBcdFx0aWYgKG9wdGlvbnMuc3Ryb2tlKSB7XG4gIFx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2UnLCBvcHRpb25zLmNvbG9yKTtcbiAgXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1vcGFjaXR5Jywgb3B0aW9ucy5vcGFjaXR5KTtcbiAgXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS13aWR0aCcsIG9wdGlvbnMud2VpZ2h0KTtcbiAgXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1saW5lY2FwJywgb3B0aW9ucy5saW5lQ2FwKTtcbiAgXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1saW5lam9pbicsIG9wdGlvbnMubGluZUpvaW4pO1xuXG4gIFx0XHRcdGlmIChvcHRpb25zLmRhc2hBcnJheSkge1xuICBcdFx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2UtZGFzaGFycmF5Jywgb3B0aW9ucy5kYXNoQXJyYXkpO1xuICBcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdHBhdGgucmVtb3ZlQXR0cmlidXRlKCdzdHJva2UtZGFzaGFycmF5Jyk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRpZiAob3B0aW9ucy5kYXNoT2Zmc2V0KSB7XG4gIFx0XHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1kYXNob2Zmc2V0Jywgb3B0aW9ucy5kYXNoT2Zmc2V0KTtcbiAgXHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRwYXRoLnJlbW92ZUF0dHJpYnV0ZSgnc3Ryb2tlLWRhc2hvZmZzZXQnKTtcbiAgXHRcdFx0fVxuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZScsICdub25lJyk7XG4gIFx0XHR9XG5cbiAgXHRcdGlmIChvcHRpb25zLmZpbGwpIHtcbiAgXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLCBvcHRpb25zLmZpbGxDb2xvciB8fCBvcHRpb25zLmNvbG9yKTtcbiAgXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ2ZpbGwtb3BhY2l0eScsIG9wdGlvbnMuZmlsbE9wYWNpdHkpO1xuICBcdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnZmlsbC1ydWxlJywgb3B0aW9ucy5maWxsUnVsZSB8fCAnZXZlbm9kZCcpO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLCAnbm9uZScpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfdXBkYXRlUG9seTogZnVuY3Rpb24gKGxheWVyLCBjbG9zZWQpIHtcbiAgXHRcdHRoaXMuX3NldFBhdGgobGF5ZXIsIHBvaW50c1RvUGF0aChsYXllci5fcGFydHMsIGNsb3NlZCkpO1xuICBcdH0sXG5cbiAgXHRfdXBkYXRlQ2lyY2xlOiBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgXHRcdHZhciBwID0gbGF5ZXIuX3BvaW50LFxuICBcdFx0ICAgIHIgPSBNYXRoLm1heChNYXRoLnJvdW5kKGxheWVyLl9yYWRpdXMpLCAxKSxcbiAgXHRcdCAgICByMiA9IE1hdGgubWF4KE1hdGgucm91bmQobGF5ZXIuX3JhZGl1c1kpLCAxKSB8fCByLFxuICBcdFx0ICAgIGFyYyA9ICdhJyArIHIgKyAnLCcgKyByMiArICcgMCAxLDAgJztcblxuICBcdFx0Ly8gZHJhd2luZyBhIGNpcmNsZSB3aXRoIHR3byBoYWxmLWFyY3NcbiAgXHRcdHZhciBkID0gbGF5ZXIuX2VtcHR5KCkgPyAnTTAgMCcgOlxuICBcdFx0XHQnTScgKyAocC54IC0gcikgKyAnLCcgKyBwLnkgK1xuICBcdFx0XHRhcmMgKyAociAqIDIpICsgJywwICcgK1xuICBcdFx0XHRhcmMgKyAoLXIgKiAyKSArICcsMCAnO1xuXG4gIFx0XHR0aGlzLl9zZXRQYXRoKGxheWVyLCBkKTtcbiAgXHR9LFxuXG4gIFx0X3NldFBhdGg6IGZ1bmN0aW9uIChsYXllciwgcGF0aCkge1xuICBcdFx0bGF5ZXIuX3BhdGguc2V0QXR0cmlidXRlKCdkJywgcGF0aCk7XG4gIFx0fSxcblxuICBcdC8vIFNWRyBkb2VzIG5vdCBoYXZlIHRoZSBjb25jZXB0IG9mIHpJbmRleCBzbyB3ZSByZXNvcnQgdG8gY2hhbmdpbmcgdGhlIERPTSBvcmRlciBvZiBlbGVtZW50c1xuICBcdF9icmluZ1RvRnJvbnQ6IGZ1bmN0aW9uIChsYXllcikge1xuICBcdFx0dG9Gcm9udChsYXllci5fcGF0aCk7XG4gIFx0fSxcblxuICBcdF9icmluZ1RvQmFjazogZnVuY3Rpb24gKGxheWVyKSB7XG4gIFx0XHR0b0JhY2sobGF5ZXIuX3BhdGgpO1xuICBcdH1cbiAgfSk7XG5cbiAgaWYgKHZtbCkge1xuICBcdFNWRy5pbmNsdWRlKHZtbE1peGluKTtcbiAgfVxuXG4gIC8vIEBuYW1lc3BhY2UgU1ZHXG4gIC8vIEBmYWN0b3J5IEwuc3ZnKG9wdGlvbnM/OiBSZW5kZXJlciBvcHRpb25zKVxuICAvLyBDcmVhdGVzIGEgU1ZHIHJlbmRlcmVyIHdpdGggdGhlIGdpdmVuIG9wdGlvbnMuXG4gIGZ1bmN0aW9uIHN2ZyQxKG9wdGlvbnMpIHtcbiAgXHRyZXR1cm4gc3ZnIHx8IHZtbCA/IG5ldyBTVkcob3B0aW9ucykgOiBudWxsO1xuICB9XG5cbiAgTWFwLmluY2x1ZGUoe1xuICBcdC8vIEBuYW1lc3BhY2UgTWFwOyBAbWV0aG9kIGdldFJlbmRlcmVyKGxheWVyOiBQYXRoKTogUmVuZGVyZXJcbiAgXHQvLyBSZXR1cm5zIHRoZSBpbnN0YW5jZSBvZiBgUmVuZGVyZXJgIHRoYXQgc2hvdWxkIGJlIHVzZWQgdG8gcmVuZGVyIHRoZSBnaXZlblxuICBcdC8vIGBQYXRoYC4gSXQgd2lsbCBlbnN1cmUgdGhhdCB0aGUgYHJlbmRlcmVyYCBvcHRpb25zIG9mIHRoZSBtYXAgYW5kIHBhdGhzXG4gIFx0Ly8gYXJlIHJlc3BlY3RlZCwgYW5kIHRoYXQgdGhlIHJlbmRlcmVycyBkbyBleGlzdCBvbiB0aGUgbWFwLlxuICBcdGdldFJlbmRlcmVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgXHRcdC8vIEBuYW1lc3BhY2UgUGF0aDsgQG9wdGlvbiByZW5kZXJlcjogUmVuZGVyZXJcbiAgXHRcdC8vIFVzZSB0aGlzIHNwZWNpZmljIGluc3RhbmNlIG9mIGBSZW5kZXJlcmAgZm9yIHRoaXMgcGF0aC4gVGFrZXNcbiAgXHRcdC8vIHByZWNlZGVuY2Ugb3ZlciB0aGUgbWFwJ3MgW2RlZmF1bHQgcmVuZGVyZXJdKCNtYXAtcmVuZGVyZXIpLlxuICBcdFx0dmFyIHJlbmRlcmVyID0gbGF5ZXIub3B0aW9ucy5yZW5kZXJlciB8fCB0aGlzLl9nZXRQYW5lUmVuZGVyZXIobGF5ZXIub3B0aW9ucy5wYW5lKSB8fCB0aGlzLm9wdGlvbnMucmVuZGVyZXIgfHwgdGhpcy5fcmVuZGVyZXI7XG5cbiAgXHRcdGlmICghcmVuZGVyZXIpIHtcbiAgXHRcdFx0cmVuZGVyZXIgPSB0aGlzLl9yZW5kZXJlciA9IHRoaXMuX2NyZWF0ZVJlbmRlcmVyKCk7XG4gIFx0XHR9XG5cbiAgXHRcdGlmICghdGhpcy5oYXNMYXllcihyZW5kZXJlcikpIHtcbiAgXHRcdFx0dGhpcy5hZGRMYXllcihyZW5kZXJlcik7XG4gIFx0XHR9XG4gIFx0XHRyZXR1cm4gcmVuZGVyZXI7XG4gIFx0fSxcblxuICBcdF9nZXRQYW5lUmVuZGVyZXI6IGZ1bmN0aW9uIChuYW1lKSB7XG4gIFx0XHRpZiAobmFtZSA9PT0gJ292ZXJsYXlQYW5lJyB8fCBuYW1lID09PSB1bmRlZmluZWQpIHtcbiAgXHRcdFx0cmV0dXJuIGZhbHNlO1xuICBcdFx0fVxuXG4gIFx0XHR2YXIgcmVuZGVyZXIgPSB0aGlzLl9wYW5lUmVuZGVyZXJzW25hbWVdO1xuICBcdFx0aWYgKHJlbmRlcmVyID09PSB1bmRlZmluZWQpIHtcbiAgXHRcdFx0cmVuZGVyZXIgPSB0aGlzLl9jcmVhdGVSZW5kZXJlcih7cGFuZTogbmFtZX0pO1xuICBcdFx0XHR0aGlzLl9wYW5lUmVuZGVyZXJzW25hbWVdID0gcmVuZGVyZXI7XG4gIFx0XHR9XG4gIFx0XHRyZXR1cm4gcmVuZGVyZXI7XG4gIFx0fSxcblxuICBcdF9jcmVhdGVSZW5kZXJlcjogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgXHRcdC8vIEBuYW1lc3BhY2UgTWFwOyBAb3B0aW9uIHByZWZlckNhbnZhczogQm9vbGVhbiA9IGZhbHNlXG4gIFx0XHQvLyBXaGV0aGVyIGBQYXRoYHMgc2hvdWxkIGJlIHJlbmRlcmVkIG9uIGEgYENhbnZhc2AgcmVuZGVyZXIuXG4gIFx0XHQvLyBCeSBkZWZhdWx0LCBhbGwgYFBhdGhgcyBhcmUgcmVuZGVyZWQgaW4gYSBgU1ZHYCByZW5kZXJlci5cbiAgXHRcdHJldHVybiAodGhpcy5vcHRpb25zLnByZWZlckNhbnZhcyAmJiBjYW52YXMkMShvcHRpb25zKSkgfHwgc3ZnJDEob3B0aW9ucyk7XG4gIFx0fVxuICB9KTtcblxuICAvKlxuICAgKiBMLlJlY3RhbmdsZSBleHRlbmRzIFBvbHlnb24gYW5kIGNyZWF0ZXMgYSByZWN0YW5nbGUgd2hlbiBwYXNzZWQgYSBMYXRMbmdCb3VuZHMgb2JqZWN0LlxuICAgKi9cblxuICAvKlxuICAgKiBAY2xhc3MgUmVjdGFuZ2xlXG4gICAqIEBha2EgTC5SZWN0YW5nbGVcbiAgICogQGluaGVyaXRzIFBvbHlnb25cbiAgICpcbiAgICogQSBjbGFzcyBmb3IgZHJhd2luZyByZWN0YW5nbGUgb3ZlcmxheXMgb24gYSBtYXAuIEV4dGVuZHMgYFBvbHlnb25gLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBgYGBqc1xuICAgKiAvLyBkZWZpbmUgcmVjdGFuZ2xlIGdlb2dyYXBoaWNhbCBib3VuZHNcbiAgICogdmFyIGJvdW5kcyA9IFtbNTQuNTU5MzIyLCAtNS43Njc4MjJdLCBbNTYuMTIxMDYwNCwgLTMuMDIxMjQwXV07XG4gICAqXG4gICAqIC8vIGNyZWF0ZSBhbiBvcmFuZ2UgcmVjdGFuZ2xlXG4gICAqIEwucmVjdGFuZ2xlKGJvdW5kcywge2NvbG9yOiBcIiNmZjc4MDBcIiwgd2VpZ2h0OiAxfSkuYWRkVG8obWFwKTtcbiAgICpcbiAgICogLy8gem9vbSB0aGUgbWFwIHRvIHRoZSByZWN0YW5nbGUgYm91bmRzXG4gICAqIG1hcC5maXRCb3VuZHMoYm91bmRzKTtcbiAgICogYGBgXG4gICAqXG4gICAqL1xuXG5cbiAgdmFyIFJlY3RhbmdsZSA9IFBvbHlnb24uZXh0ZW5kKHtcbiAgXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobGF0TG5nQm91bmRzLCBvcHRpb25zKSB7XG4gIFx0XHRQb2x5Z29uLnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcywgdGhpcy5fYm91bmRzVG9MYXRMbmdzKGxhdExuZ0JvdW5kcyksIG9wdGlvbnMpO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIHNldEJvdW5kcyhsYXRMbmdCb3VuZHM6IExhdExuZ0JvdW5kcyk6IHRoaXNcbiAgXHQvLyBSZWRyYXdzIHRoZSByZWN0YW5nbGUgd2l0aCB0aGUgcGFzc2VkIGJvdW5kcy5cbiAgXHRzZXRCb3VuZHM6IGZ1bmN0aW9uIChsYXRMbmdCb3VuZHMpIHtcbiAgXHRcdHJldHVybiB0aGlzLnNldExhdExuZ3ModGhpcy5fYm91bmRzVG9MYXRMbmdzKGxhdExuZ0JvdW5kcykpO1xuICBcdH0sXG5cbiAgXHRfYm91bmRzVG9MYXRMbmdzOiBmdW5jdGlvbiAobGF0TG5nQm91bmRzKSB7XG4gIFx0XHRsYXRMbmdCb3VuZHMgPSB0b0xhdExuZ0JvdW5kcyhsYXRMbmdCb3VuZHMpO1xuICBcdFx0cmV0dXJuIFtcbiAgXHRcdFx0bGF0TG5nQm91bmRzLmdldFNvdXRoV2VzdCgpLFxuICBcdFx0XHRsYXRMbmdCb3VuZHMuZ2V0Tm9ydGhXZXN0KCksXG4gIFx0XHRcdGxhdExuZ0JvdW5kcy5nZXROb3J0aEVhc3QoKSxcbiAgXHRcdFx0bGF0TG5nQm91bmRzLmdldFNvdXRoRWFzdCgpXG4gIFx0XHRdO1xuICBcdH1cbiAgfSk7XG5cblxuICAvLyBAZmFjdG9yeSBMLnJlY3RhbmdsZShsYXRMbmdCb3VuZHM6IExhdExuZ0JvdW5kcywgb3B0aW9ucz86IFBvbHlsaW5lIG9wdGlvbnMpXG4gIGZ1bmN0aW9uIHJlY3RhbmdsZShsYXRMbmdCb3VuZHMsIG9wdGlvbnMpIHtcbiAgXHRyZXR1cm4gbmV3IFJlY3RhbmdsZShsYXRMbmdCb3VuZHMsIG9wdGlvbnMpO1xuICB9XG5cbiAgU1ZHLmNyZWF0ZSA9IGNyZWF0ZSQyO1xuICBTVkcucG9pbnRzVG9QYXRoID0gcG9pbnRzVG9QYXRoO1xuXG4gIEdlb0pTT04uZ2VvbWV0cnlUb0xheWVyID0gZ2VvbWV0cnlUb0xheWVyO1xuICBHZW9KU09OLmNvb3Jkc1RvTGF0TG5nID0gY29vcmRzVG9MYXRMbmc7XG4gIEdlb0pTT04uY29vcmRzVG9MYXRMbmdzID0gY29vcmRzVG9MYXRMbmdzO1xuICBHZW9KU09OLmxhdExuZ1RvQ29vcmRzID0gbGF0TG5nVG9Db29yZHM7XG4gIEdlb0pTT04ubGF0TG5nc1RvQ29vcmRzID0gbGF0TG5nc1RvQ29vcmRzO1xuICBHZW9KU09OLmdldEZlYXR1cmUgPSBnZXRGZWF0dXJlO1xuICBHZW9KU09OLmFzRmVhdHVyZSA9IGFzRmVhdHVyZTtcblxuICAvKlxuICAgKiBMLkhhbmRsZXIuQm94Wm9vbSBpcyB1c2VkIHRvIGFkZCBzaGlmdC1kcmFnIHpvb20gaW50ZXJhY3Rpb24gdG8gdGhlIG1hcFxuICAgKiAoem9vbSB0byBhIHNlbGVjdGVkIGJvdW5kaW5nIGJveCksIGVuYWJsZWQgYnkgZGVmYXVsdC5cbiAgICovXG5cbiAgLy8gQG5hbWVzcGFjZSBNYXBcbiAgLy8gQHNlY3Rpb24gSW50ZXJhY3Rpb24gT3B0aW9uc1xuICBNYXAubWVyZ2VPcHRpb25zKHtcbiAgXHQvLyBAb3B0aW9uIGJveFpvb206IEJvb2xlYW4gPSB0cnVlXG4gIFx0Ly8gV2hldGhlciB0aGUgbWFwIGNhbiBiZSB6b29tZWQgdG8gYSByZWN0YW5ndWxhciBhcmVhIHNwZWNpZmllZCBieVxuICBcdC8vIGRyYWdnaW5nIHRoZSBtb3VzZSB3aGlsZSBwcmVzc2luZyB0aGUgc2hpZnQga2V5LlxuICBcdGJveFpvb206IHRydWVcbiAgfSk7XG5cbiAgdmFyIEJveFpvb20gPSBIYW5kbGVyLmV4dGVuZCh7XG4gIFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG1hcCkge1xuICBcdFx0dGhpcy5fbWFwID0gbWFwO1xuICBcdFx0dGhpcy5fY29udGFpbmVyID0gbWFwLl9jb250YWluZXI7XG4gIFx0XHR0aGlzLl9wYW5lID0gbWFwLl9wYW5lcy5vdmVybGF5UGFuZTtcbiAgXHRcdHRoaXMuX3Jlc2V0U3RhdGVUaW1lb3V0ID0gMDtcbiAgXHRcdG1hcC5vbigndW5sb2FkJywgdGhpcy5fZGVzdHJveSwgdGhpcyk7XG4gIFx0fSxcblxuICBcdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRvbih0aGlzLl9jb250YWluZXIsICdtb3VzZWRvd24nLCB0aGlzLl9vbk1vdXNlRG93biwgdGhpcyk7XG4gIFx0fSxcblxuICBcdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRvZmYodGhpcy5fY29udGFpbmVyLCAnbW91c2Vkb3duJywgdGhpcy5fb25Nb3VzZURvd24sIHRoaXMpO1xuICBcdH0sXG5cbiAgXHRtb3ZlZDogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMuX21vdmVkO1xuICBcdH0sXG5cbiAgXHRfZGVzdHJveTogZnVuY3Rpb24gKCkge1xuICBcdFx0cmVtb3ZlKHRoaXMuX3BhbmUpO1xuICBcdFx0ZGVsZXRlIHRoaXMuX3BhbmU7XG4gIFx0fSxcblxuICBcdF9yZXNldFN0YXRlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLl9yZXNldFN0YXRlVGltZW91dCA9IDA7XG4gIFx0XHR0aGlzLl9tb3ZlZCA9IGZhbHNlO1xuICBcdH0sXG5cbiAgXHRfY2xlYXJEZWZlcnJlZFJlc2V0U3RhdGU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICh0aGlzLl9yZXNldFN0YXRlVGltZW91dCAhPT0gMCkge1xuICBcdFx0XHRjbGVhclRpbWVvdXQodGhpcy5fcmVzZXRTdGF0ZVRpbWVvdXQpO1xuICBcdFx0XHR0aGlzLl9yZXNldFN0YXRlVGltZW91dCA9IDA7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF9vbk1vdXNlRG93bjogZnVuY3Rpb24gKGUpIHtcbiAgXHRcdGlmICghZS5zaGlmdEtleSB8fCAoKGUud2hpY2ggIT09IDEpICYmIChlLmJ1dHRvbiAhPT0gMSkpKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIFx0XHQvLyBDbGVhciB0aGUgZGVmZXJyZWQgcmVzZXRTdGF0ZSBpZiBpdCBoYXNuJ3QgZXhlY3V0ZWQgeWV0LCBvdGhlcndpc2UgaXRcbiAgXHRcdC8vIHdpbGwgaW50ZXJydXB0IHRoZSBpbnRlcmFjdGlvbiBhbmQgb3JwaGFuIGEgYm94IGVsZW1lbnQgaW4gdGhlIGNvbnRhaW5lci5cbiAgXHRcdHRoaXMuX2NsZWFyRGVmZXJyZWRSZXNldFN0YXRlKCk7XG4gIFx0XHR0aGlzLl9yZXNldFN0YXRlKCk7XG5cbiAgXHRcdGRpc2FibGVUZXh0U2VsZWN0aW9uKCk7XG4gIFx0XHRkaXNhYmxlSW1hZ2VEcmFnKCk7XG5cbiAgXHRcdHRoaXMuX3N0YXJ0UG9pbnQgPSB0aGlzLl9tYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZSk7XG5cbiAgXHRcdG9uKGRvY3VtZW50LCB7XG4gIFx0XHRcdGNvbnRleHRtZW51OiBzdG9wLFxuICBcdFx0XHRtb3VzZW1vdmU6IHRoaXMuX29uTW91c2VNb3ZlLFxuICBcdFx0XHRtb3VzZXVwOiB0aGlzLl9vbk1vdXNlVXAsXG4gIFx0XHRcdGtleWRvd246IHRoaXMuX29uS2V5RG93blxuICBcdFx0fSwgdGhpcyk7XG4gIFx0fSxcblxuICBcdF9vbk1vdXNlTW92ZTogZnVuY3Rpb24gKGUpIHtcbiAgXHRcdGlmICghdGhpcy5fbW92ZWQpIHtcbiAgXHRcdFx0dGhpcy5fbW92ZWQgPSB0cnVlO1xuXG4gIFx0XHRcdHRoaXMuX2JveCA9IGNyZWF0ZSQxKCdkaXYnLCAnbGVhZmxldC16b29tLWJveCcsIHRoaXMuX2NvbnRhaW5lcik7XG4gIFx0XHRcdGFkZENsYXNzKHRoaXMuX2NvbnRhaW5lciwgJ2xlYWZsZXQtY3Jvc3NoYWlyJyk7XG5cbiAgXHRcdFx0dGhpcy5fbWFwLmZpcmUoJ2JveHpvb21zdGFydCcpO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLl9wb2ludCA9IHRoaXMuX21hcC5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlKTtcblxuICBcdFx0dmFyIGJvdW5kcyA9IG5ldyBCb3VuZHModGhpcy5fcG9pbnQsIHRoaXMuX3N0YXJ0UG9pbnQpLFxuICBcdFx0ICAgIHNpemUgPSBib3VuZHMuZ2V0U2l6ZSgpO1xuXG4gIFx0XHRzZXRQb3NpdGlvbih0aGlzLl9ib3gsIGJvdW5kcy5taW4pO1xuXG4gIFx0XHR0aGlzLl9ib3guc3R5bGUud2lkdGggID0gc2l6ZS54ICsgJ3B4JztcbiAgXHRcdHRoaXMuX2JveC5zdHlsZS5oZWlnaHQgPSBzaXplLnkgKyAncHgnO1xuICBcdH0sXG5cbiAgXHRfZmluaXNoOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAodGhpcy5fbW92ZWQpIHtcbiAgXHRcdFx0cmVtb3ZlKHRoaXMuX2JveCk7XG4gIFx0XHRcdHJlbW92ZUNsYXNzKHRoaXMuX2NvbnRhaW5lciwgJ2xlYWZsZXQtY3Jvc3NoYWlyJyk7XG4gIFx0XHR9XG5cbiAgXHRcdGVuYWJsZVRleHRTZWxlY3Rpb24oKTtcbiAgXHRcdGVuYWJsZUltYWdlRHJhZygpO1xuXG4gIFx0XHRvZmYoZG9jdW1lbnQsIHtcbiAgXHRcdFx0Y29udGV4dG1lbnU6IHN0b3AsXG4gIFx0XHRcdG1vdXNlbW92ZTogdGhpcy5fb25Nb3VzZU1vdmUsXG4gIFx0XHRcdG1vdXNldXA6IHRoaXMuX29uTW91c2VVcCxcbiAgXHRcdFx0a2V5ZG93bjogdGhpcy5fb25LZXlEb3duXG4gIFx0XHR9LCB0aGlzKTtcbiAgXHR9LFxuXG4gIFx0X29uTW91c2VVcDogZnVuY3Rpb24gKGUpIHtcbiAgXHRcdGlmICgoZS53aGljaCAhPT0gMSkgJiYgKGUuYnV0dG9uICE9PSAxKSkgeyByZXR1cm47IH1cblxuICBcdFx0dGhpcy5fZmluaXNoKCk7XG5cbiAgXHRcdGlmICghdGhpcy5fbW92ZWQpIHsgcmV0dXJuOyB9XG4gIFx0XHQvLyBQb3N0cG9uZSB0byBuZXh0IEpTIHRpY2sgc28gaW50ZXJuYWwgY2xpY2sgZXZlbnQgaGFuZGxpbmdcbiAgXHRcdC8vIHN0aWxsIHNlZSBpdCBhcyBcIm1vdmVkXCIuXG4gIFx0XHR0aGlzLl9jbGVhckRlZmVycmVkUmVzZXRTdGF0ZSgpO1xuICBcdFx0dGhpcy5fcmVzZXRTdGF0ZVRpbWVvdXQgPSBzZXRUaW1lb3V0KGJpbmQodGhpcy5fcmVzZXRTdGF0ZSwgdGhpcyksIDApO1xuXG4gIFx0XHR2YXIgYm91bmRzID0gbmV3IExhdExuZ0JvdW5kcyhcbiAgXHRcdCAgICAgICAgdGhpcy5fbWFwLmNvbnRhaW5lclBvaW50VG9MYXRMbmcodGhpcy5fc3RhcnRQb2ludCksXG4gIFx0XHQgICAgICAgIHRoaXMuX21hcC5jb250YWluZXJQb2ludFRvTGF0TG5nKHRoaXMuX3BvaW50KSk7XG5cbiAgXHRcdHRoaXMuX21hcFxuICBcdFx0XHQuZml0Qm91bmRzKGJvdW5kcylcbiAgXHRcdFx0LmZpcmUoJ2JveHpvb21lbmQnLCB7Ym94Wm9vbUJvdW5kczogYm91bmRzfSk7XG4gIFx0fSxcblxuICBcdF9vbktleURvd246IGZ1bmN0aW9uIChlKSB7XG4gIFx0XHRpZiAoZS5rZXlDb2RlID09PSAyNykge1xuICBcdFx0XHR0aGlzLl9maW5pc2goKTtcbiAgXHRcdH1cbiAgXHR9XG4gIH0pO1xuXG4gIC8vIEBzZWN0aW9uIEhhbmRsZXJzXG4gIC8vIEBwcm9wZXJ0eSBib3hab29tOiBIYW5kbGVyXG4gIC8vIEJveCAoc2hpZnQtZHJhZyB3aXRoIG1vdXNlKSB6b29tIGhhbmRsZXIuXG4gIE1hcC5hZGRJbml0SG9vaygnYWRkSGFuZGxlcicsICdib3hab29tJywgQm94Wm9vbSk7XG5cbiAgLypcbiAgICogTC5IYW5kbGVyLkRvdWJsZUNsaWNrWm9vbSBpcyB1c2VkIHRvIGhhbmRsZSBkb3VibGUtY2xpY2sgem9vbSBvbiB0aGUgbWFwLCBlbmFibGVkIGJ5IGRlZmF1bHQuXG4gICAqL1xuXG4gIC8vIEBuYW1lc3BhY2UgTWFwXG4gIC8vIEBzZWN0aW9uIEludGVyYWN0aW9uIE9wdGlvbnNcblxuICBNYXAubWVyZ2VPcHRpb25zKHtcbiAgXHQvLyBAb3B0aW9uIGRvdWJsZUNsaWNrWm9vbTogQm9vbGVhbnxTdHJpbmcgPSB0cnVlXG4gIFx0Ly8gV2hldGhlciB0aGUgbWFwIGNhbiBiZSB6b29tZWQgaW4gYnkgZG91YmxlIGNsaWNraW5nIG9uIGl0IGFuZFxuICBcdC8vIHpvb21lZCBvdXQgYnkgZG91YmxlIGNsaWNraW5nIHdoaWxlIGhvbGRpbmcgc2hpZnQuIElmIHBhc3NlZFxuICBcdC8vIGAnY2VudGVyJ2AsIGRvdWJsZS1jbGljayB6b29tIHdpbGwgem9vbSB0byB0aGUgY2VudGVyIG9mIHRoZVxuICBcdC8vICB2aWV3IHJlZ2FyZGxlc3Mgb2Ygd2hlcmUgdGhlIG1vdXNlIHdhcy5cbiAgXHRkb3VibGVDbGlja1pvb206IHRydWVcbiAgfSk7XG5cbiAgdmFyIERvdWJsZUNsaWNrWm9vbSA9IEhhbmRsZXIuZXh0ZW5kKHtcbiAgXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5fbWFwLm9uKCdkYmxjbGljaycsIHRoaXMuX29uRG91YmxlQ2xpY2ssIHRoaXMpO1xuICBcdH0sXG5cbiAgXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5fbWFwLm9mZignZGJsY2xpY2snLCB0aGlzLl9vbkRvdWJsZUNsaWNrLCB0aGlzKTtcbiAgXHR9LFxuXG4gIFx0X29uRG91YmxlQ2xpY2s6IGZ1bmN0aW9uIChlKSB7XG4gIFx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuICBcdFx0ICAgIG9sZFpvb20gPSBtYXAuZ2V0Wm9vbSgpLFxuICBcdFx0ICAgIGRlbHRhID0gbWFwLm9wdGlvbnMuem9vbURlbHRhLFxuICBcdFx0ICAgIHpvb20gPSBlLm9yaWdpbmFsRXZlbnQuc2hpZnRLZXkgPyBvbGRab29tIC0gZGVsdGEgOiBvbGRab29tICsgZGVsdGE7XG5cbiAgXHRcdGlmIChtYXAub3B0aW9ucy5kb3VibGVDbGlja1pvb20gPT09ICdjZW50ZXInKSB7XG4gIFx0XHRcdG1hcC5zZXRab29tKHpvb20pO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0bWFwLnNldFpvb21Bcm91bmQoZS5jb250YWluZXJQb2ludCwgem9vbSk7XG4gIFx0XHR9XG4gIFx0fVxuICB9KTtcblxuICAvLyBAc2VjdGlvbiBIYW5kbGVyc1xuICAvL1xuICAvLyBNYXAgcHJvcGVydGllcyBpbmNsdWRlIGludGVyYWN0aW9uIGhhbmRsZXJzIHRoYXQgYWxsb3cgeW91IHRvIGNvbnRyb2xcbiAgLy8gaW50ZXJhY3Rpb24gYmVoYXZpb3IgaW4gcnVudGltZSwgZW5hYmxpbmcgb3IgZGlzYWJsaW5nIGNlcnRhaW4gZmVhdHVyZXMgc3VjaFxuICAvLyBhcyBkcmFnZ2luZyBvciB0b3VjaCB6b29tIChzZWUgYEhhbmRsZXJgIG1ldGhvZHMpLiBGb3IgZXhhbXBsZTpcbiAgLy9cbiAgLy8gYGBganNcbiAgLy8gbWFwLmRvdWJsZUNsaWNrWm9vbS5kaXNhYmxlKCk7XG4gIC8vIGBgYFxuICAvL1xuICAvLyBAcHJvcGVydHkgZG91YmxlQ2xpY2tab29tOiBIYW5kbGVyXG4gIC8vIERvdWJsZSBjbGljayB6b29tIGhhbmRsZXIuXG4gIE1hcC5hZGRJbml0SG9vaygnYWRkSGFuZGxlcicsICdkb3VibGVDbGlja1pvb20nLCBEb3VibGVDbGlja1pvb20pO1xuXG4gIC8qXG4gICAqIEwuSGFuZGxlci5NYXBEcmFnIGlzIHVzZWQgdG8gbWFrZSB0aGUgbWFwIGRyYWdnYWJsZSAod2l0aCBwYW5uaW5nIGluZXJ0aWEpLCBlbmFibGVkIGJ5IGRlZmF1bHQuXG4gICAqL1xuXG4gIC8vIEBuYW1lc3BhY2UgTWFwXG4gIC8vIEBzZWN0aW9uIEludGVyYWN0aW9uIE9wdGlvbnNcbiAgTWFwLm1lcmdlT3B0aW9ucyh7XG4gIFx0Ly8gQG9wdGlvbiBkcmFnZ2luZzogQm9vbGVhbiA9IHRydWVcbiAgXHQvLyBXaGV0aGVyIHRoZSBtYXAgYmUgZHJhZ2dhYmxlIHdpdGggbW91c2UvdG91Y2ggb3Igbm90LlxuICBcdGRyYWdnaW5nOiB0cnVlLFxuXG4gIFx0Ly8gQHNlY3Rpb24gUGFubmluZyBJbmVydGlhIE9wdGlvbnNcbiAgXHQvLyBAb3B0aW9uIGluZXJ0aWE6IEJvb2xlYW4gPSAqXG4gIFx0Ly8gSWYgZW5hYmxlZCwgcGFubmluZyBvZiB0aGUgbWFwIHdpbGwgaGF2ZSBhbiBpbmVydGlhIGVmZmVjdCB3aGVyZVxuICBcdC8vIHRoZSBtYXAgYnVpbGRzIG1vbWVudHVtIHdoaWxlIGRyYWdnaW5nIGFuZCBjb250aW51ZXMgbW92aW5nIGluXG4gIFx0Ly8gdGhlIHNhbWUgZGlyZWN0aW9uIGZvciBzb21lIHRpbWUuIEZlZWxzIGVzcGVjaWFsbHkgbmljZSBvbiB0b3VjaFxuICBcdC8vIGRldmljZXMuIEVuYWJsZWQgYnkgZGVmYXVsdCB1bmxlc3MgcnVubmluZyBvbiBvbGQgQW5kcm9pZCBkZXZpY2VzLlxuICBcdGluZXJ0aWE6ICFhbmRyb2lkMjMsXG5cbiAgXHQvLyBAb3B0aW9uIGluZXJ0aWFEZWNlbGVyYXRpb246IE51bWJlciA9IDMwMDBcbiAgXHQvLyBUaGUgcmF0ZSB3aXRoIHdoaWNoIHRoZSBpbmVydGlhbCBtb3ZlbWVudCBzbG93cyBkb3duLCBpbiBwaXhlbHMvc2Vjb25kwrIuXG4gIFx0aW5lcnRpYURlY2VsZXJhdGlvbjogMzQwMCwgLy8gcHgvc14yXG5cbiAgXHQvLyBAb3B0aW9uIGluZXJ0aWFNYXhTcGVlZDogTnVtYmVyID0gSW5maW5pdHlcbiAgXHQvLyBNYXggc3BlZWQgb2YgdGhlIGluZXJ0aWFsIG1vdmVtZW50LCBpbiBwaXhlbHMvc2Vjb25kLlxuICBcdGluZXJ0aWFNYXhTcGVlZDogSW5maW5pdHksIC8vIHB4L3NcblxuICBcdC8vIEBvcHRpb24gZWFzZUxpbmVhcml0eTogTnVtYmVyID0gMC4yXG4gIFx0ZWFzZUxpbmVhcml0eTogMC4yLFxuXG4gIFx0Ly8gVE9ETyByZWZhY3RvciwgbW92ZSB0byBDUlNcbiAgXHQvLyBAb3B0aW9uIHdvcmxkQ29weUp1bXA6IEJvb2xlYW4gPSBmYWxzZVxuICBcdC8vIFdpdGggdGhpcyBvcHRpb24gZW5hYmxlZCwgdGhlIG1hcCB0cmFja3Mgd2hlbiB5b3UgcGFuIHRvIGFub3RoZXIgXCJjb3B5XCJcbiAgXHQvLyBvZiB0aGUgd29ybGQgYW5kIHNlYW1sZXNzbHkganVtcHMgdG8gdGhlIG9yaWdpbmFsIG9uZSBzbyB0aGF0IGFsbCBvdmVybGF5c1xuICBcdC8vIGxpa2UgbWFya2VycyBhbmQgdmVjdG9yIGxheWVycyBhcmUgc3RpbGwgdmlzaWJsZS5cbiAgXHR3b3JsZENvcHlKdW1wOiBmYWxzZSxcblxuICBcdC8vIEBvcHRpb24gbWF4Qm91bmRzVmlzY29zaXR5OiBOdW1iZXIgPSAwLjBcbiAgXHQvLyBJZiBgbWF4Qm91bmRzYCBpcyBzZXQsIHRoaXMgb3B0aW9uIHdpbGwgY29udHJvbCBob3cgc29saWQgdGhlIGJvdW5kc1xuICBcdC8vIGFyZSB3aGVuIGRyYWdnaW5nIHRoZSBtYXAgYXJvdW5kLiBUaGUgZGVmYXVsdCB2YWx1ZSBvZiBgMC4wYCBhbGxvd3MgdGhlXG4gIFx0Ly8gdXNlciB0byBkcmFnIG91dHNpZGUgdGhlIGJvdW5kcyBhdCBub3JtYWwgc3BlZWQsIGhpZ2hlciB2YWx1ZXMgd2lsbFxuICBcdC8vIHNsb3cgZG93biBtYXAgZHJhZ2dpbmcgb3V0c2lkZSBib3VuZHMsIGFuZCBgMS4wYCBtYWtlcyB0aGUgYm91bmRzIGZ1bGx5XG4gIFx0Ly8gc29saWQsIHByZXZlbnRpbmcgdGhlIHVzZXIgZnJvbSBkcmFnZ2luZyBvdXRzaWRlIHRoZSBib3VuZHMuXG4gIFx0bWF4Qm91bmRzVmlzY29zaXR5OiAwLjBcbiAgfSk7XG5cbiAgdmFyIERyYWcgPSBIYW5kbGVyLmV4dGVuZCh7XG4gIFx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICghdGhpcy5fZHJhZ2dhYmxlKSB7XG4gIFx0XHRcdHZhciBtYXAgPSB0aGlzLl9tYXA7XG5cbiAgXHRcdFx0dGhpcy5fZHJhZ2dhYmxlID0gbmV3IERyYWdnYWJsZShtYXAuX21hcFBhbmUsIG1hcC5fY29udGFpbmVyKTtcblxuICBcdFx0XHR0aGlzLl9kcmFnZ2FibGUub24oe1xuICBcdFx0XHRcdGRyYWdzdGFydDogdGhpcy5fb25EcmFnU3RhcnQsXG4gIFx0XHRcdFx0ZHJhZzogdGhpcy5fb25EcmFnLFxuICBcdFx0XHRcdGRyYWdlbmQ6IHRoaXMuX29uRHJhZ0VuZFxuICBcdFx0XHR9LCB0aGlzKTtcblxuICBcdFx0XHR0aGlzLl9kcmFnZ2FibGUub24oJ3ByZWRyYWcnLCB0aGlzLl9vblByZURyYWdMaW1pdCwgdGhpcyk7XG4gIFx0XHRcdGlmIChtYXAub3B0aW9ucy53b3JsZENvcHlKdW1wKSB7XG4gIFx0XHRcdFx0dGhpcy5fZHJhZ2dhYmxlLm9uKCdwcmVkcmFnJywgdGhpcy5fb25QcmVEcmFnV3JhcCwgdGhpcyk7XG4gIFx0XHRcdFx0bWFwLm9uKCd6b29tZW5kJywgdGhpcy5fb25ab29tRW5kLCB0aGlzKTtcblxuICBcdFx0XHRcdG1hcC53aGVuUmVhZHkodGhpcy5fb25ab29tRW5kLCB0aGlzKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdFx0YWRkQ2xhc3ModGhpcy5fbWFwLl9jb250YWluZXIsICdsZWFmbGV0LWdyYWIgbGVhZmxldC10b3VjaC1kcmFnJyk7XG4gIFx0XHR0aGlzLl9kcmFnZ2FibGUuZW5hYmxlKCk7XG4gIFx0XHR0aGlzLl9wb3NpdGlvbnMgPSBbXTtcbiAgXHRcdHRoaXMuX3RpbWVzID0gW107XG4gIFx0fSxcblxuICBcdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZW1vdmVDbGFzcyh0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ2xlYWZsZXQtZ3JhYicpO1xuICBcdFx0cmVtb3ZlQ2xhc3ModGhpcy5fbWFwLl9jb250YWluZXIsICdsZWFmbGV0LXRvdWNoLWRyYWcnKTtcbiAgXHRcdHRoaXMuX2RyYWdnYWJsZS5kaXNhYmxlKCk7XG4gIFx0fSxcblxuICBcdG1vdmVkOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5fZHJhZ2dhYmxlICYmIHRoaXMuX2RyYWdnYWJsZS5fbW92ZWQ7XG4gIFx0fSxcblxuICBcdG1vdmluZzogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMuX2RyYWdnYWJsZSAmJiB0aGlzLl9kcmFnZ2FibGUuX21vdmluZztcbiAgXHR9LFxuXG4gIFx0X29uRHJhZ1N0YXJ0OiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgbWFwID0gdGhpcy5fbWFwO1xuXG4gIFx0XHRtYXAuX3N0b3AoKTtcbiAgXHRcdGlmICh0aGlzLl9tYXAub3B0aW9ucy5tYXhCb3VuZHMgJiYgdGhpcy5fbWFwLm9wdGlvbnMubWF4Qm91bmRzVmlzY29zaXR5KSB7XG4gIFx0XHRcdHZhciBib3VuZHMgPSB0b0xhdExuZ0JvdW5kcyh0aGlzLl9tYXAub3B0aW9ucy5tYXhCb3VuZHMpO1xuXG4gIFx0XHRcdHRoaXMuX29mZnNldExpbWl0ID0gdG9Cb3VuZHMoXG4gIFx0XHRcdFx0dGhpcy5fbWFwLmxhdExuZ1RvQ29udGFpbmVyUG9pbnQoYm91bmRzLmdldE5vcnRoV2VzdCgpKS5tdWx0aXBseUJ5KC0xKSxcbiAgXHRcdFx0XHR0aGlzLl9tYXAubGF0TG5nVG9Db250YWluZXJQb2ludChib3VuZHMuZ2V0U291dGhFYXN0KCkpLm11bHRpcGx5QnkoLTEpXG4gIFx0XHRcdFx0XHQuYWRkKHRoaXMuX21hcC5nZXRTaXplKCkpKTtcblxuICBcdFx0XHR0aGlzLl92aXNjb3NpdHkgPSBNYXRoLm1pbigxLjAsIE1hdGgubWF4KDAuMCwgdGhpcy5fbWFwLm9wdGlvbnMubWF4Qm91bmRzVmlzY29zaXR5KSk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHR0aGlzLl9vZmZzZXRMaW1pdCA9IG51bGw7XG4gIFx0XHR9XG5cbiAgXHRcdG1hcFxuICBcdFx0ICAgIC5maXJlKCdtb3Zlc3RhcnQnKVxuICBcdFx0ICAgIC5maXJlKCdkcmFnc3RhcnQnKTtcblxuICBcdFx0aWYgKG1hcC5vcHRpb25zLmluZXJ0aWEpIHtcbiAgXHRcdFx0dGhpcy5fcG9zaXRpb25zID0gW107XG4gIFx0XHRcdHRoaXMuX3RpbWVzID0gW107XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF9vbkRyYWc6IGZ1bmN0aW9uIChlKSB7XG4gIFx0XHRpZiAodGhpcy5fbWFwLm9wdGlvbnMuaW5lcnRpYSkge1xuICBcdFx0XHR2YXIgdGltZSA9IHRoaXMuX2xhc3RUaW1lID0gK25ldyBEYXRlKCksXG4gIFx0XHRcdCAgICBwb3MgPSB0aGlzLl9sYXN0UG9zID0gdGhpcy5fZHJhZ2dhYmxlLl9hYnNQb3MgfHwgdGhpcy5fZHJhZ2dhYmxlLl9uZXdQb3M7XG5cbiAgXHRcdFx0dGhpcy5fcG9zaXRpb25zLnB1c2gocG9zKTtcbiAgXHRcdFx0dGhpcy5fdGltZXMucHVzaCh0aW1lKTtcblxuICBcdFx0XHR0aGlzLl9wcnVuZVBvc2l0aW9ucyh0aW1lKTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5fbWFwXG4gIFx0XHQgICAgLmZpcmUoJ21vdmUnLCBlKVxuICBcdFx0ICAgIC5maXJlKCdkcmFnJywgZSk7XG4gIFx0fSxcblxuICBcdF9wcnVuZVBvc2l0aW9uczogZnVuY3Rpb24gKHRpbWUpIHtcbiAgXHRcdHdoaWxlICh0aGlzLl9wb3NpdGlvbnMubGVuZ3RoID4gMSAmJiB0aW1lIC0gdGhpcy5fdGltZXNbMF0gPiA1MCkge1xuICBcdFx0XHR0aGlzLl9wb3NpdGlvbnMuc2hpZnQoKTtcbiAgXHRcdFx0dGhpcy5fdGltZXMuc2hpZnQoKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X29uWm9vbUVuZDogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIHB4Q2VudGVyID0gdGhpcy5fbWFwLmdldFNpemUoKS5kaXZpZGVCeSgyKSxcbiAgXHRcdCAgICBweFdvcmxkQ2VudGVyID0gdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludChbMCwgMF0pO1xuXG4gIFx0XHR0aGlzLl9pbml0aWFsV29ybGRPZmZzZXQgPSBweFdvcmxkQ2VudGVyLnN1YnRyYWN0KHB4Q2VudGVyKS54O1xuICBcdFx0dGhpcy5fd29ybGRXaWR0aCA9IHRoaXMuX21hcC5nZXRQaXhlbFdvcmxkQm91bmRzKCkuZ2V0U2l6ZSgpLng7XG4gIFx0fSxcblxuICBcdF92aXNjb3VzTGltaXQ6IGZ1bmN0aW9uICh2YWx1ZSwgdGhyZXNob2xkKSB7XG4gIFx0XHRyZXR1cm4gdmFsdWUgLSAodmFsdWUgLSB0aHJlc2hvbGQpICogdGhpcy5fdmlzY29zaXR5O1xuICBcdH0sXG5cbiAgXHRfb25QcmVEcmFnTGltaXQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICghdGhpcy5fdmlzY29zaXR5IHx8ICF0aGlzLl9vZmZzZXRMaW1pdCkgeyByZXR1cm47IH1cblxuICBcdFx0dmFyIG9mZnNldCA9IHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zLnN1YnRyYWN0KHRoaXMuX2RyYWdnYWJsZS5fc3RhcnRQb3MpO1xuXG4gIFx0XHR2YXIgbGltaXQgPSB0aGlzLl9vZmZzZXRMaW1pdDtcbiAgXHRcdGlmIChvZmZzZXQueCA8IGxpbWl0Lm1pbi54KSB7IG9mZnNldC54ID0gdGhpcy5fdmlzY291c0xpbWl0KG9mZnNldC54LCBsaW1pdC5taW4ueCk7IH1cbiAgXHRcdGlmIChvZmZzZXQueSA8IGxpbWl0Lm1pbi55KSB7IG9mZnNldC55ID0gdGhpcy5fdmlzY291c0xpbWl0KG9mZnNldC55LCBsaW1pdC5taW4ueSk7IH1cbiAgXHRcdGlmIChvZmZzZXQueCA+IGxpbWl0Lm1heC54KSB7IG9mZnNldC54ID0gdGhpcy5fdmlzY291c0xpbWl0KG9mZnNldC54LCBsaW1pdC5tYXgueCk7IH1cbiAgXHRcdGlmIChvZmZzZXQueSA+IGxpbWl0Lm1heC55KSB7IG9mZnNldC55ID0gdGhpcy5fdmlzY291c0xpbWl0KG9mZnNldC55LCBsaW1pdC5tYXgueSk7IH1cblxuICBcdFx0dGhpcy5fZHJhZ2dhYmxlLl9uZXdQb3MgPSB0aGlzLl9kcmFnZ2FibGUuX3N0YXJ0UG9zLmFkZChvZmZzZXQpO1xuICBcdH0sXG5cbiAgXHRfb25QcmVEcmFnV3JhcDogZnVuY3Rpb24gKCkge1xuICBcdFx0Ly8gVE9ETyByZWZhY3RvciB0byBiZSBhYmxlIHRvIGFkanVzdCBtYXAgcGFuZSBwb3NpdGlvbiBhZnRlciB6b29tXG4gIFx0XHR2YXIgd29ybGRXaWR0aCA9IHRoaXMuX3dvcmxkV2lkdGgsXG4gIFx0XHQgICAgaGFsZldpZHRoID0gTWF0aC5yb3VuZCh3b3JsZFdpZHRoIC8gMiksXG4gIFx0XHQgICAgZHggPSB0aGlzLl9pbml0aWFsV29ybGRPZmZzZXQsXG4gIFx0XHQgICAgeCA9IHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zLngsXG4gIFx0XHQgICAgbmV3WDEgPSAoeCAtIGhhbGZXaWR0aCArIGR4KSAlIHdvcmxkV2lkdGggKyBoYWxmV2lkdGggLSBkeCxcbiAgXHRcdCAgICBuZXdYMiA9ICh4ICsgaGFsZldpZHRoICsgZHgpICUgd29ybGRXaWR0aCAtIGhhbGZXaWR0aCAtIGR4LFxuICBcdFx0ICAgIG5ld1ggPSBNYXRoLmFicyhuZXdYMSArIGR4KSA8IE1hdGguYWJzKG5ld1gyICsgZHgpID8gbmV3WDEgOiBuZXdYMjtcblxuICBcdFx0dGhpcy5fZHJhZ2dhYmxlLl9hYnNQb3MgPSB0aGlzLl9kcmFnZ2FibGUuX25ld1Bvcy5jbG9uZSgpO1xuICBcdFx0dGhpcy5fZHJhZ2dhYmxlLl9uZXdQb3MueCA9IG5ld1g7XG4gIFx0fSxcblxuICBcdF9vbkRyYWdFbmQ6IGZ1bmN0aW9uIChlKSB7XG4gIFx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuICBcdFx0ICAgIG9wdGlvbnMgPSBtYXAub3B0aW9ucyxcblxuICBcdFx0ICAgIG5vSW5lcnRpYSA9ICFvcHRpb25zLmluZXJ0aWEgfHwgdGhpcy5fdGltZXMubGVuZ3RoIDwgMjtcblxuICBcdFx0bWFwLmZpcmUoJ2RyYWdlbmQnLCBlKTtcblxuICBcdFx0aWYgKG5vSW5lcnRpYSkge1xuICBcdFx0XHRtYXAuZmlyZSgnbW92ZWVuZCcpO1xuXG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHR0aGlzLl9wcnVuZVBvc2l0aW9ucygrbmV3IERhdGUoKSk7XG5cbiAgXHRcdFx0dmFyIGRpcmVjdGlvbiA9IHRoaXMuX2xhc3RQb3Muc3VidHJhY3QodGhpcy5fcG9zaXRpb25zWzBdKSxcbiAgXHRcdFx0ICAgIGR1cmF0aW9uID0gKHRoaXMuX2xhc3RUaW1lIC0gdGhpcy5fdGltZXNbMF0pIC8gMTAwMCxcbiAgXHRcdFx0ICAgIGVhc2UgPSBvcHRpb25zLmVhc2VMaW5lYXJpdHksXG5cbiAgXHRcdFx0ICAgIHNwZWVkVmVjdG9yID0gZGlyZWN0aW9uLm11bHRpcGx5QnkoZWFzZSAvIGR1cmF0aW9uKSxcbiAgXHRcdFx0ICAgIHNwZWVkID0gc3BlZWRWZWN0b3IuZGlzdGFuY2VUbyhbMCwgMF0pLFxuXG4gIFx0XHRcdCAgICBsaW1pdGVkU3BlZWQgPSBNYXRoLm1pbihvcHRpb25zLmluZXJ0aWFNYXhTcGVlZCwgc3BlZWQpLFxuICBcdFx0XHQgICAgbGltaXRlZFNwZWVkVmVjdG9yID0gc3BlZWRWZWN0b3IubXVsdGlwbHlCeShsaW1pdGVkU3BlZWQgLyBzcGVlZCksXG5cbiAgXHRcdFx0ICAgIGRlY2VsZXJhdGlvbkR1cmF0aW9uID0gbGltaXRlZFNwZWVkIC8gKG9wdGlvbnMuaW5lcnRpYURlY2VsZXJhdGlvbiAqIGVhc2UpLFxuICBcdFx0XHQgICAgb2Zmc2V0ID0gbGltaXRlZFNwZWVkVmVjdG9yLm11bHRpcGx5QnkoLWRlY2VsZXJhdGlvbkR1cmF0aW9uIC8gMikucm91bmQoKTtcblxuICBcdFx0XHRpZiAoIW9mZnNldC54ICYmICFvZmZzZXQueSkge1xuICBcdFx0XHRcdG1hcC5maXJlKCdtb3ZlZW5kJyk7XG5cbiAgXHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRvZmZzZXQgPSBtYXAuX2xpbWl0T2Zmc2V0KG9mZnNldCwgbWFwLm9wdGlvbnMubWF4Qm91bmRzKTtcblxuICBcdFx0XHRcdHJlcXVlc3RBbmltRnJhbWUoZnVuY3Rpb24gKCkge1xuICBcdFx0XHRcdFx0bWFwLnBhbkJ5KG9mZnNldCwge1xuICBcdFx0XHRcdFx0XHRkdXJhdGlvbjogZGVjZWxlcmF0aW9uRHVyYXRpb24sXG4gIFx0XHRcdFx0XHRcdGVhc2VMaW5lYXJpdHk6IGVhc2UsXG4gIFx0XHRcdFx0XHRcdG5vTW92ZVN0YXJ0OiB0cnVlLFxuICBcdFx0XHRcdFx0XHRhbmltYXRlOiB0cnVlXG4gIFx0XHRcdFx0XHR9KTtcbiAgXHRcdFx0XHR9KTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH1cbiAgfSk7XG5cbiAgLy8gQHNlY3Rpb24gSGFuZGxlcnNcbiAgLy8gQHByb3BlcnR5IGRyYWdnaW5nOiBIYW5kbGVyXG4gIC8vIE1hcCBkcmFnZ2luZyBoYW5kbGVyIChieSBib3RoIG1vdXNlIGFuZCB0b3VjaCkuXG4gIE1hcC5hZGRJbml0SG9vaygnYWRkSGFuZGxlcicsICdkcmFnZ2luZycsIERyYWcpO1xuXG4gIC8qXG4gICAqIEwuTWFwLktleWJvYXJkIGlzIGhhbmRsaW5nIGtleWJvYXJkIGludGVyYWN0aW9uIHdpdGggdGhlIG1hcCwgZW5hYmxlZCBieSBkZWZhdWx0LlxuICAgKi9cblxuICAvLyBAbmFtZXNwYWNlIE1hcFxuICAvLyBAc2VjdGlvbiBLZXlib2FyZCBOYXZpZ2F0aW9uIE9wdGlvbnNcbiAgTWFwLm1lcmdlT3B0aW9ucyh7XG4gIFx0Ly8gQG9wdGlvbiBrZXlib2FyZDogQm9vbGVhbiA9IHRydWVcbiAgXHQvLyBNYWtlcyB0aGUgbWFwIGZvY3VzYWJsZSBhbmQgYWxsb3dzIHVzZXJzIHRvIG5hdmlnYXRlIHRoZSBtYXAgd2l0aCBrZXlib2FyZFxuICBcdC8vIGFycm93cyBhbmQgYCtgL2AtYCBrZXlzLlxuICBcdGtleWJvYXJkOiB0cnVlLFxuXG4gIFx0Ly8gQG9wdGlvbiBrZXlib2FyZFBhbkRlbHRhOiBOdW1iZXIgPSA4MFxuICBcdC8vIEFtb3VudCBvZiBwaXhlbHMgdG8gcGFuIHdoZW4gcHJlc3NpbmcgYW4gYXJyb3cga2V5LlxuICBcdGtleWJvYXJkUGFuRGVsdGE6IDgwXG4gIH0pO1xuXG4gIHZhciBLZXlib2FyZCA9IEhhbmRsZXIuZXh0ZW5kKHtcblxuICBcdGtleUNvZGVzOiB7XG4gIFx0XHRsZWZ0OiAgICBbMzddLFxuICBcdFx0cmlnaHQ6ICAgWzM5XSxcbiAgXHRcdGRvd246ICAgIFs0MF0sXG4gIFx0XHR1cDogICAgICBbMzhdLFxuICBcdFx0em9vbUluOiAgWzE4NywgMTA3LCA2MSwgMTcxXSxcbiAgXHRcdHpvb21PdXQ6IFsxODksIDEwOSwgNTQsIDE3M11cbiAgXHR9LFxuXG4gIFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG1hcCkge1xuICBcdFx0dGhpcy5fbWFwID0gbWFwO1xuXG4gIFx0XHR0aGlzLl9zZXRQYW5EZWx0YShtYXAub3B0aW9ucy5rZXlib2FyZFBhbkRlbHRhKTtcbiAgXHRcdHRoaXMuX3NldFpvb21EZWx0YShtYXAub3B0aW9ucy56b29tRGVsdGEpO1xuICBcdH0sXG5cbiAgXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIGNvbnRhaW5lciA9IHRoaXMuX21hcC5fY29udGFpbmVyO1xuXG4gIFx0XHQvLyBtYWtlIHRoZSBjb250YWluZXIgZm9jdXNhYmxlIGJ5IHRhYmJpbmdcbiAgXHRcdGlmIChjb250YWluZXIudGFiSW5kZXggPD0gMCkge1xuICBcdFx0XHRjb250YWluZXIudGFiSW5kZXggPSAnMCc7XG4gIFx0XHR9XG5cbiAgXHRcdG9uKGNvbnRhaW5lciwge1xuICBcdFx0XHRmb2N1czogdGhpcy5fb25Gb2N1cyxcbiAgXHRcdFx0Ymx1cjogdGhpcy5fb25CbHVyLFxuICBcdFx0XHRtb3VzZWRvd246IHRoaXMuX29uTW91c2VEb3duXG4gIFx0XHR9LCB0aGlzKTtcblxuICBcdFx0dGhpcy5fbWFwLm9uKHtcbiAgXHRcdFx0Zm9jdXM6IHRoaXMuX2FkZEhvb2tzLFxuICBcdFx0XHRibHVyOiB0aGlzLl9yZW1vdmVIb29rc1xuICBcdFx0fSwgdGhpcyk7XG4gIFx0fSxcblxuICBcdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLl9yZW1vdmVIb29rcygpO1xuXG4gIFx0XHRvZmYodGhpcy5fbWFwLl9jb250YWluZXIsIHtcbiAgXHRcdFx0Zm9jdXM6IHRoaXMuX29uRm9jdXMsXG4gIFx0XHRcdGJsdXI6IHRoaXMuX29uQmx1cixcbiAgXHRcdFx0bW91c2Vkb3duOiB0aGlzLl9vbk1vdXNlRG93blxuICBcdFx0fSwgdGhpcyk7XG5cbiAgXHRcdHRoaXMuX21hcC5vZmYoe1xuICBcdFx0XHRmb2N1czogdGhpcy5fYWRkSG9va3MsXG4gIFx0XHRcdGJsdXI6IHRoaXMuX3JlbW92ZUhvb2tzXG4gIFx0XHR9LCB0aGlzKTtcbiAgXHR9LFxuXG4gIFx0X29uTW91c2VEb3duOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAodGhpcy5fZm9jdXNlZCkgeyByZXR1cm47IH1cblxuICBcdFx0dmFyIGJvZHkgPSBkb2N1bWVudC5ib2R5LFxuICBcdFx0ICAgIGRvY0VsID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LFxuICBcdFx0ICAgIHRvcCA9IGJvZHkuc2Nyb2xsVG9wIHx8IGRvY0VsLnNjcm9sbFRvcCxcbiAgXHRcdCAgICBsZWZ0ID0gYm9keS5zY3JvbGxMZWZ0IHx8IGRvY0VsLnNjcm9sbExlZnQ7XG5cbiAgXHRcdHRoaXMuX21hcC5fY29udGFpbmVyLmZvY3VzKCk7XG5cbiAgXHRcdHdpbmRvdy5zY3JvbGxUbyhsZWZ0LCB0b3ApO1xuICBcdH0sXG5cbiAgXHRfb25Gb2N1czogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5fZm9jdXNlZCA9IHRydWU7XG4gIFx0XHR0aGlzLl9tYXAuZmlyZSgnZm9jdXMnKTtcbiAgXHR9LFxuXG4gIFx0X29uQmx1cjogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5fZm9jdXNlZCA9IGZhbHNlO1xuICBcdFx0dGhpcy5fbWFwLmZpcmUoJ2JsdXInKTtcbiAgXHR9LFxuXG4gIFx0X3NldFBhbkRlbHRhOiBmdW5jdGlvbiAocGFuRGVsdGEpIHtcbiAgXHRcdHZhciBrZXlzID0gdGhpcy5fcGFuS2V5cyA9IHt9LFxuICBcdFx0ICAgIGNvZGVzID0gdGhpcy5rZXlDb2RlcyxcbiAgXHRcdCAgICBpLCBsZW47XG5cbiAgXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNvZGVzLmxlZnQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgXHRcdFx0a2V5c1tjb2Rlcy5sZWZ0W2ldXSA9IFstMSAqIHBhbkRlbHRhLCAwXTtcbiAgXHRcdH1cbiAgXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNvZGVzLnJpZ2h0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gIFx0XHRcdGtleXNbY29kZXMucmlnaHRbaV1dID0gW3BhbkRlbHRhLCAwXTtcbiAgXHRcdH1cbiAgXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNvZGVzLmRvd24ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgXHRcdFx0a2V5c1tjb2Rlcy5kb3duW2ldXSA9IFswLCBwYW5EZWx0YV07XG4gIFx0XHR9XG4gIFx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjb2Rlcy51cC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICBcdFx0XHRrZXlzW2NvZGVzLnVwW2ldXSA9IFswLCAtMSAqIHBhbkRlbHRhXTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X3NldFpvb21EZWx0YTogZnVuY3Rpb24gKHpvb21EZWx0YSkge1xuICBcdFx0dmFyIGtleXMgPSB0aGlzLl96b29tS2V5cyA9IHt9LFxuICBcdFx0ICAgIGNvZGVzID0gdGhpcy5rZXlDb2RlcyxcbiAgXHRcdCAgICBpLCBsZW47XG5cbiAgXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNvZGVzLnpvb21Jbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICBcdFx0XHRrZXlzW2NvZGVzLnpvb21JbltpXV0gPSB6b29tRGVsdGE7XG4gIFx0XHR9XG4gIFx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjb2Rlcy56b29tT3V0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gIFx0XHRcdGtleXNbY29kZXMuem9vbU91dFtpXV0gPSAtem9vbURlbHRhO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfYWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdG9uKGRvY3VtZW50LCAna2V5ZG93bicsIHRoaXMuX29uS2V5RG93biwgdGhpcyk7XG4gIFx0fSxcblxuICBcdF9yZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuICBcdFx0b2ZmKGRvY3VtZW50LCAna2V5ZG93bicsIHRoaXMuX29uS2V5RG93biwgdGhpcyk7XG4gIFx0fSxcblxuICBcdF9vbktleURvd246IGZ1bmN0aW9uIChlKSB7XG4gIFx0XHRpZiAoZS5hbHRLZXkgfHwgZS5jdHJsS2V5IHx8IGUubWV0YUtleSkgeyByZXR1cm47IH1cblxuICBcdFx0dmFyIGtleSA9IGUua2V5Q29kZSxcbiAgXHRcdCAgICBtYXAgPSB0aGlzLl9tYXAsXG4gIFx0XHQgICAgb2Zmc2V0O1xuXG4gIFx0XHRpZiAoa2V5IGluIHRoaXMuX3BhbktleXMpIHtcbiAgXHRcdFx0aWYgKCFtYXAuX3BhbkFuaW0gfHwgIW1hcC5fcGFuQW5pbS5faW5Qcm9ncmVzcykge1xuICBcdFx0XHRcdG9mZnNldCA9IHRoaXMuX3BhbktleXNba2V5XTtcbiAgXHRcdFx0XHRpZiAoZS5zaGlmdEtleSkge1xuICBcdFx0XHRcdFx0b2Zmc2V0ID0gdG9Qb2ludChvZmZzZXQpLm11bHRpcGx5QnkoMyk7XG4gIFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0bWFwLnBhbkJ5KG9mZnNldCk7XG5cbiAgXHRcdFx0XHRpZiAobWFwLm9wdGlvbnMubWF4Qm91bmRzKSB7XG4gIFx0XHRcdFx0XHRtYXAucGFuSW5zaWRlQm91bmRzKG1hcC5vcHRpb25zLm1heEJvdW5kcyk7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHR9IGVsc2UgaWYgKGtleSBpbiB0aGlzLl96b29tS2V5cykge1xuICBcdFx0XHRtYXAuc2V0Wm9vbShtYXAuZ2V0Wm9vbSgpICsgKGUuc2hpZnRLZXkgPyAzIDogMSkgKiB0aGlzLl96b29tS2V5c1trZXldKTtcblxuICBcdFx0fSBlbHNlIGlmIChrZXkgPT09IDI3ICYmIG1hcC5fcG9wdXAgJiYgbWFwLl9wb3B1cC5vcHRpb25zLmNsb3NlT25Fc2NhcGVLZXkpIHtcbiAgXHRcdFx0bWFwLmNsb3NlUG9wdXAoKTtcblxuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHRzdG9wKGUpO1xuICBcdH1cbiAgfSk7XG5cbiAgLy8gQHNlY3Rpb24gSGFuZGxlcnNcbiAgLy8gQHNlY3Rpb24gSGFuZGxlcnNcbiAgLy8gQHByb3BlcnR5IGtleWJvYXJkOiBIYW5kbGVyXG4gIC8vIEtleWJvYXJkIG5hdmlnYXRpb24gaGFuZGxlci5cbiAgTWFwLmFkZEluaXRIb29rKCdhZGRIYW5kbGVyJywgJ2tleWJvYXJkJywgS2V5Ym9hcmQpO1xuXG4gIC8qXG4gICAqIEwuSGFuZGxlci5TY3JvbGxXaGVlbFpvb20gaXMgdXNlZCBieSBMLk1hcCB0byBlbmFibGUgbW91c2Ugc2Nyb2xsIHdoZWVsIHpvb20gb24gdGhlIG1hcC5cbiAgICovXG5cbiAgLy8gQG5hbWVzcGFjZSBNYXBcbiAgLy8gQHNlY3Rpb24gSW50ZXJhY3Rpb24gT3B0aW9uc1xuICBNYXAubWVyZ2VPcHRpb25zKHtcbiAgXHQvLyBAc2VjdGlvbiBNb3VzZSB3aGVlbCBvcHRpb25zXG4gIFx0Ly8gQG9wdGlvbiBzY3JvbGxXaGVlbFpvb206IEJvb2xlYW58U3RyaW5nID0gdHJ1ZVxuICBcdC8vIFdoZXRoZXIgdGhlIG1hcCBjYW4gYmUgem9vbWVkIGJ5IHVzaW5nIHRoZSBtb3VzZSB3aGVlbC4gSWYgcGFzc2VkIGAnY2VudGVyJ2AsXG4gIFx0Ly8gaXQgd2lsbCB6b29tIHRvIHRoZSBjZW50ZXIgb2YgdGhlIHZpZXcgcmVnYXJkbGVzcyBvZiB3aGVyZSB0aGUgbW91c2Ugd2FzLlxuICBcdHNjcm9sbFdoZWVsWm9vbTogdHJ1ZSxcblxuICBcdC8vIEBvcHRpb24gd2hlZWxEZWJvdW5jZVRpbWU6IE51bWJlciA9IDQwXG4gIFx0Ly8gTGltaXRzIHRoZSByYXRlIGF0IHdoaWNoIGEgd2hlZWwgY2FuIGZpcmUgKGluIG1pbGxpc2Vjb25kcykuIEJ5IGRlZmF1bHRcbiAgXHQvLyB1c2VyIGNhbid0IHpvb20gdmlhIHdoZWVsIG1vcmUgb2Z0ZW4gdGhhbiBvbmNlIHBlciA0MCBtcy5cbiAgXHR3aGVlbERlYm91bmNlVGltZTogNDAsXG5cbiAgXHQvLyBAb3B0aW9uIHdoZWVsUHhQZXJab29tTGV2ZWw6IE51bWJlciA9IDYwXG4gIFx0Ly8gSG93IG1hbnkgc2Nyb2xsIHBpeGVscyAoYXMgcmVwb3J0ZWQgYnkgW0wuRG9tRXZlbnQuZ2V0V2hlZWxEZWx0YV0oI2RvbWV2ZW50LWdldHdoZWVsZGVsdGEpKVxuICBcdC8vIG1lYW4gYSBjaGFuZ2Ugb2Ygb25lIGZ1bGwgem9vbSBsZXZlbC4gU21hbGxlciB2YWx1ZXMgd2lsbCBtYWtlIHdoZWVsLXpvb21pbmdcbiAgXHQvLyBmYXN0ZXIgKGFuZCB2aWNlIHZlcnNhKS5cbiAgXHR3aGVlbFB4UGVyWm9vbUxldmVsOiA2MFxuICB9KTtcblxuICB2YXIgU2Nyb2xsV2hlZWxab29tID0gSGFuZGxlci5leHRlbmQoe1xuICBcdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRvbih0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ3doZWVsJywgdGhpcy5fb25XaGVlbFNjcm9sbCwgdGhpcyk7XG5cbiAgXHRcdHRoaXMuX2RlbHRhID0gMDtcbiAgXHR9LFxuXG4gIFx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdG9mZih0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ3doZWVsJywgdGhpcy5fb25XaGVlbFNjcm9sbCwgdGhpcyk7XG4gIFx0fSxcblxuICBcdF9vbldoZWVsU2Nyb2xsOiBmdW5jdGlvbiAoZSkge1xuICBcdFx0dmFyIGRlbHRhID0gZ2V0V2hlZWxEZWx0YShlKTtcblxuICBcdFx0dmFyIGRlYm91bmNlID0gdGhpcy5fbWFwLm9wdGlvbnMud2hlZWxEZWJvdW5jZVRpbWU7XG5cbiAgXHRcdHRoaXMuX2RlbHRhICs9IGRlbHRhO1xuICBcdFx0dGhpcy5fbGFzdE1vdXNlUG9zID0gdGhpcy5fbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUpO1xuXG4gIFx0XHRpZiAoIXRoaXMuX3N0YXJ0VGltZSkge1xuICBcdFx0XHR0aGlzLl9zdGFydFRpbWUgPSArbmV3IERhdGUoKTtcbiAgXHRcdH1cblxuICBcdFx0dmFyIGxlZnQgPSBNYXRoLm1heChkZWJvdW5jZSAtICgrbmV3IERhdGUoKSAtIHRoaXMuX3N0YXJ0VGltZSksIDApO1xuXG4gIFx0XHRjbGVhclRpbWVvdXQodGhpcy5fdGltZXIpO1xuICBcdFx0dGhpcy5fdGltZXIgPSBzZXRUaW1lb3V0KGJpbmQodGhpcy5fcGVyZm9ybVpvb20sIHRoaXMpLCBsZWZ0KTtcblxuICBcdFx0c3RvcChlKTtcbiAgXHR9LFxuXG4gIFx0X3BlcmZvcm1ab29tOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuICBcdFx0ICAgIHpvb20gPSBtYXAuZ2V0Wm9vbSgpLFxuICBcdFx0ICAgIHNuYXAgPSB0aGlzLl9tYXAub3B0aW9ucy56b29tU25hcCB8fCAwO1xuXG4gIFx0XHRtYXAuX3N0b3AoKTsgLy8gc3RvcCBwYW5uaW5nIGFuZCBmbHkgYW5pbWF0aW9ucyBpZiBhbnlcblxuICBcdFx0Ly8gbWFwIHRoZSBkZWx0YSB3aXRoIGEgc2lnbW9pZCBmdW5jdGlvbiB0byAtNC4uNCByYW5nZSBsZWFuaW5nIG9uIC0xLi4xXG4gIFx0XHR2YXIgZDIgPSB0aGlzLl9kZWx0YSAvICh0aGlzLl9tYXAub3B0aW9ucy53aGVlbFB4UGVyWm9vbUxldmVsICogNCksXG4gIFx0XHQgICAgZDMgPSA0ICogTWF0aC5sb2coMiAvICgxICsgTWF0aC5leHAoLU1hdGguYWJzKGQyKSkpKSAvIE1hdGguTE4yLFxuICBcdFx0ICAgIGQ0ID0gc25hcCA/IE1hdGguY2VpbChkMyAvIHNuYXApICogc25hcCA6IGQzLFxuICBcdFx0ICAgIGRlbHRhID0gbWFwLl9saW1pdFpvb20oem9vbSArICh0aGlzLl9kZWx0YSA+IDAgPyBkNCA6IC1kNCkpIC0gem9vbTtcblxuICBcdFx0dGhpcy5fZGVsdGEgPSAwO1xuICBcdFx0dGhpcy5fc3RhcnRUaW1lID0gbnVsbDtcblxuICBcdFx0aWYgKCFkZWx0YSkgeyByZXR1cm47IH1cblxuICBcdFx0aWYgKG1hcC5vcHRpb25zLnNjcm9sbFdoZWVsWm9vbSA9PT0gJ2NlbnRlcicpIHtcbiAgXHRcdFx0bWFwLnNldFpvb20oem9vbSArIGRlbHRhKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdG1hcC5zZXRab29tQXJvdW5kKHRoaXMuX2xhc3RNb3VzZVBvcywgem9vbSArIGRlbHRhKTtcbiAgXHRcdH1cbiAgXHR9XG4gIH0pO1xuXG4gIC8vIEBzZWN0aW9uIEhhbmRsZXJzXG4gIC8vIEBwcm9wZXJ0eSBzY3JvbGxXaGVlbFpvb206IEhhbmRsZXJcbiAgLy8gU2Nyb2xsIHdoZWVsIHpvb20gaGFuZGxlci5cbiAgTWFwLmFkZEluaXRIb29rKCdhZGRIYW5kbGVyJywgJ3Njcm9sbFdoZWVsWm9vbScsIFNjcm9sbFdoZWVsWm9vbSk7XG5cbiAgLypcbiAgICogTC5NYXAuVGFwIGlzIHVzZWQgdG8gZW5hYmxlIG1vYmlsZSBoYWNrcyBsaWtlIHF1aWNrIHRhcHMgYW5kIGxvbmcgaG9sZC5cbiAgICovXG5cbiAgLy8gQG5hbWVzcGFjZSBNYXBcbiAgLy8gQHNlY3Rpb24gSW50ZXJhY3Rpb24gT3B0aW9uc1xuICBNYXAubWVyZ2VPcHRpb25zKHtcbiAgXHQvLyBAc2VjdGlvbiBUb3VjaCBpbnRlcmFjdGlvbiBvcHRpb25zXG4gIFx0Ly8gQG9wdGlvbiB0YXA6IEJvb2xlYW4gPSB0cnVlXG4gIFx0Ly8gRW5hYmxlcyBtb2JpbGUgaGFja3MgZm9yIHN1cHBvcnRpbmcgaW5zdGFudCB0YXBzIChmaXhpbmcgMjAwbXMgY2xpY2tcbiAgXHQvLyBkZWxheSBvbiBpT1MvQW5kcm9pZCkgYW5kIHRvdWNoIGhvbGRzIChmaXJlZCBhcyBgY29udGV4dG1lbnVgIGV2ZW50cykuXG4gIFx0dGFwOiB0cnVlLFxuXG4gIFx0Ly8gQG9wdGlvbiB0YXBUb2xlcmFuY2U6IE51bWJlciA9IDE1XG4gIFx0Ly8gVGhlIG1heCBudW1iZXIgb2YgcGl4ZWxzIGEgdXNlciBjYW4gc2hpZnQgaGlzIGZpbmdlciBkdXJpbmcgdG91Y2hcbiAgXHQvLyBmb3IgaXQgdG8gYmUgY29uc2lkZXJlZCBhIHZhbGlkIHRhcC5cbiAgXHR0YXBUb2xlcmFuY2U6IDE1XG4gIH0pO1xuXG4gIHZhciBUYXAgPSBIYW5kbGVyLmV4dGVuZCh7XG4gIFx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdG9uKHRoaXMuX21hcC5fY29udGFpbmVyLCAndG91Y2hzdGFydCcsIHRoaXMuX29uRG93biwgdGhpcyk7XG4gIFx0fSxcblxuICBcdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRvZmYodGhpcy5fbWFwLl9jb250YWluZXIsICd0b3VjaHN0YXJ0JywgdGhpcy5fb25Eb3duLCB0aGlzKTtcbiAgXHR9LFxuXG4gIFx0X29uRG93bjogZnVuY3Rpb24gKGUpIHtcbiAgXHRcdGlmICghZS50b3VjaGVzKSB7IHJldHVybjsgfVxuXG4gIFx0XHRwcmV2ZW50RGVmYXVsdChlKTtcblxuICBcdFx0dGhpcy5fZmlyZUNsaWNrID0gdHJ1ZTtcblxuICBcdFx0Ly8gZG9uJ3Qgc2ltdWxhdGUgY2xpY2sgb3IgdHJhY2sgbG9uZ3ByZXNzIGlmIG1vcmUgdGhhbiAxIHRvdWNoXG4gIFx0XHRpZiAoZS50b3VjaGVzLmxlbmd0aCA+IDEpIHtcbiAgXHRcdFx0dGhpcy5fZmlyZUNsaWNrID0gZmFsc2U7XG4gIFx0XHRcdGNsZWFyVGltZW91dCh0aGlzLl9ob2xkVGltZW91dCk7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0dmFyIGZpcnN0ID0gZS50b3VjaGVzWzBdLFxuICBcdFx0ICAgIGVsID0gZmlyc3QudGFyZ2V0O1xuXG4gIFx0XHR0aGlzLl9zdGFydFBvcyA9IHRoaXMuX25ld1BvcyA9IG5ldyBQb2ludChmaXJzdC5jbGllbnRYLCBmaXJzdC5jbGllbnRZKTtcblxuICBcdFx0Ly8gaWYgdG91Y2hpbmcgYSBsaW5rLCBoaWdobGlnaHQgaXRcbiAgXHRcdGlmIChlbC50YWdOYW1lICYmIGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2EnKSB7XG4gIFx0XHRcdGFkZENsYXNzKGVsLCAnbGVhZmxldC1hY3RpdmUnKTtcbiAgXHRcdH1cblxuICBcdFx0Ly8gc2ltdWxhdGUgbG9uZyBob2xkIGJ1dCBzZXR0aW5nIGEgdGltZW91dFxuICBcdFx0dGhpcy5faG9sZFRpbWVvdXQgPSBzZXRUaW1lb3V0KGJpbmQoZnVuY3Rpb24gKCkge1xuICBcdFx0XHRpZiAodGhpcy5faXNUYXBWYWxpZCgpKSB7XG4gIFx0XHRcdFx0dGhpcy5fZmlyZUNsaWNrID0gZmFsc2U7XG4gIFx0XHRcdFx0dGhpcy5fb25VcCgpO1xuICBcdFx0XHRcdHRoaXMuX3NpbXVsYXRlRXZlbnQoJ2NvbnRleHRtZW51JywgZmlyc3QpO1xuICBcdFx0XHR9XG4gIFx0XHR9LCB0aGlzKSwgMTAwMCk7XG5cbiAgXHRcdHRoaXMuX3NpbXVsYXRlRXZlbnQoJ21vdXNlZG93bicsIGZpcnN0KTtcblxuICBcdFx0b24oZG9jdW1lbnQsIHtcbiAgXHRcdFx0dG91Y2htb3ZlOiB0aGlzLl9vbk1vdmUsXG4gIFx0XHRcdHRvdWNoZW5kOiB0aGlzLl9vblVwXG4gIFx0XHR9LCB0aGlzKTtcbiAgXHR9LFxuXG4gIFx0X29uVXA6IGZ1bmN0aW9uIChlKSB7XG4gIFx0XHRjbGVhclRpbWVvdXQodGhpcy5faG9sZFRpbWVvdXQpO1xuXG4gIFx0XHRvZmYoZG9jdW1lbnQsIHtcbiAgXHRcdFx0dG91Y2htb3ZlOiB0aGlzLl9vbk1vdmUsXG4gIFx0XHRcdHRvdWNoZW5kOiB0aGlzLl9vblVwXG4gIFx0XHR9LCB0aGlzKTtcblxuICBcdFx0aWYgKHRoaXMuX2ZpcmVDbGljayAmJiBlICYmIGUuY2hhbmdlZFRvdWNoZXMpIHtcblxuICBcdFx0XHR2YXIgZmlyc3QgPSBlLmNoYW5nZWRUb3VjaGVzWzBdLFxuICBcdFx0XHQgICAgZWwgPSBmaXJzdC50YXJnZXQ7XG5cbiAgXHRcdFx0aWYgKGVsICYmIGVsLnRhZ05hbWUgJiYgZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnYScpIHtcbiAgXHRcdFx0XHRyZW1vdmVDbGFzcyhlbCwgJ2xlYWZsZXQtYWN0aXZlJyk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHR0aGlzLl9zaW11bGF0ZUV2ZW50KCdtb3VzZXVwJywgZmlyc3QpO1xuXG4gIFx0XHRcdC8vIHNpbXVsYXRlIGNsaWNrIGlmIHRoZSB0b3VjaCBkaWRuJ3QgbW92ZSB0b28gbXVjaFxuICBcdFx0XHRpZiAodGhpcy5faXNUYXBWYWxpZCgpKSB7XG4gIFx0XHRcdFx0dGhpcy5fc2ltdWxhdGVFdmVudCgnY2xpY2snLCBmaXJzdCk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X2lzVGFwVmFsaWQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLl9uZXdQb3MuZGlzdGFuY2VUbyh0aGlzLl9zdGFydFBvcykgPD0gdGhpcy5fbWFwLm9wdGlvbnMudGFwVG9sZXJhbmNlO1xuICBcdH0sXG5cbiAgXHRfb25Nb3ZlOiBmdW5jdGlvbiAoZSkge1xuICBcdFx0dmFyIGZpcnN0ID0gZS50b3VjaGVzWzBdO1xuICBcdFx0dGhpcy5fbmV3UG9zID0gbmV3IFBvaW50KGZpcnN0LmNsaWVudFgsIGZpcnN0LmNsaWVudFkpO1xuICBcdFx0dGhpcy5fc2ltdWxhdGVFdmVudCgnbW91c2Vtb3ZlJywgZmlyc3QpO1xuICBcdH0sXG5cbiAgXHRfc2ltdWxhdGVFdmVudDogZnVuY3Rpb24gKHR5cGUsIGUpIHtcbiAgXHRcdHZhciBzaW11bGF0ZWRFdmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdNb3VzZUV2ZW50cycpO1xuXG4gIFx0XHRzaW11bGF0ZWRFdmVudC5fc2ltdWxhdGVkID0gdHJ1ZTtcbiAgXHRcdGUudGFyZ2V0Ll9zaW11bGF0ZWRDbGljayA9IHRydWU7XG5cbiAgXHRcdHNpbXVsYXRlZEV2ZW50LmluaXRNb3VzZUV2ZW50KFxuICBcdFx0ICAgICAgICB0eXBlLCB0cnVlLCB0cnVlLCB3aW5kb3csIDEsXG4gIFx0XHQgICAgICAgIGUuc2NyZWVuWCwgZS5zY3JlZW5ZLFxuICBcdFx0ICAgICAgICBlLmNsaWVudFgsIGUuY2xpZW50WSxcbiAgXHRcdCAgICAgICAgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIDAsIG51bGwpO1xuXG4gIFx0XHRlLnRhcmdldC5kaXNwYXRjaEV2ZW50KHNpbXVsYXRlZEV2ZW50KTtcbiAgXHR9XG4gIH0pO1xuXG4gIC8vIEBzZWN0aW9uIEhhbmRsZXJzXG4gIC8vIEBwcm9wZXJ0eSB0YXA6IEhhbmRsZXJcbiAgLy8gTW9iaWxlIHRvdWNoIGhhY2tzIChxdWljayB0YXAgYW5kIHRvdWNoIGhvbGQpIGhhbmRsZXIuXG4gIGlmICh0b3VjaCAmJiAoIXBvaW50ZXIgfHwgc2FmYXJpKSkge1xuICBcdE1hcC5hZGRJbml0SG9vaygnYWRkSGFuZGxlcicsICd0YXAnLCBUYXApO1xuICB9XG5cbiAgLypcbiAgICogTC5IYW5kbGVyLlRvdWNoWm9vbSBpcyB1c2VkIGJ5IEwuTWFwIHRvIGFkZCBwaW5jaCB6b29tIG9uIHN1cHBvcnRlZCBtb2JpbGUgYnJvd3NlcnMuXG4gICAqL1xuXG4gIC8vIEBuYW1lc3BhY2UgTWFwXG4gIC8vIEBzZWN0aW9uIEludGVyYWN0aW9uIE9wdGlvbnNcbiAgTWFwLm1lcmdlT3B0aW9ucyh7XG4gIFx0Ly8gQHNlY3Rpb24gVG91Y2ggaW50ZXJhY3Rpb24gb3B0aW9uc1xuICBcdC8vIEBvcHRpb24gdG91Y2hab29tOiBCb29sZWFufFN0cmluZyA9ICpcbiAgXHQvLyBXaGV0aGVyIHRoZSBtYXAgY2FuIGJlIHpvb21lZCBieSB0b3VjaC1kcmFnZ2luZyB3aXRoIHR3byBmaW5nZXJzLiBJZlxuICBcdC8vIHBhc3NlZCBgJ2NlbnRlcidgLCBpdCB3aWxsIHpvb20gdG8gdGhlIGNlbnRlciBvZiB0aGUgdmlldyByZWdhcmRsZXNzIG9mXG4gIFx0Ly8gd2hlcmUgdGhlIHRvdWNoIGV2ZW50cyAoZmluZ2Vycykgd2VyZS4gRW5hYmxlZCBmb3IgdG91Y2gtY2FwYWJsZSB3ZWJcbiAgXHQvLyBicm93c2VycyBleGNlcHQgZm9yIG9sZCBBbmRyb2lkcy5cbiAgXHR0b3VjaFpvb206IHRvdWNoICYmICFhbmRyb2lkMjMsXG5cbiAgXHQvLyBAb3B0aW9uIGJvdW5jZUF0Wm9vbUxpbWl0czogQm9vbGVhbiA9IHRydWVcbiAgXHQvLyBTZXQgaXQgdG8gZmFsc2UgaWYgeW91IGRvbid0IHdhbnQgdGhlIG1hcCB0byB6b29tIGJleW9uZCBtaW4vbWF4IHpvb21cbiAgXHQvLyBhbmQgdGhlbiBib3VuY2UgYmFjayB3aGVuIHBpbmNoLXpvb21pbmcuXG4gIFx0Ym91bmNlQXRab29tTGltaXRzOiB0cnVlXG4gIH0pO1xuXG4gIHZhciBUb3VjaFpvb20gPSBIYW5kbGVyLmV4dGVuZCh7XG4gIFx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGFkZENsYXNzKHRoaXMuX21hcC5fY29udGFpbmVyLCAnbGVhZmxldC10b3VjaC16b29tJyk7XG4gIFx0XHRvbih0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ3RvdWNoc3RhcnQnLCB0aGlzLl9vblRvdWNoU3RhcnQsIHRoaXMpO1xuICBcdH0sXG5cbiAgXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuICBcdFx0cmVtb3ZlQ2xhc3ModGhpcy5fbWFwLl9jb250YWluZXIsICdsZWFmbGV0LXRvdWNoLXpvb20nKTtcbiAgXHRcdG9mZih0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ3RvdWNoc3RhcnQnLCB0aGlzLl9vblRvdWNoU3RhcnQsIHRoaXMpO1xuICBcdH0sXG5cbiAgXHRfb25Ub3VjaFN0YXJ0OiBmdW5jdGlvbiAoZSkge1xuICBcdFx0dmFyIG1hcCA9IHRoaXMuX21hcDtcbiAgXHRcdGlmICghZS50b3VjaGVzIHx8IGUudG91Y2hlcy5sZW5ndGggIT09IDIgfHwgbWFwLl9hbmltYXRpbmdab29tIHx8IHRoaXMuX3pvb21pbmcpIHsgcmV0dXJuOyB9XG5cbiAgXHRcdHZhciBwMSA9IG1hcC5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlLnRvdWNoZXNbMF0pLFxuICBcdFx0ICAgIHAyID0gbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUudG91Y2hlc1sxXSk7XG5cbiAgXHRcdHRoaXMuX2NlbnRlclBvaW50ID0gbWFwLmdldFNpemUoKS5fZGl2aWRlQnkoMik7XG4gIFx0XHR0aGlzLl9zdGFydExhdExuZyA9IG1hcC5jb250YWluZXJQb2ludFRvTGF0TG5nKHRoaXMuX2NlbnRlclBvaW50KTtcbiAgXHRcdGlmIChtYXAub3B0aW9ucy50b3VjaFpvb20gIT09ICdjZW50ZXInKSB7XG4gIFx0XHRcdHRoaXMuX3BpbmNoU3RhcnRMYXRMbmcgPSBtYXAuY29udGFpbmVyUG9pbnRUb0xhdExuZyhwMS5hZGQocDIpLl9kaXZpZGVCeSgyKSk7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMuX3N0YXJ0RGlzdCA9IHAxLmRpc3RhbmNlVG8ocDIpO1xuICBcdFx0dGhpcy5fc3RhcnRab29tID0gbWFwLmdldFpvb20oKTtcblxuICBcdFx0dGhpcy5fbW92ZWQgPSBmYWxzZTtcbiAgXHRcdHRoaXMuX3pvb21pbmcgPSB0cnVlO1xuXG4gIFx0XHRtYXAuX3N0b3AoKTtcblxuICBcdFx0b24oZG9jdW1lbnQsICd0b3VjaG1vdmUnLCB0aGlzLl9vblRvdWNoTW92ZSwgdGhpcyk7XG4gIFx0XHRvbihkb2N1bWVudCwgJ3RvdWNoZW5kJywgdGhpcy5fb25Ub3VjaEVuZCwgdGhpcyk7XG5cbiAgXHRcdHByZXZlbnREZWZhdWx0KGUpO1xuICBcdH0sXG5cbiAgXHRfb25Ub3VjaE1vdmU6IGZ1bmN0aW9uIChlKSB7XG4gIFx0XHRpZiAoIWUudG91Y2hlcyB8fCBlLnRvdWNoZXMubGVuZ3RoICE9PSAyIHx8ICF0aGlzLl96b29taW5nKSB7IHJldHVybjsgfVxuXG4gIFx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuICBcdFx0ICAgIHAxID0gbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUudG91Y2hlc1swXSksXG4gIFx0XHQgICAgcDIgPSBtYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZS50b3VjaGVzWzFdKSxcbiAgXHRcdCAgICBzY2FsZSA9IHAxLmRpc3RhbmNlVG8ocDIpIC8gdGhpcy5fc3RhcnREaXN0O1xuXG4gIFx0XHR0aGlzLl96b29tID0gbWFwLmdldFNjYWxlWm9vbShzY2FsZSwgdGhpcy5fc3RhcnRab29tKTtcblxuICBcdFx0aWYgKCFtYXAub3B0aW9ucy5ib3VuY2VBdFpvb21MaW1pdHMgJiYgKFxuICBcdFx0XHQodGhpcy5fem9vbSA8IG1hcC5nZXRNaW5ab29tKCkgJiYgc2NhbGUgPCAxKSB8fFxuICBcdFx0XHQodGhpcy5fem9vbSA+IG1hcC5nZXRNYXhab29tKCkgJiYgc2NhbGUgPiAxKSkpIHtcbiAgXHRcdFx0dGhpcy5fem9vbSA9IG1hcC5fbGltaXRab29tKHRoaXMuX3pvb20pO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAobWFwLm9wdGlvbnMudG91Y2hab29tID09PSAnY2VudGVyJykge1xuICBcdFx0XHR0aGlzLl9jZW50ZXIgPSB0aGlzLl9zdGFydExhdExuZztcbiAgXHRcdFx0aWYgKHNjYWxlID09PSAxKSB7IHJldHVybjsgfVxuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0Ly8gR2V0IGRlbHRhIGZyb20gcGluY2ggdG8gY2VudGVyLCBzbyBjZW50ZXJMYXRMbmcgaXMgZGVsdGEgYXBwbGllZCB0byBpbml0aWFsIHBpbmNoTGF0TG5nXG4gIFx0XHRcdHZhciBkZWx0YSA9IHAxLl9hZGQocDIpLl9kaXZpZGVCeSgyKS5fc3VidHJhY3QodGhpcy5fY2VudGVyUG9pbnQpO1xuICBcdFx0XHRpZiAoc2NhbGUgPT09IDEgJiYgZGVsdGEueCA9PT0gMCAmJiBkZWx0YS55ID09PSAwKSB7IHJldHVybjsgfVxuICBcdFx0XHR0aGlzLl9jZW50ZXIgPSBtYXAudW5wcm9qZWN0KG1hcC5wcm9qZWN0KHRoaXMuX3BpbmNoU3RhcnRMYXRMbmcsIHRoaXMuX3pvb20pLnN1YnRyYWN0KGRlbHRhKSwgdGhpcy5fem9vbSk7XG4gIFx0XHR9XG5cbiAgXHRcdGlmICghdGhpcy5fbW92ZWQpIHtcbiAgXHRcdFx0bWFwLl9tb3ZlU3RhcnQodHJ1ZSwgZmFsc2UpO1xuICBcdFx0XHR0aGlzLl9tb3ZlZCA9IHRydWU7XG4gIFx0XHR9XG5cbiAgXHRcdGNhbmNlbEFuaW1GcmFtZSh0aGlzLl9hbmltUmVxdWVzdCk7XG5cbiAgXHRcdHZhciBtb3ZlRm4gPSBiaW5kKG1hcC5fbW92ZSwgbWFwLCB0aGlzLl9jZW50ZXIsIHRoaXMuX3pvb20sIHtwaW5jaDogdHJ1ZSwgcm91bmQ6IGZhbHNlfSk7XG4gIFx0XHR0aGlzLl9hbmltUmVxdWVzdCA9IHJlcXVlc3RBbmltRnJhbWUobW92ZUZuLCB0aGlzLCB0cnVlKTtcblxuICBcdFx0cHJldmVudERlZmF1bHQoZSk7XG4gIFx0fSxcblxuICBcdF9vblRvdWNoRW5kOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAoIXRoaXMuX21vdmVkIHx8ICF0aGlzLl96b29taW5nKSB7XG4gIFx0XHRcdHRoaXMuX3pvb21pbmcgPSBmYWxzZTtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLl96b29taW5nID0gZmFsc2U7XG4gIFx0XHRjYW5jZWxBbmltRnJhbWUodGhpcy5fYW5pbVJlcXVlc3QpO1xuXG4gIFx0XHRvZmYoZG9jdW1lbnQsICd0b3VjaG1vdmUnLCB0aGlzLl9vblRvdWNoTW92ZSwgdGhpcyk7XG4gIFx0XHRvZmYoZG9jdW1lbnQsICd0b3VjaGVuZCcsIHRoaXMuX29uVG91Y2hFbmQsIHRoaXMpO1xuXG4gIFx0XHQvLyBQaW5jaCB1cGRhdGVzIEdyaWRMYXllcnMnIGxldmVscyBvbmx5IHdoZW4gem9vbVNuYXAgaXMgb2ZmLCBzbyB6b29tU25hcCBiZWNvbWVzIG5vVXBkYXRlLlxuICBcdFx0aWYgKHRoaXMuX21hcC5vcHRpb25zLnpvb21BbmltYXRpb24pIHtcbiAgXHRcdFx0dGhpcy5fbWFwLl9hbmltYXRlWm9vbSh0aGlzLl9jZW50ZXIsIHRoaXMuX21hcC5fbGltaXRab29tKHRoaXMuX3pvb20pLCB0cnVlLCB0aGlzLl9tYXAub3B0aW9ucy56b29tU25hcCk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHR0aGlzLl9tYXAuX3Jlc2V0Vmlldyh0aGlzLl9jZW50ZXIsIHRoaXMuX21hcC5fbGltaXRab29tKHRoaXMuX3pvb20pKTtcbiAgXHRcdH1cbiAgXHR9XG4gIH0pO1xuXG4gIC8vIEBzZWN0aW9uIEhhbmRsZXJzXG4gIC8vIEBwcm9wZXJ0eSB0b3VjaFpvb206IEhhbmRsZXJcbiAgLy8gVG91Y2ggem9vbSBoYW5kbGVyLlxuICBNYXAuYWRkSW5pdEhvb2soJ2FkZEhhbmRsZXInLCAndG91Y2hab29tJywgVG91Y2hab29tKTtcblxuICBNYXAuQm94Wm9vbSA9IEJveFpvb207XG4gIE1hcC5Eb3VibGVDbGlja1pvb20gPSBEb3VibGVDbGlja1pvb207XG4gIE1hcC5EcmFnID0gRHJhZztcbiAgTWFwLktleWJvYXJkID0gS2V5Ym9hcmQ7XG4gIE1hcC5TY3JvbGxXaGVlbFpvb20gPSBTY3JvbGxXaGVlbFpvb207XG4gIE1hcC5UYXAgPSBUYXA7XG4gIE1hcC5Ub3VjaFpvb20gPSBUb3VjaFpvb207XG5cbiAgZXhwb3J0cy52ZXJzaW9uID0gdmVyc2lvbjtcbiAgZXhwb3J0cy5Db250cm9sID0gQ29udHJvbDtcbiAgZXhwb3J0cy5jb250cm9sID0gY29udHJvbDtcbiAgZXhwb3J0cy5Ccm93c2VyID0gQnJvd3NlcjtcbiAgZXhwb3J0cy5FdmVudGVkID0gRXZlbnRlZDtcbiAgZXhwb3J0cy5NaXhpbiA9IE1peGluO1xuICBleHBvcnRzLlV0aWwgPSBVdGlsO1xuICBleHBvcnRzLkNsYXNzID0gQ2xhc3M7XG4gIGV4cG9ydHMuSGFuZGxlciA9IEhhbmRsZXI7XG4gIGV4cG9ydHMuZXh0ZW5kID0gZXh0ZW5kO1xuICBleHBvcnRzLmJpbmQgPSBiaW5kO1xuICBleHBvcnRzLnN0YW1wID0gc3RhbXA7XG4gIGV4cG9ydHMuc2V0T3B0aW9ucyA9IHNldE9wdGlvbnM7XG4gIGV4cG9ydHMuRG9tRXZlbnQgPSBEb21FdmVudDtcbiAgZXhwb3J0cy5Eb21VdGlsID0gRG9tVXRpbDtcbiAgZXhwb3J0cy5Qb3NBbmltYXRpb24gPSBQb3NBbmltYXRpb247XG4gIGV4cG9ydHMuRHJhZ2dhYmxlID0gRHJhZ2dhYmxlO1xuICBleHBvcnRzLkxpbmVVdGlsID0gTGluZVV0aWw7XG4gIGV4cG9ydHMuUG9seVV0aWwgPSBQb2x5VXRpbDtcbiAgZXhwb3J0cy5Qb2ludCA9IFBvaW50O1xuICBleHBvcnRzLnBvaW50ID0gdG9Qb2ludDtcbiAgZXhwb3J0cy5Cb3VuZHMgPSBCb3VuZHM7XG4gIGV4cG9ydHMuYm91bmRzID0gdG9Cb3VuZHM7XG4gIGV4cG9ydHMuVHJhbnNmb3JtYXRpb24gPSBUcmFuc2Zvcm1hdGlvbjtcbiAgZXhwb3J0cy50cmFuc2Zvcm1hdGlvbiA9IHRvVHJhbnNmb3JtYXRpb247XG4gIGV4cG9ydHMuUHJvamVjdGlvbiA9IGluZGV4O1xuICBleHBvcnRzLkxhdExuZyA9IExhdExuZztcbiAgZXhwb3J0cy5sYXRMbmcgPSB0b0xhdExuZztcbiAgZXhwb3J0cy5MYXRMbmdCb3VuZHMgPSBMYXRMbmdCb3VuZHM7XG4gIGV4cG9ydHMubGF0TG5nQm91bmRzID0gdG9MYXRMbmdCb3VuZHM7XG4gIGV4cG9ydHMuQ1JTID0gQ1JTO1xuICBleHBvcnRzLkdlb0pTT04gPSBHZW9KU09OO1xuICBleHBvcnRzLmdlb0pTT04gPSBnZW9KU09OO1xuICBleHBvcnRzLmdlb0pzb24gPSBnZW9Kc29uO1xuICBleHBvcnRzLkxheWVyID0gTGF5ZXI7XG4gIGV4cG9ydHMuTGF5ZXJHcm91cCA9IExheWVyR3JvdXA7XG4gIGV4cG9ydHMubGF5ZXJHcm91cCA9IGxheWVyR3JvdXA7XG4gIGV4cG9ydHMuRmVhdHVyZUdyb3VwID0gRmVhdHVyZUdyb3VwO1xuICBleHBvcnRzLmZlYXR1cmVHcm91cCA9IGZlYXR1cmVHcm91cDtcbiAgZXhwb3J0cy5JbWFnZU92ZXJsYXkgPSBJbWFnZU92ZXJsYXk7XG4gIGV4cG9ydHMuaW1hZ2VPdmVybGF5ID0gaW1hZ2VPdmVybGF5O1xuICBleHBvcnRzLlZpZGVvT3ZlcmxheSA9IFZpZGVvT3ZlcmxheTtcbiAgZXhwb3J0cy52aWRlb092ZXJsYXkgPSB2aWRlb092ZXJsYXk7XG4gIGV4cG9ydHMuU1ZHT3ZlcmxheSA9IFNWR092ZXJsYXk7XG4gIGV4cG9ydHMuc3ZnT3ZlcmxheSA9IHN2Z092ZXJsYXk7XG4gIGV4cG9ydHMuRGl2T3ZlcmxheSA9IERpdk92ZXJsYXk7XG4gIGV4cG9ydHMuUG9wdXAgPSBQb3B1cDtcbiAgZXhwb3J0cy5wb3B1cCA9IHBvcHVwO1xuICBleHBvcnRzLlRvb2x0aXAgPSBUb29sdGlwO1xuICBleHBvcnRzLnRvb2x0aXAgPSB0b29sdGlwO1xuICBleHBvcnRzLkljb24gPSBJY29uO1xuICBleHBvcnRzLmljb24gPSBpY29uO1xuICBleHBvcnRzLkRpdkljb24gPSBEaXZJY29uO1xuICBleHBvcnRzLmRpdkljb24gPSBkaXZJY29uO1xuICBleHBvcnRzLk1hcmtlciA9IE1hcmtlcjtcbiAgZXhwb3J0cy5tYXJrZXIgPSBtYXJrZXI7XG4gIGV4cG9ydHMuVGlsZUxheWVyID0gVGlsZUxheWVyO1xuICBleHBvcnRzLnRpbGVMYXllciA9IHRpbGVMYXllcjtcbiAgZXhwb3J0cy5HcmlkTGF5ZXIgPSBHcmlkTGF5ZXI7XG4gIGV4cG9ydHMuZ3JpZExheWVyID0gZ3JpZExheWVyO1xuICBleHBvcnRzLlNWRyA9IFNWRztcbiAgZXhwb3J0cy5zdmcgPSBzdmckMTtcbiAgZXhwb3J0cy5SZW5kZXJlciA9IFJlbmRlcmVyO1xuICBleHBvcnRzLkNhbnZhcyA9IENhbnZhcztcbiAgZXhwb3J0cy5jYW52YXMgPSBjYW52YXMkMTtcbiAgZXhwb3J0cy5QYXRoID0gUGF0aDtcbiAgZXhwb3J0cy5DaXJjbGVNYXJrZXIgPSBDaXJjbGVNYXJrZXI7XG4gIGV4cG9ydHMuY2lyY2xlTWFya2VyID0gY2lyY2xlTWFya2VyO1xuICBleHBvcnRzLkNpcmNsZSA9IENpcmNsZTtcbiAgZXhwb3J0cy5jaXJjbGUgPSBjaXJjbGU7XG4gIGV4cG9ydHMuUG9seWxpbmUgPSBQb2x5bGluZTtcbiAgZXhwb3J0cy5wb2x5bGluZSA9IHBvbHlsaW5lO1xuICBleHBvcnRzLlBvbHlnb24gPSBQb2x5Z29uO1xuICBleHBvcnRzLnBvbHlnb24gPSBwb2x5Z29uO1xuICBleHBvcnRzLlJlY3RhbmdsZSA9IFJlY3RhbmdsZTtcbiAgZXhwb3J0cy5yZWN0YW5nbGUgPSByZWN0YW5nbGU7XG4gIGV4cG9ydHMuTWFwID0gTWFwO1xuICBleHBvcnRzLm1hcCA9IGNyZWF0ZU1hcDtcblxuICB2YXIgb2xkTCA9IHdpbmRvdy5MO1xuICBleHBvcnRzLm5vQ29uZmxpY3QgPSBmdW5jdGlvbigpIHtcbiAgXHR3aW5kb3cuTCA9IG9sZEw7XG4gIFx0cmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBBbHdheXMgZXhwb3J0IHVzIHRvIHdpbmRvdyBnbG9iYWwgKHNlZSAjMjM2NClcbiAgd2luZG93LkwgPSBleHBvcnRzO1xuXG59KSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGVhZmxldC1zcmMuanMubWFwXG4iLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB7fTsiLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fc3ByZWFkQXJyYXlzID0gKHRoaXMgJiYgdGhpcy5fX3NwcmVhZEFycmF5cykgfHwgZnVuY3Rpb24gKCkge1xyXG4gICAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XHJcbiAgICBmb3IgKHZhciByID0gQXJyYXkocyksIGsgPSAwLCBpID0gMDsgaSA8IGlsOyBpKyspXHJcbiAgICAgICAgZm9yICh2YXIgYSA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYS5sZW5ndGg7IGogPCBqbDsgaisrLCBrKyspXHJcbiAgICAgICAgICAgIHJba10gPSBhW2pdO1xyXG4gICAgcmV0dXJuIHI7XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5EaXNwYXRjaGVyV3JhcHBlciA9IGV4cG9ydHMuRXZlbnRMaXN0QmFzZSA9IGV4cG9ydHMuRGlzcGF0Y2hlckJhc2UgPSB2b2lkIDA7XHJcbnZhciBtYW5hZ2VtZW50XzEgPSByZXF1aXJlKFwiLi9tYW5hZ2VtZW50XCIpO1xyXG52YXIgc3Vic2NyaXB0aW9uXzEgPSByZXF1aXJlKFwiLi9zdWJzY3JpcHRpb25cIik7XHJcbi8qKlxyXG4gKiBCYXNlIGNsYXNzIGZvciBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgZGlzcGF0Y2hlci4gSXQgZmFjaWxpdGF0ZXMgdGhlIHN1YnNjcmliZVxyXG4gKiBhbmQgdW5zdWJzY3JpYmUgbWV0aG9kcyBiYXNlZCBvbiBnZW5lcmljIGhhbmRsZXJzLiBUaGUgVEV2ZW50VHlwZSBzcGVjaWZpZXNcclxuICogdGhlIHR5cGUgb2YgZXZlbnQgdGhhdCBzaG91bGQgYmUgZXhwb3NlZC4gVXNlIHRoZSBhc0V2ZW50IHRvIGV4cG9zZSB0aGVcclxuICogZGlzcGF0Y2hlciBhcyBldmVudC5cclxuICovXHJcbnZhciBEaXNwYXRjaGVyQmFzZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIERpc3BhdGNoZXJCYXNlKCkge1xyXG4gICAgICAgIHRoaXMuX3dyYXAgPSBuZXcgRGlzcGF0Y2hlcldyYXBwZXIodGhpcyk7XHJcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9ucyA9IG5ldyBBcnJheSgpO1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERpc3BhdGNoZXJCYXNlLnByb3RvdHlwZSwgXCJjb3VudFwiLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIHN1YnNjcmlwdGlvbnMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmVhZG9ubHlcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBEaXNwYXRjaGVyQmFzZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3Vic2NyaXB0aW9ucy5sZW5ndGg7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTdWJzY3JpYmUgdG8gdGhlIGV2ZW50IGRpc3BhdGNoZXIuXHJcbiAgICAgKiBAcGFyYW0gZm4gVGhlIGV2ZW50IGhhbmRsZXIgdGhhdCBpcyBjYWxsZWQgd2hlbiB0aGUgZXZlbnQgaXMgZGlzcGF0Y2hlZC5cclxuICAgICAqIEByZXR1cm5zIEEgZnVuY3Rpb24gdGhhdCB1bnN1YnNjcmliZXMgdGhlIGV2ZW50IGhhbmRsZXIgZnJvbSB0aGUgZXZlbnQuXHJcbiAgICAgKi9cclxuICAgIERpc3BhdGNoZXJCYXNlLnByb3RvdHlwZS5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoZm4pIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmIChmbikge1xyXG4gICAgICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb25zLnB1c2gobmV3IHN1YnNjcmlwdGlvbl8xLlN1YnNjcmlwdGlvbihmbiwgZmFsc2UpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgX3RoaXMudW5zdWJzY3JpYmUoZm4pO1xyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBTdWJzY3JpYmUgdG8gdGhlIGV2ZW50IGRpc3BhdGNoZXIuXHJcbiAgICAgKiBAcGFyYW0gZm4gVGhlIGV2ZW50IGhhbmRsZXIgdGhhdCBpcyBjYWxsZWQgd2hlbiB0aGUgZXZlbnQgaXMgZGlzcGF0Y2hlZC5cclxuICAgICAqIEByZXR1cm5zIEEgZnVuY3Rpb24gdGhhdCB1bnN1YnNjcmliZXMgdGhlIGV2ZW50IGhhbmRsZXIgZnJvbSB0aGUgZXZlbnQuXHJcbiAgICAgKi9cclxuICAgIERpc3BhdGNoZXJCYXNlLnByb3RvdHlwZS5zdWIgPSBmdW5jdGlvbiAoZm4pIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zdWJzY3JpYmUoZm4pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogU3Vic2NyaWJlIG9uY2UgdG8gdGhlIGV2ZW50IHdpdGggdGhlIHNwZWNpZmllZCBuYW1lLlxyXG4gICAgICogQHBhcmFtIGZuIFRoZSBldmVudCBoYW5kbGVyIHRoYXQgaXMgY2FsbGVkIHdoZW4gdGhlIGV2ZW50IGlzIGRpc3BhdGNoZWQuXHJcbiAgICAgKiBAcmV0dXJucyBBIGZ1bmN0aW9uIHRoYXQgdW5zdWJzY3JpYmVzIHRoZSBldmVudCBoYW5kbGVyIGZyb20gdGhlIGV2ZW50LlxyXG4gICAgICovXHJcbiAgICBEaXNwYXRjaGVyQmFzZS5wcm90b3R5cGUub25lID0gZnVuY3Rpb24gKGZuKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAoZm4pIHtcclxuICAgICAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9ucy5wdXNoKG5ldyBzdWJzY3JpcHRpb25fMS5TdWJzY3JpcHRpb24oZm4sIHRydWUpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgX3RoaXMudW5zdWJzY3JpYmUoZm4pO1xyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3MgaXQgdGhlIGV2ZW50IGhhcyBhIHN1YnNjcmlwdGlvbiBmb3IgdGhlIHNwZWNpZmllZCBoYW5kbGVyLlxyXG4gICAgICogQHBhcmFtIGZuIFRoZSBldmVudCBoYW5kbGVyLlxyXG4gICAgICovXHJcbiAgICBEaXNwYXRjaGVyQmFzZS5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gKGZuKSB7XHJcbiAgICAgICAgaWYgKCFmbilcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9zdWJzY3JpcHRpb25zLnNvbWUoZnVuY3Rpb24gKHN1YikgeyByZXR1cm4gc3ViLmhhbmRsZXIgPT0gZm47IH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogVW5zdWJzY3JpYmVzIHRoZSBoYW5kbGVyIGZyb20gdGhlIGRpc3BhdGNoZXIuXHJcbiAgICAgKiBAcGFyYW0gZm4gVGhlIGV2ZW50IGhhbmRsZXIuXHJcbiAgICAgKi9cclxuICAgIERpc3BhdGNoZXJCYXNlLnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uIChmbikge1xyXG4gICAgICAgIGlmICghZm4pXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3N1YnNjcmlwdGlvbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX3N1YnNjcmlwdGlvbnNbaV0uaGFuZGxlciA9PSBmbikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9ucy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFVuc3Vic2NyaWJlcyB0aGUgaGFuZGxlciBmcm9tIHRoZSBkaXNwYXRjaGVyLlxyXG4gICAgICogQHBhcmFtIGZuIFRoZSBldmVudCBoYW5kbGVyLlxyXG4gICAgICovXHJcbiAgICBEaXNwYXRjaGVyQmFzZS5wcm90b3R5cGUudW5zdWIgPSBmdW5jdGlvbiAoZm4pIHtcclxuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKGZuKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEdlbmVyaWMgZGlzcGF0Y2ggd2lsbCBkaXNwYXRjaCB0aGUgaGFuZGxlcnMgd2l0aCB0aGUgZ2l2ZW4gYXJndW1lbnRzLlxyXG4gICAgICpcclxuICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZXhlY3V0ZUFzeW5jIFRydWUgaWYgdGhlIGV2ZW4gc2hvdWxkIGJlIGV4ZWN1dGVkIGFzeW5jLlxyXG4gICAgICogQHBhcmFtIHsqfSBUaGUgc2NvcGUgdGhlIHNjb3BlIG9mIHRoZSBldmVudC4gVGhlIHNjb3BlIGJlY29tZXMgdGhlIFwidGhpc1wiIGZvciBoYW5kbGVyLlxyXG4gICAgICogQHBhcmFtIHtJQXJndW1lbnRzfSBhcmdzIFRoZSBhcmd1bWVudHMgZm9yIHRoZSBldmVudC5cclxuICAgICAqL1xyXG4gICAgRGlzcGF0Y2hlckJhc2UucHJvdG90eXBlLl9kaXNwYXRjaCA9IGZ1bmN0aW9uIChleGVjdXRlQXN5bmMsIHNjb3BlLCBhcmdzKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uIChzdWIpIHtcclxuICAgICAgICAgICAgdmFyIGV2ID0gbmV3IG1hbmFnZW1lbnRfMS5FdmVudE1hbmFnZW1lbnQoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMudW5zdWIoc3ViLmhhbmRsZXIpOyB9KTtcclxuICAgICAgICAgICAgdmFyIG5hcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncyk7XHJcbiAgICAgICAgICAgIG5hcmdzLnB1c2goZXYpO1xyXG4gICAgICAgICAgICBzdWIuZXhlY3V0ZShleGVjdXRlQXN5bmMsIHNjb3BlLCBuYXJncyk7XHJcbiAgICAgICAgICAgIC8vY2xlYW51cCBzdWJzIHRoYXQgYXJlIG5vIGxvbmdlciBuZWVkZWRcclxuICAgICAgICAgICAgdGhpc18xLmNsZWFudXAoc3ViKTtcclxuICAgICAgICAgICAgaWYgKCFleGVjdXRlQXN5bmMgJiYgZXYucHJvcGFnYXRpb25TdG9wcGVkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJicmVha1wiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgdGhpc18xID0gdGhpcztcclxuICAgICAgICAvL2V4ZWN1dGUgb24gYSBjb3B5IGJlY2F1c2Ugb2YgYnVnICM5XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IF9fc3ByZWFkQXJyYXlzKHRoaXMuX3N1YnNjcmlwdGlvbnMpOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICB2YXIgc3ViID0gX2FbX2ldO1xyXG4gICAgICAgICAgICB2YXIgc3RhdGVfMSA9IF9sb29wXzEoc3ViKTtcclxuICAgICAgICAgICAgaWYgKHN0YXRlXzEgPT09IFwiYnJlYWtcIilcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENsZWFucyB1cCBzdWJzIHRoYXQgcmFuIGFuZCBzaG91bGQgcnVuIG9ubHkgb25jZS5cclxuICAgICAqL1xyXG4gICAgRGlzcGF0Y2hlckJhc2UucHJvdG90eXBlLmNsZWFudXAgPSBmdW5jdGlvbiAoc3ViKSB7XHJcbiAgICAgICAgaWYgKHN1Yi5pc09uY2UgJiYgc3ViLmlzRXhlY3V0ZWQpIHtcclxuICAgICAgICAgICAgdmFyIGkgPSB0aGlzLl9zdWJzY3JpcHRpb25zLmluZGV4T2Yoc3ViKTtcclxuICAgICAgICAgICAgaWYgKGkgPiAtMSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9ucy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGV2ZW50IGZyb20gdGhlIGRpc3BhdGNoZXIuIFdpbGwgcmV0dXJuIHRoZSBkaXNwYXRjaGVyXHJcbiAgICAgKiBpbiBhIHdyYXBwZXIuIFRoaXMgd2lsbCBwcmV2ZW50IGV4cG9zdXJlIG9mIGFueSBkaXNwYXRjaGVyIG1ldGhvZHMuXHJcbiAgICAgKi9cclxuICAgIERpc3BhdGNoZXJCYXNlLnByb3RvdHlwZS5hc0V2ZW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl93cmFwO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQ2xlYXJzIGFsbCB0aGUgc3Vic2NyaXB0aW9ucy5cclxuICAgICAqL1xyXG4gICAgRGlzcGF0Y2hlckJhc2UucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbnMuc3BsaWNlKDAsIHRoaXMuX3N1YnNjcmlwdGlvbnMubGVuZ3RoKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRGlzcGF0Y2hlckJhc2U7XHJcbn0oKSk7XHJcbmV4cG9ydHMuRGlzcGF0Y2hlckJhc2UgPSBEaXNwYXRjaGVyQmFzZTtcclxuLyoqXHJcbiAqIEJhc2UgY2xhc3MgZm9yIGV2ZW50IGxpc3RzIGNsYXNzZXMuIEltcGxlbWVudHMgdGhlIGdldCBhbmQgcmVtb3ZlLlxyXG4gKi9cclxudmFyIEV2ZW50TGlzdEJhc2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBFdmVudExpc3RCYXNlKCkge1xyXG4gICAgICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBkaXNwYXRjaGVyIGFzc29jaWF0ZWQgd2l0aCB0aGUgbmFtZS5cclxuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudC5cclxuICAgICAqL1xyXG4gICAgRXZlbnRMaXN0QmFzZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICB2YXIgZXZlbnQgPSB0aGlzLl9ldmVudHNbbmFtZV07XHJcbiAgICAgICAgaWYgKGV2ZW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBldmVudDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZXZlbnQgPSB0aGlzLmNyZWF0ZURpc3BhdGNoZXIoKTtcclxuICAgICAgICB0aGlzLl9ldmVudHNbbmFtZV0gPSBldmVudDtcclxuICAgICAgICByZXR1cm4gZXZlbnQ7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIHRoZSBkaXNwYXRjaGVyIGFzc29jaWF0ZWQgd2l0aCB0aGUgbmFtZS5cclxuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudC5cclxuICAgICAqL1xyXG4gICAgRXZlbnRMaXN0QmFzZS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW25hbWVdO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBFdmVudExpc3RCYXNlO1xyXG59KCkpO1xyXG5leHBvcnRzLkV2ZW50TGlzdEJhc2UgPSBFdmVudExpc3RCYXNlO1xyXG4vKipcclxuICogSGlkZXMgdGhlIGltcGxlbWVudGF0aW9uIG9mIHRoZSBldmVudCBkaXNwYXRjaGVyLiBXaWxsIGV4cG9zZSBtZXRob2RzIHRoYXRcclxuICogYXJlIHJlbGV2ZW50IHRvIHRoZSBldmVudC5cclxuICovXHJcbnZhciBEaXNwYXRjaGVyV3JhcHBlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBFdmVudERpc3BhdGNoZXJXcmFwcGVyIGluc3RhbmNlLlxyXG4gICAgICogQHBhcmFtIGRpc3BhdGNoZXIgVGhlIGRpc3BhdGNoZXIuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIERpc3BhdGNoZXJXcmFwcGVyKGRpc3BhdGNoZXIpIHtcclxuICAgICAgICB0aGlzLl9zdWJzY3JpYmUgPSBmdW5jdGlvbiAoZm4pIHsgcmV0dXJuIGRpc3BhdGNoZXIuc3Vic2NyaWJlKGZuKTsgfTtcclxuICAgICAgICB0aGlzLl91bnN1YnNjcmliZSA9IGZ1bmN0aW9uIChmbikgeyByZXR1cm4gZGlzcGF0Y2hlci51bnN1YnNjcmliZShmbik7IH07XHJcbiAgICAgICAgdGhpcy5fb25lID0gZnVuY3Rpb24gKGZuKSB7IHJldHVybiBkaXNwYXRjaGVyLm9uZShmbik7IH07XHJcbiAgICAgICAgdGhpcy5faGFzID0gZnVuY3Rpb24gKGZuKSB7IHJldHVybiBkaXNwYXRjaGVyLmhhcyhmbik7IH07XHJcbiAgICAgICAgdGhpcy5fY2xlYXIgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBkaXNwYXRjaGVyLmNsZWFyKCk7IH07XHJcbiAgICAgICAgdGhpcy5fY291bnQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBkaXNwYXRjaGVyLmNvdW50OyB9O1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERpc3BhdGNoZXJXcmFwcGVyLnByb3RvdHlwZSwgXCJjb3VudFwiLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIHN1YnNjcmlwdGlvbnMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmVhZG9ubHlcclxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBEaXNwYXRjaGVyV3JhcHBlclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY291bnQoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICAvKipcclxuICAgICAqIFN1YnNjcmliZSB0byB0aGUgZXZlbnQgZGlzcGF0Y2hlci5cclxuICAgICAqIEBwYXJhbSBmbiBUaGUgZXZlbnQgaGFuZGxlciB0aGF0IGlzIGNhbGxlZCB3aGVuIHRoZSBldmVudCBpcyBkaXNwYXRjaGVkLlxyXG4gICAgICogQHJldHVybnMgQSBmdW5jdGlvbiB0aGF0IHVuc3Vic2NyaWJlcyB0aGUgZXZlbnQgaGFuZGxlciBmcm9tIHRoZSBldmVudC5cclxuICAgICAqL1xyXG4gICAgRGlzcGF0Y2hlcldyYXBwZXIucHJvdG90eXBlLnN1YnNjcmliZSA9IGZ1bmN0aW9uIChmbikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9zdWJzY3JpYmUoZm4pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogU3Vic2NyaWJlIHRvIHRoZSBldmVudCBkaXNwYXRjaGVyLlxyXG4gICAgICogQHBhcmFtIGZuIFRoZSBldmVudCBoYW5kbGVyIHRoYXQgaXMgY2FsbGVkIHdoZW4gdGhlIGV2ZW50IGlzIGRpc3BhdGNoZWQuXHJcbiAgICAgKiBAcmV0dXJucyBBIGZ1bmN0aW9uIHRoYXQgdW5zdWJzY3JpYmVzIHRoZSBldmVudCBoYW5kbGVyIGZyb20gdGhlIGV2ZW50LlxyXG4gICAgICovXHJcbiAgICBEaXNwYXRjaGVyV3JhcHBlci5wcm90b3R5cGUuc3ViID0gZnVuY3Rpb24gKGZuKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3Vic2NyaWJlKGZuKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFVuc3Vic2NyaWJlIGZyb20gdGhlIGV2ZW50IGRpc3BhdGNoZXIuXHJcbiAgICAgKiBAcGFyYW0gZm4gVGhlIGV2ZW50IGhhbmRsZXIgdGhhdCBpcyBjYWxsZWQgd2hlbiB0aGUgZXZlbnQgaXMgZGlzcGF0Y2hlZC5cclxuICAgICAqL1xyXG4gICAgRGlzcGF0Y2hlcldyYXBwZXIucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKGZuKSB7XHJcbiAgICAgICAgdGhpcy5fdW5zdWJzY3JpYmUoZm4pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogVW5zdWJzY3JpYmUgZnJvbSB0aGUgZXZlbnQgZGlzcGF0Y2hlci5cclxuICAgICAqIEBwYXJhbSBmbiBUaGUgZXZlbnQgaGFuZGxlciB0aGF0IGlzIGNhbGxlZCB3aGVuIHRoZSBldmVudCBpcyBkaXNwYXRjaGVkLlxyXG4gICAgICovXHJcbiAgICBEaXNwYXRjaGVyV3JhcHBlci5wcm90b3R5cGUudW5zdWIgPSBmdW5jdGlvbiAoZm4pIHtcclxuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKGZuKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFN1YnNjcmliZSBvbmNlIHRvIHRoZSBldmVudCB3aXRoIHRoZSBzcGVjaWZpZWQgbmFtZS5cclxuICAgICAqIEBwYXJhbSBmbiBUaGUgZXZlbnQgaGFuZGxlciB0aGF0IGlzIGNhbGxlZCB3aGVuIHRoZSBldmVudCBpcyBkaXNwYXRjaGVkLlxyXG4gICAgICovXHJcbiAgICBEaXNwYXRjaGVyV3JhcHBlci5wcm90b3R5cGUub25lID0gZnVuY3Rpb24gKGZuKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX29uZShmbik7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3MgaXQgdGhlIGV2ZW50IGhhcyBhIHN1YnNjcmlwdGlvbiBmb3IgdGhlIHNwZWNpZmllZCBoYW5kbGVyLlxyXG4gICAgICogQHBhcmFtIGZuIFRoZSBldmVudCBoYW5kbGVyLlxyXG4gICAgICovXHJcbiAgICBEaXNwYXRjaGVyV3JhcHBlci5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gKGZuKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhcyhmbik7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDbGVhcnMgYWxsIHRoZSBzdWJzY3JpcHRpb25zLlxyXG4gICAgICovXHJcbiAgICBEaXNwYXRjaGVyV3JhcHBlci5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5fY2xlYXIoKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRGlzcGF0Y2hlcldyYXBwZXI7XHJcbn0oKSk7XHJcbmV4cG9ydHMuRGlzcGF0Y2hlcldyYXBwZXIgPSBEaXNwYXRjaGVyV3JhcHBlcjtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qIVxyXG4gKiBTdHJvbmdseSBUeXBlZCBFdmVudHMgZm9yIFR5cGVTY3JpcHQgLSBDb3JlXHJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9LZWVzQ0Jha2tlci9TdHJvbmx5VHlwZWRFdmVudHMvXHJcbiAqIGh0dHA6Ly9rZWVzdGFsa3N0ZWNoLmNvbVxyXG4gKlxyXG4gKiBDb3B5cmlnaHQgS2VlcyBDLiBCYWtrZXIgLyBLZWVzVGFsa3NUZWNoXHJcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLlN1YnNjcmlwdGlvbiA9IGV4cG9ydHMuRXZlbnRMaXN0QmFzZSA9IGV4cG9ydHMuRGlzcGF0Y2hlcldyYXBwZXIgPSBleHBvcnRzLkRpc3BhdGNoZXJCYXNlID0gdm9pZCAwO1xyXG52YXIgZGlzcGF0Y2hpbmdfMSA9IHJlcXVpcmUoXCIuL2Rpc3BhdGNoaW5nXCIpO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJEaXNwYXRjaGVyQmFzZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZGlzcGF0Y2hpbmdfMS5EaXNwYXRjaGVyQmFzZTsgfSB9KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRGlzcGF0Y2hlcldyYXBwZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRpc3BhdGNoaW5nXzEuRGlzcGF0Y2hlcldyYXBwZXI7IH0gfSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkV2ZW50TGlzdEJhc2VcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRpc3BhdGNoaW5nXzEuRXZlbnRMaXN0QmFzZTsgfSB9KTtcclxudmFyIHN1YnNjcmlwdGlvbl8xID0gcmVxdWlyZShcIi4vc3Vic2NyaXB0aW9uXCIpO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTdWJzY3JpcHRpb25cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN1YnNjcmlwdGlvbl8xLlN1YnNjcmlwdGlvbjsgfSB9KTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5FdmVudE1hbmFnZW1lbnQgPSB2b2lkIDA7XHJcbi8qKlxyXG4gKiBBbGxvd3MgdGhlIHVzZXIgdG8gaW50ZXJhY3Qgd2l0aCB0aGUgZXZlbnQuXHJcbiAqXHJcbiAqIEBjbGFzcyBFdmVudE1hbmFnZW1lbnRcclxuICogQGltcGxlbWVudHMge0lFdmVudE1hbmFnZW1lbnR9XHJcbiAqL1xyXG52YXIgRXZlbnRNYW5hZ2VtZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRXZlbnRNYW5hZ2VtZW50KHVuc3ViKSB7XHJcbiAgICAgICAgdGhpcy51bnN1YiA9IHVuc3ViO1xyXG4gICAgICAgIHRoaXMucHJvcGFnYXRpb25TdG9wcGVkID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBFdmVudE1hbmFnZW1lbnQucHJvdG90eXBlLnN0b3BQcm9wYWdhdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnByb3BhZ2F0aW9uU3RvcHBlZCA9IHRydWU7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEV2ZW50TWFuYWdlbWVudDtcclxufSgpKTtcclxuZXhwb3J0cy5FdmVudE1hbmFnZW1lbnQgPSBFdmVudE1hbmFnZW1lbnQ7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuU3Vic2NyaXB0aW9uID0gdm9pZCAwO1xyXG4vKipcclxuICogU3RvcmVzIGEgaGFuZGxlci4gTWFuYWdlcyBleGVjdXRpb24gbWV0YSBkYXRhLlxyXG4gKiBAY2xhc3MgU3Vic2NyaXB0aW9uXHJcbiAqIEB0ZW1wbGF0ZSBURXZlbnRIYW5kbGVyXHJcbiAqL1xyXG52YXIgU3Vic2NyaXB0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIFN1YnNjcmlwdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1RFdmVudEhhbmRsZXJ9IGhhbmRsZXIgVGhlIGhhbmRsZXIgZm9yIHRoZSBzdWJzY3JpcHRpb24uXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzT25jZSBJbmRpY2F0ZXMgaWYgdGhlIGhhbmRsZXIgc2hvdWxkIG9ubHkgYmUgZXhlY3V0ZWQgb25jZS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gU3Vic2NyaXB0aW9uKGhhbmRsZXIsIGlzT25jZSkge1xyXG4gICAgICAgIHRoaXMuaGFuZGxlciA9IGhhbmRsZXI7XHJcbiAgICAgICAgdGhpcy5pc09uY2UgPSBpc09uY2U7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSW5kaWNhdGVzIGlmIHRoZSBzdWJzY3JpcHRpb24gaGFzIGJlZW4gZXhlY3V0ZWQgYmVmb3JlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuaXNFeGVjdXRlZCA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBFeGVjdXRlcyB0aGUgaGFuZGxlci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGV4ZWN1dGVBc3luYyBUcnVlIGlmIHRoZSBldmVuIHNob3VsZCBiZSBleGVjdXRlZCBhc3luYy5cclxuICAgICAqIEBwYXJhbSB7Kn0gc2NvcGUgVGhlIHNjb3BlIHRoZSBzY29wZSBvZiB0aGUgZXZlbnQuXHJcbiAgICAgKiBAcGFyYW0ge0lBcmd1bWVudHN9IGFyZ3MgVGhlIGFyZ3VtZW50cyBmb3IgdGhlIGV2ZW50LlxyXG4gICAgICovXHJcbiAgICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLmV4ZWN1dGUgPSBmdW5jdGlvbiAoZXhlY3V0ZUFzeW5jLCBzY29wZSwgYXJncykge1xyXG4gICAgICAgIGlmICghdGhpcy5pc09uY2UgfHwgIXRoaXMuaXNFeGVjdXRlZCkge1xyXG4gICAgICAgICAgICB0aGlzLmlzRXhlY3V0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB2YXIgZm4gPSB0aGlzLmhhbmRsZXI7XHJcbiAgICAgICAgICAgIGlmIChleGVjdXRlQXN5bmMpIHtcclxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZuLmFwcGx5KHNjb3BlLCBhcmdzKTtcclxuICAgICAgICAgICAgICAgIH0sIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZm4uYXBwbHkoc2NvcGUsIGFyZ3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBTdWJzY3JpcHRpb247XHJcbn0oKSk7XHJcbmV4cG9ydHMuU3Vic2NyaXB0aW9uID0gU3Vic2NyaXB0aW9uO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gICAgfTtcclxufSkoKTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLkV2ZW50SGFuZGxpbmdCYXNlID0gZXhwb3J0cy5FdmVudExpc3QgPSBleHBvcnRzLk5vblVuaWZvcm1FdmVudExpc3QgPSBleHBvcnRzLkV2ZW50RGlzcGF0Y2hlciA9IHZvaWQgMDtcclxudmFyIHN0ZV9jb3JlXzEgPSByZXF1aXJlKFwic3RlLWNvcmVcIik7XHJcbi8qKlxyXG4gKiBEaXNwYXRjaGVyIGltcGxlbWVudGF0aW9uIGZvciBldmVudHMuIENhbiBiZSB1c2VkIHRvIHN1YnNjcmliZSwgdW5zdWJzY3JpYmVcclxuICogb3IgZGlzcGF0Y2ggZXZlbnRzLiBVc2UgdGhlIFRvRXZlbnQoKSBtZXRob2QgdG8gZXhwb3NlIHRoZSBldmVudC5cclxuICovXHJcbnZhciBFdmVudERpc3BhdGNoZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoRXZlbnREaXNwYXRjaGVyLCBfc3VwZXIpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IEV2ZW50RGlzcGF0Y2hlciBpbnN0YW5jZS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gRXZlbnREaXNwYXRjaGVyKCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBEaXNwYXRjaGVzIHRoZSBldmVudC5cclxuICAgICAqIEBwYXJhbSBzZW5kZXIgVGhlIHNlbmRlci5cclxuICAgICAqIEBwYXJhbSBhcmdzIFRoZSBhcmd1bWVudHMgb2JqZWN0LlxyXG4gICAgICovXHJcbiAgICBFdmVudERpc3BhdGNoZXIucHJvdG90eXBlLmRpc3BhdGNoID0gZnVuY3Rpb24gKHNlbmRlciwgYXJncykge1xyXG4gICAgICAgIHRoaXMuX2Rpc3BhdGNoKGZhbHNlLCB0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogRGlzcGF0Y2hlcyB0aGUgZXZlbnRzIHRocmVhZC5cclxuICAgICAqIEBwYXJhbSBzZW5kZXIgVGhlIHNlbmRlci5cclxuICAgICAqIEBwYXJhbSBhcmdzIFRoZSBhcmd1bWVudHMgb2JqZWN0LlxyXG4gICAgICovXHJcbiAgICBFdmVudERpc3BhdGNoZXIucHJvdG90eXBlLmRpc3BhdGNoQXN5bmMgPSBmdW5jdGlvbiAoc2VuZGVyLCBhcmdzKSB7XHJcbiAgICAgICAgdGhpcy5fZGlzcGF0Y2godHJ1ZSwgdGhpcywgYXJndW1lbnRzKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gZXZlbnQgZnJvbSB0aGUgZGlzcGF0Y2hlci4gV2lsbCByZXR1cm4gdGhlIGRpc3BhdGNoZXJcclxuICAgICAqIGluIGEgd3JhcHBlci4gVGhpcyB3aWxsIHByZXZlbnQgZXhwb3N1cmUgb2YgYW55IGRpc3BhdGNoZXIgbWV0aG9kcy5cclxuICAgICAqL1xyXG4gICAgRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5hc0V2ZW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLmFzRXZlbnQuY2FsbCh0aGlzKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRXZlbnREaXNwYXRjaGVyO1xyXG59KHN0ZV9jb3JlXzEuRGlzcGF0Y2hlckJhc2UpKTtcclxuZXhwb3J0cy5FdmVudERpc3BhdGNoZXIgPSBFdmVudERpc3BhdGNoZXI7XHJcbi8qKlxyXG4gKiBTaW1pbGFyIHRvIEV2ZW50TGlzdCwgYnV0IGluc3RlYWQgb2YgVEFyZ3MsIGEgbWFwIG9mIGV2ZW50IG5hbWVzIGFuZyBhcmd1bWVudCB0eXBlcyBpcyBwcm92aWRlZCB3aXRoIFRBcmdzTWFwLlxyXG4gKi9cclxudmFyIE5vblVuaWZvcm1FdmVudExpc3QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBOb25Vbmlmb3JtRXZlbnRMaXN0KCkge1xyXG4gICAgICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBkaXNwYXRjaGVyIGFzc29jaWF0ZWQgd2l0aCB0aGUgbmFtZS5cclxuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudC5cclxuICAgICAqL1xyXG4gICAgTm9uVW5pZm9ybUV2ZW50TGlzdC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICBpZiAodGhpcy5fZXZlbnRzW25hbWVdKSB7XHJcbiAgICAgICAgICAgIC8vIEBUT0RPIGF2b2lkIHR5cGVjYXN0aW5nLiBOb3Qgc3VyZSB3aHkgVFMgdGhpbmtzIHRoaXMuX2V2ZW50c1tuYW1lXSBjb3VsZCBzdGlsbCBiZSB1bmRlZmluZWQuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9ldmVudHNbbmFtZV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBldmVudCA9IHRoaXMuY3JlYXRlRGlzcGF0Y2hlcigpO1xyXG4gICAgICAgIHRoaXMuX2V2ZW50c1tuYW1lXSA9IGV2ZW50O1xyXG4gICAgICAgIHJldHVybiBldmVudDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgdGhlIGRpc3BhdGNoZXIgYXNzb2NpYXRlZCB3aXRoIHRoZSBuYW1lLlxyXG4gICAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50LlxyXG4gICAgICovXHJcbiAgICBOb25Vbmlmb3JtRXZlbnRMaXN0LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbbmFtZV07XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGRpc3BhdGNoZXIgaW5zdGFuY2UuXHJcbiAgICAgKi9cclxuICAgIE5vblVuaWZvcm1FdmVudExpc3QucHJvdG90eXBlLmNyZWF0ZURpc3BhdGNoZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBFdmVudERpc3BhdGNoZXIoKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gTm9uVW5pZm9ybUV2ZW50TGlzdDtcclxufSgpKTtcclxuZXhwb3J0cy5Ob25Vbmlmb3JtRXZlbnRMaXN0ID0gTm9uVW5pZm9ybUV2ZW50TGlzdDtcclxuLyoqXHJcbiAqIFN0b3JhZ2UgY2xhc3MgZm9yIG11bHRpcGxlIGV2ZW50cyB0aGF0IGFyZSBhY2Nlc3NpYmxlIGJ5IG5hbWUuXHJcbiAqIEV2ZW50cyBkaXNwYXRjaGVycyBhcmUgYXV0b21hdGljYWxseSBjcmVhdGVkLlxyXG4gKi9cclxudmFyIEV2ZW50TGlzdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhFdmVudExpc3QsIF9zdXBlcik7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgRXZlbnRMaXN0IGluc3RhbmNlLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBFdmVudExpc3QoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgZGlzcGF0Y2hlciBpbnN0YW5jZS5cclxuICAgICAqL1xyXG4gICAgRXZlbnRMaXN0LnByb3RvdHlwZS5jcmVhdGVEaXNwYXRjaGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgRXZlbnREaXNwYXRjaGVyKCk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEV2ZW50TGlzdDtcclxufShzdGVfY29yZV8xLkV2ZW50TGlzdEJhc2UpKTtcclxuZXhwb3J0cy5FdmVudExpc3QgPSBFdmVudExpc3Q7XHJcbi8qKlxyXG4gKiBFeHRlbmRzIG9iamVjdHMgd2l0aCBldmVudCBoYW5kbGluZyBjYXBhYmlsaXRpZXMuXHJcbiAqL1xyXG52YXIgRXZlbnRIYW5kbGluZ0Jhc2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBFdmVudEhhbmRsaW5nQmFzZSgpIHtcclxuICAgICAgICB0aGlzLl9ldmVudHMgPSBuZXcgRXZlbnRMaXN0KCk7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRIYW5kbGluZ0Jhc2UucHJvdG90eXBlLCBcImV2ZW50c1wiLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyB0aGUgbGlzdCB3aXRoIGFsbCB0aGUgZXZlbnQgZGlzcGF0Y2hlcnMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9ldmVudHM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTdWJzY3JpYmVzIHRvIHRoZSBldmVudCB3aXRoIHRoZSBzcGVjaWZpZWQgbmFtZS5cclxuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudC5cclxuICAgICAqIEBwYXJhbSBmbiBUaGUgZXZlbnQgaGFuZGxlci5cclxuICAgICAqL1xyXG4gICAgRXZlbnRIYW5kbGluZ0Jhc2UucHJvdG90eXBlLnN1YnNjcmliZSA9IGZ1bmN0aW9uIChuYW1lLCBmbikge1xyXG4gICAgICAgIHRoaXMuX2V2ZW50cy5nZXQobmFtZSkuc3Vic2NyaWJlKGZuKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFN1YnNjcmliZXMgdG8gdGhlIGV2ZW50IHdpdGggdGhlIHNwZWNpZmllZCBuYW1lLlxyXG4gICAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50LlxyXG4gICAgICogQHBhcmFtIGZuIFRoZSBldmVudCBoYW5kbGVyLlxyXG4gICAgICovXHJcbiAgICBFdmVudEhhbmRsaW5nQmFzZS5wcm90b3R5cGUuc3ViID0gZnVuY3Rpb24gKG5hbWUsIGZuKSB7XHJcbiAgICAgICAgdGhpcy5zdWJzY3JpYmUobmFtZSwgZm4pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogVW5zdWJzY3JpYmVzIGZyb20gdGhlIGV2ZW50IHdpdGggdGhlIHNwZWNpZmllZCBuYW1lLlxyXG4gICAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50LlxyXG4gICAgICogQHBhcmFtIGZuIFRoZSBldmVudCBoYW5kbGVyLlxyXG4gICAgICovXHJcbiAgICBFdmVudEhhbmRsaW5nQmFzZS5wcm90b3R5cGUudW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAobmFtZSwgZm4pIHtcclxuICAgICAgICB0aGlzLl9ldmVudHMuZ2V0KG5hbWUpLnVuc3Vic2NyaWJlKGZuKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFVuc3Vic2NyaWJlcyBmcm9tIHRoZSBldmVudCB3aXRoIHRoZSBzcGVjaWZpZWQgbmFtZS5cclxuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudC5cclxuICAgICAqIEBwYXJhbSBmbiBUaGUgZXZlbnQgaGFuZGxlci5cclxuICAgICAqL1xyXG4gICAgRXZlbnRIYW5kbGluZ0Jhc2UucHJvdG90eXBlLnVuc3ViID0gZnVuY3Rpb24gKG5hbWUsIGZuKSB7XHJcbiAgICAgICAgdGhpcy51bnN1YnNjcmliZShuYW1lLCBmbik7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBTdWJzY3JpYmVzIHRvIG9uY2UgdGhlIGV2ZW50IHdpdGggdGhlIHNwZWNpZmllZCBuYW1lLlxyXG4gICAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50LlxyXG4gICAgICogQHBhcmFtIGZuIFRoZSBldmVudCBoYW5kbGVyLlxyXG4gICAgICovXHJcbiAgICBFdmVudEhhbmRsaW5nQmFzZS5wcm90b3R5cGUub25lID0gZnVuY3Rpb24gKG5hbWUsIGZuKSB7XHJcbiAgICAgICAgdGhpcy5fZXZlbnRzLmdldChuYW1lKS5vbmUoZm4pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogU3Vic2NyaWJlcyB0byBvbmNlIHRoZSBldmVudCB3aXRoIHRoZSBzcGVjaWZpZWQgbmFtZS5cclxuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudC5cclxuICAgICAqIEBwYXJhbSBmbiBUaGUgZXZlbnQgaGFuZGxlci5cclxuICAgICAqL1xyXG4gICAgRXZlbnRIYW5kbGluZ0Jhc2UucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIChuYW1lLCBmbikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9ldmVudHMuZ2V0KG5hbWUpLmhhcyhmbik7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEV2ZW50SGFuZGxpbmdCYXNlO1xyXG59KCkpO1xyXG5leHBvcnRzLkV2ZW50SGFuZGxpbmdCYXNlID0gRXZlbnRIYW5kbGluZ0Jhc2U7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuTm9uVW5pZm9ybUV2ZW50TGlzdCA9IGV4cG9ydHMuRXZlbnRMaXN0ID0gZXhwb3J0cy5FdmVudEhhbmRsaW5nQmFzZSA9IGV4cG9ydHMuRXZlbnREaXNwYXRjaGVyID0gdm9pZCAwO1xyXG52YXIgZXZlbnRzXzEgPSByZXF1aXJlKFwiLi9ldmVudHNcIik7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkV2ZW50RGlzcGF0Y2hlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZXZlbnRzXzEuRXZlbnREaXNwYXRjaGVyOyB9IH0pO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJFdmVudEhhbmRsaW5nQmFzZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZXZlbnRzXzEuRXZlbnRIYW5kbGluZ0Jhc2U7IH0gfSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkV2ZW50TGlzdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZXZlbnRzXzEuRXZlbnRMaXN0OyB9IH0pO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOb25Vbmlmb3JtRXZlbnRMaXN0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBldmVudHNfMS5Ob25Vbmlmb3JtRXZlbnRMaXN0OyB9IH0pO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLlNpZ25hbExpc3QgPSBleHBvcnRzLlNpZ25hbEhhbmRsaW5nQmFzZSA9IGV4cG9ydHMuU2lnbmFsRGlzcGF0Y2hlciA9IHZvaWQgMDtcclxudmFyIHNpZ25hbHNfMSA9IHJlcXVpcmUoXCIuL3NpZ25hbHNcIik7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNpZ25hbERpc3BhdGNoZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNpZ25hbHNfMS5TaWduYWxEaXNwYXRjaGVyOyB9IH0pO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTaWduYWxIYW5kbGluZ0Jhc2VcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNpZ25hbHNfMS5TaWduYWxIYW5kbGluZ0Jhc2U7IH0gfSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNpZ25hbExpc3RcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNpZ25hbHNfMS5TaWduYWxMaXN0OyB9IH0pO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gICAgfTtcclxufSkoKTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLlNpZ25hbEhhbmRsaW5nQmFzZSA9IGV4cG9ydHMuU2lnbmFsTGlzdCA9IGV4cG9ydHMuU2lnbmFsRGlzcGF0Y2hlciA9IHZvaWQgMDtcclxudmFyIHN0ZV9jb3JlXzEgPSByZXF1aXJlKFwic3RlLWNvcmVcIik7XHJcbi8qKlxyXG4gKiBUaGUgZGlzcGF0Y2hlciBoYW5kbGVzIHRoZSBzdG9yYWdlIG9mIHN1YnNjaXB0aW9ucyBhbmQgZmFjaWxpdGF0ZXNcclxuICogc3Vic2NyaXB0aW9uLCB1bnN1YnNjcmlwdGlvbiBhbmQgZGlzcGF0Y2hpbmcgb2YgYSBzaWduYWwgZXZlbnQuXHJcbiAqL1xyXG52YXIgU2lnbmFsRGlzcGF0Y2hlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhTaWduYWxEaXNwYXRjaGVyLCBfc3VwZXIpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFNpZ25hbERpc3BhdGNoZXIgaW5zdGFuY2UuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIFNpZ25hbERpc3BhdGNoZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERpc3BhdGNoZXMgdGhlIHNpZ25hbC5cclxuICAgICAqL1xyXG4gICAgU2lnbmFsRGlzcGF0Y2hlci5wcm90b3R5cGUuZGlzcGF0Y2ggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5fZGlzcGF0Y2goZmFsc2UsIHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBEaXNwYXRjaGVzIHRoZSBzaWduYWwgdGhyZWFkZWQuXHJcbiAgICAgKi9cclxuICAgIFNpZ25hbERpc3BhdGNoZXIucHJvdG90eXBlLmRpc3BhdGNoQXN5bmMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5fZGlzcGF0Y2godHJ1ZSwgdGhpcywgYXJndW1lbnRzKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gZXZlbnQgZnJvbSB0aGUgZGlzcGF0Y2hlci4gV2lsbCByZXR1cm4gdGhlIGRpc3BhdGNoZXJcclxuICAgICAqIGluIGEgd3JhcHBlci4gVGhpcyB3aWxsIHByZXZlbnQgZXhwb3N1cmUgb2YgYW55IGRpc3BhdGNoZXIgbWV0aG9kcy5cclxuICAgICAqL1xyXG4gICAgU2lnbmFsRGlzcGF0Y2hlci5wcm90b3R5cGUuYXNFdmVudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5hc0V2ZW50LmNhbGwodGhpcyk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFNpZ25hbERpc3BhdGNoZXI7XHJcbn0oc3RlX2NvcmVfMS5EaXNwYXRjaGVyQmFzZSkpO1xyXG5leHBvcnRzLlNpZ25hbERpc3BhdGNoZXIgPSBTaWduYWxEaXNwYXRjaGVyO1xyXG4vKipcclxuICogU3RvcmFnZSBjbGFzcyBmb3IgbXVsdGlwbGUgc2lnbmFsIGV2ZW50cyB0aGF0IGFyZSBhY2Nlc3NpYmxlIGJ5IG5hbWUuXHJcbiAqIEV2ZW50cyBkaXNwYXRjaGVycyBhcmUgYXV0b21hdGljYWxseSBjcmVhdGVkLlxyXG4gKi9cclxudmFyIFNpZ25hbExpc3QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoU2lnbmFsTGlzdCwgX3N1cGVyKTtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBTaWduYWxMaXN0IGluc3RhbmNlLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBTaWduYWxMaXN0KCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGRpc3BhdGNoZXIgaW5zdGFuY2UuXHJcbiAgICAgKi9cclxuICAgIFNpZ25hbExpc3QucHJvdG90eXBlLmNyZWF0ZURpc3BhdGNoZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBTaWduYWxEaXNwYXRjaGVyKCk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFNpZ25hbExpc3Q7XHJcbn0oc3RlX2NvcmVfMS5FdmVudExpc3RCYXNlKSk7XHJcbmV4cG9ydHMuU2lnbmFsTGlzdCA9IFNpZ25hbExpc3Q7XHJcbi8qKlxyXG4gKiBFeHRlbmRzIG9iamVjdHMgd2l0aCBzaWduYWwgZXZlbnQgaGFuZGxpbmcgY2FwYWJpbGl0aWVzLlxyXG4gKi9cclxudmFyIFNpZ25hbEhhbmRsaW5nQmFzZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFNpZ25hbEhhbmRsaW5nQmFzZSgpIHtcclxuICAgICAgICB0aGlzLl9ldmVudHMgPSBuZXcgU2lnbmFsTGlzdCgpO1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNpZ25hbEhhbmRsaW5nQmFzZS5wcm90b3R5cGUsIFwiZXZlbnRzXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2V2ZW50cztcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICAvKipcclxuICAgICAqIFN1YnNjcmliZXMgb25jZSB0byB0aGUgZXZlbnQgd2l0aCB0aGUgc3BlY2lmaWVkIG5hbWUuXHJcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQuXHJcbiAgICAgKiBAcGFyYW0gZm4gVGhlIGV2ZW50IGhhbmRsZXIuXHJcbiAgICAgKi9cclxuICAgIFNpZ25hbEhhbmRsaW5nQmFzZS5wcm90b3R5cGUub25lID0gZnVuY3Rpb24gKG5hbWUsIGZuKSB7XHJcbiAgICAgICAgdGhpcy5fZXZlbnRzLmdldChuYW1lKS5vbmUoZm4pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIGl0IHRoZSBldmVudCBoYXMgYSBzdWJzY3JpcHRpb24gZm9yIHRoZSBzcGVjaWZpZWQgaGFuZGxlci5cclxuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudC5cclxuICAgICAqIEBwYXJhbSBmbiBUaGUgZXZlbnQgaGFuZGxlci5cclxuICAgICAqL1xyXG4gICAgU2lnbmFsSGFuZGxpbmdCYXNlLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiAobmFtZSwgZm4pIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZXZlbnRzLmdldChuYW1lKS5oYXMoZm4pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogU3Vic2NyaWJlcyB0byB0aGUgZXZlbnQgd2l0aCB0aGUgc3BlY2lmaWVkIG5hbWUuXHJcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQuXHJcbiAgICAgKiBAcGFyYW0gZm4gVGhlIGV2ZW50IGhhbmRsZXIuXHJcbiAgICAgKi9cclxuICAgIFNpZ25hbEhhbmRsaW5nQmFzZS5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24gKG5hbWUsIGZuKSB7XHJcbiAgICAgICAgdGhpcy5fZXZlbnRzLmdldChuYW1lKS5zdWJzY3JpYmUoZm4pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogU3Vic2NyaWJlcyB0byB0aGUgZXZlbnQgd2l0aCB0aGUgc3BlY2lmaWVkIG5hbWUuXHJcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQuXHJcbiAgICAgKiBAcGFyYW0gZm4gVGhlIGV2ZW50IGhhbmRsZXIuXHJcbiAgICAgKi9cclxuICAgIFNpZ25hbEhhbmRsaW5nQmFzZS5wcm90b3R5cGUuc3ViID0gZnVuY3Rpb24gKG5hbWUsIGZuKSB7XHJcbiAgICAgICAgdGhpcy5zdWJzY3JpYmUobmFtZSwgZm4pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogVW5zdWJzY3JpYmVzIGZyb20gdGhlIGV2ZW50IHdpdGggdGhlIHNwZWNpZmllZCBuYW1lLlxyXG4gICAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50LlxyXG4gICAgICogQHBhcmFtIGZuIFRoZSBldmVudCBoYW5kbGVyLlxyXG4gICAgICovXHJcbiAgICBTaWduYWxIYW5kbGluZ0Jhc2UucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKG5hbWUsIGZuKSB7XHJcbiAgICAgICAgdGhpcy5fZXZlbnRzLmdldChuYW1lKS51bnN1YnNjcmliZShmbik7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBVbnN1YnNjcmliZXMgZnJvbSB0aGUgZXZlbnQgd2l0aCB0aGUgc3BlY2lmaWVkIG5hbWUuXHJcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQuXHJcbiAgICAgKiBAcGFyYW0gZm4gVGhlIGV2ZW50IGhhbmRsZXIuXHJcbiAgICAgKi9cclxuICAgIFNpZ25hbEhhbmRsaW5nQmFzZS5wcm90b3R5cGUudW5zdWIgPSBmdW5jdGlvbiAobmFtZSwgZm4pIHtcclxuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKG5hbWUsIGZuKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gU2lnbmFsSGFuZGxpbmdCYXNlO1xyXG59KCkpO1xyXG5leHBvcnRzLlNpZ25hbEhhbmRsaW5nQmFzZSA9IFNpZ25hbEhhbmRsaW5nQmFzZTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5Ob25Vbmlmb3JtU2ltcGxlRXZlbnRMaXN0ID0gZXhwb3J0cy5TaW1wbGVFdmVudExpc3QgPSBleHBvcnRzLlNpbXBsZUV2ZW50SGFuZGxpbmdCYXNlID0gZXhwb3J0cy5TaW1wbGVFdmVudERpc3BhdGNoZXIgPSB2b2lkIDA7XHJcbnZhciBzaW1wbGVfZXZlbnRzXzEgPSByZXF1aXJlKFwiLi9zaW1wbGUtZXZlbnRzXCIpO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTaW1wbGVFdmVudERpc3BhdGNoZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNpbXBsZV9ldmVudHNfMS5TaW1wbGVFdmVudERpc3BhdGNoZXI7IH0gfSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNpbXBsZUV2ZW50SGFuZGxpbmdCYXNlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzaW1wbGVfZXZlbnRzXzEuU2ltcGxlRXZlbnRIYW5kbGluZ0Jhc2U7IH0gfSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNpbXBsZUV2ZW50TGlzdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2ltcGxlX2V2ZW50c18xLlNpbXBsZUV2ZW50TGlzdDsgfSB9KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTm9uVW5pZm9ybVNpbXBsZUV2ZW50TGlzdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2ltcGxlX2V2ZW50c18xLk5vblVuaWZvcm1TaW1wbGVFdmVudExpc3Q7IH0gfSk7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9O1xyXG59KSgpO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuU2ltcGxlRXZlbnRIYW5kbGluZ0Jhc2UgPSBleHBvcnRzLlNpbXBsZUV2ZW50TGlzdCA9IGV4cG9ydHMuTm9uVW5pZm9ybVNpbXBsZUV2ZW50TGlzdCA9IGV4cG9ydHMuU2ltcGxlRXZlbnREaXNwYXRjaGVyID0gdm9pZCAwO1xyXG52YXIgc3RlX2NvcmVfMSA9IHJlcXVpcmUoXCJzdGUtY29yZVwiKTtcclxuLyoqXHJcbiAqIFRoZSBkaXNwYXRjaGVyIGhhbmRsZXMgdGhlIHN0b3JhZ2Ugb2Ygc3Vic2NpcHRpb25zIGFuZCBmYWNpbGl0YXRlc1xyXG4gKiBzdWJzY3JpcHRpb24sIHVuc3Vic2NyaXB0aW9uIGFuZCBkaXNwYXRjaGluZyBvZiBhIHNpbXBsZSBldmVudFxyXG4gKi9cclxudmFyIFNpbXBsZUV2ZW50RGlzcGF0Y2hlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhTaW1wbGVFdmVudERpc3BhdGNoZXIsIF9zdXBlcik7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgU2ltcGxlRXZlbnREaXNwYXRjaGVyIGluc3RhbmNlLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBTaW1wbGVFdmVudERpc3BhdGNoZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERpc3BhdGNoZXMgdGhlIGV2ZW50LlxyXG4gICAgICogQHBhcmFtIGFyZ3MgVGhlIGFyZ3VtZW50cyBvYmplY3QuXHJcbiAgICAgKi9cclxuICAgIFNpbXBsZUV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuZGlzcGF0Y2ggPSBmdW5jdGlvbiAoYXJncykge1xyXG4gICAgICAgIHRoaXMuX2Rpc3BhdGNoKGZhbHNlLCB0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogRGlzcGF0Y2hlcyB0aGUgZXZlbnRzIHRocmVhZC5cclxuICAgICAqIEBwYXJhbSBhcmdzIFRoZSBhcmd1bWVudHMgb2JqZWN0LlxyXG4gICAgICovXHJcbiAgICBTaW1wbGVFdmVudERpc3BhdGNoZXIucHJvdG90eXBlLmRpc3BhdGNoQXN5bmMgPSBmdW5jdGlvbiAoYXJncykge1xyXG4gICAgICAgIHRoaXMuX2Rpc3BhdGNoKHRydWUsIHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGV2ZW50IGZyb20gdGhlIGRpc3BhdGNoZXIuIFdpbGwgcmV0dXJuIHRoZSBkaXNwYXRjaGVyXHJcbiAgICAgKiBpbiBhIHdyYXBwZXIuIFRoaXMgd2lsbCBwcmV2ZW50IGV4cG9zdXJlIG9mIGFueSBkaXNwYXRjaGVyIG1ldGhvZHMuXHJcbiAgICAgKi9cclxuICAgIFNpbXBsZUV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuYXNFdmVudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5hc0V2ZW50LmNhbGwodGhpcyk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFNpbXBsZUV2ZW50RGlzcGF0Y2hlcjtcclxufShzdGVfY29yZV8xLkRpc3BhdGNoZXJCYXNlKSk7XHJcbmV4cG9ydHMuU2ltcGxlRXZlbnREaXNwYXRjaGVyID0gU2ltcGxlRXZlbnREaXNwYXRjaGVyO1xyXG4vKipcclxuICogU2ltaWxhciB0byBFdmVudExpc3QsIGJ1dCBpbnN0ZWFkIG9mIFRBcmdzLCBhIG1hcCBvZiBldmVudCBuYW1lcyBhbmcgYXJndW1lbnQgdHlwZXMgaXMgcHJvdmlkZWQgd2l0aCBUQXJnc01hcC5cclxuICovXHJcbnZhciBOb25Vbmlmb3JtU2ltcGxlRXZlbnRMaXN0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gTm9uVW5pZm9ybVNpbXBsZUV2ZW50TGlzdCgpIHtcclxuICAgICAgICB0aGlzLl9ldmVudHMgPSB7fTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgZGlzcGF0Y2hlciBhc3NvY2lhdGVkIHdpdGggdGhlIG5hbWUuXHJcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQuXHJcbiAgICAgKi9cclxuICAgIE5vblVuaWZvcm1TaW1wbGVFdmVudExpc3QucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2V2ZW50c1tuYW1lXSkge1xyXG4gICAgICAgICAgICAvLyBAVE9ETyBhdm9pZCB0eXBlY2FzdGluZy4gTm90IHN1cmUgd2h5IFRTIHRoaW5rcyB0aGlzLl9ldmVudHNbbmFtZV0gY291bGQgc3RpbGwgYmUgdW5kZWZpbmVkLlxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZXZlbnRzW25hbWVdO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgZXZlbnQgPSB0aGlzLmNyZWF0ZURpc3BhdGNoZXIoKTtcclxuICAgICAgICB0aGlzLl9ldmVudHNbbmFtZV0gPSBldmVudDtcclxuICAgICAgICByZXR1cm4gZXZlbnQ7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIHRoZSBkaXNwYXRjaGVyIGFzc29jaWF0ZWQgd2l0aCB0aGUgbmFtZS5cclxuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudC5cclxuICAgICAqL1xyXG4gICAgTm9uVW5pZm9ybVNpbXBsZUV2ZW50TGlzdC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW25hbWVdO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBkaXNwYXRjaGVyIGluc3RhbmNlLlxyXG4gICAgICovXHJcbiAgICBOb25Vbmlmb3JtU2ltcGxlRXZlbnRMaXN0LnByb3RvdHlwZS5jcmVhdGVEaXNwYXRjaGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgU2ltcGxlRXZlbnREaXNwYXRjaGVyKCk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIE5vblVuaWZvcm1TaW1wbGVFdmVudExpc3Q7XHJcbn0oKSk7XHJcbmV4cG9ydHMuTm9uVW5pZm9ybVNpbXBsZUV2ZW50TGlzdCA9IE5vblVuaWZvcm1TaW1wbGVFdmVudExpc3Q7XHJcbi8qKlxyXG4gKiBTdG9yYWdlIGNsYXNzIGZvciBtdWx0aXBsZSBzaW1wbGUgZXZlbnRzIHRoYXQgYXJlIGFjY2Vzc2libGUgYnkgbmFtZS5cclxuICogRXZlbnRzIGRpc3BhdGNoZXJzIGFyZSBhdXRvbWF0aWNhbGx5IGNyZWF0ZWQuXHJcbiAqL1xyXG52YXIgU2ltcGxlRXZlbnRMaXN0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFNpbXBsZUV2ZW50TGlzdCwgX3N1cGVyKTtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBTaW1wbGVFdmVudExpc3QgaW5zdGFuY2UuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIFNpbXBsZUV2ZW50TGlzdCgpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBkaXNwYXRjaGVyIGluc3RhbmNlLlxyXG4gICAgICovXHJcbiAgICBTaW1wbGVFdmVudExpc3QucHJvdG90eXBlLmNyZWF0ZURpc3BhdGNoZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBTaW1wbGVFdmVudERpc3BhdGNoZXIoKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gU2ltcGxlRXZlbnRMaXN0O1xyXG59KHN0ZV9jb3JlXzEuRXZlbnRMaXN0QmFzZSkpO1xyXG5leHBvcnRzLlNpbXBsZUV2ZW50TGlzdCA9IFNpbXBsZUV2ZW50TGlzdDtcclxuLyoqXHJcbiAqIEV4dGVuZHMgb2JqZWN0cyB3aXRoIHNpbXBsZSBldmVudCBoYW5kbGluZyBjYXBhYmlsaXRpZXMuXHJcbiAqL1xyXG52YXIgU2ltcGxlRXZlbnRIYW5kbGluZ0Jhc2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBTaW1wbGVFdmVudEhhbmRsaW5nQmFzZSgpIHtcclxuICAgICAgICB0aGlzLl9ldmVudHMgPSBuZXcgU2ltcGxlRXZlbnRMaXN0KCk7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2ltcGxlRXZlbnRIYW5kbGluZ0Jhc2UucHJvdG90eXBlLCBcImV2ZW50c1wiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9ldmVudHM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTdWJzY3JpYmVzIHRvIHRoZSBldmVudCB3aXRoIHRoZSBzcGVjaWZpZWQgbmFtZS5cclxuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudC5cclxuICAgICAqIEBwYXJhbSBmbiBUaGUgZXZlbnQgaGFuZGxlci5cclxuICAgICAqL1xyXG4gICAgU2ltcGxlRXZlbnRIYW5kbGluZ0Jhc2UucHJvdG90eXBlLnN1YnNjcmliZSA9IGZ1bmN0aW9uIChuYW1lLCBmbikge1xyXG4gICAgICAgIHRoaXMuX2V2ZW50cy5nZXQobmFtZSkuc3Vic2NyaWJlKGZuKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFN1YnNjcmliZXMgdG8gdGhlIGV2ZW50IHdpdGggdGhlIHNwZWNpZmllZCBuYW1lLlxyXG4gICAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50LlxyXG4gICAgICogQHBhcmFtIGZuIFRoZSBldmVudCBoYW5kbGVyLlxyXG4gICAgICovXHJcbiAgICBTaW1wbGVFdmVudEhhbmRsaW5nQmFzZS5wcm90b3R5cGUuc3ViID0gZnVuY3Rpb24gKG5hbWUsIGZuKSB7XHJcbiAgICAgICAgdGhpcy5zdWJzY3JpYmUobmFtZSwgZm4pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogU3Vic2NyaWJlcyBvbmNlIHRvIHRoZSBldmVudCB3aXRoIHRoZSBzcGVjaWZpZWQgbmFtZS5cclxuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudC5cclxuICAgICAqIEBwYXJhbSBmbiBUaGUgZXZlbnQgaGFuZGxlci5cclxuICAgICAqL1xyXG4gICAgU2ltcGxlRXZlbnRIYW5kbGluZ0Jhc2UucHJvdG90eXBlLm9uZSA9IGZ1bmN0aW9uIChuYW1lLCBmbikge1xyXG4gICAgICAgIHRoaXMuX2V2ZW50cy5nZXQobmFtZSkub25lKGZuKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyBpdCB0aGUgZXZlbnQgaGFzIGEgc3Vic2NyaXB0aW9uIGZvciB0aGUgc3BlY2lmaWVkIGhhbmRsZXIuXHJcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQuXHJcbiAgICAgKiBAcGFyYW0gZm4gVGhlIGV2ZW50IGhhbmRsZXIuXHJcbiAgICAgKi9cclxuICAgIFNpbXBsZUV2ZW50SGFuZGxpbmdCYXNlLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiAobmFtZSwgZm4pIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZXZlbnRzLmdldChuYW1lKS5oYXMoZm4pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogVW5zdWJzY3JpYmVzIGZyb20gdGhlIGV2ZW50IHdpdGggdGhlIHNwZWNpZmllZCBuYW1lLlxyXG4gICAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50LlxyXG4gICAgICogQHBhcmFtIGZuIFRoZSBldmVudCBoYW5kbGVyLlxyXG4gICAgICovXHJcbiAgICBTaW1wbGVFdmVudEhhbmRsaW5nQmFzZS5wcm90b3R5cGUudW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAobmFtZSwgZm4pIHtcclxuICAgICAgICB0aGlzLl9ldmVudHMuZ2V0KG5hbWUpLnVuc3Vic2NyaWJlKGZuKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFVuc3Vic2NyaWJlcyBmcm9tIHRoZSBldmVudCB3aXRoIHRoZSBzcGVjaWZpZWQgbmFtZS5cclxuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudC5cclxuICAgICAqIEBwYXJhbSBmbiBUaGUgZXZlbnQgaGFuZGxlci5cclxuICAgICAqL1xyXG4gICAgU2ltcGxlRXZlbnRIYW5kbGluZ0Jhc2UucHJvdG90eXBlLnVuc3ViID0gZnVuY3Rpb24gKG5hbWUsIGZuKSB7XHJcbiAgICAgICAgdGhpcy51bnN1YnNjcmliZShuYW1lLCBmbik7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFNpbXBsZUV2ZW50SGFuZGxpbmdCYXNlO1xyXG59KCkpO1xyXG5leHBvcnRzLlNpbXBsZUV2ZW50SGFuZGxpbmdCYXNlID0gU2ltcGxlRXZlbnRIYW5kbGluZ0Jhc2U7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG4vKiFcclxuICogU3Ryb25nbHkgVHlwZWQgRXZlbnRzIGZvciBUeXBlU2NyaXB0XHJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9LZWVzQ0Jha2tlci9TdHJvbmx5VHlwZWRFdmVudHMvXHJcbiAqIGh0dHA6Ly9rZWVzdGFsa3N0ZWNoLmNvbVxyXG4gKlxyXG4gKiBDb3B5cmlnaHQgS2VlcyBDLiBCYWtrZXIgLyBLZWVzVGFsa3NUZWNoXHJcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLlNpZ25hbExpc3QgPSBleHBvcnRzLlNpZ25hbEhhbmRsaW5nQmFzZSA9IGV4cG9ydHMuU2lnbmFsRGlzcGF0Y2hlciA9IGV4cG9ydHMuTm9uVW5pZm9ybVNpbXBsZUV2ZW50TGlzdCA9IGV4cG9ydHMuU2ltcGxlRXZlbnRMaXN0ID0gZXhwb3J0cy5TaW1wbGVFdmVudEhhbmRsaW5nQmFzZSA9IGV4cG9ydHMuU2ltcGxlRXZlbnREaXNwYXRjaGVyID0gZXhwb3J0cy5Ob25Vbmlmb3JtRXZlbnRMaXN0ID0gZXhwb3J0cy5FdmVudExpc3QgPSBleHBvcnRzLkV2ZW50SGFuZGxpbmdCYXNlID0gZXhwb3J0cy5FdmVudERpc3BhdGNoZXIgPSBleHBvcnRzLlN1YnNjcmlwdGlvbiA9IGV4cG9ydHMuRXZlbnRMaXN0QmFzZSA9IGV4cG9ydHMuRGlzcGF0Y2hlcldyYXBwZXIgPSBleHBvcnRzLkRpc3BhdGNoZXJCYXNlID0gdm9pZCAwO1xyXG52YXIgc3RlX2NvcmVfMSA9IHJlcXVpcmUoXCJzdGUtY29yZVwiKTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRGlzcGF0Y2hlckJhc2VcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN0ZV9jb3JlXzEuRGlzcGF0Y2hlckJhc2U7IH0gfSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkRpc3BhdGNoZXJXcmFwcGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzdGVfY29yZV8xLkRpc3BhdGNoZXJXcmFwcGVyOyB9IH0pO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJFdmVudExpc3RCYXNlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzdGVfY29yZV8xLkV2ZW50TGlzdEJhc2U7IH0gfSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlN1YnNjcmlwdGlvblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc3RlX2NvcmVfMS5TdWJzY3JpcHRpb247IH0gfSk7XHJcbnZhciBzdGVfZXZlbnRzXzEgPSByZXF1aXJlKFwic3RlLWV2ZW50c1wiKTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRXZlbnREaXNwYXRjaGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzdGVfZXZlbnRzXzEuRXZlbnREaXNwYXRjaGVyOyB9IH0pO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJFdmVudEhhbmRsaW5nQmFzZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc3RlX2V2ZW50c18xLkV2ZW50SGFuZGxpbmdCYXNlOyB9IH0pO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJFdmVudExpc3RcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN0ZV9ldmVudHNfMS5FdmVudExpc3Q7IH0gfSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5vblVuaWZvcm1FdmVudExpc3RcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN0ZV9ldmVudHNfMS5Ob25Vbmlmb3JtRXZlbnRMaXN0OyB9IH0pO1xyXG52YXIgc3RlX3NpbXBsZV9ldmVudHNfMSA9IHJlcXVpcmUoXCJzdGUtc2ltcGxlLWV2ZW50c1wiKTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU2ltcGxlRXZlbnREaXNwYXRjaGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzdGVfc2ltcGxlX2V2ZW50c18xLlNpbXBsZUV2ZW50RGlzcGF0Y2hlcjsgfSB9KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU2ltcGxlRXZlbnRIYW5kbGluZ0Jhc2VcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN0ZV9zaW1wbGVfZXZlbnRzXzEuU2ltcGxlRXZlbnRIYW5kbGluZ0Jhc2U7IH0gfSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNpbXBsZUV2ZW50TGlzdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc3RlX3NpbXBsZV9ldmVudHNfMS5TaW1wbGVFdmVudExpc3Q7IH0gfSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5vblVuaWZvcm1TaW1wbGVFdmVudExpc3RcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN0ZV9zaW1wbGVfZXZlbnRzXzEuTm9uVW5pZm9ybVNpbXBsZUV2ZW50TGlzdDsgfSB9KTtcclxudmFyIHN0ZV9zaWduYWxzXzEgPSByZXF1aXJlKFwic3RlLXNpZ25hbHNcIik7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNpZ25hbERpc3BhdGNoZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN0ZV9zaWduYWxzXzEuU2lnbmFsRGlzcGF0Y2hlcjsgfSB9KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU2lnbmFsSGFuZGxpbmdCYXNlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzdGVfc2lnbmFsc18xLlNpZ25hbEhhbmRsaW5nQmFzZTsgfSB9KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU2lnbmFsTGlzdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc3RlX3NpZ25hbHNfMS5TaWduYWxMaXN0OyB9IH0pO1xyXG4iLCJyZXF1aXJlKFwiLi9jc3MvZW5lcmdpZWF0bGFzLnNjc3NcIik7XHJcbmltcG9ydCB7IGluaXRNYXAgfSBmcm9tIFwiLi90cy9NYXBBcHBcIjtcclxuZGVjbGFyZSB2YXIgTEFZRVJERUZVUkw7XHJcbmZ1bmN0aW9uIHN3aXRjaFNpZGViYXIoKSB7XHJcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIm1haW5cIikuY2xhc3NMaXN0LnRvZ2dsZShcInNpZGViYXItY29sbGFwc2VkXCIpO1xyXG59XHJcbmZ1bmN0aW9uIGluaXQoKSB7XHJcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInNpZGViYXItc3dpdGNoXCIpLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBzd2l0Y2hTaWRlYmFyKTtcclxuICAgIGxldCB1cmw6IHN0cmluZztcclxuICAgIGlmICh0eXBlb2YgTEFZRVJERUZVUkwgIT09IFwidW5kZWZpbmVkXCIpIHtcclxuICAgICAgICB1cmwgPSBMQVlFUkRFRlVSTDtcclxuICAgIH1cclxuICAgIGluaXRNYXAodXJsKTtcclxufVxyXG5pZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gXCJpbnRlcmFjdGl2ZVwiIHx8IGRvY3VtZW50LnJlYWR5U3RhdGUgPT09IFwiY29tcGxldGVcIikge1xyXG4gICAgaW5pdCgpO1xyXG59IGVsc2Uge1xyXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgaW5pdCk7XHJcbn1cclxuXHJcbiIsImltcG9ydCAqIGFzIE1hcERlc2NyaXB0aW9uIGZyb20gXCIuL2NvbmYvTWFwRGVzY3JpcHRpb25cIjtcclxuaW1wb3J0IHsgTGF5ZXJFdmVudCwgTGF5ZXJXcmFwcGVyLCBNYXBDb250cm9sLCBNYXBEaXNwYXRjaGVyIH0gZnJvbSBcIi4vY29udHJvbHMvTWFwQ29udHJvbFwiO1xyXG5pbXBvcnQgeyBFeHByZXNzaW9uLCBwYXJzZUV4cHJlc3Npb24gfSBmcm9tIFwiLi9NYXBDbGFzc1BhcnNlclwiO1xyXG4vLyBpbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4vVXRpbCc7XHJcbmltcG9ydCAqIGFzIEwgZnJvbSBcImxlYWZsZXRcIjtcclxuaW1wb3J0ICogYXMgZ2VvSnNvbiBmcm9tIFwiZ2VvanNvblwiO1xyXG5pbXBvcnQgeyBDYXRlZ29yeUNpcmNsZU1hcmtlciwgQ2F0ZWdvcnlNYXJrZXIsIEZlYXR1cmVDbGlja0V2ZW50LCBHZW9qc29uTGF5ZXIgfSBmcm9tIFwiLi9jb250cm9scy9DYXRlZ29yaWVMYXllclwiO1xyXG5pbXBvcnQgeyBjcmVhdGVFeHByZXNzaW9uRmN0IH0gZnJvbSBcIi4vdXRpbC9Gb3JtYXRFeHByZXNzaW9uXCI7XHJcbmltcG9ydCB7IExlYWZsZXRNb3VzZUV2ZW50IH0gZnJvbSBcImxlYWZsZXRcIjtcclxuaW1wb3J0IHsgbG9hZEpzb24gfSBmcm9tIFwiLi9VdGlsXCI7XHJcbmltcG9ydCB7IFBpZWNoYXJ0TGF5ZXIsIFBpZWNoYXJ0TWFya2VyIH0gZnJvbSBcIi4vUGllY2hhcnRMYXllclwiO1xyXG5cclxudHlwZSBDbGFzc2lmaWVkU3R5bGVzID0ge1xyXG4gICAgY2xhc3NpZmllcnM6IHsgZXhwOiBFeHByZXNzaW9uOyBzdHlsZT86IGFueTsgaWNvbj86IGFueSB9W107XHJcbiAgICBzdGFuZGFyZFN0eWxlPzogYW55O1xyXG59O1xyXG5cclxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzaWZpZXJzKGNsYXN6ZXM6IE1hcERlc2NyaXB0aW9uLkxheWVyQ2xhc3NbXSk6IENsYXNzaWZpZWRTdHlsZXMge1xyXG4gICAgY29uc3QgcmVzdWx0OiBDbGFzc2lmaWVkU3R5bGVzID0geyBjbGFzc2lmaWVyczogW10gfTtcclxuICAgIGNsYXN6ZXMuZm9yRWFjaCgoY2xhc3opID0+IHtcclxuICAgICAgICBjb25zdCBpY29uID0gY2xhc3ouaWNvbiA/IEwuaWNvbihjbGFzei5pY29uKSA6IHVuZGVmaW5lZDtcclxuICAgICAgICBpZiAoY2xhc3ouZGVmKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHIgPSA8RXhwcmVzc2lvbj5wYXJzZUV4cHJlc3Npb24oY2xhc3ouZGVmKTtcclxuICAgICAgICAgICAgcmVzdWx0LmNsYXNzaWZpZXJzLnB1c2goeyBleHA6IHIsIHN0eWxlOiBjbGFzei5zdHlsZSwgaWNvbjogaWNvbiB9KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXN1bHQuc3RhbmRhcmRTdHlsZSA9IGNsYXN6LnN0eWxlID8gY2xhc3ouc3R5bGUgOiB7IGljb246IGljb24gfTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9jcmVhdGVTdHlsZUZjdChsYXllckRlc2NyOiBNYXBEZXNjcmlwdGlvbi5MYXllckRlc2NyaXB0aW9uKTogKGZlYXR1cmU6IGFueSkgPT4gYW55IHtcclxuICAgIGlmIChsYXllckRlc2NyLmNsYXNzZXMpIHtcclxuICAgICAgICBjb25zdCBzdHlsZXMgPSBfY3JlYXRlQ2xhc3NpZmllcnMobGF5ZXJEZXNjci5jbGFzc2VzKTtcclxuICAgICAgICByZXR1cm4gKGZlYXR1cmU6IGFueSkgPT4ge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgY291bnQgPSBzdHlsZXMuY2xhc3NpZmllcnMubGVuZ3RoOyBpIDwgY291bnQ7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHN0eWxlcy5jbGFzc2lmaWVyc1tpXS5leHAuZXZhbChmZWF0dXJlLnByb3BlcnRpZXMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0eWxlcy5jbGFzc2lmaWVyc1tpXS5pY29uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGljb246IHN0eWxlcy5jbGFzc2lmaWVyc1tpXS5pY29uIH07XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0eWxlcy5jbGFzc2lmaWVyc1tpXS5zdHlsZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHN0eWxlcy5zdGFuZGFyZFN0eWxlID8gc3R5bGVzLnN0YW5kYXJkU3R5bGUgOiBsYXllckRlc2NyLnN0eWxlIHx8IHsgY29sb3I6IFwiIzMzODhmZlwiLCBmaWxsQ29sb3I6IFwiIzMzODhmZlwiIH07XHJcbiAgICAgICAgfTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYgKGxheWVyRGVzY3Iuc3R5bGUgJiYgIWxheWVyRGVzY3Iuc3R5bGUuZmlsbENvbG9yKSB7XHJcbiAgICAgICAgICAgIGxheWVyRGVzY3Iuc3R5bGUuZmlsbENvbG9yID0gbGF5ZXJEZXNjci5zdHlsZT8uY29sb3I7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAoZmVhdHVyZTogYW55KSA9PiBsYXllckRlc2NyLnN0eWxlO1xyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRIaWdobGlnaHRGY3QobGF5ZXJEZXNjcjogTWFwRGVzY3JpcHRpb24uTGF5ZXJEZXNjcmlwdGlvbikge1xyXG4gICAgaWYgKGxheWVyRGVzY3IuZ2VvbVR5cGUgPT09IFwiTGluZXN0cmluZ1wiKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChmZWF0dXJlLCBoaWdobGlnaHQ6IGJvb2xlYW4pIHtcclxuICAgICAgICAgICAgY29uc29sZS5pbmZvKFwiaEZjdCBMaW5lc3RyaW5nXCIsIHRoaXMsIGZlYXR1cmUsIGhpZ2hsaWdodCk7XHJcbiAgICAgICAgICAgIGlmIChoaWdobGlnaHQpIHtcclxuICAgICAgICAgICAgICAgIGZlYXR1cmUuc2V0U3R5bGUoeyBjb2xvcjogXCJibGFja1wiIH0pO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbGV0IHN0eWxlID0gdGhpcy5vcHRpb25zLnN0eWxlO1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzdHlsZSA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGUgPSBzdHlsZShmZWF0dXJlLmZlYXR1cmUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc29sZS5pbmZvKHN0eWxlKTtcclxuICAgICAgICAgICAgICAgIGZlYXR1cmUuc2V0U3R5bGUoc3R5bGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH0gZWxzZSBpZiAobGF5ZXJEZXNjci5nZW9tVHlwZSA9PT0gXCJQb2x5Z29uXCIpIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGZlYXR1cmUsIGhpZ2hsaWdodDogYm9vbGVhbikge1xyXG4gICAgICAgICAgICAvLyBjb25zb2xlLmVycm9yKFwiaEZjdCBQb2x5Z29uXCIsIHRoaXMsIGZlYXR1cmUsIGhpZ2hsaWdodCk7XHJcbiAgICAgICAgICAgIGlmIChoaWdobGlnaHQpIHtcclxuICAgICAgICAgICAgICAgIGZlYXR1cmUuc2V0U3R5bGUoeyBmaWxsQ29sb3I6IFwicmVkXCIgfSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgc3R5bGUgPSBmZWF0dXJlLm9wdGlvbnMuc3R5bGU7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHN0eWxlID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdHlsZSA9IHN0eWxlKGZlYXR1cmUuZmVhdHVyZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmluZm8oc3R5bGUpO1xyXG4gICAgICAgICAgICAgICAgZmVhdHVyZS5zZXRTdHlsZShzdHlsZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgTGF5ZXJMb2FkZXIge1xyXG4gICAgbG9hZGVkTGF5ZXJzOiBMYXllcldyYXBwZXJbXSA9IFtdO1xyXG4gICAgbWFwOiBMLk1hcDtcclxuICAgIGxheWVyTnIgPSA0MDE7XHJcblxyXG4gICAgY29uc3RydWN0b3IobWFwOiBMLk1hcCkge1xyXG4gICAgICAgIE1hcERpc3BhdGNoZXIub25MYXllclJlcXVlc3Quc3Vic2NyaWJlKChzZW5kZXIsIGV2dCkgPT4gdGhpcy5fbGF5ZXJSZXF1ZXN0ZWQoc2VuZGVyLCBldnQpKTtcclxuICAgICAgICB0aGlzLm1hcCA9IG1hcDtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIF9sYXllclJlcXVlc3RlZChzZW5kZXI6IE1hcENvbnRyb2wsIGV2dDogTGF5ZXJFdmVudCk6IHZvaWQge1xyXG4gICAgICAgIGNvbnNvbGUuaW5mbyhgX2xheWVyUmVxdWVzdGVkIGlkPSR7ZXZ0LmxheWVyLmxheWVyRGVzY3JpcHRpb24uaWR9IGxhYmVsPSR7ZXZ0LmxheWVyLmxheWVyRGVzY3JpcHRpb24ubGFiZWx9YCk7XHJcbiAgICAgICAgaWYgKCF0aGlzLmxvYWRlZExheWVycy5pbmNsdWRlcyhldnQubGF5ZXIpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlTGF5ZXIoZXZ0LmxheWVyLmxheWVyRGVzY3JpcHRpb24pXHJcbiAgICAgICAgICAgICAgICAudGhlbigobGF5ZXIpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBldnQubGF5ZXIubGF5ZXIgPSBsYXllcjtcclxuICAgICAgICAgICAgICAgICAgICBldnQubGF5ZXIubG9hZEVycm9yID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2FkZWRMYXllcnMucHVzaChldnQubGF5ZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIE1hcERpc3BhdGNoZXIub25MYXllclJlYWR5LmRpc3BhdGNoKHRoaXMsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJsYXllci1yZWFkeVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXllcjogZXZ0LmxheWVyLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5jYXRjaCgocmVhc29uKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgbGF5ZXIgXCIke2V2dC5sYXllci5sYXllckRlc2NyaXB0aW9uLmxhYmVsfVwiIGtvbm50ZSBuaWNodCBnZWxhZGVuIHdlcmRlbmAsIHJlYXNvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgZXZ0LmxheWVyLmxvYWRFcnJvciA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgTWFwRGlzcGF0Y2hlci5vbkxheWVyRXJyb3IuZGlzcGF0Y2godGhpcywge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImxheWVyLWVycm9yXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxheWVyOiBldnQubGF5ZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiYWxyZWFkeSByZXF1ZXN0ZWRcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIF9jcmVhdGVQaWVjaGFydExheWVyKGxheWVyRGVzY3I6IE1hcERlc2NyaXB0aW9uLkxheWVyRGVzY3JpcHRpb24sIGdlb0pzb246IGdlb0pzb24uRmVhdHVyZUNvbGxlY3Rpb24pOiBMLkxheWVyIHtcclxuICAgICAgICBjb25zdCBsYXllciA9IG5ldyBQaWVjaGFydExheWVyKG51bGwsIDxhbnk+e1xyXG4gICAgICAgICAgICBhdHRyaWJ1dGlvbjogbGF5ZXJEZXNjci5vcHRpb25zLmF0dHJpYnV0aW9uLFxyXG4gICAgICAgICAgICBsYXllckRlc2NyaXB0aW9uOiBsYXllckRlc2NyLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGxheWVyW1wiTGF5ZXJEZXNjcmlwdGlvblwiXSA9IGxheWVyRGVzY3I7XHJcbiAgICAgICAgbGF5ZXIub24oXCJjbGlja1wiLCAoZXZ0OiBMZWFmbGV0TW91c2VFdmVudCkgPT4ge1xyXG4gICAgICAgICAgICBNYXBEaXNwYXRjaGVyLm9uTWFwRmVhdHVyZUNsaWNrLmRpc3BhdGNoKGxheWVyLCBldnQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGdlb0pzb24uZmVhdHVyZXMuZm9yRWFjaCgoZmVhdHVyZTogZ2VvSnNvbi5GZWF0dXJlPGdlb0pzb24uUG9pbnQ+LCBpZHgpID0+IHtcclxuICAgICAgICAgICAgaWYgKGZlYXR1cmU/Lmdlb21ldHJ5Py5jb29yZGluYXRlcykge1xyXG4gICAgICAgICAgICAgICAgbGF5ZXIuYWRkTGF5ZXIoXHJcbiAgICAgICAgICAgICAgICAgICAgbmV3IFBpZWNoYXJ0TWFya2VyKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXllcixcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG5nOiBmZWF0dXJlLmdlb21ldHJ5LmNvb3JkaW5hdGVzWzBdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGF0OiBmZWF0dXJlLmdlb21ldHJ5LmNvb3JkaW5hdGVzWzFdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmZWF0dXJlLnByb3BlcnRpZXNcclxuICAgICAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGxheWVyO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBsYXllckRlc2NyIGNyZWF0ZSBhIFBvaW50TGF5ZXJcclxuICAgICAqIEBwYXJhbSBnZW9Kc29uXHJcbiAgICAgKiBAcmV0dXJuc1xyXG4gICAgICovXHJcbiAgICBfY3JlYXRlUG9pbnRMYXllcihsYXllckRlc2NyOiBNYXBEZXNjcmlwdGlvbi5MYXllckRlc2NyaXB0aW9uLCBnZW9Kc29uOiBnZW9Kc29uLkZlYXR1cmVDb2xsZWN0aW9uKTogTC5MYXllciB7XHJcbiAgICAgICAgY29uc29sZS5pbmZvKFwiX2NyZWF0ZVBvaW50TGF5ZXJcIiwgbGF5ZXJEZXNjcik7XHJcbiAgICAgICAgY29uc3QgcGFuZUlkID0gdGhpcy5fY3JlYXRlUGFuZSgpO1xyXG4gICAgICAgIGNvbnN0IGxheWVyID0gbmV3IEdlb2pzb25MYXllcih7XHJcbiAgICAgICAgICAgIG1heENsdXN0ZXJSYWRpdXM6ICh6b29tKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvLyByZXR1cm4gMTU7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gNTA7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGF0dHJpYnV0aW9uOiBsYXllckRlc2NyLm9wdGlvbnMuYXR0cmlidXRpb24sXHJcbiAgICAgICAgICAgIHBhbmU6IHBhbmVJZCxcclxuICAgICAgICAgICAgbGF5ZXJEZXNjcmlwdGlvbjogbGF5ZXJEZXNjcixcclxuICAgICAgICB9KTtcclxuICAgICAgICBsYXllcltcIkxheWVyRGVzY3JpcHRpb25cIl0gPSBsYXllckRlc2NyO1xyXG4gICAgICAgIC8vIGxheWVyLm9uKCdmZWF0dXJlY2xpY2tlZCcsIChldnQ6RmVhdHVyZUNsaWNrRXZlbnQpPT57TWFwRGlzcGF0Y2hlci5vbk1hcEZlYXR1cmVDbGljay5kaXNwYXRjaChldnQuZmVhdHVyZSwgZXZ0KX0pXHJcbiAgICAgICAgbGF5ZXIub24oXCJjbGlja1wiLCAoZXZ0OiBMZWFmbGV0TW91c2VFdmVudCkgPT4ge1xyXG4gICAgICAgICAgICBNYXBEaXNwYXRjaGVyLm9uTWFwRmVhdHVyZUNsaWNrLmRpc3BhdGNoKGxheWVyLCBldnQpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpZiAobGF5ZXJEZXNjci5pY29uKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG15SWNvbiA9IEwuaWNvbihsYXllckRlc2NyLmljb24pO1xyXG4gICAgICAgICAgICBjb25zdCBtYXJrZXJPcHQgPSB7IGljb246IG15SWNvbiwgcGFuZTogcGFuZUlkIH07XHJcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcImdlb0pzb25cIiwgZ2VvSnNvbik7XHJcbiAgICAgICAgICAgIGdlb0pzb24uZmVhdHVyZXMuZm9yRWFjaCgoZmVhdHVyZTogZ2VvSnNvbi5GZWF0dXJlPGdlb0pzb24uUG9pbnQ+LCBpZHgpID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIGNvbnN0IGZlYXR1cmUgPSA8Z2VvSnNvbi5GZWF0dXJlPGdlb0pzb24uUG9pbnQ+Pmdlb0pzb24uZmVhdHVyZXNbaV07XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxheWVyLmFkZExheWVyKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXcgQ2F0ZWdvcnlNYXJrZXIoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXllcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsbmc6IGZlYXR1cmUuZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGF0OiBmZWF0dXJlLmdlb21ldHJ5LmNvb3JkaW5hdGVzWzFdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZlYXR1cmUucHJvcGVydGllcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmtlck9wdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihleCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHN0eWxlRmN0ID0gX2NyZWF0ZVN0eWxlRmN0KGxheWVyRGVzY3IpO1xyXG4gICAgICAgICAgICBnZW9Kc29uLmZlYXR1cmVzLmZvckVhY2goKGZlYXR1cmU6IGdlb0pzb24uRmVhdHVyZTxnZW9Kc29uLlBvaW50PiwgaWR4KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvLyBUT0RPICBjb25zdCBtYXJrZXJPcHQgPSB7Li4uc3R5bGVGY3QoZmVhdHVyZSksIHBhbmU6cGFuZUlkfTtcclxuICAgICAgICAgICAgICAgIGlmIChmZWF0dXJlPy5nZW9tZXRyeT8uY29vcmRpbmF0ZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXJrZXJPcHQgPSB7IC4uLnN0eWxlRmN0KGZlYXR1cmUpIH07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hcmtlck9wdC5pY29uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxheWVyLmFkZExheWVyKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IENhdGVnb3J5TWFya2VyKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxheWVyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG5nOiBmZWF0dXJlLmdlb21ldHJ5LmNvb3JkaW5hdGVzWzBdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXQ6IGZlYXR1cmUuZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMV0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmZWF0dXJlLnByb3BlcnRpZXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFya2VyT3B0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXIuYWRkTGF5ZXIoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgQ2F0ZWdvcnlDaXJjbGVNYXJrZXIoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsbmc6IGZlYXR1cmUuZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhdDogZmVhdHVyZS5nZW9tZXRyeS5jb29yZGluYXRlc1sxXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZlYXR1cmUucHJvcGVydGllcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJrZXJPcHRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5pbmZvKGZlYXR1cmUpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRmVhdHVyIHdpdGhvdXQgY29vcmRpbmF0ZXNcIiwgZmVhdHVyZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbGF5ZXI7XHJcbiAgICB9XHJcblxyXG4gICAgYXN5bmMgY3JlYXRlV01TTGF5ZXIobGF5ZXJEZXNjcjogTWFwRGVzY3JpcHRpb24uTGF5ZXJEZXNjcmlwdGlvbik6IFByb21pc2U8TC5MYXllcj4ge1xyXG4gICAgICAgIC8vIGNvbnNvbGUuZXJyb3IoYGNyZWF0ZVdNU0xheWVyYCwgbGF5ZXJEZXNjcik7XHJcbiAgICAgICAgY29uc3QgZG9jOiBhbnkgPSBhd2FpdCBnZXRDYXBhYmlsaXRpZXMobGF5ZXJEZXNjci51cmwsIDxMLldNU09wdGlvbnM+bGF5ZXJEZXNjci5vcHRpb25zKTtcclxuICAgICAgICBpZiAoZG9jKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcInNkZHNqaGFrXCIpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmluZm8oZG9jKTtcclxuICAgICAgICAgICAgY29uc3QgbCA9IG5ldyBMLlRpbGVMYXllci5XTVMobGF5ZXJEZXNjci51cmwsIHtcclxuICAgICAgICAgICAgICAgIC4uLig8TC5XTVNPcHRpb25zPmxheWVyRGVzY3Iub3B0aW9ucyksXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBjb25zb2xlLmluZm8oXCJXTVNcIiwgbCk7XHJcbiAgICAgICAgICAgIHJldHVybiBsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBhc3luYyBjcmVhdGVHZW9KU09OTGF5ZXIobGF5ZXJEZXNjcjogTWFwRGVzY3JpcHRpb24uTGF5ZXJEZXNjcmlwdGlvbik6IFByb21pc2U8TC5MYXllcj4ge1xyXG4gICAgICAgIC8vIGNvbnNvbGUuZGVidWcoYGNyZWF0ZUpzb25MYXllciAke2xheWVyRGVzY3IubGFiZWx9YCk7XHJcblxyXG4gICAgICAgIGNvbnN0IGpzb246IGFueSA9IGF3YWl0IGxvYWRKc29uKGxheWVyRGVzY3IudXJsLCBsYXllckRlc2NyLnBhcmFtcyk7XHJcblxyXG4gICAgICAgIGNvbnN0IGZGZWF0dXJlQ2xpY2tlZCA9IChldnQ6IEwuTGVhZmxldE1vdXNlRXZlbnQpID0+IHtcclxuICAgICAgICAgICAgTWFwRGlzcGF0Y2hlci5vbk1hcEZlYXR1cmVDbGljay5kaXNwYXRjaChldnQudGFyZ2V0LCBldnQpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGlmIChsYXllckRlc2NyLmdlb21UeXBlID09IFwiUG9pbnRcIikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY3JlYXRlUG9pbnRMYXllcihsYXllckRlc2NyLCA8Z2VvSnNvbi5GZWF0dXJlQ29sbGVjdGlvbj5qc29uKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGxheWVyRGVzY3IuZ2VvbVR5cGUgPT0gXCJDaGFydFwiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jcmVhdGVQaWVjaGFydExheWVyKGxheWVyRGVzY3IsIDxnZW9Kc29uLkZlYXR1cmVDb2xsZWN0aW9uPmpzb24pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHN0eWxlRmN0ID0gX2NyZWF0ZVN0eWxlRmN0KGxheWVyRGVzY3IpO1xyXG4gICAgICAgICAgICBjb25zdCBsYXllciA9IG5ldyBMLkdlb0pTT04oanNvbiwgPGFueT57XHJcbiAgICAgICAgICAgICAgICBzdHlsZTogc3R5bGVGY3QsXHJcbiAgICAgICAgICAgICAgICBwYW5lOiB0aGlzLl9jcmVhdGVQYW5lKCksXHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgaWYgKGxheWVyRGVzY3IucG9wdXApIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGV4cEZjdCA9IGNyZWF0ZUV4cHJlc3Npb25GY3QobGF5ZXJEZXNjci5wb3B1cCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBmY3RQb3B1cCA9IChsYXllcjogTC5HZW9KU09OKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZiA9IDxhbnk+bGF5ZXIuZmVhdHVyZTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmluZm8oJ3BvcHVwRmN0JywgZik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGYpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV4cEZjdChmLnByb3BlcnRpZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBsYXllci5iaW5kUG9wdXAoZmN0UG9wdXApO1xyXG4gICAgICAgICAgICAgICAgbGF5ZXIub24oXCJjbGlja1wiLCBmRmVhdHVyZUNsaWNrZWQpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbGF5ZXIub24oXCJjbGlja1wiLCBmRmVhdHVyZUNsaWNrZWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxheWVyW1wiaGlnaGxpZ2h0TWFya2VyXCJdID0gZ2V0SGlnaGxpZ2h0RmN0KGxheWVyRGVzY3IpO1xyXG4gICAgICAgICAgICBsYXllcltcIkxheWVyRGVzY3JpcHRpb25cIl0gPSBsYXllckRlc2NyO1xyXG4gICAgICAgICAgICByZXR1cm4gbGF5ZXI7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgX2NyZWF0ZVBhbmUoKTogc3RyaW5nIHtcclxuICAgICAgICBjb25zdCBwYW5lSWQgPSBcImxwX1wiICsgdGhpcy5sYXllck5yO1xyXG4gICAgICAgIGNvbnN0IHBhbmUgPSB0aGlzLm1hcC5jcmVhdGVQYW5lKFwibHBfXCIgKyB0aGlzLmxheWVyTnIpO1xyXG4gICAgICAgIGNvbnNvbGUuaW5mbyhcInRoaXMubGF5ZXJOci50b1N0cmluZygpPVwiICsgdGhpcy5sYXllck5yLCBwYW5lKTtcclxuICAgICAgICBwYW5lLnN0eWxlLnpJbmRleCA9IHRoaXMubGF5ZXJOci50b1N0cmluZygpO1xyXG4gICAgICAgIHRoaXMubGF5ZXJOcisrO1xyXG4gICAgICAgIHJldHVybiBwYW5lSWQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBhc3luYyBjcmVhdGVMYXllcihsYXllckRlc2NyOiBNYXBEZXNjcmlwdGlvbi5MYXllckRlc2NyaXB0aW9uKTogUHJvbWlzZTxMLkxheWVyPiB7XHJcbiAgICAgICAgLy8gY29uc29sZS5lcnJvcihgY3JlYXRlTGF5ZXIgJHtsYXllckRlc2NyLmxhYmVsfWApO1xyXG5cclxuICAgICAgICBpZiAobGF5ZXJEZXNjci50eXBlID09IFwiR2VvSlNPTlwiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUdlb0pTT05MYXllcihsYXllckRlc2NyKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGxheWVyRGVzY3IudHlwZSA9PSBcIldNU1wiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVdNU0xheWVyKGxheWVyRGVzY3IpO1xyXG4gICAgICAgICAgICAvLyByZXR1cm4gZ2V0Q2FwYWJpbGl0aWVzKGxheWVyRGVzY3IudXJsLCA8TC5XTVNPcHRpb25zPmxheWVyRGVzY3Iub3B0aW9ucykudGhlbigodikgPT4ge1xyXG4gICAgICAgICAgICAvLyAgICAgY29uc29sZS5pbmZvKFwic2Rkc2poYWtcIik7XHJcbiAgICAgICAgICAgIC8vICAgICBjb25zb2xlLmluZm8odik7XHJcbiAgICAgICAgICAgIC8vICAgICBjb25zdCBsID0gbmV3IEwuVGlsZUxheWVyLldNUyhsYXllckRlc2NyLnVybCwge1xyXG4gICAgICAgICAgICAvLyAgICAgICAgIC4uLig8TC5XTVNPcHRpb25zPmxheWVyRGVzY3Iub3B0aW9ucyksXHJcbiAgICAgICAgICAgIC8vICAgICB9KTtcclxuICAgICAgICAgICAgLy8gICAgIGNvbnNvbGUuaW5mbyhcIldNU1wiLCBsKTtcclxuICAgICAgICAgICAgLy8gICAgIHJldHVybiBsO1xyXG4gICAgICAgICAgICAvLyB9KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBub3Qgc3VwcG9ydGVkIExheWVydHlwZTogJHtsYXllckRlc2NyLnR5cGV9YCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbn1cclxuXHJcbmFzeW5jIGZ1bmN0aW9uIGdldENhcGFiaWxpdGllcyh1cmw6IHN0cmluZywgb3B0aW9uczogTC5XTVNPcHRpb25zKTogUHJvbWlzZTxEb2N1bWVudD4ge1xyXG4gICAgLy8gaHR0cHM6Ly9tYXBzLmR3ZC5kZS9nZW9zZXJ2ZXIvZHdkL3dtcz92ZXJzaW9uPTEuMy4wJnJlcXVlc3Q9R2V0Q2FwYWJpbGl0aWVzJnNlcnZpY2U9V01TXHJcbiAgICBjb25zdCBjVXJsID0gdXJsICsgXCI/dmVyc2lvbj0xLjMuMCZyZXF1ZXN0PUdldENhcGFiaWxpdGllcyZzZXJ2aWNlPVdNU1wiO1xyXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgd2luZG93XHJcbiAgICAgICAgLmZldGNoKGNVcmwpXHJcbiAgICAgICAgLnRoZW4oKHJlc3BvbnNlKSA9PiByZXNwb25zZS50ZXh0KCkpXHJcbiAgICAgICAgLnRoZW4oKHRleHQpID0+IHtcclxuICAgICAgICAgICAgbGV0IHhtbDogYW55O1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHdpbmRvdy5ET01QYXJzZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJzZXIgPSBuZXcgd2luZG93LkRPTVBhcnNlcigpO1xyXG4gICAgICAgICAgICAgICAgICAgIHhtbCA9IHBhcnNlci5wYXJzZUZyb21TdHJpbmcodGV4dCwgXCJ0ZXh0L3htbFwiKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyB9IGVsc2UgaWYgKHdpbmRvdy5BY3RpdmVYT2JqZWN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgIHhtbCA9IG5ldyB3aW5kb3cuQWN0aXZlWE9iamVjdChcIk1pY3Jvc29mdC5YTUxET01cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgIHhtbC5hc3luYyA9IFwiZmFsc2VcIjtcclxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgeG1sLmxvYWRYTUwodGV4dCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geG1sO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG4iLCJpbXBvcnQgKiBhcyBMIGZyb20gXCJsZWFmbGV0XCI7XHJcbmltcG9ydCB7IE1hcERpc3BhdGNoZXIsIE1hcENvbnRyb2wsIExheWVyV3JhcHBlciB9IGZyb20gXCIuL2NvbnRyb2xzL01hcENvbnRyb2xcIjtcclxuaW1wb3J0IHsgR2VvY29kZXIgfSBmcm9tIFwiLi91dGlsL0wuR2VvY29kZXJNVlwiO1xyXG5pbXBvcnQgeyBMYXllckxvYWRlciB9IGZyb20gXCIuL0xheWVyTG9hZGVyXCI7XHJcbmltcG9ydCB7IEF0dHJpYnV0aW9uQ3RybCB9IGZyb20gXCIuL2NvbnRyb2xzL0F0dHJpYnV0aW9uQ3RybFwiO1xyXG5pbXBvcnQgeyBMZWdlbmRDb250cm9sIH0gZnJvbSBcIi4vY29udHJvbHMvTGVnZW5kQ29udHJvbFwiO1xyXG5pbXBvcnQgeyBnZXRDb25mLCBNYXBEZXNjcmlwdGlvbiwgVGhlbWUgfSBmcm9tIFwiLi9jb25mL01hcERlc2NyaXB0aW9uXCI7XHJcbmltcG9ydCBGdXNlIGZyb20gXCJmdXNlLmpzXCI7XHJcbi8vIGltcG9ydCB7IG12IH0gZnJvbSBcIi4vTVZcIjtcclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZUdlb0NvZGVyKG9iamNsYXNzOiBcInBhcmNlbFwiIHwgXCJhZGRyZXNzXCIgfCBcImFkZHJlc3MscGFyY2VsXCIsIGxpbWl0OiBudW1iZXIpOiBHZW9jb2RlciB7XHJcbiAgICByZXR1cm4gbmV3IEdlb2NvZGVyKFwiZXNEdGI3SDVLaDh6bDVZWEozaUlQNnhQbktFSWI1Q2hcIiwge1xyXG4gICAgICAgIHNlcnZpY2VVcmw6IFwiaHR0cHM6Ly9nZW8uc3Yucm9zdG9jay5kZS9nZW9jb2RyL3F1ZXJ5XCIsXHJcbiAgICAgICAgZ2VvY29kaW5nUXVlcnlQYXJhbXM6IHtcclxuICAgICAgICAgICAgY2xhc3M6IG9iamNsYXNzLFxyXG4gICAgICAgICAgICBvdXRfZXBzZzogXCI0MzI2XCIsXHJcbiAgICAgICAgICAgIHNoYXBlOiBcImdlb21ldHJ5XCIsXHJcbiAgICAgICAgICAgIGxpbWl0OiBsaW1pdCxcclxuICAgICAgICB9LFxyXG4gICAgICAgIHJldmVyc2VRdWVyeVBhcmFtczoge1xyXG4gICAgICAgICAgICBjbGFzczogb2JqY2xhc3MsXHJcbiAgICAgICAgICAgIGluX2Vwc2c6IFwiNDMyNlwiLFxyXG4gICAgICAgICAgICBsaW1pdDogbGltaXQsXHJcbiAgICAgICAgICAgIHNoYXBlOiBcImNlbnRyb2lkXCIsXHJcbiAgICAgICAgICAgIG91dF9lcHNnOiBcIjQzMjZcIixcclxuICAgICAgICB9LFxyXG4gICAgfSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKlxyXG4gKiBAcGFyYW0gbWFwRGVzY3JpcHRpb25VcmwgaW5pdGlhbGl6ZWQgdGhlIG1hcCB3aXRoIHRoZSBtYXAgZGVzY3JpcHRpb24gZmlsZSAoU3RhbmRhcmQ6IGxheWVyZGVmLmpzb24pIHNlZTp7QGxpbmsgTWFwRGVzY3JpcHRpb259XHJcbiAqIEByZXR1cm5zXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaW5pdE1hcChtYXBEZXNjcmlwdGlvblVybD86IHN0cmluZykge1xyXG4gICAgY29uc3QgbWFwQXBwID0gbmV3IE1hcEFwcChtYXBEZXNjcmlwdGlvblVybCB8fCBcImxheWVyZGVmLmpzb25cIik7XHJcbiAgICBtYXBBcHAuaW5pdCgpO1xyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgTWFwQXBwIHtcclxuICAgIGF2YWlsYWJsZUxheWVycz86IHN0cmluZztcclxuXHJcbiAgICBtYXA6IEwuTWFwO1xyXG5cclxuICAgIHNlbGVjdGVkTGF5ZXJJZHM6IHN0cmluZ1tdO1xyXG4gICAgY3VycmVudExheWVyczogTC5MYXllcltdID0gW107XHJcbiAgICBtYXBDdHJsOiBNYXBDb250cm9sO1xyXG4gICAgZ2VvY29kZXJBZHJlc3M6IEdlb2NvZGVyO1xyXG4gICAgZ2VvY29kZXJQYXJjZWw6IEdlb2NvZGVyO1xyXG5cclxuICAgIGZ1c2VTZWFyY2g6IEZ1c2U8YW55PjtcclxuXHJcbiAgICBsYXllckxvYWRlcjogTGF5ZXJMb2FkZXI7XHJcblxyXG4gICAgcHJpdmF0ZSBtYXBEZXNjcmlwdGlvblVybDogc3RyaW5nO1xyXG4gICAgcHJpdmF0ZSBtYXBEZXNjcmlwdGlvbjogTWFwRGVzY3JpcHRpb247XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG1hcERlc2NyaXB0aW9uIHVybCB0byB0aGUgbWFwZGVzY3JpcHRpb24tZmlsZSBzZWU6e0BsaW5rIE1hcERlc2NyaXB0aW9ufVxyXG4gICAgICpcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IobWFwRGVzY3JpcHRpb24/OiBzdHJpbmcpIHtcclxuICAgICAgICB0aGlzLm1hcERlc2NyaXB0aW9uVXJsID0gbWFwRGVzY3JpcHRpb247XHJcbiAgICB9XHJcblxyXG4gICAgaW5pdCgpIHtcclxuICAgICAgICBnZXRDb25mKHRoaXMubWFwRGVzY3JpcHRpb25VcmwpLnRoZW4oKG1hcERlc2NyKSA9PiB0aGlzLl9pbml0KG1hcERlc2NyKSk7XHJcbiAgICAgICAgdGhpcy5fYXR0YWNoSG9tZUNsb3NlQnR0bnMoKTtcclxuXHJcbiAgICAgICAgY29uc3QgdXJsUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh3aW5kb3cubG9jYXRpb24uc2VhcmNoKTtcclxuICAgICAgICBjb25zdCBzZWxMID0gdXJsUGFyYW1zLmdldChcImxheWVyc1wiKTtcclxuICAgICAgICBpZiAoc2VsTCkge1xyXG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkTGF5ZXJJZHMgPSBzZWxMLnNwbGl0KFwiLFwiKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMubWFwQ3RybCA9IG5ldyBNYXBDb250cm9sKHtcclxuICAgICAgICAgICAgcG9zaXRpb246IFwidG9wbGVmdFwiLFxyXG4gICAgICAgICAgICBwYXJlbnROb2RlOiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInNpZGViYXItbWFwY3RybFwiKSxcclxuICAgICAgICAgICAgc2VhcmNoRmN0OiAocykgPT4gdGhpcy5fc2VhcmNoKHMpLFxyXG4gICAgICAgICAgICByZXNldE1hcDogKCkgPT4gdGhpcy5fcmVzZXRNYXAoKSxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBfcmVzZXRNYXAoKSB7XHJcbiAgICAgICAgY29uc29sZS5pbmZvKFwicmVzZXRNYXBcIik7XHJcbiAgICAgICAgaWYgKHRoaXMubWFwRGVzY3JpcHRpb24ubWFwT3B0aW9ucy5jZW50ZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5tYXAuc2V0Wm9vbSh0aGlzLm1hcERlc2NyaXB0aW9uLm1hcE9wdGlvbnMuem9vbSk7XHJcbiAgICAgICAgICAgIHRoaXMubWFwLnBhblRvKHRoaXMubWFwRGVzY3JpcHRpb24ubWFwT3B0aW9ucy5jZW50ZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBfYXR0YWNoSG9tZUNsb3NlQnR0bnMoKSB7XHJcbiAgICAgICAgY29uc3QgYnR0bjEgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImNsb3NlLWhvbWUtb3ZlcmxheTFcIik7XHJcbiAgICAgICAgaWYgKGJ0dG4xKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGJ0dG4yID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJjbG9zZS1ob21lLW92ZXJsYXkyXCIpO1xyXG4gICAgICAgICAgICBjb25zdCBmID0gKGV2OiBNb3VzZUV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBob21lID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJob21lLW92ZXJsYXlcIik7XHJcbiAgICAgICAgICAgICAgICBob21lLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgY29uc3QgZkNsb3NlT3ZlcmxheUJ5Q2xpY2sgPSAoZXY6IE1vdXNlRXZlbnQpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChldi5jdXJyZW50VGFyZ2V0ID09PSBldi50YXJnZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICAoPEhUTUxFbGVtZW50PmV2LmN1cnJlbnRUYXJnZXQpLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgY29uc3QgZkNsb3NlT3ZlcmxheUJ5RXNjYXBlID0gKGV2OiBLZXlib2FyZEV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXYua2V5ID09PSBcIkVzY2FwZVwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi5ob21lLW92ZXJsYXlcIikuZm9yRWFjaCgoaXRlbSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAoPEhUTUxFbGVtZW50Pml0ZW0pLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgYnR0bjEuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGYpO1xyXG4gICAgICAgICAgICBidHRuMi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZik7XHJcblxyXG4gICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImNsb3NlLWRhdGVuc2NodXR6LW92ZXJsYXlcIikuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGhvbWUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImRhdGVuc2NodXR6LW92ZXJsYXlcIik7XHJcbiAgICAgICAgICAgICAgICBob21lLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiY2xvc2UtaW1wcmVzc3VtLW92ZXJsYXlcIikuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGhvbWUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImltcHJlc3N1bS1vdmVybGF5XCIpO1xyXG4gICAgICAgICAgICAgICAgaG9tZS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImNsb3NlLWZhcS1vdmVybGF5XCIpLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoKSA9PiB7XHJcblx0XHRcdFx0XHRcdFx0Y29uc3QgaG9tZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZmFxLW92ZXJsYXlcIik7XHJcblx0XHRcdFx0XHRcdFx0aG9tZS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XHJcblx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHRcdFx0ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJidHRuX2ltcHJlc3N1bVwiKS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaG9tZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiaW1wcmVzc3VtLW92ZXJsYXlcIik7XHJcbiAgICAgICAgICAgICAgICBob21lLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImJ0dG5fZGF0ZW5zY2h1dHpcIikuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGhvbWUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImRhdGVuc2NodXR6LW92ZXJsYXlcIik7XHJcbiAgICAgICAgICAgICAgICBob21lLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImJ0dG5fZmFxXCIpLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoKSA9PiB7XHJcblx0XHRcdFx0XHRcdFx0Y29uc3QgaG9tZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZmFxLW92ZXJsYXlcIik7XHJcblx0XHRcdFx0XHRcdFx0aG9tZS5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xyXG5cdFx0XHRcdFx0ICB9KTtcclxuXHJcbiAgICAgICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIuaG9tZS1vdmVybGF5XCIpLmZvckVhY2goKGl0ZW0pID0+IHtcclxuICAgICAgICAgICAgICAgIGl0ZW0uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZDbG9zZU92ZXJsYXlCeUNsaWNrKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBmQ2xvc2VPdmVybGF5QnlFc2NhcGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBfaW5pdChtYXBEZXNjcjogTWFwRGVzY3JpcHRpb24pIHtcclxuICAgICAgICB0aGlzLm1hcERlc2NyaXB0aW9uID0gbWFwRGVzY3I7XHJcbiAgICAgICAgY29uc29sZS5pbmZvKFwibWFwb3B0aW9uc1wiLCBtYXBEZXNjci5tYXBPcHRpb25zKTtcclxuICAgICAgICBjb25zdCBtYXBPcHRpb25zOiBMLk1hcE9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgIC4uLm1hcERlc2NyLm1hcE9wdGlvbnMsXHJcbiAgICAgICAgICAgIC8vIHByZWZlckNhbnZhczogdHJ1ZSxcclxuICAgICAgICAgICAgcmVuZGVyZXI6IG5ldyBMLlNWRygpLFxyXG4gICAgICAgICAgICB6b29tQ29udHJvbDogZmFsc2UsXHJcbiAgICAgICAgICAgIGF0dHJpYnV0aW9uQ29udHJvbDogZmFsc2UsXHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBtYXAgPSAodGhpcy5tYXAgPSBuZXcgTC5NYXAoXCJtYXBcIiwgbWFwT3B0aW9ucykpO1xyXG4gICAgICAgIHRoaXMubGF5ZXJMb2FkZXIgPSBuZXcgTGF5ZXJMb2FkZXIobWFwKTtcclxuICAgICAgICBtYXAuYWRkQ29udHJvbChuZXcgTC5Db250cm9sLlNjYWxlKHsgcG9zaXRpb246IFwiYm90dG9tcmlnaHRcIiwgaW1wZXJpYWw6IGZhbHNlIH0pKTtcclxuICAgICAgICBtYXAuYWRkQ29udHJvbCh0aGlzLm1hcEN0cmwpO1xyXG4gICAgICAgIG1hcC5hZGRDb250cm9sKG5ldyBBdHRyaWJ1dGlvbkN0cmwoKSk7XHJcbiAgICAgICAgbWFwLmFkZENvbnRyb2wobmV3IExlZ2VuZENvbnRyb2woeyBwb3NpdGlvbjogXCJib3R0b21yaWdodFwiIH0pKTtcclxuICAgICAgICBtYXAuYWRkQ29udHJvbChuZXcgTC5Db250cm9sLlpvb20oeyBwb3NpdGlvbjogXCJib3R0b21yaWdodFwiIH0pKTtcclxuICAgICAgICBtYXAub24oXCJjbGlja1wiLCAoZXYpID0+IHtcclxuICAgICAgICAgICAgY29uc29sZS5pbmZvKFwiem9vbUxldmVsPVwiICsgbWFwLmdldFpvb20oKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5pbml0TGF5ZXIobWFwRGVzY3IpO1xyXG4gICAgICAgIC8vIHdpbmRvdy5zZXRUaW1lb3V0KCgpPT50aGlzLmluaXRMYXllcihtYXBEZXNjciksIDEwKTtcclxuICAgIH1cclxuXHJcbiAgICBnZXRPdmVybGF5cyh0aGVtZXM6IFRoZW1lW10pOiBMYXllcldyYXBwZXJbXSB7XHJcbiAgICAgICAgbGV0IG92ZXJsYXlzID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGVtZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKHRoZW1lc1tpXS5sYXllcnMpIHtcclxuICAgICAgICAgICAgICAgIG92ZXJsYXlzID0gb3ZlcmxheXMuY29uY2F0KHRoZW1lc1tpXS5sYXllcnMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGVtZXNbaV0udGhlbWVzKSB7XHJcbiAgICAgICAgICAgICAgICBvdmVybGF5cyA9IG92ZXJsYXlzLmNvbmNhdCh0aGlzLmdldE92ZXJsYXlzKHRoZW1lc1tpXS50aGVtZXMpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb3ZlcmxheXM7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBfc2VhcmNoKHM6IHN0cmluZyk6IFByb21pc2U8YW55W10+IHtcclxuICAgICAgICBjb25zb2xlLmluZm8oXCJNYXBBcHAuX3NlYXJjaFwiKTtcclxuICAgICAgICBpZiAoIXRoaXMuZ2VvY29kZXJBZHJlc3MpIHtcclxuICAgICAgICAgICAgdGhpcy5nZW9jb2RlckFkcmVzcyA9IGNyZWF0ZUdlb0NvZGVyKFwiYWRkcmVzcyxwYXJjZWxcIiwgMzApO1xyXG4gICAgICAgICAgICBjb25zdCBvdmVybGF5cyA9IHRoaXMuZ2V0T3ZlcmxheXModGhpcy5tYXBEZXNjcmlwdGlvbi50aGVtZXMpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmluZm8oXCJvdmVybGF5cy5sZW5ndGhcIiwgb3ZlcmxheXMubGVuZ3RoKTtcclxuICAgICAgICAgICAgdGhpcy5mdXNlU2VhcmNoID0gbmV3IEZ1c2Uob3ZlcmxheXMsIHtcclxuICAgICAgICAgICAgICAgIGlzQ2FzZVNlbnNpdGl2ZTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBpZ25vcmVMb2NhdGlvbjogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIHVzZUV4dGVuZGVkU2VhcmNoOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgaW5jbHVkZVNjb3JlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAga2V5czogW1wibGF5ZXJEZXNjcmlwdGlvbi5hYnN0cmFjdFwiXSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGdlb0NvZGVQcm9taXNlID0gdGhpcy5nZW9jb2RlckFkcmVzcy5nZW9jb2RlKHMpO1xyXG4gICAgICAgIC8vIGNvbnN0IGdlb0NvZGVQcm9taXNlID0gbmV3IFByb21pc2U8YW55W10+KChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAvLyAgICAgdGhpcy5nZW9jb2RlckFkcmVzcy5nZW9jb2RlKHMpLnRoZW4oXHJcbiAgICAgICAgLy8gICAgICAgICAocmVzdWx0OiBhbnkpID0+IHJlc29sdmUocmVzdWx0KVxyXG4gICAgICAgIC8vICAgICApLmNhdGNoKFxyXG4gICAgICAgIC8vICAgICAgICAgKHJlYXNvbjogYW55KSA9PiByZWplY3QocmVhc29uKVxyXG4gICAgICAgIC8vICAgICApO1xyXG4gICAgICAgIC8vIH0pXHJcbiAgICAgICAgY29uc3QgcHJvbWlzZUNvbGxlY3RvciA9IFByb21pc2UuYWxsKFtcclxuICAgICAgICAgICAgbmV3IFByb21pc2U8YW55W10+KChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGZ1c2VSZXN1bHRzOiBhbnlbXSA9IHRoaXMuZnVzZVNlYXJjaC5zZWFyY2gocyk7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmluZm8oXCJmdXNlUmVzdWx0c1wiLCBmdXNlUmVzdWx0cyk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHRzID0gW107XHJcbiAgICAgICAgICAgICAgICBmdXNlUmVzdWx0cy5mb3JFYWNoKChlbGVtZW50KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQuc2NvcmUgPCAwLjEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGVsZW1lbnQuaXRlbS5sYXllckRlc2NyaXB0aW9uLmxhYmVsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXA6IFwiVGhlbWFcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxheWVyOiBlbGVtZW50Lml0ZW0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHRzKTtcclxuICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgIGdlb0NvZGVQcm9taXNlLFxyXG4gICAgICAgIF0pO1xyXG4gICAgICAgIGNvbnN0IHAgPSBuZXcgUHJvbWlzZTxhbnlbXT4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICBwcm9taXNlQ29sbGVjdG9yXHJcbiAgICAgICAgICAgICAgICAudGhlbigocmVzdWx0OiBhbnlbXVtdKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRvdGFsUmVzdWx0OiBhbnlbXTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3VsdC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0W2ldKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3RhbFJlc3VsdCA9IHRvdGFsUmVzdWx0ID8gdG90YWxSZXN1bHQuY29uY2F0KHJlc3VsdFtpXSkgOiByZXN1bHRbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh0b3RhbFJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLmNhdGNoKChyZWFzb246IGFueSkgPT4gcmVqZWN0KHJlYXNvbikpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHBbXCJjYW5jZWxcIl0gPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIGdlb0NvZGVQcm9taXNlW1wiY2FuY2VsXCJdKCk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcInByb21pc2UgY2FuY2VsZWRcIik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gcDtcclxuICAgICAgICAvLyByZXR1cm4gbmV3IFByb21pc2U8YW55W10+KChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAvLyAgICAgdGhpcy5nZW9jb2RlckFkcmVzcy5nZW9jb2RlKHMpLnRoZW4oXHJcbiAgICAgICAgLy8gICAgICAgICAocmVzdWx0OiBhbnkpID0+IHJlc29sdmUocmVzdWx0KVxyXG4gICAgICAgIC8vICAgICApLmNhdGNoKFxyXG4gICAgICAgIC8vICAgICAgICAgKHJlYXNvbjogYW55KSA9PiByZWplY3QocmVhc29uKVxyXG4gICAgICAgIC8vICAgICApO1xyXG4gICAgICAgIC8vIH0pO1xyXG4gICAgfVxyXG4gICAgaW5pdExheWVyKG1hcERlc2NyOiBNYXBEZXNjcmlwdGlvbik6IHZvaWQge1xyXG4gICAgICAgIG1hcERlc2NyLmJhc2VMYXllcnMuZm9yRWFjaCgobGF5ZXJEZXNjcikgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBsYXllciA9IEwudGlsZUxheWVyKGxheWVyRGVzY3IudXJsLCBsYXllckRlc2NyLm9wdGlvbnMpO1xyXG4gICAgICAgICAgICBsYXllckRlc2NyW1wibGF5ZXJcIl0gPSBsYXllcjtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdGhpcy5tYXBDdHJsLnNldEJhc2VMYXllcnMobWFwRGVzY3IuYmFzZUxheWVycywgeyBsYWJlbEF0dHJpYnV0ZTogXCJsYWJlbFwiIH0pO1xyXG4gICAgICAgIHRoaXMubWFwQ3RybC5jYXRlZ29yaWVMYXllckN0cmwuYWRkVGhlbWVzKG1hcERlc2NyLnRoZW1lcyk7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGVkTGF5ZXJJZHMpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRMYXllcklkcy5sZW5ndGggPT09IDEgJiYgdGhpcy5zZWxlY3RlZExheWVySWRzWzBdID09PSBcImFsbFwiKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNob3dBbGxUaGVtZXMobWFwRGVzY3IudGhlbWVzKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2hvd1RoZW1lcyhtYXBEZXNjci50aGVtZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLm1hcC5hZGRFdmVudExpc3RlbmVyKFwiem9vbWVuZFwiLCAoZXYpID0+IHtcclxuICAgICAgICAgICAgY29uc29sZS5pbmZvKFwicmVzaXplXCIsIGV2LCB0aGlzLm1hcC5nZXRab29tKCkpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvLyB0aGlzLm1hcC5hZGRMYXllcihuZXcgTC5Qb2x5Z29uKG12KSk7XHJcbiAgICB9XHJcblxyXG4gICAgc2hvd0FsbFRoZW1lcyh0aGVtZXM6IFRoZW1lW10pIHtcclxuICAgICAgICB0aGVtZXMuZm9yRWFjaCgodGhlbWUpID0+IHtcclxuICAgICAgICAgICAgdGhlbWUubGF5ZXJzLmZvckVhY2goKGxheWVyKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsYXllci5pc1NlbGVjdGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIE1hcERpc3BhdGNoZXIub25MYXllclJlcXVlc3QuZGlzcGF0Y2godGhpcy5tYXBDdHJsLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJyZXF1ZXN0LWxheWVyXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXI6IGxheWVyLFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAodGhlbWUudGhlbWVzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNob3dUaGVtZXModGhlbWUudGhlbWVzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHNob3dUaGVtZXModGhlbWVzOiBUaGVtZVtdKSB7XHJcbiAgICAgICAgdGhlbWVzLmZvckVhY2goKHRoZW1lKSA9PiB7XHJcbiAgICAgICAgICAgIHRoZW1lLmxheWVycy5mb3JFYWNoKChsYXllcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRMYXllcklkcy5pbmRleE9mKGxheWVyLmxheWVyRGVzY3JpcHRpb24ubGFiZWwpID49IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBsYXllci5pc1NlbGVjdGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBNYXBEaXNwYXRjaGVyLm9uTGF5ZXJSZXF1ZXN0LmRpc3BhdGNoKHRoaXMubWFwQ3RybCwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInJlcXVlc3QtbGF5ZXJcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXI6IGxheWVyLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaWYgKHRoZW1lLnRoZW1lcykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zaG93VGhlbWVzKHRoZW1lLnRoZW1lcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG4iLCIvLyBjb25zdCBDTE9TSU5HX1RPX09QRU5JTkdfQ0hBUkFDVEVSID0ge1xyXG4vLyAgICAgJyknOiAnKCcsXHJcbi8vICAgICAnXSc6ICdbJyxcclxuLy8gICAgICc+JzogJzwnLFxyXG4vLyAgICAgJ1wiJzogJ1wiJ1xyXG4vLyB9O1xyXG5cclxudHlwZSBPcGVyYXRvciA9IHtcclxuICAgIHN5bWJvbDogc3RyaW5nO1xyXG4gICAga2V5OiBzdHJpbmc7XHJcbiAgICBwcmVjZWRlbmNlOiBudW1iZXI7XHJcbiAgICBhc3NvY2lhdGl2aXR5OiAnbGVmdCd8J3JpZ2h0JztcclxuICAgIGZjdDogKC4uLnBhcmFtczphbnlbXSk9Pm51bWJlcnxib29sZWFuO1xyXG59XHJcblxyXG50eXBlIGJvb2xlYW5FeHByID0gKCkgPT4gYm9vbGVhbjtcclxuXHJcblxyXG5cclxuZnVuY3Rpb24gYW5kT3BlcmF0b3IoLi4uYXJnczogYm9vbGVhbkV4cHJbXSk6IGJvb2xlYW4ge1xyXG4gICAgLy8gY29uc29sZS5pbmZvKCdhbmRPcCcsIGFyZ3MpO1xyXG4gICAgZm9yIChsZXQgaT0wOyBpPGFyZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpZiAoIWFyZ3NbaV0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcblxyXG5mdW5jdGlvbiBvck9wZXJhdG9yKC4uLmFyZ3M6IGJvb2xlYW5FeHByW10pOiBib29sZWFuIHtcclxuICAgIGZvciAobGV0IGk9MDsgaTxhcmdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKGFyZ3NbaV0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59XHJcblxyXG5mdW5jdGlvbiBlcU9wZXJhdG9yKGFyZzAxOiBhbnksIGFyZzAyOiBhbnkpOiBib29sZWFuIHtcclxuICAgIC8vIGNvbnNvbGUuaW5mbyhgZXFPcGVyYXRvciAke2FyZzAxfSAke2FyZzAyfWApO1xyXG4gICAgcmV0dXJuIGFyZzAxID09IGFyZzAyO1xyXG59XHJcblxyXG5mdW5jdGlvbiBsdE9wZXJhdG9yKGFyZzAxOiBhbnksIGFyZzAyOiBhbnkpOiBib29sZWFuIHtcclxuICAgIC8vIGNvbnNvbGUuaW5mbyhgbHRPcGVyYXRvciAke2FyZzAxfSAke2FyZzAyfWApO1xyXG4gICAgcmV0dXJuIGFyZzAxIDwgYXJnMDI7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGd0T3BlcmF0b3IoYXJnMDE6IGFueSwgYXJnMDI6IGFueSk6IGJvb2xlYW4ge1xyXG4gICAgLy8gY29uc29sZS5pbmZvKGBndE9wZXJhdG9yICR7YXJnMDF9ICR7YXJnMDJ9YCk7XHJcbiAgICByZXR1cm4gYXJnMDEgPiBhcmcwMjtcclxufVxyXG5cclxuZnVuY3Rpb24gbGVPcGVyYXRvcihhcmcwMTogYW55LCBhcmcwMjogYW55KTogYm9vbGVhbiB7XHJcbiAgICAvLyBjb25zb2xlLmluZm8oYGxlT3BlcmF0b3IgJHthcmcwMX0gJHthcmcwMn1gKTtcclxuICAgIHJldHVybiBhcmcwMSA8PSBhcmcwMjtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2VPcGVyYXRvcihhcmcwMTogYW55LCBhcmcwMjogYW55KTogYm9vbGVhbiB7XHJcbiAgICAvLyBjb25zb2xlLmluZm8oYGdlT3BlcmF0b3IgJHthcmcwMX0gJHthcmcwMn1gKTtcclxuICAgIHJldHVybiBhcmcwMSA+PSBhcmcwMjtcclxufVxyXG5cclxuZnVuY3Rpb24gbmVPcGVyYXRvcihhcmcwMTogYW55LCBhcmcwMjogYW55KTogYm9vbGVhbiB7XHJcbiAgICAvLyBjb25zb2xlLmluZm8oYG5lT3BlcmF0b3IgJHthcmcwMX0gJHthcmcwMn1gKTtcclxuICAgIHJldHVybiBhcmcwMSAhPSBhcmcwMjtcclxufVxyXG5cclxuY29uc3QgT3BlcmF0b3JzID0gW1xyXG4gICAgeyBzeW1ib2xzOiBbXCJhbmRcIiwgXCImJlwiXSwgZmN0OiBhbmRPcGVyYXRvciwgcHJlY2VkZW5jZTogMSwgYXNzb2NpYXRpdml0eTogJ2xlZnQnfSxcclxuICAgIHsgc3ltYm9sczogW1wib3JcIiwgXCJ8fFwiXSwgZmN0OiBvck9wZXJhdG9yLCBwcmVjZWRlbmNlOiAyLCBhc3NvY2lhdGl2aXR5OiAnbGVmdCd9LFxyXG4gICAgeyBzeW1ib2xzOiBbXCJlcVwiLCBcIj1cIl0sIGZjdDogZXFPcGVyYXRvciwgcHJlY2VkZW5jZTogMywgYXNzb2NpYXRpdml0eTogJ2xlZnQnfSxcclxuICAgIHsgc3ltYm9sczogW1wibHRcIiwgXCI8XCJdLCBmY3Q6IGx0T3BlcmF0b3IsIHByZWNlZGVuY2U6IDMsIGFzc29jaWF0aXZpdHk6ICdsZWZ0J30sXHJcbiAgICB7IHN5bWJvbHM6IFtcImd0XCIsIFwiPlwiXSwgZmN0OiBndE9wZXJhdG9yLCBwcmVjZWRlbmNlOiAzLCBhc3NvY2lhdGl2aXR5OiAnbGVmdCd9LFxyXG4gICAgeyBzeW1ib2xzOiBbXCJsZVwiLCBcIjw9XCJdLCBmY3Q6IGxlT3BlcmF0b3IsIHByZWNlZGVuY2U6IDMsIGFzc29jaWF0aXZpdHk6ICdsZWZ0J30sXHJcbiAgICB7IHN5bWJvbHM6IFtcImdlXCIsIFwiPj1cIl0sIGZjdDogZ2VPcGVyYXRvciwgcHJlY2VkZW5jZTogMywgYXNzb2NpYXRpdml0eTogJ2xlZnQnfSxcclxuICAgIHsgc3ltYm9sczogW1wibmVcIiwgXCIhPVwiXSwgZmN0OiBuZU9wZXJhdG9yLCBwcmVjZWRlbmNlOiAzLCBhc3NvY2lhdGl2aXR5OiAnbGVmdCd9XHJcbl07XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVCaW5hcmllcyhvcGVyYXRvcnMpOk9wZXJhdG9yW10ge1xyXG4gICAgY29uc3Qgb3BzOk9wZXJhdG9yW10gPSBbXTtcclxuICAgIG9wZXJhdG9ycy5mb3JFYWNoKGVsZW1lbnQgPT4ge1xyXG4gICAgICAgIGVsZW1lbnQuc3ltYm9scy5mb3JFYWNoKChzeW1ib2w6c3RyaW5nKSA9PiB7XHJcbiAgICAgICAgICAgIG9wcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgIHN5bWJvbDogc3ltYm9sLFxyXG4gICAgICAgICAgICAgICAga2V5OiBlbGVtZW50LnN5bWJvbHNbMF0sXHJcbiAgICAgICAgICAgICAgICBmY3Q6IGVsZW1lbnQuZmN0LFxyXG4gICAgICAgICAgICAgICAgcHJlY2VkZW5jZTogZWxlbWVudC5mY3QsXHJcbiAgICAgICAgICAgICAgICBhc3NvY2lhdGl2aXR5OiBlbGVtZW50LmFzc29jaWF0aXZpdHlcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIG9wcztcclxufVxyXG5cclxuY29uc3QgYmluYXJpZXMgPSBjcmVhdGVCaW5hcmllcyhPcGVyYXRvcnMpO1xyXG5cclxuXHJcblxyXG5cclxuY2xhc3MgVmFsdWUge1xyXG4gICAgdmFyOnN0cmluZ3xudW1iZXJcclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIEV4cHJlc3Npb24ge1xyXG4gICAga2V5OiBzdHJpbmc7XHJcbiAgICBwYXJhbXM6IChFeHByZXNzaW9ufFZhbHVlKVtdO1xyXG4gICAgZmN0OiAoLi4ucGFyYW1zOmFueVtdKT0+YW55O1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGtleTpzdHJpbmcsIGZjdDooLi4ucGFyYW1zOmFueVtdKT0+YW55LCBwYXJhbTogKEV4cHJlc3Npb258VmFsdWUpW10pIHtcclxuICAgICAgICB0aGlzLmtleSA9IGtleTtcclxuICAgICAgICB0aGlzLnBhcmFtcyA9IHBhcmFtO1xyXG4gICAgICAgIHRoaXMuZmN0ID0gZmN0O1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgX2V2YWxFeHByZXNzaW9uKGV4cHJlc3Npb246RXhwcmVzc2lvbiwgdmFsdWVzOmFueSk6YW55IHtcclxuICAgICAgICByZXR1cm4gZXhwcmVzc2lvbi5ldmFsKHZhbHVlcylcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIF9ldmFsVmFsdWUodmFsOmFueSwgdmFsdWVzOmFueSk6YW55IHtcclxuICAgICAgICAvLyBjb25zb2xlLmluZm8oXCJfZXZhbFZhbHVlXCIsIHZhbCwgdmFsdWVzKTtcclxuICAgICAgICBsZXQgcmVzdWx0OmFueTtcclxuICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgaWYgKHZhbC5zdGFydHNXaXRoKFwiW1wiKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gdmFsLnN1YnN0cmluZygxLCB2YWwubGVuZ3RoLTEpO1xyXG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5pbmZvKFwiX2V2YWxWYWx1ZVwiK2tleSk7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB2YWx1ZXNbdmFsLnN1YnN0cmluZygxLCB2YWwubGVuZ3RoLTEpXTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmICh2YWwuc3RhcnRzV2l0aChcIidcIikpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB2YWwuc3Vic3RyaW5nKDEsIHZhbC5sZW5ndGgtMSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHZhbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHZhbDtcclxuICAgICAgICB9IFxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgZXZhbCh2YWx1ZXM6YW55KTphbnkge1xyXG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IFtdOyAgICAgICAgXHJcbiAgICAgICAgdGhpcy5wYXJhbXMuZm9yRWFjaCggZWxlbWVudCA9PiB7XHJcbiAgICAgICAgICAgIGlmIChlbGVtZW50IGluc3RhbmNlb2YgRXhwcmVzc2lvbikge1xyXG4gICAgICAgICAgICAgICAgcGFyYW1zLnB1c2godGhpcy5fZXZhbEV4cHJlc3Npb24oZWxlbWVudCwgdmFsdWVzKSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBwYXJhbXMucHVzaCh0aGlzLl9ldmFsVmFsdWUoZWxlbWVudC52YXIsIHZhbHVlcykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7ICBcclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gdGhpcy5mY3QoLi4ucGFyYW1zKTtcclxuICAgIH1cclxufVxyXG5cclxudHlwZSBQYXJzZVJlc3VsdCA9IHtcclxuICAgIHJlbWFpbmRlcjpzdHJpbmc7XHJcbiAgICBmb3JtdWxhOlZhbHVlfEV4cHJlc3Npb247XHJcbn1cclxuXHJcblxyXG5jb25zdCBNSU5fUFJFQ0VERU5DRSA9IDA7XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSByZW1haW5kZXIgb2YgYSBnaXZlbiBzdHJpbmcgYWZ0ZXIgc2xpY2luZyBvZmZcclxuICogdGhlIGxlbmd0aCBvZiBhIGdpdmVuIHN5bWJvbCBhbmQgYW55IGZvbGxvd2luZyB3aGl0ZXNwYWNlLlxyXG4gKiAoRG9lcyBub3QgdmVyaWZ5IHRoYXQgdGhlIHN5bWJvbCBpcyBhbiBpbml0aWFsIHN1YnN0cmluZy4pXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBzdGF0aWNcclxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciAgICAtIGEgc3RyaW5nIHRvIHNsaWNlXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzeW1ib2wgLSBhbiBpbml0aWFsIHN1YnN0cmluZ1xyXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxyXG4gKi9cclxuZnVuY3Rpb24gc2xpY2VTeW1ib2woc3RyOnN0cmluZywgc3ltYm9sOnN0cmluZyk6c3RyaW5nIHtcclxuICAgIHJldHVybiBzdHIuc2xpY2Uoc3ltYm9sLmxlbmd0aCkudHJpbSgpO1xyXG59XHJcblxyXG4vKipcclxuICogQXR0ZW1wdHMgdG8gbWF0Y2ggYSBnaXZlbiBsaXN0IG9mIG9wZXJhdG9ycyBhZ2FpbnN0IHRoZSBoZWFkIG9mIGEgZ2l2ZW4gc3RyaW5nLlxyXG4gKiBSZXR1cm5zIHRoZSBmaXJzdCBtYXRjaCBpZiBzdWNjZXNzZnVsLCBvdGhlcndpc2UgbnVsbC5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQHN0YXRpY1xyXG4gKiBAcGFyYW0ge3N0cmluZ30gICBzdHIgICAgICAgICAgLSBhIHN0cmluZyB0byBtYXRjaCBhZ2FpbnN0XHJcbiAqIEBwYXJhbSB7T2JqZWN0W119IG9wZXJhdG9yTGlzdCAtIGFuIGFycmF5IG9mIG9wZXJhdG9yIGRlZmluaXRpb25zLCBzb3J0ZWQgYnkgbG9uZ2VzdCBzeW1ib2xcclxuICogQHJldHVybnMgez9PYmplY3R9XHJcbiAqL1xyXG5mdW5jdGlvbiBtYXRjaE9wZXJhdG9yKHN0cjogc3RyaW5nLCBvcGVyYXRvckxpc3Q6T3BlcmF0b3JbXSk6T3BlcmF0b3J8dW5kZWZpbmVkIHtcclxuICAgIGNvbnN0IHMgPSBzdHIudG9Mb3dlckNhc2UoKTtcclxuICAgIHJldHVybiBvcGVyYXRvckxpc3QucmVkdWNlKChtYXRjaDpPcGVyYXRvciwgb3BlcmF0b3I6T3BlcmF0b3IpID0+IHtcclxuICAgICAgICByZXR1cm4gbWF0Y2ggfHxcclxuICAgICAgICAgICAgKHMuc3RhcnRzV2l0aChvcGVyYXRvci5zeW1ib2wpID8gb3BlcmF0b3IgOiB1bmRlZmluZWQpO1xyXG4gICAgfSwgdW5kZWZpbmVkKTtcclxufVxyXG5cclxuXHJcbi8qKlxyXG4gKiBBIHBhcnNlciBjbGFzcyBmb3IgXCJvcGVyYXRvci1wcmVjZWRlbmNlIGxhbmd1YWdlc1wiLCBpLmUuLFxyXG4gKiBjb250ZXh0LWZyZWUgbGFuZ3VhZ2VzIHdoaWNoIGhhdmUgb25seSB2YXJpYWJsZXMsIHVuYXJ5IG9wZXJhdG9ycywgYW5kIGJpbmFyeSBvcGVyYXRvcnMuXHJcbiAqXHJcbiAqIFRoZSBncmFtbWFyIGZvciBhIHBhcnNlciBpbnN0YW5jZSBpcyB0aHVzIHdob2xseSBzcGVjaWZpZWQgYnkgdGhlIG9wZXJhdG9yIGRlZmluaXRpb25zXHJcbiAqIChhcyB3ZWxsIGFzIGEga2V5IHdpdGggd2hpY2ggdG8gbGFiZWwgdmFyaWFibGUgbm9kZXMpLlxyXG4gKlxyXG4gKiBBbiBvcGVyYXRvciBkZWZpbml0aW9uIGlzIGFuIG9iamVjdCBsaWtlIHRoZSBmb2xsb3dpbmc6XHJcbiAqICAgeyBzeW1ib2w6ICcrJywga2V5OiAncGx1cycsIHByZWNlZGVuY2U6IDEsIGFzc29jaWF0aXZpdHk6ICdsZWZ0JyB9XHJcbiAqIEl0IHNwZWNpZmllcyBhIHN5bWJvbCwgYSBrZXkgZm9yIGl0cyBBU1Qgbm9kZSwgYSBwcmVjZWRlbmNlIGxldmVsLFxyXG4gKiBhbmQgKGZvciBiaW5hcmllcykgYW4gYXNzb2NpYXRpdml0eSBkaXJlY3Rpb24uXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgRm9ybXVsYVBhcnNlclgge1xyXG4gICAgdW5hcmllczogYW55W107XHJcbiAgICBiaW5hcmllczogYW55W107XHJcbiAgICB2YXJpYWJsZUtleTogc3RyaW5nO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gICB2YXJpYWJsZUtleSAtIGtleSB0byB1c2UgZm9yIGEgdmFyaWFibGUncyBBU1Qgbm9kZVxyXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gdW5hcmllcyAgICAgLSBhbiBhcnJheSBvZiB1bmFyeSBvcGVyYXRvciBkZWZpbml0aW9uc1xyXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gYmluYXJpZXMgICAgLSBhbiBhcnJheSBvZiBiaW5hcnkgb3BlcmF0b3IgZGVmaW5pdGlvbnNcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IodmFyaWFibGVLZXkgPSAndmFyJywgdW5hcmllcyA9IFtdLCBiaW5hcmllcyA9IFtdKSB7XHJcbiAgICAgICAgY29uc3QgYnlMb25nZXN0U3ltYm9sID0gKHgsIHkpID0+IHkuc3ltYm9sLmxlbmd0aCAtIHguc3ltYm9sLmxlbmd0aDtcclxuICAgICAgICB0aGlzLnZhcmlhYmxlS2V5ID0gdmFyaWFibGVLZXksXHJcbiAgICAgICAgICAgIHRoaXMudW5hcmllcyA9IHVuYXJpZXMuc2xpY2UoKS5zb3J0KGJ5TG9uZ2VzdFN5bWJvbCksXHJcbiAgICAgICAgICAgIHRoaXMuYmluYXJpZXMgPSBiaW5hcmllcy5zbGljZSgpLnNvcnQoYnlMb25nZXN0U3ltYm9sKVxyXG5cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEF0dGVtcHRzIHRvIHBhcnNlIGEgYmluYXJ5IHN1YmZvcm11bGEgYXQgdGhlIGhlYWQgb2YgYSBnaXZlbiBzdHJpbmcsXHJcbiAgICAgKiBnaXZlbiBhIGxvd2VyIHByZWNlZGVuY2UgYm91bmQgYW5kIGFuIEFTVCBub2RlIHRvIGJlIHVzZWQgYXMgYSBsZWZ0IG9wZXJhbmQuXHJcbiAgICAgKiBSZXR1cm5zIGFuIEFTVCBub2RlIGFuZCBzdHJpbmcgcmVtYWluZGVyIGlmIHN1Y2Nlc3NmdWwsIG90aGVyd2lzZSBudWxsLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge0Zvcm11bGFQYXJzZXJ9IHNlbGZcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgY3VycmVudFN0cmluZyAgICAgLSByZW1haW5kZXIgb2YgaW5wdXQgc3RyaW5nIGxlZnQgdG8gcGFyc2VcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSAgICAgICAgY3VycmVudFByZWNlZGVuY2UgLSBsb3dlc3QgYmluYXJ5IHByZWNlZGVuY2UgYWxsb3dhYmxlIGF0IGN1cnJlbnQgcGFyc2Ugc3RhZ2VcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICAgbGVmdE9wZXJhbmRKU09OICAgLSBBU1Qgbm9kZSBmb3IgYWxyZWFkeS1wYXJzZWQgbGVmdCBvcGVyYW5kXHJcbiAgICAgKiBAcmV0dXJucyB7P09iamVjdH1cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBfcGFyc2VCaW5hcnlTdWJmb3JtdWxhKGN1cnJlbnRTdHJpbmc6c3RyaW5nLCBjdXJyZW50UHJlY2VkZW5jZTpudW1iZXIsIGxlZnRPcGVyYW5kSlNPTjpFeHByZXNzaW9ufFZhbHVlKTpQYXJzZVJlc3VsdCB7XHJcbiAgICAgICAgY29uc3QgYmluYXJ5ID0gbWF0Y2hPcGVyYXRvcihjdXJyZW50U3RyaW5nLCB0aGlzLmJpbmFyaWVzKTtcclxuICAgICAgICBpZiAoIWJpbmFyeSB8fCBiaW5hcnkucHJlY2VkZW5jZSA8IGN1cnJlbnRQcmVjZWRlbmNlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBuZXh0UHJlY2VkZW5jZSA9ICAoYmluYXJ5LmFzc29jaWF0aXZpdHkgPT09ICdsZWZ0JykgPyBiaW5hcnkucHJlY2VkZW5jZSArIDEgOiBiaW5hcnkucHJlY2VkZW5jZTtcclxuICAgICAgICBjb25zdCBwYXJzZWRSaWdodE9wZXJhbmQgPSB0aGlzLl9wYXJzZUZvcm11bGEoc2xpY2VTeW1ib2woY3VycmVudFN0cmluZywgYmluYXJ5LnN5bWJvbCksIG5leHRQcmVjZWRlbmNlKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgLy8ganNvbjogeyBbYmluYXJ5LmtleV06IFtsZWZ0T3BlcmFuZEpTT04sIHBhcnNlZFJpZ2h0T3BlcmFuZC5qc29uXSB9LFxyXG4gICAgICAgICAgICBmb3JtdWxhOiBuZXcgRXhwcmVzc2lvbiggYmluYXJ5LmtleSwgYmluYXJ5LmZjdCwgW2xlZnRPcGVyYW5kSlNPTiwgcGFyc2VkUmlnaHRPcGVyYW5kLmZvcm11bGFdKSAsXHJcbiAgICAgICAgICAgIHJlbWFpbmRlcjogcGFyc2VkUmlnaHRPcGVyYW5kLnJlbWFpbmRlclxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQXR0ZW1wdHMgdG8gcGFyc2UgYSB1bmFyeSBzdWJmb3JtdWxhIGF0IHRoZSBoZWFkIG9mIGEgZ2l2ZW4gc3RyaW5nLlxyXG4gICAgICogUmV0dXJucyBhbiBBU1Qgbm9kZSBhbmQgc3RyaW5nIHJlbWFpbmRlciBpZiBzdWNjZXNzZnVsLCBvdGhlcndpc2UgbnVsbC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9ICAgICAgICBjdXJyZW50U3RyaW5nIC0gcmVtYWluZGVyIG9mIGlucHV0IHN0cmluZyBsZWZ0IHRvIHBhcnNlXHJcbiAgICAgKiBAcmV0dXJucyB7P09iamVjdH1cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBfcGFyc2VVbmFyeVN1YmZvcm11bGEoY3VycmVudFN0cmluZzpzdHJpbmcpOlBhcnNlUmVzdWx0IHtcclxuICAgICAgICBjb25zdCB1bmFyeSA9IG1hdGNoT3BlcmF0b3IoY3VycmVudFN0cmluZywgdGhpcy51bmFyaWVzKTtcclxuICAgICAgICBpZiAoIXVuYXJ5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgcGFyc2VkU3ViZm9ybXVsYSA9IHRoaXMuX3BhcnNlRm9ybXVsYShzbGljZVN5bWJvbChjdXJyZW50U3RyaW5nLCB1bmFyeS5zeW1ib2wpLCB1bmFyeS5wcmVjZWRlbmNlKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgLy8gVE9ETyBVTkFSWVxyXG4gICAgICAgICAgICBmb3JtdWxhOiBuZXcgRXhwcmVzc2lvbih1bmFyeS5rZXksIHVuZGVmaW5lZCwgW3BhcnNlZFN1YmZvcm11bGEuZm9ybXVsYV0pLFxyXG4gICAgICAgICAgICByZW1haW5kZXI6IHBhcnNlZFN1YmZvcm11bGEucmVtYWluZGVyXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVjdXJzaXZlbHkgcGFyc2VzIGEgZm9ybXVsYSBhY2NvcmRpbmcgdG8gdGhpcyBwYXJzZXIncyBwYXJhbWV0ZXJzLlxyXG4gICAgICogUmV0dXJucyBhbiBjb21wbGV0ZSBBU1QgYW5kIGEgKGhvcGVmdWxseSBlbXB0eSkgc3RyaW5nIHJlbWFpbmRlci5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtGb3JtdWxhUGFyc2VyfSBzZWxmXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gICAgICAgIGN1cnJlbnRTdHJpbmcgICAgIC0gcmVtYWluZGVyIG9mIGlucHV0IHN0cmluZyBsZWZ0IHRvIHBhcnNlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gICAgICAgIGN1cnJlbnRQcmVjZWRlbmNlIC0gbG93ZXN0IGJpbmFyeSBwcmVjZWRlbmNlIGFsbG93YWJsZSBhdCBjdXJyZW50IHBhcnNlIHN0YWdlXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gICAgICAgIFtjdXJyZW50SlNPTl0gICAgIC0gQVNUIG5vZGUgcmV0YWluZWQgZnJvbSBwcmV2aW91cyBwYXJzZSBzdGFnZVxyXG4gICAgICogQHJldHVybnMge09iamVjdH1cclxuICAgICAqL1xyXG4gICAgX3BhcnNlRm9ybXVsYShjdXJyZW50U3RyaW5nOiBzdHJpbmcsIGN1cnJlbnRQcmVjZWRlbmNlOiBudW1iZXIsIGN1cnJlbnRKU09OPzogYW55KTpQYXJzZVJlc3VsdCB7XHJcbiAgICAgICAgLy8gY29uc29sZS5pbmZvKGBwYXJzZSAke2N1cnJlbnRTdHJpbmd9YCwgY3VycmVudEpTT04pO1xyXG4gICAgICAgIGlmICghY3VycmVudFN0cmluZy5sZW5ndGggJiYgIWN1cnJlbnRKU09OKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignSW52YWxpZCBmb3JtdWxhISBVbmV4cGVjdGVkIGVuZCBvZiBpbnB1dC4nKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEZpcnN0LCB3ZSBuZWVkIGFuIGluaXRpYWwgc3ViZm9ybXVsYS5cclxuICAgICAgICAvLyBBIHZhbGlkIGZvcm11bGEgY2FuJ3Qgc3RhcnQgd2l0aCBhIGJpbmFyeSBvcGVyYXRvciwgYnV0IGFueXRoaW5nIGVsc2UgaXMgcG9zc2libGUuXHJcbiAgICAgICAgY29uc3QgcGFyc2VkSGVhZCA9XHJcbiAgICAgICAgICAgIGN1cnJlbnRKU09OID8geyBmb3JtdWxhOiBjdXJyZW50SlNPTiwgcmVtYWluZGVyOiBjdXJyZW50U3RyaW5nIH0gOlxyXG4gICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VVbmFyeVN1YmZvcm11bGEoY3VycmVudFN0cmluZykgfHxcclxuICAgICAgICAgICAgICAgIHRoaXMuX3BhcnNlUGFyZW50aGVzaXplZFN1YmZvcm11bGEoY3VycmVudFN0cmluZykgfHxcclxuICAgICAgICAgICAgICAgIHRoaXMuX3BhcnNlVmFyaWFibGUoY3VycmVudFN0cmluZykgfHxcclxuICAgICAgICAgICAgICAgIHRoaXMuX3BhcnNlU3RyaW5nTGl0ZXJhbChjdXJyZW50U3RyaW5nKTtcclxuXHJcbiAgICAgICAgaWYgKCFwYXJzZWRIZWFkKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignSW52YWxpZCBmb3JtdWxhISBDb3VsZCBub3QgZmluZCBhbiBpbml0aWFsIHN1YmZvcm11bGEuJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBIYXZpbmcgZm91bmQgYW4gaW5pdGlhbCBzdWJmb3JtdWxhLCBsZXQncyBzZWUgaWYgaXQncyB0aGUgbGVmdCBvcGVyYW5kIHRvIGEgYmluYXJ5IG9wZXJhdG9yLi4uXHJcbiAgICAgICAgY29uc3QgcGFyc2VkQmluYXJ5ID0gdGhpcy5fcGFyc2VCaW5hcnlTdWJmb3JtdWxhKHBhcnNlZEhlYWQucmVtYWluZGVyLCBjdXJyZW50UHJlY2VkZW5jZSwgcGFyc2VkSGVhZC5mb3JtdWxhKTtcclxuICAgICAgICBpZiAoIXBhcnNlZEJpbmFyeSkge1xyXG4gICAgICAgICAgICAvLyAuLi5pZiBpdCBpc24ndCwgd2UncmUgZG9uZSFcclxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlZEhlYWQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyAuLi5pZiBpdCBpcywgd2UgcGFyc2Ugb253YXJkLCB3aXRoIG91ciBuZXcgYmluYXJ5IHN1YmZvcm11bGEgYXMgdGhlIG5leHQgaW5pdGlhbCBzdWJmb3JtdWxhLlxyXG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJzZUZvcm11bGEocGFyc2VkQmluYXJ5LnJlbWFpbmRlciwgY3VycmVudFByZWNlZGVuY2UsIHBhcnNlZEJpbmFyeS5mb3JtdWxhKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEF0dGVtcHRzIHRvIHBhcnNlIGEgdmFyaWFibGUgKGkuZS4sIGFueSBhbHBoYW51bWVyaWMgc3Vic3RyaW5nKSBhdCB0aGUgaGVhZCBvZiBhIGdpdmVuIHN0cmluZy5cclxuICAgICAqIFJldHVybnMgYW4gQVNUIG5vZGUgYW5kIHN0cmluZyByZW1haW5kZXIgaWYgc3VjY2Vzc2Z1bCwgb3RoZXJ3aXNlIG51bGwuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgY3VycmVudFN0cmluZyAtIHJlbWFpbmRlciBvZiBpbnB1dCBzdHJpbmcgbGVmdCB0byBwYXJzZVxyXG4gICAgICogQHJldHVybnMgez9PYmplY3R9XHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgX3BhcnNlVmFyaWFibGUoY3VycmVudFN0cmluZzogc3RyaW5nKTpQYXJzZVJlc3VsdCB7XHJcbiAgICAgICAgY29uc3QgdmFyaWFibGUgPSAoY3VycmVudFN0cmluZy5tYXRjaCgvXltcXFtcXF1cXHddKy8pIHx8IFtdKVswXTtcclxuICAgICAgICBpZiAoIXZhcmlhYmxlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgZm9ybXVsYTogeyB2YXI6IHZhcmlhYmxlIH0sXHJcbiAgICAgICAgICAgIHJlbWFpbmRlcjogc2xpY2VTeW1ib2woY3VycmVudFN0cmluZywgdmFyaWFibGUpXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIHByaXZhdGUgX3BhcnNlU3RyaW5nTGl0ZXJhbChjdXJyZW50U3RyaW5nOiBzdHJpbmcpOlBhcnNlUmVzdWx0IHtcclxuICAgICAgICBpZiAoY3VycmVudFN0cmluZy5zdGFydHNXaXRoKFwiJ1wiKSkge1xyXG4gICAgICAgICAgICBsZXQgdmFyaWFibGUgPSBcIidcIjtcclxuICAgICAgICAgICAgZm9yIChsZXQgaT0xOyBpPGN1cnJlbnRTdHJpbmcubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50U3RyaW5nLmNoYXJBdChpKSE9XCInXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZSArPSBjdXJyZW50U3RyaW5nLmNoYXJBdChpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlICs9IFwiJ1wiO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcm11bGE6IHsgdmFyOiB2YXJpYWJsZSB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1haW5kZXI6IHNsaWNlU3ltYm9sKGN1cnJlbnRTdHJpbmcsIHZhcmlhYmxlKVxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBdHRlbXB0cyB0byBwYXJzZSBhIHBhcmVudGhlc2l6ZWQgc3ViZm9ybXVsYSBhdCB0aGUgaGVhZCBvZiBhIGdpdmVuIHN0cmluZy5cclxuICAgICAqIFJldHVybnMgYW4gQVNUIG5vZGUgYW5kIHN0cmluZyByZW1haW5kZXIgaWYgc3VjY2Vzc2Z1bCwgb3RoZXJ3aXNlIG51bGwuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgY3VycmVudFN0cmluZyAtIHJlbWFpbmRlciBvZiBpbnB1dCBzdHJpbmcgbGVmdCB0byBwYXJzZVxyXG4gICAgICogQHJldHVybnMgez9PYmplY3R9XHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgX3BhcnNlUGFyZW50aGVzaXplZFN1YmZvcm11bGEoY3VycmVudFN0cmluZzogc3RyaW5nKTpQYXJzZVJlc3VsdCB7XHJcbiAgICAgICAgaWYgKGN1cnJlbnRTdHJpbmcuY2hhckF0KDApICE9PSAnKCcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBwYXJzZWRTdWJmb3JtdWxhID0gdGhpcy5fcGFyc2VGb3JtdWxhKHNsaWNlU3ltYm9sKGN1cnJlbnRTdHJpbmcsICcoJyksIE1JTl9QUkVDRURFTkNFKTtcclxuICAgICAgICBpZiAocGFyc2VkU3ViZm9ybXVsYS5yZW1haW5kZXIuY2hhckF0KDApICE9PSAnKScpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdJbnZhbGlkIGZvcm11bGEhIEZvdW5kIHVubWF0Y2hlZCBwYXJlbnRoZXNpcy4nKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGZvcm11bGE6IHBhcnNlZFN1YmZvcm11bGEuZm9ybXVsYSxcclxuICAgICAgICAgICAgcmVtYWluZGVyOiBzbGljZVN5bWJvbChwYXJzZWRTdWJmb3JtdWxhLnJlbWFpbmRlciwgJyknKVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFBhcnNlcyBhIGZvcm11bGEgYWNjb3JkaW5nIHRvIHRoaXMgcGFyc2VyJ3MgcGFyYW1ldGVycy5cclxuICAgICAqIFJldHVybnMgYW4gQVNUIGluIEpTT04gZm9ybWF0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dCAtIGEgZm9ybXVsYSB0byBwYXJzZVxyXG4gICAgICogQHJldHVybnMge09iamVjdH1cclxuICAgICAqL1xyXG4gICAgcGFyc2UoaW5wdXQ6IHN0cmluZyk6RXhwcmVzc2lvbnxWYWx1ZSB7XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignSW52YWxpZCBmb3JtdWxhISBGb3VuZCBub24tc3RyaW5nIGlucHV0LicpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgcGFyc2VkRm9ybXVsYSA9IHRoaXMuX3BhcnNlRm9ybXVsYShpbnB1dC50cmltKCksIE1JTl9QUkVDRURFTkNFKTtcclxuICAgICAgICBpZiAocGFyc2VkRm9ybXVsYS5yZW1haW5kZXIubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignSW52YWxpZCBmb3JtdWxhISBVbmV4cGVjdGVkIGNvbnRpbnVhdGlvbiBvZiBpbnB1dC4nKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBwYXJzZWRGb3JtdWxhLmZvcm11bGE7XHJcbiAgICB9XHJcbn1cclxuXHJcbmNvbnN0IEZvcm11bGFyUGFyc2VyID0gbmV3IEZvcm11bGFQYXJzZXJYKCd2YXInLCBbXSwgYmluYXJpZXMpO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlRXhwcmVzc2lvbihzOnN0cmluZyk6RXhwcmVzc2lvbnxWYWx1ZSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHJldHVybiBGb3JtdWxhclBhcnNlci5wYXJzZShzKTsgICAgXHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYGNvdWxkIG5vdCBwYXJzZSBleHByZXNzaW9uIHtzfWApXHJcbiAgICB9XHJcbiAgICBcclxufSIsImltcG9ydCB7IE1hcmtlciwgSWNvbiwgRGl2SWNvbiwgSWNvbk9wdGlvbnMsIGZlYXR1cmVHcm91cCwgRmVhdHVyZUdyb3VwLCBMZWFmbGV0RXZlbnQsIE1hcCwgTGF5ZXJPcHRpb25zLCBMYXllciwgQmFzZUljb25PcHRpb25zIH0gZnJvbSBcImxlYWZsZXRcIjtcclxuaW1wb3J0IHsgTGF5ZXJEZXNjcmlwdGlvbiB9IGZyb20gXCIuL2NvbmYvTWFwRGVzY3JpcHRpb25cIjtcclxuaW1wb3J0IHsgQ2F0ZWdvcmllTGF5ZXIsIENhdGVnb3J5TWFwT2JqZWN0LCBJbnRlcmFjdGl2ZUxheWVyLCBQb3B1cENyZWF0b3IgfSBmcm9tIFwiLi9jb250cm9scy9DYXRlZ29yaWVMYXllclwiO1xyXG5pbXBvcnQgeyBNYXBEaXNwYXRjaGVyIH0gZnJvbSBcIi4vY29udHJvbHMvTWFwQ29udHJvbFwiO1xyXG5pbXBvcnQgeyBNYXJrZXJWaWV3IH0gZnJvbSBcIi4vY29udHJvbHMvTWFya2VyTGlzdFZpZXdcIjtcclxuaW1wb3J0IHsgVmlldyB9IGZyb20gXCIuL2NvbnRyb2xzL1ZpZXdDb250cm9sXCI7XHJcbmltcG9ydCB7IGNyZWF0ZVBpZWNoYXJ0LCBQaWVDaGFydFBhcmFtIH0gZnJvbSBcIi4vc3ZnL3BpZWNoYXJ0XCI7XHJcbmltcG9ydCB7IFN2Z1N0eWxlIH0gZnJvbSBcIi4vc3ZnL3N2Z1wiO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBQaWVjaGFydE1hcmtlck9wdGlvbnMgZXh0ZW5kcyBCYXNlSWNvbk9wdGlvbnMge1xyXG4gICAgcmFkaXVzOiBudW1iZXI7XHJcbiAgICBmaWxsT3BhY2l0eT86IG51bWJlcjtcclxuICAgIGNvbG9yPzogc3RyaW5nO1xyXG4gICAgc3Ryb2tlT3BhY2l0eT86IG51bWJlcjtcclxuICAgIHN0cm9rZVdlaWdodD86IG51bWJlcjtcclxuICAgIC8vIHBpZWNoYXJ0OiB7IGF0dE46IHN0cmluZzsgY29sb3I6IHN0cmluZyB9W107XHJcbiAgICBwaWVjaGFydDogeyBbaWQ6IHN0cmluZ106IFN2Z1N0eWxlIH07XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBQaWVjaGFydEljb24gZXh0ZW5kcyBJY29uPFBpZWNoYXJ0TWFya2VyT3B0aW9ucz4ge1xyXG4gICAgcGllY2hhcnQ6IFNWR1NWR0VsZW1lbnQ7XHJcblxyXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBkYXRhOiBhbnksIG9wdGlvbnM6IFBpZWNoYXJ0TWFya2VyT3B0aW9ucykge1xyXG4gICAgICAgIHN1cGVyKG9wdGlvbnMpO1xyXG4gICAgICAgIGNvbnNvbGUuaW5mbyhcIlBpZWNoYXJ0SWNvblwiLCBvcHRpb25zLCBkYXRhKTtcclxuICAgICAgICAvLyB0aGlzLmRhdGEgPSBkYXRhO1xyXG4gICAgfVxyXG5cclxuICAgIGNyZWF0ZUljb24oKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnBpZWNoYXJ0KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtOiBQaWVDaGFydFBhcmFtID0gPGFueT57IC4uLnRoaXMub3B0aW9ucyB9O1xyXG4gICAgICAgICAgICBwYXJhbS5zZWdtZW50cyA9IFtdO1xyXG4gICAgICAgICAgICAvLyBmb3IgKGxldCBrIGluIHRoaXMub3B0aW9ucykge31cclxuICAgICAgICAgICAgLy8gICAgIHJhZGl1czogdGhpcy5vcHRpb25zLnJhZGl1cywgLy9zZXQgcmFkaXVzIG9mIHBpZVxyXG4gICAgICAgICAgICAvLyAgICAgZmlsbE9wYWNpdHk6IHRoaXMub3B0aW9ucy5maWxsT3BhY2l0eSxcclxuICAgICAgICAgICAgLy8gICAgIHNlZ21lbnRzOiBbXSxcclxuICAgICAgICAgICAgLy8gfTtcclxuICAgICAgICAgICAgY29uc29sZS5pbmZvKFwiUGllY2hhcnRJY29uLmNyZWF0ZUljb24gcGFyYW1cIiwgcGFyYW0pO1xyXG4gICAgICAgICAgICBjb25zb2xlLmluZm8oXCJQaWVjaGFydEljb24uY3JlYXRlSWNvbiBvcHRpb25zXCIsIHRoaXMub3B0aW9ucyk7XHJcbiAgICAgICAgICAgIC8vIGZvciAobGV0IGkgPSAwLCBjb3VudCA9IHRoaXMub3B0aW9ucy5waWVjaGFydC5sZW5ndGg7IGkgPCBjb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGsgaW4gdGhpcy5vcHRpb25zLnBpZWNoYXJ0KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBjb25zdCBwID0gdGhpcy5vcHRpb25zLnBpZWNoYXJ0W2ldO1xyXG4gICAgICAgICAgICAgICAgLy8gcGFyYW0uc2VnbWVudHMucHVzaCh7IHZhbHVlOiB0aGlzLmRhdGFbcC5hdHROXSwgY29sb3I6IHAuY29sb3IgfSk7XHJcbiAgICAgICAgICAgICAgICBwYXJhbS5zZWdtZW50cy5wdXNoKHsgdmFsdWU6IHBhcnNlRmxvYXQodGhpcy5kYXRhW2tdKSwgc3R5bGU6IHRoaXMub3B0aW9ucy5waWVjaGFydFtrXSB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnBpZWNoYXJ0ID0gY3JlYXRlUGllY2hhcnQocGFyYW0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gPGFueT50aGlzLnBpZWNoYXJ0O1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgUGllY2hhcnRNYXJrZXI8VCBleHRlbmRzIEwuTGF0TG5nRXhwcmVzc2lvbj4gZXh0ZW5kcyBNYXJrZXIge1xyXG4gICAgdmlzaWJsZTogYm9vbGVhbiA9IGZhbHNlO1xyXG5cclxuICAgIHBhcmVudExheWVyOiBDYXRlZ29yaWVMYXllcjxULCBhbnk+IHwgSW50ZXJhY3RpdmVMYXllcjtcclxuICAgIGRhdGE6IFQ7XHJcbiAgICBwcml2YXRlIF9jbGlja0Nsb3N1cmU6IChldjogYW55KSA9PiB2b2lkO1xyXG4gICAgc2VsZWN0ZWQgPSBmYWxzZTtcclxuICAgIHByaXZhdGUgX2ljb246IEhUTUxJbWFnZUVsZW1lbnQ7XHJcbiAgICAvLyBpY29uOkwuSWNvbjtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnRMYXllcjogUGllY2hhcnRMYXllciwgY29vcmQ6IEwuTGF0TG5nRXhwcmVzc2lvbiwgZGF0YTogYW55LCBvcHRpb25zPzogUGllY2hhcnRNYXJrZXJPcHRpb25zKSB7XHJcbiAgICAgICAgc3VwZXIoY29vcmQsIG9wdGlvbnMpO1xyXG4gICAgICAgIC8vIGNvbnNvbGUuaW5mbyhcIlBpZWNoYXJ0TWFya2VyXCIsIG9wdGlvbnMsIGRhdGEpO1xyXG4gICAgICAgIHRoaXMub3B0aW9ucy5pY29uID0gbmV3IFBpZWNoYXJ0SWNvbihkYXRhLCBwYXJlbnRMYXllci5nZXRQaWVjaGFydE1hcmtlck9wdGlvbnMoKSk7XHJcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcclxuICAgICAgICB0aGlzLnBhcmVudExheWVyID0gcGFyZW50TGF5ZXI7XHJcbiAgICAgICAgLy8gdGhpcy5vcHRpb25zID0gb3B0aW9ucztcclxuICAgIH1cclxuXHJcbiAgICBzZXRWaXNpYmxlKHZpc2libGU6IGJvb2xlYW4pIHtcclxuICAgICAgICB0aGlzLnZpc2libGUgPSB2aXNpYmxlO1xyXG4gICAgfVxyXG5cclxuICAgIGlzVmlzaWJsZSgpOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gdGhpcy52aXNpYmxlO1xyXG4gICAgfVxyXG5cclxuICAgIGhpZ2hsaWdodChoaWdobGlnaHQ6IGJvb2xlYW4pIHtcclxuICAgICAgICBjb25zb2xlLmluZm8oXCJDYXRlZ29yeU1hcmtlci5oaWdobGlnaHRcIiwgdGhpcy5kYXRhW1wiaWRcIl0sIGhpZ2hsaWdodCk7XHJcbiAgICAgICAgdGhpcy5zZWxlY3RlZCA9IGhpZ2hsaWdodDtcclxuICAgICAgICBpZiAodGhpcy5faWNvbikge1xyXG4gICAgICAgICAgICBpZiAoaGlnaGxpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pY29uLmNsYXNzTGlzdC5hZGQoXCJpY29uLWhpZ2hsaWdodGVkXCIpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faWNvbi5jbGFzc0xpc3QucmVtb3ZlKFwiaWNvbi1oaWdobGlnaHRlZFwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zb2xlLmluZm8oXCJ0aGlzXCIsIHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIGdldFBpZWNoYXJ0KCkge1xyXG4gICAgICAgIHJldHVybiAoPFBpZWNoYXJ0SWNvbj50aGlzLm9wdGlvbnMuaWNvbikucGllY2hhcnQuY2xvbmVOb2RlKHRydWUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGdldEljb24oKTogRGl2SWNvbiB8IEljb248SWNvbk9wdGlvbnM+IHtcclxuICAgIC8vICAgICByZXR1cm4gbmV3IFBpZWNoYXJ0SWNvbih0aGlzLmRhdGEsIHRoaXMub3B0aW9ucyBhcyBQaWVjaGFydE1hcmtlck9wdGlvbnMpO1xyXG4gICAgLy8gfVxyXG59XHJcbmV4cG9ydCBpbnRlcmZhY2UgUGllY2hhcnRMYXllckxheWVyT3B0aW9ucyBleHRlbmRzIExheWVyT3B0aW9ucyB7XHJcbiAgICBsYXllckRlc2NyaXB0aW9uOiBMYXllckRlc2NyaXB0aW9uO1xyXG59XHJcbmV4cG9ydCBjbGFzcyBQaWVjaGFydExheWVyIGV4dGVuZHMgRmVhdHVyZUdyb3VwIGltcGxlbWVudHMgSW50ZXJhY3RpdmVMYXllciB7XHJcbiAgICBsYXllckRlc2NyaXB0aW9uOiBMYXllckRlc2NyaXB0aW9uO1xyXG4gICAgcGllY2hhcnRNYXJrZXJPcHRpb25zOiBQaWVjaGFydE1hcmtlck9wdGlvbnM7XHJcblxyXG4gICAgY29uc3RydWN0b3IobGF5ZXJzPzogTGF5ZXJbXSwgb3B0aW9ucz86IFBpZWNoYXJ0TGF5ZXJMYXllck9wdGlvbnMpIHtcclxuICAgICAgICBzdXBlcihsYXllcnMsIG9wdGlvbnMpO1xyXG4gICAgICAgIHRoaXMubGF5ZXJEZXNjcmlwdGlvbiA9IG9wdGlvbnMubGF5ZXJEZXNjcmlwdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICBoaWdobGlnaHRNYXJrZXIobWFya2VyOiBDYXRlZ29yeU1hcE9iamVjdDxhbnk+LCBoaWdobGlnaHQ6IGJvb2xlYW4pIHtcclxuICAgICAgICBtYXJrZXIuaGlnaGxpZ2h0KGhpZ2hsaWdodCk7XHJcbiAgICB9XHJcblxyXG4gICAgbWFwSXRlbUNsaWNrZWQobWFya2VyOiBDYXRlZ29yeU1hcE9iamVjdDxhbnk+LCBldjogTC5MZWFmbGV0TW91c2VFdmVudCk6IHZvaWQge1xyXG4gICAgICAgIC8vIE1hcERpc3BhdGNoZXIub25NYXBGZWF0dXJlQ2xpY2suZGlzcGF0Y2gobWFya2VyLCB7Li4uZXYsIGxheWVyOnRoaXMsIGZlYXR1cmU6bWFya2VyfSk7XHJcbiAgICAgICAgTWFwRGlzcGF0Y2hlci5vbk1hcEZlYXR1cmVDbGljay5kaXNwYXRjaChtYXJrZXIsIGV2KTtcclxuICAgIH1cclxuXHJcbiAgICByZW5kZXJEYXRhKG1hcmtlcjogQ2F0ZWdvcnlNYXBPYmplY3Q8YW55Pik6IFZpZXcge1xyXG4gICAgICAgIHJldHVybiBuZXcgTWFya2VyVmlldyh0aGlzLCBtYXJrZXIpO1xyXG4gICAgfVxyXG5cclxuICAgIGdldFBpZWNoYXJ0TWFya2VyT3B0aW9ucygpOiBQaWVjaGFydE1hcmtlck9wdGlvbnMge1xyXG4gICAgICAgIGlmICghdGhpcy5waWVjaGFydE1hcmtlck9wdGlvbnMpIHtcclxuICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9ICh0aGlzLnBpZWNoYXJ0TWFya2VyT3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgICAgIHJhZGl1czogdGhpcy5sYXllckRlc2NyaXB0aW9uLnByb2Nlc3Npbmcuc3R5bGUucmFkaXVzID8/IDE1LFxyXG4gICAgICAgICAgICAgICAgY29sb3I6IHRoaXMubGF5ZXJEZXNjcmlwdGlvbi5wcm9jZXNzaW5nLnN0eWxlLmNvbG9yID8/IFwiZGFya2dyYXlcIixcclxuICAgICAgICAgICAgICAgIHN0cm9rZU9wYWNpdHk6IHRoaXMubGF5ZXJEZXNjcmlwdGlvbi5wcm9jZXNzaW5nLnN0eWxlLnN0cm9rZU9wYWNpdHkgPz8gMSxcclxuICAgICAgICAgICAgICAgIHN0cm9rZVdlaWdodDogdGhpcy5sYXllckRlc2NyaXB0aW9uLnByb2Nlc3Npbmcuc3R5bGUuc3Ryb2tlV2VpZ2h0ID8/IDEsXHJcbiAgICAgICAgICAgICAgICBwaWVjaGFydDoge30sXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBjb25zdCBsRGVzY3JDbGFzc2VzID0gdGhpcy5sYXllckRlc2NyaXB0aW9uLmNsYXNzZXM7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBjb3VudCA9IGxEZXNjckNsYXNzZXMubGVuZ3RoOyBpIDwgY291bnQ7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2xhc3ogPSBsRGVzY3JDbGFzc2VzW2ldO1xyXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5waWVjaGFydFtjbGFzei5zdHlsZS5zaXplXSA9IHtcclxuICAgICAgICAgICAgICAgICAgICBmaWxsOiBjbGFzei5zdHlsZS5maWxsQ29sb3IsXHJcbiAgICAgICAgICAgICAgICAgICAgb3BhY2l0eTogY2xhc3ouc3R5bGUuZmlsbE9wYWNpdHksXHJcbiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlOiBjbGFzei5zdHlsZS5jb2xvciA/PyBcIiNiYmJcIixcclxuICAgICAgICAgICAgICAgICAgICBzdHJva2VPcGFjaXR5OiBjbGFzei5zdHlsZS5zdHJva2VPcGFjaXR5ID8/IFwiMC42XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IGNsYXN6LnN0eWxlLnN0cm9rZVdlaWdodCA/PyBcIjFcIixcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc29sZS5pbmZvKHRoaXMucGllY2hhcnRNYXJrZXJPcHRpb25zKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5waWVjaGFydE1hcmtlck9wdGlvbnM7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgQnJvd3NlciB9IGZyb20gXCJsZWFmbGV0XCI7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIENhbmNlbGFibGVQcm9taXNlIGV4dGVuZHMgUHJvbWlzZTxhbnk+IHtcclxuICAgIG9uQ2FuY2VsKGNiOiAoKSA9PiB2b2lkKTogdGhpcztcclxuICAgIGNhbmNlbCgpOiB2b2lkO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ2FuY2VsbGFibGVQcm9taXNlKGV4ZWN1dG9yOiAocmVzb2x2ZTogKHZhbHVlPzogYW55IHwgUHJvbWlzZUxpa2U8YW55PikgPT4gdm9pZCwgcmVqZWN0OiAocmVhc29uPzogYW55KSA9PiB2b2lkKSA9PiBhbnkpOiBDYW5jZWxhYmxlUHJvbWlzZSB7XHJcbiAgICBjb25zdCB0ID0gKDxDYW5jZWxhYmxlUHJvbWlzZT5uZXcgUHJvbWlzZShleGVjdXRvcikpIGFzIENhbmNlbGFibGVQcm9taXNlO1xyXG4gICAgdC5vbkNhbmNlbCA9IChjYjogKCkgPT4gdm9pZCkgPT4ge1xyXG4gICAgICAgICg8YW55PnQpLmNhbmNlbE1ldGhvZCA9IGNiO1xyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfTtcclxuICAgIHQuY2FuY2VsID0gKCkgPT4ge1xyXG4gICAgICAgIGNvbnNvbGUuaW5mbyhcImNhbmNlbCBjYWxsZWRcIik7XHJcbiAgICAgICAgaWYgKCg8YW55PnQpLmNhbmNlbE1ldGhvZCkge1xyXG4gICAgICAgICAgICAoPGFueT50KS5jYW5jZWxNZXRob2QoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIHQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBsb2FkSnNvbih1cmw6IHN0cmluZywgcGFyYW1zPzogYW55KTogQ2FuY2VsYWJsZVByb21pc2Uge1xyXG4gICAgbGV0IHByb21pc2U6IENhbmNlbGFibGVQcm9taXNlO1xyXG4gICAgcmV0dXJuIGNyZWF0ZUNhbmNlbGxhYmxlUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgY29uc3Qgc1VybCA9IHVybCArIGdldFBhcmFtU3RyaW5nKHBhcmFtcyk7XHJcbiAgICAgICAgcHJvbWlzZSA9IG1ha2VSZXF1ZXN0KHNVcmwpO1xyXG4gICAgICAgIHByb21pc2VcclxuICAgICAgICAgICAgLnRoZW4oKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IEpTT04ucGFyc2UodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcclxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGBFcnJvciBwYXJzaW5nIHJlc3BvbnNlIGZyb20gXCIke3NVcmx9XCIgcmVhc29uOlwiJHtleH1cImApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAuY2F0Y2goKHJlYXNvbikgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KHJlYXNvbik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgfSkub25DYW5jZWwoKCkgPT4ge1xyXG4gICAgICAgIGNvbnNvbGUuaW5mbyhcImNhbmNlbFwiKTtcclxuICAgICAgICBpZiAocHJvbWlzZSkge1xyXG4gICAgICAgICAgICBwcm9taXNlLmNhbmNlbCgpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgLy8gbGV0IHZhbHVlID0gYXdhaXQgbWFrZVJlcXVlc3QodXJsICsgZ2V0UGFyYW1TdHJpbmcocGFyYW1zKSk7XHJcbiAgICAvLyByZXR1cm4gSlNPTi5wYXJzZSh2YWx1ZSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBtYWtlUmVxdWVzdCh1cmw6IHN0cmluZywgYXV0aD86IHN0cmluZyk6IENhbmNlbGFibGVQcm9taXNlIHtcclxuICAgIGNvbnN0IHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xyXG4gICAgcmV0dXJuIGNyZWF0ZUNhbmNlbGxhYmxlUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgeGhyLm9ubG9hZGVuZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdHVzID09PSAyMDApIHtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUoeGhyLnJlc3BvbnNlVGV4dCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3Qoe1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1czogdGhpcy5zdGF0dXMsXHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzVGV4dDogeGhyLnN0YXR1c1RleHQsXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgcmVqZWN0KHtcclxuICAgICAgICAgICAgICAgIHN0YXR1czogdGhpcy5zdGF0dXMsXHJcbiAgICAgICAgICAgICAgICBzdGF0dXNUZXh0OiB4aHIuc3RhdHVzVGV4dCxcclxuICAgICAgICAgICAgICAgIGV2ZW50OiBldixcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB4aHIub3BlbihcIkdFVFwiLCB1cmwpO1xyXG4gICAgICAgIGlmIChhdXRoKSB7XHJcbiAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKFwiQXV0aG9yaXphdGlvblwiLCBhdXRoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc29sZS5pbmZvKGBydW4gcmVxdWVzdCBcIiR7dXJsfVwiYCk7XHJcbiAgICAgICAgeGhyLnNlbmQoKTtcclxuICAgIH0pLm9uQ2FuY2VsKCgpID0+IHtcclxuICAgICAgICBjb25zb2xlLmRlYnVnKFwieGhyIGFib3J0XCIsIHhocik7XHJcbiAgICAgICAgeGhyLmFib3J0KCk7XHJcbiAgICB9KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFBhcmFtU3RyaW5nKG9iajogYW55LCBleGlzdGluZ1VybD86IHN0cmluZywgdXBwZXJjYXNlPzogYm9vbGVhbikge1xyXG4gICAgaWYgKCFvYmopIHtcclxuICAgICAgICByZXR1cm4gXCJcIjtcclxuICAgIH1cclxuICAgIGNvbnN0IHBhcmFtcyA9IFtdO1xyXG4gICAgZm9yIChsZXQgaSBpbiBvYmopIHtcclxuICAgICAgICBjb25zdCBrZXkgPSBlbmNvZGVVUklDb21wb25lbnQodXBwZXJjYXNlID8gaS50b1VwcGVyQ2FzZSgpIDogaSk7XHJcbiAgICAgICAgY29uc3QgdmFsdWUgPSBvYmpbaV07XHJcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgICAgICBwYXJhbXMucHVzaChrZXkgKyBcIj1cIiArIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdmFsdWUubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIHBhcmFtcy5wdXNoKGtleSArIFwiPVwiICsgZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlW2pdKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gKCFleGlzdGluZ1VybCB8fCBleGlzdGluZ1VybC5pbmRleE9mKFwiP1wiKSA9PT0gLTEgPyBcIj9cIiA6IFwiJlwiKSArIHBhcmFtcy5qb2luKFwiJlwiKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVNsaWRlcihtaW46IHN0cmluZywgbWF4OiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcsIG9uY2hhbmdlPzogKGV2OiBFdmVudCkgPT4gdm9pZCwgY2xhc3NOYW1lPzogc3RyaW5nKTogSFRNTElucHV0RWxlbWVudCB7XHJcbiAgICAvLyA8aW5wdXQgdHlwZT1cInJhbmdlXCIgbWluPVwiMVwiIG1heD1cIjEwMFwiIHZhbHVlPVwiNTBcIiBjbGFzcz1cInNsaWRlclwiIGlkPVwibXlSYW5nZVwiPlxyXG4gICAgY29uc3QgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XHJcbiAgICBpbnB1dC50eXBlID0gXCJyYW5nZVwiO1xyXG4gICAgaW5wdXQubWluID0gbWluO1xyXG4gICAgaW5wdXQubWF4ID0gbWF4O1xyXG4gICAgaW5wdXQudmFsdWUgPSB2YWx1ZTtcclxuICAgIGlmIChvbmNoYW5nZSkge1xyXG4gICAgICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCBvbmNoYW5nZSk7XHJcbiAgICB9XHJcbiAgICBpZiAoY2xhc3NOYW1lKSB7XHJcbiAgICAgICAgaW5wdXQuY2xhc3NOYW1lID0gY2xhc3NOYW1lO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGlucHV0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlSHRtbEVsZW1lbnQ8SyBleHRlbmRzIGtleW9mIEhUTUxFbGVtZW50VGFnTmFtZU1hcD4odGFnOiBLLCBwYXJlbnQ/OiBIVE1MRWxlbWVudCwgY2xhc3NOYW1lPzogc3RyaW5nLCBtaXhpbj86IGFueSk6IEhUTUxFbGVtZW50VGFnTmFtZU1hcFtLXSB7XHJcbiAgICBjb25zdCBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcclxuICAgIGlmIChwYXJlbnQpIHtcclxuICAgICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoZWwpO1xyXG4gICAgfVxyXG4gICAgaWYgKGNsYXNzTmFtZSkge1xyXG4gICAgICAgIGVsLmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcclxuICAgIH1cclxuICAgIGlmIChtaXhpbikge1xyXG4gICAgICAgIGZvciAoY29uc3QgayBpbiBtaXhpbikge1xyXG4gICAgICAgICAgICBlbFtrXSA9IG1peGluW2tdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBlbDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNsb3NlQnV0dG9uKGNiOiAoZXY6IE1vdXNlRXZlbnQpID0+IHZvaWQpIHtcclxuICAgIGNvbnN0IGNsb3NlQnR0biA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xyXG4gICAgY2xvc2VCdHRuLmNsYXNzTmFtZSA9IFwiY2xvc2UtYnV0dG9uXCI7XHJcbiAgICAvKiBjbG9zZUJ0dG4uaW5uZXJIVE1MID0gJyYjeGYwMGQ7JzsgKi9cclxuICAgIGNsb3NlQnR0bi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgY2IpO1xyXG4gICAgcmV0dXJuIGNsb3NlQnR0bjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVJvdyhhdHROYW1lOiBzdHJpbmcsIHZhbHVlOiBhbnksIHBhcmVudDogSFRNTEVsZW1lbnQpOiBIVE1MVGFibGVSb3dFbGVtZW50IHtcclxuICAgIGNvbnN0IHJvdyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0clwiKTtcclxuICAgIGNvbnN0IGMxID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRkXCIpO1xyXG4gICAgYzEuaW5uZXJUZXh0ID0gYXR0TmFtZTtcclxuICAgIGNvbnN0IGMyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRkXCIpO1xyXG4gICAgYzIuaW5uZXJUZXh0ID0gdmFsdWU7XHJcbiAgICByb3cuYXBwZW5kQ2hpbGQoYzEpO1xyXG4gICAgcm93LmFwcGVuZENoaWxkKGMyKTtcclxuICAgIHBhcmVudC5hcHBlbmRDaGlsZChyb3cpO1xyXG4gICAgcmV0dXJuIHJvdztcclxufVxyXG5cclxuY29uc3QgZm5TdG9wUHJvcGFnYXRpb24gPSAoZXY6IEV2ZW50KSA9PiB7XHJcbiAgICBpZiAoZXYuc3RvcFByb3BhZ2F0aW9uKSB7XHJcbiAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGV2LmNhbmNlbEJ1YmJsZSA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgIGlmIChldi5wcmV2ZW50RGVmYXVsdCkge1xyXG4gICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGV2LnJldHVyblZhbHVlID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn07XHJcbi8vIGlmICh0eXBlID09PSAndG91Y2hzdGFydCcgfHwgdHlwZSA9PT0gJ3RvdWNobW92ZScgfHwgdHlwZSA9PT0gJ3doZWVsJyB8fCAgdHlwZSA9PT0gJ21vdXNld2hlZWwnKSB7XHJcbmV4cG9ydCBmdW5jdGlvbiBkaXNhYmxlRXZ0UHJvcGFnYXRpb24oZG9tOiBIVE1MRWxlbWVudCk6IHZvaWQge1xyXG4gICAgY29uc3QgcGFzc2l2ZUV2ZW50cyA9ICg8YW55PkJyb3dzZXIpLnBhc3NpdmVFdmVudHM7XHJcbiAgICBkb20uYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJtb3ZlXCIsIGZuU3RvcFByb3BhZ2F0aW9uKTtcclxuICAgIGRvbS5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIGZuU3RvcFByb3BhZ2F0aW9uKTtcclxuICAgIGRvbS5hZGRFdmVudExpc3RlbmVyKFwiZGJsY2xpY2tcIiwgZm5TdG9wUHJvcGFnYXRpb24pO1xyXG4gICAgZG9tLmFkZEV2ZW50TGlzdGVuZXIoXCJkcmFnc3RhcnRcIiwgZm5TdG9wUHJvcGFnYXRpb24pO1xyXG4gICAgZG9tLmFkZEV2ZW50TGlzdGVuZXIoXCJkcmFnXCIsIGZuU3RvcFByb3BhZ2F0aW9uKTtcclxuICAgIGRvbS5hZGRFdmVudExpc3RlbmVyKFwid2hlZWxcIiwgZm5TdG9wUHJvcGFnYXRpb24sIHBhc3NpdmVFdmVudHMgPyB7IHBhc3NpdmU6IGZhbHNlIH0gOiBmYWxzZSk7XHJcbn1cclxuXHJcbi8qKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNTU1NlbGVjdG9yKHNlbGVjdG9yLCBzdHlsZSkge1xyXG4gICAgY29uc29sZS5pbmZvKGBjcmVhdGVDU1NTZWxlY3Rvcigke3NlbGVjdG9yfSwgJHtzdHlsZX0pYCk7XHJcbiAgICBpZiAoIWRvY3VtZW50LnN0eWxlU2hlZXRzKSByZXR1cm47XHJcbiAgICBpZiAoZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpLmxlbmd0aCA9PSAwKSByZXR1cm47XHJcblxyXG4gICAgbGV0IHN0eWxlU2hlZXQ6IENTU1N0eWxlU2hlZXQ7XHJcbiAgICAvLyBsZXQgbWVkaWFUeXBlO1xyXG5cclxuICAgIGZvciAobGV0IGkgPSAwLCBjb3VudCA9IGRvY3VtZW50LnN0eWxlU2hlZXRzLmxlbmd0aDsgaSA8IGNvdW50ICYmIHN0eWxlU2hlZXQ7IGkrKykge1xyXG4gICAgICAgIGlmICghZG9jdW1lbnQuc3R5bGVTaGVldHNbaV0uZGlzYWJsZWQpIHtcclxuICAgICAgICAgICAgY29uc3QgbWVkaWEgPSBkb2N1bWVudC5zdHlsZVNoZWV0c1tpXS5tZWRpYTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWVkaWEgPT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgICAgICAgICAgaWYgKG1lZGlhLm1lZGlhVGV4dCA9PT0gXCJcIiB8fCBtZWRpYS5tZWRpYVRleHQuaW5kZXhPZihcInNjcmVlblwiKSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdHlsZVNoZWV0ID0gZG9jdW1lbnQuc3R5bGVTaGVldHNbaV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFzdHlsZVNoZWV0KSB7XHJcbiAgICAgICAgY29uc3Qgc3R5bGVTaGVldEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XHJcbiAgICAgICAgc3R5bGVTaGVldEVsZW1lbnQudHlwZSA9IFwidGV4dC9jc3NcIjtcclxuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImhlYWRcIilbMF0uYXBwZW5kQ2hpbGQoc3R5bGVTaGVldEVsZW1lbnQpO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRvY3VtZW50LnN0eWxlU2hlZXRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChkb2N1bWVudC5zdHlsZVNoZWV0c1tpXS5kaXNhYmxlZCkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc3R5bGVTaGVldCA9IGRvY3VtZW50LnN0eWxlU2hlZXRzW2ldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBzdHlsZVNoZWV0TGVuZ3RoID0gc3R5bGVTaGVldC5jc3NSdWxlcyA/IHN0eWxlU2hlZXQuY3NzUnVsZXMubGVuZ3RoIDogMDtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3R5bGVTaGVldExlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgcnVsZSA9IHN0eWxlU2hlZXQuY3NzUnVsZXNbaV07XHJcbiAgICAgICAgaWYgKHJ1bGUgaW5zdGFuY2VvZiBDU1NTdHlsZVJ1bGUpIHtcclxuICAgICAgICAgICAgaWYgKHJ1bGUuc2VsZWN0b3JUZXh0ICYmIHJ1bGUuc2VsZWN0b3JUZXh0LnRvTG93ZXJDYXNlKCkgPT0gc2VsZWN0b3IudG9Mb3dlckNhc2UoKSkge1xyXG4gICAgICAgICAgICAgICAgcnVsZS5zdHlsZS5jc3NUZXh0ID0gc3R5bGU7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzdHlsZVNoZWV0Lmluc2VydFJ1bGUoc2VsZWN0b3IgKyBcIntcIiArIHN0eWxlICsgXCJ9XCIsIHN0eWxlU2hlZXRMZW5ndGgpO1xyXG59XHJcbiIsImltcG9ydCB7IEljb25PcHRpb25zLCBDUlMsIE1hcE9wdGlvbnMgfSBmcm9tIFwibGVhZmxldFwiO1xyXG5pbXBvcnQgeyBMYXllcldyYXBwZXIgfSBmcm9tIFwiLi4vY29udHJvbHMvTWFwQ29udHJvbFwiO1xyXG5pbXBvcnQgeyBsb2FkSnNvbiB9IGZyb20gXCIuLi9VdGlsXCI7XHJcblxyXG5sZXQgbWFwRGVzY3I6IE1hcERlc2NyaXB0aW9uO1xyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldENvbmYodXJsOiBzdHJpbmcpOiBQcm9taXNlPE1hcERlc2NyaXB0aW9uPiB7XHJcbiAgICBpZiAoIW1hcERlc2NyKSB7XHJcbiAgICAgICAgY29uc3QganNvbiA9IGF3YWl0IGxvYWRKc29uKHVybCk7XHJcblxyXG4gICAgICAgIG1hcERlc2NyID0ge1xyXG4gICAgICAgICAgICBkZWZhdWx0X3dtc19sZWdlbmRfaWNvbjoganNvbi5kZWZhdWx0X3dtc19sZWdlbmRfaWNvbixcclxuICAgICAgICAgICAgbWFwT3B0aW9uczoganNvbi5tYXBPcHRpb25zLFxyXG4gICAgICAgICAgICBiYXNlTGF5ZXJzOiBqc29uLmJhc2VMYXllcnMsXHJcbiAgICAgICAgICAgIHRoZW1lczogW10sXHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBtYXBUaGVtZXM6IHsgW2lkOiBzdHJpbmddOiBUaGVtZSB9ID0ge307XHJcbiAgICAgICAgY29uc3QgcGFyc2UgPSBmdW5jdGlvbiAodGhlbWVzOiBUaGVtZVtdKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhlbWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0aGVtZSA9IHRoZW1lc1tpXTtcclxuICAgICAgICAgICAgICAgIHRoZW1lLmxheWVycyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoZW1lLnRoZW1lcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlKHRoZW1lLnRoZW1lcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBtYXBUaGVtZXNbdGhlbWUudGhlbWFdID0gdGhlbWU7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0aGVtZXNBcnIgPSB0aGVtZS50aGVtYS5zcGxpdChcInxcIik7XHJcbiAgICAgICAgICAgICAgICB0aGVtZS50aGVtYSA9IHRoZW1lc0Fyclt0aGVtZXNBcnIubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHBhcnNlKGpzb24udGhlbWVzKTtcclxuICAgICAgICBtYXBEZXNjci50aGVtZXMgPSBqc29uLnRoZW1lcztcclxuXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGNvdW50ID0ganNvbi5vdmVybGF5cy5sZW5ndGg7IGkgPCBjb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG92ZXJsYXk6IExheWVyRGVzY3JpcHRpb24gPSBqc29uLm92ZXJsYXlzW2ldO1xyXG5cclxuICAgICAgICAgICAgbGV0IHRoZW1lID0gbWFwVGhlbWVzW292ZXJsYXkudGhlbWFdO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRoZW1lKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAob3ZlcmxheS50eXBlID09PSBcIldNU1wiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmxheS5vcHRpb25zW1wiY3JzXCJdID0gQ1JTWzxzdHJpbmc+b3ZlcmxheS5vcHRpb25zW1wiY3JzXCJdXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoZW1lLmxheWVycy5wdXNoKG5ldyBMYXllcldyYXBwZXIob3ZlcmxheSkpO1xyXG4gICAgICAgICAgICAgICAgb3ZlcmxheS50aGVtZSA9IHRoZW1lO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIlRoZW1hIG5vdCBkZWZpbmVkXCIsIG92ZXJsYXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG1hcERlc2NyO1xyXG59XHJcblxyXG4vKlxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Q29uZk9sZCh1cmw6IHN0cmluZyk6IFByb21pc2U8TWFwRGVzY3JpcHRpb24+IHtcclxuXHJcblx0aWYgKCFtYXBEZXNjcikge1xyXG5cdFx0Y29uc3QganNvbiA9IGF3YWl0IFV0aWwubG9hZEpzb24odXJsKTtcclxuXHRcdG1hcERlc2NyID0ge1xyXG5cdFx0XHRkZWZhdWx0X3dtc19sZWdlbmRfaWNvbjoganNvbi5kZWZhdWx0X3dtc19sZWdlbmRfaWNvbixcclxuXHRcdFx0bWFwT3B0aW9uczoganNvbi5tYXBPcHRpb25zLFxyXG5cdFx0XHRiYXNlTGF5ZXJzOiBqc29uLmJhc2VMYXllcnMsXHJcblx0XHRcdHRoZW1lczogW11cclxuXHRcdH07XHJcblxyXG5cdFx0Y29uc3QgdGhlbWVzOiB7IFtpZDogc3RyaW5nXTogVGhlbWUgfSA9IHt9O1xyXG5cdFx0Zm9yIChsZXQgaSA9IDAsIGNvdW50ID0ganNvbi5vdmVybGF5cy5sZW5ndGg7IGkgPCBjb3VudDsgaSsrKSB7XHJcblx0XHRcdGNvbnN0IG92ZXJsYXk6IExheWVyRGVzY3JpcHRpb24gPSBqc29uLm92ZXJsYXlzW2ldO1xyXG5cdFx0XHRcclxuXHRcdFx0bGV0IHRoZW1lID0gdGhlbWVzW292ZXJsYXkudGhlbWFdO1xyXG5cclxuXHRcdFx0aWYgKCF0aGVtZSkge1xyXG5cdFx0XHRcdGNvbnN0IHRoZW1lc0FyciA9IG92ZXJsYXkudGhlbWEuc3BsaXQoJ3wnKTtcclxuXHRcdFx0XHRsZXQgdGhlbWVzSWQ6c3RyaW5nO1xyXG5cdFx0XHRcdGxldCBjdXJyZW50VGhlbWU6VGhlbWU7XHJcblx0XHRcdFx0Zm9yIChsZXQgaT0wOyBpPHRoZW1lc0Fyci5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdFx0dGhlbWVzSWQgPSB0aGVtZXNJZCA/ICh0aGVtZXNJZCsnfCcrdGhlbWVzQXJyW2ldKSA6IHRoZW1lc0FycltpXTtcdFx0XHRcdFx0XHJcblx0XHRcdFx0XHR0aGVtZSA9IHRoZW1lc1t0aGVtZXNJZF07XHJcblx0XHRcdFx0XHRpZiAoIXRoZW1lKSB7XHJcblx0XHRcdFx0XHRcdHRoZW1lID0gdGhlbWVzW3RoZW1lc0lkXSA9IHsgdGhlbWE6IHRoZW1lc0FycltpXSwgbGF5ZXJzOiBbXSB9O1xyXG5cdFx0XHRcdFx0XHRpZiAoY3VycmVudFRoZW1lKSB7XHJcblx0XHRcdFx0XHRcdFx0aWYgKCFjdXJyZW50VGhlbWUudGhlbWVzKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRjdXJyZW50VGhlbWUudGhlbWVzID0gW107XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdGN1cnJlbnRUaGVtZS50aGVtZXMucHVzaCh0aGVtZSk7XHJcblx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdFx0bWFwRGVzY3IudGhlbWVzLnB1c2godGhlbWUpO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRjdXJyZW50VGhlbWUgPSB0aGVtZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKG92ZXJsYXkudHlwZSA9PT0gXCJXTVNcIikge1xyXG5cdFx0XHRcdG92ZXJsYXkub3B0aW9uc1tcImNyc1wiXSA9IENSU1s8c3RyaW5nPm92ZXJsYXkub3B0aW9uc1tcImNyc1wiXV07XHJcblx0XHRcdH1cclxuXHRcdFx0dGhlbWUubGF5ZXJzLnB1c2gobmV3IExheWVyV3JhcHBlcihvdmVybGF5KSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yIChsZXQgaT0wLCBjb3VudCA9IGpzb24udGhlbWVzLmxlbmd0aDsgaTxjb3VudDsgaSsrKSB7XHJcblx0XHRcdGNvbnN0IHQgPSBqc29uLnRoZW1lc1tpXTtcclxuXHRcdFx0Y29uc3QgdGhlbWEgPSB0aGVtZXNbdFtcInRoZW1hXCJdXTtcclxuXHRcdFx0aWYgKHRoZW1hKSB7XHJcblx0XHRcdFx0dGhlbWFbJ2ljb24nXSA9IHRbXCJpY29uXCJdO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cdHJldHVybiBtYXBEZXNjcjtcclxufSovXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0TWFwRGVzY3JpcHRpb24oKTogTWFwRGVzY3JpcHRpb24ge1xyXG4gICAgaWYgKCFtYXBEZXNjcikge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1hcGRlc2NyaXB0aW9uIG5vdCBpbml0aWFsaXppZWRcIik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbWFwRGVzY3I7XHJcbn1cclxuXHJcbmV4cG9ydCB0eXBlIE1hcERlc2NyaXB0aW9uID0ge1xyXG4gICAgZGVmYXVsdF93bXNfbGVnZW5kX2ljb246IHN0cmluZztcclxuICAgIG1hcE9wdGlvbnM6IE1hcE9wdGlvbnM7XHJcbiAgICBiYXNlTGF5ZXJzOiBMYXllckRlc2NyaXB0aW9uW107XHJcbiAgICB0aGVtZXM6IFRoZW1lW107XHJcbn07XHJcblxyXG5leHBvcnQgdHlwZSBUaGVtZSA9IHtcclxuICAgIHRoZW1hOiBzdHJpbmc7XHJcbiAgICBsYXllcnM6IExheWVyV3JhcHBlcltdO1xyXG4gICAgaWNvbj86IHN0cmluZztcclxuICAgIHRoZW1lcz86IFRoZW1lW107XHJcbn07XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIExheWVyT3B0aW9ucyB7XHJcbiAgICBwYW5lPzogc3RyaW5nO1xyXG4gICAgYXR0cmlidXRpb24/OiBzdHJpbmc7XHJcbn1cclxuZXhwb3J0IGludGVyZmFjZSBMYXllck9wdGlvbnNXTVMgZXh0ZW5kcyBMYXllck9wdGlvbnMge1xyXG4gICAgLyoqIHRyYW5zcGFyZW50IGlmIFdNUyAqL1xyXG4gICAgdHJhbnNwYXJlbnQ/OiBib29sZWFuO1xyXG4gICAgLyoqIGluIGxlYWZsZXQgZGVmaW5lZCBDUlMgc2VlOiBodHRwczovL2xlYWZsZXRqcy5jb20vcmVmZXJlbmNlLTEuNy4xLmh0bWwjY3JzICAqL1xyXG4gICAgY3JzOiBzdHJpbmcgfCBDUlM7XHJcbiAgICAvKiogQ29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgV01TIGxheWVycyB0byBzaG93LiAqL1xyXG4gICAgbGF5ZXJzOiBzdHJpbmc7XHJcbn1cclxuZXhwb3J0IHR5cGUgTGF5ZXJDbGFzcyA9IHtcclxuICAgIGRlZjogc3RyaW5nO1xyXG4gICAgbmFtZTogc3RyaW5nO1xyXG4gICAgc3R5bGU/OiBhbnk7XHJcbiAgICBpY29uPzogYW55O1xyXG59O1xyXG5cclxuZXhwb3J0IHR5cGUgUHJvY2Vzc2luZ0luc3RydWN0aW9uID0ge1xyXG4gICAgY2hhcnRfdHlwZTogXCJwaWVcIjtcclxuICAgIHN0eWxlOiB7XHJcbiAgICAgICAgcmFkaXVzPzogbnVtYmVyO1xyXG4gICAgICAgIGNvbG9yPzogc3RyaW5nO1xyXG4gICAgICAgIHN0cm9rZU9wYWNpdHk/OiBudW1iZXI7XHJcbiAgICAgICAgc3Ryb2tlV2VpZ2h0PzogbnVtYmVyO1xyXG4gICAgfTtcclxufTtcclxuXHJcbmV4cG9ydCB0eXBlIExheWVyRGVzY3JpcHRpb24gPSB7XHJcbiAgICBpZDogbnVtYmVyIHwgc3RyaW5nO1xyXG4gICAgdGhlbWE/OiBzdHJpbmc7XHJcbiAgICB0aGVtZT86IFRoZW1lO1xyXG4gICAgbGFiZWw/OiBzdHJpbmc7XHJcbiAgICBpbmZvQXR0cmlidXRlPzogc3RyaW5nO1xyXG4gICAgaW1nPzogc3RyaW5nO1xyXG4gICAgYmFja2dyb3VuZENvbG9yPzogc3RyaW5nO1xyXG4gICAgdXJsPzogc3RyaW5nO1xyXG4gICAgd2hlcmVDbGF1c2VsPzogc3RyaW5nO1xyXG4gICAgcGFyYW1zPzogYW55O1xyXG4gICAgY29udGFjdE9yZ2FuaXNhdGlvbj86IHN0cmluZztcclxuICAgIGFic3RyYWN0Pzogc3RyaW5nO1xyXG4gICAgY29udGFjdFBlcnNvbk5hbWU/OiBzdHJpbmc7XHJcbiAgICBjb250YWN0RU1haWw/OiBzdHJpbmc7XHJcbiAgICBjb250YWN0UGhvbj86IHN0cmluZztcclxuICAgIGFjdHVhbGl0eT86IHN0cmluZztcclxuICAgIGFjdHVhbGl0eUNpcmNsZT86IHN0cmluZztcclxuICAgIHR5cGU/OiBcIkdlb0pTT05cIiB8IFwiV01TXCI7XHJcbiAgICB1cmxfbGVnZW5kPzogc3RyaW5nO1xyXG4gICAgZ2VvbVR5cGU/OiBcIlBvaW50XCIgfCBcIkxpbmVzdHJpbmdcIiB8IFwiUG9seWdvblwiIHwgXCJDaGFydFwiO1xyXG4gICAgb3B0aW9ucz86IExheWVyT3B0aW9ucyB8IExheWVyT3B0aW9uc1dNUztcclxuICAgIHN0eWxlPzogYW55O1xyXG4gICAgY2xhc3Nlcz86IExheWVyQ2xhc3NbXTtcclxuICAgIG1pblNjYWxlPzogbnVtYmVyO1xyXG4gICAgbWF4U2NhbGU/OiBudW1iZXI7XHJcbiAgICBwcm9jZXNzaW5nPzogUHJvY2Vzc2luZ0luc3RydWN0aW9uO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAb3B0aW9uIGljb25Vcmw6IFN0cmluZyA9IG51bGxcclxuICAgICAqICoqKHJlcXVpcmVkKSoqIFRoZSBVUkwgdG8gdGhlIGljb24gaW1hZ2UgKGFic29sdXRlIG9yIHJlbGF0aXZlIHRvIHlvdXIgc2NyaXB0IHBhdGgpLlxyXG4gICAgICpcclxuICAgICAqIEBvcHRpb24gaWNvblJldGluYVVybDogU3RyaW5nID0gbnVsbFxyXG4gICAgICogVGhlIFVSTCB0byBhIHJldGluYSBzaXplZCB2ZXJzaW9uIG9mIHRoZSBpY29uIGltYWdlIChhYnNvbHV0ZSBvciByZWxhdGl2ZSB0byB5b3VyXHJcbiAgICAgKiBzY3JpcHQgcGF0aCkuIFVzZWQgZm9yIFJldGluYSBzY3JlZW4gZGV2aWNlcy5cclxuICAgICAqXHJcbiAgICAgKiBAb3B0aW9uIGljb25TaXplOiBQb2ludCA9IG51bGxcclxuICAgICAqIFNpemUgb2YgdGhlIGljb24gaW1hZ2UgaW4gcGl4ZWxzLlxyXG4gICAgICpcclxuICAgICAqIEBvcHRpb24gaWNvbkFuY2hvcjogUG9pbnQgPSBudWxsXHJcbiAgICAgKiBUaGUgY29vcmRpbmF0ZXMgb2YgdGhlIFwidGlwXCIgb2YgdGhlIGljb24gKHJlbGF0aXZlIHRvIGl0cyB0b3AgbGVmdCBjb3JuZXIpLiBUaGUgaWNvblxyXG4gICAgICogd2lsbCBiZSBhbGlnbmVkIHNvIHRoYXQgdGhpcyBwb2ludCBpcyBhdCB0aGUgbWFya2VyJ3MgZ2VvZ3JhcGhpY2FsIGxvY2F0aW9uLiBDZW50ZXJlZFxyXG4gICAgICogYnkgZGVmYXVsdCBpZiBzaXplIGlzIHNwZWNpZmllZCwgYWxzbyBjYW4gYmUgc2V0IGluIENTUyB3aXRoIG5lZ2F0aXZlIG1hcmdpbnMuXHJcbiAgICAgKlxyXG4gICAgICogQG9wdGlvbiBwb3B1cEFuY2hvcjogUG9pbnQgPSBbMCwgMF1cclxuICAgICAqIFRoZSBjb29yZGluYXRlcyBvZiB0aGUgcG9pbnQgZnJvbSB3aGljaCBwb3B1cHMgd2lsbCBcIm9wZW5cIiwgcmVsYXRpdmUgdG8gdGhlIGljb24gYW5jaG9yLlxyXG4gICAgICpcclxuICAgICAqIEBvcHRpb24gdG9vbHRpcEFuY2hvcjogUG9pbnQgPSBbMCwgMF1cclxuICAgICAqIFRoZSBjb29yZGluYXRlcyBvZiB0aGUgcG9pbnQgZnJvbSB3aGljaCB0b29sdGlwcyB3aWxsIFwib3BlblwiLCByZWxhdGl2ZSB0byB0aGUgaWNvbiBhbmNob3IuXHJcbiAgICAgKlxyXG4gICAgICogQG9wdGlvbiBzaGFkb3dVcmw6IFN0cmluZyA9IG51bGxcclxuICAgICAqIFRoZSBVUkwgdG8gdGhlIGljb24gc2hhZG93IGltYWdlLiBJZiBub3Qgc3BlY2lmaWVkLCBubyBzaGFkb3cgaW1hZ2Ugd2lsbCBiZSBjcmVhdGVkLlxyXG4gICAgICpcclxuICAgICAqIEBvcHRpb24gc2hhZG93UmV0aW5hVXJsOiBTdHJpbmcgPSBudWxsXHJcbiAgICAgKlxyXG4gICAgICogQG9wdGlvbiBzaGFkb3dTaXplOiBQb2ludCA9IG51bGxcclxuICAgICAqIFNpemUgb2YgdGhlIHNoYWRvdyBpbWFnZSBpbiBwaXhlbHMuXHJcbiAgICAgKlxyXG4gICAgICogQG9wdGlvbiBzaGFkb3dBbmNob3I6IFBvaW50ID0gbnVsbFxyXG4gICAgICogVGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBcInRpcFwiIG9mIHRoZSBzaGFkb3cgKHJlbGF0aXZlIHRvIGl0cyB0b3AgbGVmdCBjb3JuZXIpICh0aGUgc2FtZVxyXG4gICAgICogYXMgaWNvbkFuY2hvciBpZiBub3Qgc3BlY2lmaWVkKS5cclxuICAgICAqXHJcbiAgICAgKiBAb3B0aW9uIGNsYXNzTmFtZTogU3RyaW5nID0gJydcclxuICAgICAqIEEgY3VzdG9tIGNsYXNzIG5hbWUgdG8gYXNzaWduIHRvIGJvdGggaWNvbiBhbmQgc2hhZG93IGltYWdlcy4gRW1wdHkgYnkgZGVmYXVsdC5cclxuICAgICAqL1xyXG4gICAgaWNvbj86IEljb25PcHRpb25zO1xyXG5cclxuICAgIHBvcHVwPzogc3RyaW5nO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqL1xyXG4gICAgbGF5ZXJBdHRyaWJ1dGVzPzogYW55O1xyXG4gICAgLyoqXHJcbiAgICAgKiBkaXNwbGF5aW5nIGVtcHR5IGZpZWxkcyBpbiB0aGUgZGF0YSB2aWV3XHJcbiAgICAgKi9cclxuICAgIGhpZGVFbXB0eUxheWVyQXR0cmlidXRlcz86IGJvb2xlYW47XHJcbn07XHJcblxyXG5leHBvcnQgY2xhc3MgUGF0aE9wdGlvbnMge1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgaXQgdG8gYGZhbHNlYCB0byBkaXNhYmxlIGJvcmRlcnMgb24gcG9seWdvbnMgb3IgY2lyY2xlcy5cclxuICAgICAqL1xyXG4gICAgc3Ryb2tlID0gdHJ1ZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFN0cm9rZSBjb2xvclxyXG4gICAgICovXHJcbiAgICBjb2xvcjogc3RyaW5nID0gXCIjMzM4OGZmXCI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTdHJva2Ugd2lkdGggaW4gcGl4ZWxzXHJcbiAgICAgKi9cclxuICAgIHdlaWdodCA9IDM7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTdHJva2Ugb3BhY2l0eVxyXG4gICAgICovXHJcbiAgICBvcGFjaXR5ID0gMTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgc3RyaW5nIHRoYXQgZGVmaW5lcyBbc2hhcGUgdG8gYmUgdXNlZCBhdCB0aGUgZW5kXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9TVkcvQXR0cmlidXRlL3N0cm9rZS1saW5lY2FwKSBvZiB0aGUgc3Ryb2tlLlxyXG4gICAgICovXHJcbiAgICBsaW5lQ2FwOiBzdHJpbmcgPSBcInJvdW5kXCI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIHN0cmluZyB0aGF0IGRlZmluZXMgW3NoYXBlIHRvIGJlIHVzZWQgYXQgdGhlIGNvcm5lcnNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL1NWRy9BdHRyaWJ1dGUvc3Ryb2tlLWxpbmVqb2luKSBvZiB0aGUgc3Ryb2tlLlxyXG4gICAgICovXHJcbiAgICBsaW5lSm9pbjogXCJyb3VuZFwiO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSBzdHJpbmcgdGhhdCBkZWZpbmVzIHRoZSBzdHJva2UgW2Rhc2ggcGF0dGVybl0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvU1ZHL0F0dHJpYnV0ZS9zdHJva2UtZGFzaGFycmF5KS4gRG9lc24ndCB3b3JrIG9uIGBDYW52YXNgLXBvd2VyZWQgbGF5ZXJzIGluIFtzb21lIG9sZCBicm93c2Vyc10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC9zZXRMaW5lRGFzaCNCcm93c2VyX2NvbXBhdGliaWxpdHkpLlxyXG4gICAgICovXHJcbiAgICBkYXNoQXJyYXk6IHN0cmluZyA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIHN0cmluZyB0aGF0IGRlZmluZXMgdGhlIFtkaXN0YW5jZSBpbnRvIHRoZSBkYXNoIHBhdHRlcm4gdG8gc3RhcnQgdGhlIGRhc2hdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL1NWRy9BdHRyaWJ1dGUvc3Ryb2tlLWRhc2hvZmZzZXQpLiBEb2Vzbid0IHdvcmsgb24gYENhbnZhc2AtcG93ZXJlZCBsYXllcnMgaW4gW3NvbWUgb2xkIGJyb3dzZXJzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEL3NldExpbmVEYXNoI0Jyb3dzZXJfY29tcGF0aWJpbGl0eSkuXHJcbiAgICAgKi9cclxuICAgIGRhc2hPZmZzZXQ6IHN0cmluZyA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIHRvIGZpbGwgdGhlIHBhdGggd2l0aCBjb2xvci4gU2V0IGl0IHRvIGBmYWxzZWAgdG8gZGlzYWJsZSBmaWxsaW5nIG9uIHBvbHlnb25zIG9yIGNpcmNsZXMuXHJcbiAgICAgKi9cclxuICAgIGZpbGw6IGJvb2xlYW4gPSBmYWxzZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEZpbGwgY29sb3IuIERlZmF1bHRzIHRvIHRoZSB2YWx1ZSBvZiB0aGUgW2Bjb2xvcmBdKCNwYXRoLWNvbG9yKSBvcHRpb25cclxuICAgICAqL1xyXG4gICAgZmlsbENvbG9yOiBzdHJpbmcgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmlsbCBvcGFjaXR5LiBTdGFuZGFyZCA9IDAuMlxyXG4gICAgICovXHJcbiAgICBmaWxsT3BhY2l0eTogbnVtYmVyID0gMC4yO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSBzdHJpbmcgdGhhdCBkZWZpbmVzIFtob3cgdGhlIGluc2lkZSBvZiBhIHNoYXBlXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9TVkcvQXR0cmlidXRlL2ZpbGwtcnVsZSkgaXMgZGV0ZXJtaW5lZC5cclxuICAgICAqL1xyXG4gICAgZmlsbFJ1bGUgPSBcImV2ZW5vZGRcIjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdoZW4gYHRydWVgLCBhIG1vdXNlIGV2ZW50IG9uIHRoaXMgcGF0aCB3aWxsIHRyaWdnZXIgdGhlIHNhbWUgZXZlbnQgb24gdGhlIG1hcFxyXG4gICAgICogKHVubGVzcyBbYEwuRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uYF0oI2RvbWV2ZW50LXN0b3Bwcm9wYWdhdGlvbikgaXMgdXNlZCkuXHJcbiAgICAgKi9cclxuICAgIGJ1YmJsaW5nTW91c2VFdmVudHMgPSB0cnVlO1xyXG59XHJcblxyXG5jbGFzcyBDaXJjbGVNYXJrZXJPcHRpb25zIGV4dGVuZHMgUGF0aE9wdGlvbnMge1xyXG4gICAgZmlsbCA9IHRydWU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSYWRpdXMgb2YgdGhlIGNpcmNsZSBtYXJrZXIsIGluIHBpeGVsc1xyXG4gICAgICovXHJcbiAgICByYWRpdXM6IDEwO1xyXG59XHJcblxyXG5leHBvcnQgY29uc3QgU3RhbmRhcmRQYXRoT3B0aW9ucyA9IG5ldyBQYXRoT3B0aW9ucygpO1xyXG5leHBvcnQgY29uc3QgU3RhbmRhcmRDaXJjbGVNYXJrZXJPcHRpb25zID0gbmV3IENpcmNsZU1hcmtlck9wdGlvbnMoKTtcclxuIiwiaW1wb3J0IHtDb250cm9sLCBNYXAsIFV0aWwsIERvbUV2ZW50LCBEb21VdGlsfSBmcm9tICdsZWFmbGV0JztcclxuLy8gaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi9jb3JlL1V0aWwnO1xyXG4vLyBpbXBvcnQgKiBhcyBEb21FdmVudCBmcm9tICcuLi9kb20vRG9tRXZlbnQnO1xyXG4vLyBpbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uL2RvbS9Eb21VdGlsJztcclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBDb250cm9sLkF0dHJpYnV0aW9uXHJcbiAqIEBha2EgTC5Db250cm9sLkF0dHJpYnV0aW9uXHJcbiAqIEBpbmhlcml0cyBDb250cm9sXHJcbiAqXHJcbiAqIFRoZSBhdHRyaWJ1dGlvbiBjb250cm9sIGFsbG93cyB5b3UgdG8gZGlzcGxheSBhdHRyaWJ1dGlvbiBkYXRhIGluIGEgc21hbGwgdGV4dCBib3ggb24gYSBtYXAuIEl0IGlzIHB1dCBvbiB0aGUgbWFwIGJ5IGRlZmF1bHQgdW5sZXNzIHlvdSBzZXQgaXRzIFtgYXR0cmlidXRpb25Db250cm9sYCBvcHRpb25dKCNtYXAtYXR0cmlidXRpb25jb250cm9sKSB0byBgZmFsc2VgLCBhbmQgaXQgZmV0Y2hlcyBhdHRyaWJ1dGlvbiB0ZXh0cyBmcm9tIGxheWVycyB3aXRoIHRoZSBbYGdldEF0dHJpYnV0aW9uYCBtZXRob2RdKCNsYXllci1nZXRhdHRyaWJ1dGlvbikgYXV0b21hdGljYWxseS4gRXh0ZW5kcyBDb250cm9sLlxyXG4gKi9cclxuXHJcbmV4cG9ydCBjb25zdCBBdHRyaWJ1dGlvbkN0cmwgPSBDb250cm9sLmV4dGVuZCh7XHJcblx0Ly8gQHNlY3Rpb25cclxuXHQvLyBAYWthIENvbnRyb2wuQXR0cmlidXRpb24gb3B0aW9uc1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdHBvc2l0aW9uOiAnYm90dG9tcmlnaHQnLFxyXG5cdFx0Ly8gQG9wdGlvbiBwcmVmaXg6IFN0cmluZyA9ICdMZWFmbGV0J1xyXG5cdFx0Ly8gVGhlIEhUTUwgdGV4dCBzaG93biBiZWZvcmUgdGhlIGF0dHJpYnV0aW9ucy4gUGFzcyBgZmFsc2VgIHRvIGRpc2FibGUuXHJcblx0XHRwcmVmaXg6ICc8YSBocmVmPVwiaHR0cHM6Ly9sZWFmbGV0anMuY29tXCIgdGl0bGU9XCJBIEpTIGxpYnJhcnkgZm9yIGludGVyYWN0aXZlIG1hcHNcIj5MZWFmbGV0PC9hPidcclxuXHR9LFxyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdFx0VXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG4gICAgICAgIHRoaXMuX29wZW4gPSBmYWxzZTtcclxuXHRcdHRoaXMuX2F0dHJpYnV0aW9ucyA9IHt9O1xyXG5cdH0sXHJcblxyXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHRtYXAuYXR0cmlidXRpb25Db250cm9sID0gdGhpcztcclxuXHRcdHRoaXMuX2NvbnRhaW5lciA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCAnY29udHJvbC1hdHRyaWJ1dGlvbicpO1xyXG4gICAgICAgIHRoaXMuX0RpdkF0dHJpYnV0aW9uID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsICdkaXYtYXR0cmlidXRpb24nLCB0aGlzLl9jb250YWluZXIpO1xyXG4gICAgICAgIGNvbnN0IGJ0dG4gPSB0aGlzLl9CdHRuID0gRG9tVXRpbC5jcmVhdGUoJ2J1dHRvbicsICdjdHJsLWljb24nLCB0aGlzLl9jb250YWluZXIpO1xyXG4gICAgICAgIGJ0dG4uaW5uZXJIVE1MID0gXCImY29weTtcIlxyXG4gICAgICAgIHRoaXMuY2xpY2tGY3QgPSAoZXZ0Ok1vdXNlRXZlbnQpPT57XHJcbiAgICAgICAgICAgIGNvbnN0IGlzT3BlbmVkID0gYnR0bi5wYXJlbnRFbGVtZW50LmNsYXNzTGlzdC50b2dnbGUoJ29wZW4nKTtcclxuICAgICAgICAgICAgLy8gYnR0bi5pbm5lckhUTUwgPSBpc09wZW5lZD8gXCLCu1wiIDogXCImY29weTtcIlxyXG4gICAgICAgICAgICBidHRuLmlubmVySFRNTCA9IGlzT3BlbmVkPyBcIjxzcGFuPiYjeGJiOzwvc3Bhbj5cIiA6IFwiPHNwYW4+JmNvcHk7PC9zcGFuPlwiXHJcbiAgICAgICAgICAgXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJ0dG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLmNsaWNrRmN0KTtcclxuXHRcdERvbUV2ZW50LmRpc2FibGVDbGlja1Byb3BhZ2F0aW9uKHRoaXMuX2NvbnRhaW5lcik7XHJcblxyXG5cdFx0Ly8gVE9ETyB1Z2x5LCByZWZhY3RvclxyXG5cdFx0Zm9yIChsZXQgaSBpbiBtYXAuX2xheWVycykge1xyXG5cdFx0XHRpZiAobWFwLl9sYXllcnNbaV0uZ2V0QXR0cmlidXRpb24pIHtcclxuXHRcdFx0XHR0aGlzLmFkZEF0dHJpYnV0aW9uKG1hcC5fbGF5ZXJzW2ldLmdldEF0dHJpYnV0aW9uKCkpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fdXBkYXRlKCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFByZWZpeChwcmVmaXg6IFN0cmluZyk6IHRoaXNcclxuXHQvLyBTZXRzIHRoZSB0ZXh0IGJlZm9yZSB0aGUgYXR0cmlidXRpb25zLlxyXG5cdHNldFByZWZpeDogZnVuY3Rpb24gKHByZWZpeCkge1xyXG5cdFx0dGhpcy5vcHRpb25zLnByZWZpeCA9IHByZWZpeDtcclxuXHRcdHRoaXMuX3VwZGF0ZSgpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBhZGRBdHRyaWJ1dGlvbih0ZXh0OiBTdHJpbmcpOiB0aGlzXHJcblx0Ly8gQWRkcyBhbiBhdHRyaWJ1dGlvbiB0ZXh0IChlLmcuIGAnVmVjdG9yIGRhdGEgJmNvcHk7IE1hcGJveCdgKS5cclxuXHRhZGRBdHRyaWJ1dGlvbjogZnVuY3Rpb24gKHRleHQpIHtcclxuICAgICAgICAvLyBjb25zb2xlLmVycm9yKGBhZGRBdHRyaWJ1dGlvbiAke3RleHR9YClcclxuXHRcdGlmICghdGV4dCkgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdGlmICghdGhpcy5fYXR0cmlidXRpb25zW3RleHRdKSB7XHJcblx0XHRcdHRoaXMuX2F0dHJpYnV0aW9uc1t0ZXh0XSA9IDA7XHJcblx0XHR9XHJcblx0XHR0aGlzLl9hdHRyaWJ1dGlvbnNbdGV4dF0rKztcclxuXHJcblx0XHR0aGlzLl91cGRhdGUoKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHJlbW92ZUF0dHJpYnV0aW9uKHRleHQ6IFN0cmluZyk6IHRoaXNcclxuXHQvLyBSZW1vdmVzIGFuIGF0dHJpYnV0aW9uIHRleHQuXHJcblx0cmVtb3ZlQXR0cmlidXRpb246IGZ1bmN0aW9uICh0ZXh0KSB7XHJcbiAgICAgICAgLy8gY29uc29sZS5lcnJvcihgcmVtb3ZlQXR0cmlidXRpb24gJHt0ZXh0fWApXHJcblx0XHRpZiAoIXRleHQpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0XHRpZiAodGhpcy5fYXR0cmlidXRpb25zW3RleHRdKSB7XHJcblx0XHRcdHRoaXMuX2F0dHJpYnV0aW9uc1t0ZXh0XS0tO1xyXG5cdFx0XHR0aGlzLl91cGRhdGUoKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX21hcCkgeyByZXR1cm47IH1cclxuXHJcblx0XHRjb25zdCBhdHRyaWJzID0gW107XHJcblxyXG5cdFx0Zm9yIChsZXQgaSBpbiB0aGlzLl9hdHRyaWJ1dGlvbnMpIHtcclxuXHRcdFx0aWYgKHRoaXMuX2F0dHJpYnV0aW9uc1tpXSkge1xyXG5cdFx0XHRcdGF0dHJpYnMucHVzaChpKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IHByZWZpeEFuZEF0dHJpYnMgPSBbXTtcclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLnByZWZpeCkge1xyXG5cdFx0XHRwcmVmaXhBbmRBdHRyaWJzLnB1c2godGhpcy5vcHRpb25zLnByZWZpeCk7XHJcblx0XHR9XHJcblx0XHRpZiAoYXR0cmlicy5sZW5ndGgpIHtcclxuXHRcdFx0cHJlZml4QW5kQXR0cmlicy5wdXNoKGF0dHJpYnMuam9pbignLCAnKSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gdGhpcy5fRGl2QXR0cmlidXRpb24uaW5uZXJIVE1MID0gcHJlZml4QW5kQXR0cmlicy5qb2luKCcgfCAnKTtcclxuICAgICAgICB0aGlzLl9EaXZBdHRyaWJ1dGlvbi5pbm5lckhUTUwgPSBwcmVmaXhBbmRBdHRyaWJzLmpvaW4oJzxicj4nKTtcclxuXHR9XHJcbn0pO1xyXG5cclxuLy8gQG5hbWVzcGFjZSBNYXBcclxuLy8gQHNlY3Rpb24gQ29udHJvbCBvcHRpb25zXHJcbi8vIEBvcHRpb24gYXR0cmlidXRpb25Db250cm9sOiBCb29sZWFuID0gdHJ1ZVxyXG4vLyBXaGV0aGVyIGEgW2F0dHJpYnV0aW9uIGNvbnRyb2xdKCNjb250cm9sLWF0dHJpYnV0aW9uKSBpcyBhZGRlZCB0byB0aGUgbWFwIGJ5IGRlZmF1bHQuXHJcbk1hcC5tZXJnZU9wdGlvbnMoe1xyXG5cdGF0dHJpYnV0aW9uQ29udHJvbDogdHJ1ZVxyXG59KTtcclxuXHJcbk1hcC5hZGRJbml0SG9vayhmdW5jdGlvbiAoKSB7XHJcblx0aWYgKHRoaXMub3B0aW9ucy5hdHRyaWJ1dGlvbkNvbnRyb2wpIHtcclxuXHRcdG5ldyBBdHRyaWJ1dGlvbkN0cmwoKS5hZGRUbyh0aGlzKTtcclxuXHR9XHJcbn0pO1xyXG5cclxuIiwiaW1wb3J0ICogYXMgTCBmcm9tIFwibGVhZmxldFwiO1xyXG5pbXBvcnQgeyBjcmVhdGVIdG1sRWxlbWVudCB9IGZyb20gXCIuLi9VdGlsXCI7XHJcbmltcG9ydCB7IEJhc2VMYXllckRlZmluaXRpb24sIExheWVyQ29udHJvbE9wdGlvbnMsIExheWVyRGVmaW5pdGlvbk9wdGlvbnMgfSBmcm9tIFwiLi9MYXllckNvbnRyb2xcIjtcclxuaW1wb3J0IHsgTWFwRGlzcGF0Y2hlciB9IGZyb20gXCIuL01hcENvbnRyb2xcIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBCYXNlTGF5ZXJTZWxlY3RvckN0cmwgZXh0ZW5kcyBMLkNvbnRyb2wge1xyXG4gICAgZG9tOiBIVE1MRWxlbWVudDtcclxuXHJcbiAgICBiYXNlTGF5ZXJEZWZpbml0aW9uczogQmFzZUxheWVyRGVmaW5pdGlvbltdO1xyXG5cclxuICAgIGJhc2VMYXllckRlZmluaXRpb246IEJhc2VMYXllckRlZmluaXRpb247XHJcbiAgICB2aXNpYmxlQmFzZUxheWVyRGVmaW5pdGlvbjogQmFzZUxheWVyRGVmaW5pdGlvbjtcclxuXHJcbiAgICBiYXNlTGF5ZXJEZWZPcHRpb25zOiBMYXllckRlZmluaXRpb25PcHRpb25zO1xyXG4gICAgaWNvbkNvbnRhaW5lcjogSFRNTERpdkVsZW1lbnQ7XHJcblxyXG4gICAgbWFwSWQySWNvbk5vZGU6IHsgW2lkOiBzdHJpbmddOiBIVE1MRWxlbWVudCB9ID0ge307XHJcblxyXG4gICAgYmFzZUxheWVyOiBMLkxheWVyO1xyXG5cclxuICAgIGlzT3BlbiA9IGZhbHNlO1xyXG4gICAgX211dGF0aW9uT2JzZXJ2ZXI6IE11dGF0aW9uT2JzZXJ2ZXI7XHJcblxyXG4gICAgY29uc3RydWN0b3Iob3B0aW9uczogTGF5ZXJDb250cm9sT3B0aW9ucykge1xyXG4gICAgICAgIHN1cGVyKG9wdGlvbnMpO1xyXG4gICAgfVxyXG5cclxuICAgIGNyZWF0ZUljb25zKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5pY29uQ29udGFpbmVyKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGMgPSAodGhpcy5pY29uQ29udGFpbmVyID0gY3JlYXRlSHRtbEVsZW1lbnQoXCJkaXZcIiwgdW5kZWZpbmVkLCBcImJhc2VsYXllcmN0cmwtaWNvbmNvbnRhaW5lclwiKSk7XHJcbiAgICAgICAgICAgIC8vIHRoaXMuYmFzZUxheWVyRGVmaW5pdGlvbnMuZm9yRWFjaCgoaXRlbSkgPT4ge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5iYXNlTGF5ZXJEZWZpbml0aW9ucy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbSA9IHRoaXMuYmFzZUxheWVyRGVmaW5pdGlvbnNbaV07XHJcbiAgICAgICAgICAgICAgICBjb25zdCBkID0gY3JlYXRlSHRtbEVsZW1lbnQoXCJkaXZcIiwgYywgXCJiYXNlbGF5ZXJjdHJsLWJ0dG5cIik7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpY29uID0gY3JlYXRlSHRtbEVsZW1lbnQoXCJkaXZcIiwgZCwgXCJiYXNlbGF5ZXJjdHJsLWl0ZW1cIik7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzcGFuID0gY3JlYXRlSHRtbEVsZW1lbnQoXCJzcGFuXCIsIGQpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbGFiZWwgPSBpdGVtW1wic2hvcnRMYWJlbFwiXTtcclxuICAgICAgICAgICAgICAgIHNwYW4uaW5uZXJIVE1MID0gbGFiZWw7XHJcbiAgICAgICAgICAgICAgICBkLnRpdGxlID0gbGFiZWw7XHJcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmluZm8oJ2l0ZW0nLCBpdGVtLCBcInVybChcXFwiXCIrIGl0ZW0uaW1nICtcIlxcXCIpXCIpO1xyXG4gICAgICAgICAgICAgICAgaWNvbi5zdHlsZS5iYWNrZ3JvdW5kSW1hZ2UgPSAndXJsKFwiJyArIGl0ZW0uaW1nICsgJ1wiKSc7XHJcbiAgICAgICAgICAgICAgICBkLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoZXZ0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgKHRoaXMuaXNPcGVuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5iYXNlTGF5ZXJJY29uQ2xpY2tlZChldnQsIGl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgIHRoaXMuZG9tLmNsYXNzTGlzdC50b2dnbGUoXCJvcGVuXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICB0aGlzLmlzT3BlbiA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5iYXNlTGF5ZXJEZWZpbml0aW9uID09PSBpdGVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZC5jbGFzc0xpc3QuYWRkKFwiY3VycmVudFwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnZpc2libGVCYXNlTGF5ZXJEZWZpbml0aW9uID09PSBpdGVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZC5jbGFzc0xpc3QuYWRkKFwic2VsZWN0ZWRcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1hcElkMkljb25Ob2RlW2xhYmVsXSA9IGQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgY2xvc2VCdHRuID0gY3JlYXRlSHRtbEVsZW1lbnQoXCJkaXZcIiwgYywgXCJiYXNlbGF5ZXJjdHJsLWNsb3NlLWJ0dG5cIik7XHJcbiAgICAgICAgICAgIGNsb3NlQnR0bi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kb20uY2xhc3NMaXN0LnRvZ2dsZShcIm9wZW5cIik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gYztcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgb25BZGQobWFwOiBMLk1hcCk6IEhUTUxFbGVtZW50IHtcclxuICAgICAgICBpZiAoIXRoaXMuZG9tKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRpdiA9IGNyZWF0ZUh0bWxFbGVtZW50KFwiZGl2XCIsIHVuZGVmaW5lZCwgXCJiYXNlbGF5ZXJjdHJsXCIpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5iYXNlTGF5ZXJEZWZpbml0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kb20uaW5zZXJ0QmVmb3JlKHRoaXMuY3JlYXRlSWNvbnMoKSwgdGhpcy5kb20uZmlyc3RDaGlsZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5kb20gPSBkaXY7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmRvbTtcclxuICAgIH1cclxuXHJcbiAgICBzZXRCYXNlTGF5ZXJzKGJhc2VMYXllcnM6IEJhc2VMYXllckRlZmluaXRpb25bXSwgb3B0aW9ucz86IExheWVyRGVmaW5pdGlvbk9wdGlvbnMpIHtcclxuICAgICAgICB0aGlzLmJhc2VMYXllckRlZmluaXRpb25zID0gYmFzZUxheWVycztcclxuICAgICAgICB0aGlzLmJhc2VMYXllckRlZk9wdGlvbnMgPSBvcHRpb25zO1xyXG4gICAgICAgIC8vIHRoaXMubGFiZWxBdHRyaWJ1dGUgPSBvcHRpb25zPy5sYWJlbEF0dHJpYnV0ZSB8fCAnbGFiZWwnO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5kb20pIHtcclxuICAgICAgICAgICAgdGhpcy5kb20uaW5zZXJ0QmVmb3JlKHRoaXMuY3JlYXRlSWNvbnMoKSwgdGhpcy5kb20uZmlyc3RDaGlsZCk7XHJcbiAgICAgICAgICAgIGNvbnN0IG9wZW5CdHRuID0gY3JlYXRlSHRtbEVsZW1lbnQoXCJkaXZcIiwgdGhpcy5kb20sIFwiYmFzZWxheWVyY3RybC1vcGVuLWJ0dG5cIik7XHJcbiAgICAgICAgICAgIG9wZW5CdHRuLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRvbS5jbGFzc0xpc3QudG9nZ2xlKFwib3BlblwiKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc2VsZWN0QmFzZUxheWVyKHRoaXMuYmFzZUxheWVyRGVmaW5pdGlvbnNbMF0pO1xyXG4gICAgfVxyXG5cclxuICAgIF91cGRhdGVJdGVtSWNvbihiYXNlTGF5ZXI6IEJhc2VMYXllckRlZmluaXRpb24pOiB2b2lkIHtcclxuICAgICAgICAvLyBjb25zb2xlLmVycm9yKFwiX3VwZGF0ZUl0ZW1JY29uIHZpcz1cIiArICh0aGlzLnZpc2libGVCYXNlTGF5ZXJEZWZpbml0aW9uID8gdGhpcy52aXNpYmxlQmFzZUxheWVyRGVmaW5pdGlvbltcInNob3J0TGFiZWxcIl0gOiBcIlwiKSArIFwiICBuZXdCYXNlTD1cIiArIGJhc2VMYXllcltcInNob3J0TGFiZWxcIl0pO1xyXG4gICAgICAgIGlmICghYmFzZUxheWVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuYmFzZUxheWVyRGVmaW5pdGlvbikge1xyXG4gICAgICAgICAgICBjb25zdCBub2RlID0gdGhpcy5tYXBJZDJJY29uTm9kZVt0aGlzLmJhc2VMYXllckRlZmluaXRpb25bXCJzaG9ydExhYmVsXCJdXTtcclxuICAgICAgICAgICAgbm9kZS5jbGFzc0xpc3QucmVtb3ZlKFwiY3VycmVudFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMubWFwSWQySWNvbk5vZGVbYmFzZUxheWVyW1wic2hvcnRMYWJlbFwiXV07XHJcbiAgICAgICAgaWYgKG5vZGUpIHtcclxuICAgICAgICAgICAgbm9kZS5jbGFzc0xpc3QuYWRkKFwiY3VycmVudFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHZpc2libGVOb2RlOiBIVE1MRWxlbWVudDtcclxuICAgICAgICBpZiAodGhpcy52aXNpYmxlQmFzZUxheWVyRGVmaW5pdGlvbikge1xyXG4gICAgICAgICAgICBjb25zb2xlLmluZm8oXCJ2aXMgXCIpO1xyXG4gICAgICAgICAgICBjb25zdCBub2RlID0gdGhpcy5tYXBJZDJJY29uTm9kZVt0aGlzLnZpc2libGVCYXNlTGF5ZXJEZWZpbml0aW9uW1wic2hvcnRMYWJlbFwiXV07XHJcbiAgICAgICAgICAgIG5vZGUuY2xhc3NMaXN0LnJlbW92ZShcInNlbGVjdGVkXCIpO1xyXG4gICAgICAgICAgICBpZiAoYmFzZUxheWVyID09PSB0aGlzLmJhc2VMYXllckRlZmluaXRpb25zWzFdKSB7XHJcbiAgICAgICAgICAgICAgICB2aXNpYmxlTm9kZSA9IHRoaXMubWFwSWQySWNvbk5vZGVbdGhpcy5iYXNlTGF5ZXJEZWZpbml0aW9uc1swXVtcInNob3J0TGFiZWxcIl1dO1xyXG4gICAgICAgICAgICAgICAgLy8gbm9kZS5jbGFzc0xpc3QuYWRkKFwic2VsZWN0ZWRcIik7XHJcbiAgICAgICAgICAgICAgICAvLyBub2RlLnBhcmVudEVsZW1lbnQuaW5cclxuICAgICAgICAgICAgICAgIHRoaXMudmlzaWJsZUJhc2VMYXllckRlZmluaXRpb24gPSB0aGlzLmJhc2VMYXllckRlZmluaXRpb25zWzBdO1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5pbmZvKFwidmlzaWJsZUJhc2VMYXllckRlZmluaXRpb25cIik7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2aXNpYmxlTm9kZSA9IHRoaXMubWFwSWQySWNvbk5vZGVbdGhpcy5iYXNlTGF5ZXJEZWZpbml0aW9uc1sxXVtcInNob3J0TGFiZWxcIl1dO1xyXG4gICAgICAgICAgICAgICAgLy8gbm9kZS5jbGFzc0xpc3QuYWRkKFwic2VsZWN0ZWRcIik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnZpc2libGVCYXNlTGF5ZXJEZWZpbml0aW9uID0gdGhpcy5iYXNlTGF5ZXJEZWZpbml0aW9uc1sxXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHZpc2libGVOb2RlID0gdGhpcy5tYXBJZDJJY29uTm9kZVt0aGlzLmJhc2VMYXllckRlZmluaXRpb25zWzFdW1wic2hvcnRMYWJlbFwiXV07XHJcbiAgICAgICAgICAgIHRoaXMudmlzaWJsZUJhc2VMYXllckRlZmluaXRpb24gPSB0aGlzLmJhc2VMYXllckRlZmluaXRpb25zWzFdO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2aXNpYmxlTm9kZS5jbGFzc0xpc3QuYWRkKFwic2VsZWN0ZWRcIik7XHJcbiAgICAgICAgdmlzaWJsZU5vZGUucGFyZW50RWxlbWVudC5hcHBlbmRDaGlsZCh2aXNpYmxlTm9kZSk7XHJcbiAgICB9XHJcblxyXG4gICAgc2VsZWN0QmFzZUxheWVyKG5ld0Jhc2VMYXllcjogQmFzZUxheWVyRGVmaW5pdGlvbiB8IG51bWJlcik6IHZvaWQge1xyXG4gICAgICAgIGNvbnNvbGUuaW5mbyhcInNlbGVjdEJhc2VMYXllclwiLCB0aGlzLmJhc2VMYXllckRlZmluaXRpb25zLCBuZXdCYXNlTGF5ZXIpO1xyXG4gICAgICAgIC8vIGNvbnN0IGJzbCA9IGJhc2VMYXllci5pbWcgPT09IFwibWFwaWNvbnMvc2F0LnBuZ1wiID8gdGhpcy5iYXNlTGF5ZXJEZWZpbml0aW9uc1swXSA6IHRoaXMuYmFzZUxheWVyRGVmaW5pdGlvbnNbMl07XHJcblxyXG4gICAgICAgIC8vIHRoaXMuX3NlbGVjdEl0ZW1JY29uKHRoaXMuYmFzZUxheWVyRGVmaW5pdGlvbiwgZmFsc2UpO1xyXG4gICAgICAgIGxldCBiYXNlTGF5ZXI6IEJhc2VMYXllckRlZmluaXRpb247XHJcbiAgICAgICAgaWYgKHR5cGVvZiBuZXdCYXNlTGF5ZXIgPT09IFwibnVtYmVyXCIpIHtcclxuICAgICAgICAgICAgYmFzZUxheWVyID0gdGhpcy5iYXNlTGF5ZXJEZWZpbml0aW9uc1swXTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBiYXNlTGF5ZXIgPSBuZXdCYXNlTGF5ZXI7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLl91cGRhdGVJdGVtSWNvbihiYXNlTGF5ZXIpO1xyXG4gICAgICAgIHRoaXMuYmFzZUxheWVyRGVmaW5pdGlvbiA9IGJhc2VMYXllcjtcclxuICAgICAgICBNYXBEaXNwYXRjaGVyLm9uQmFzZUxheWVyU2VsZWN0aW9uLmRpc3BhdGNoKDxhbnk+dGhpcywgYmFzZUxheWVyLmxheWVyKTtcclxuICAgICAgICBNYXBEaXNwYXRjaGVyLm9uQmFzZUxheWVyU2VsZWN0aW9uLmRpc3BhdGNoKDxhbnk+dGhpcywgYmFzZUxheWVyLmxheWVyKTtcclxuICAgIH1cclxuXHJcbiAgICBiYXNlTGF5ZXJJY29uQ2xpY2tlZChldnQ6IE1vdXNlRXZlbnQsIGJhc2VMRGVmOiBCYXNlTGF5ZXJEZWZpbml0aW9uKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKCFiYXNlTERlZi5sYXllcikge1xyXG4gICAgICAgICAgICB0aGlzLmJhc2VMYXllckRlZk9wdGlvbnMuY3JlYXRlTGF5ZXIoYmFzZUxEZWYpLnRoZW4oKGxheWVyKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBiYXNlTERlZi5sYXllciA9IGxheWVyO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zZWxlY3RCYXNlTGF5ZXIoYmFzZUxEZWYpO1xyXG4gICAgICAgIC8vIHRoaXMuZG9tLmNsYXNzTGlzdC50b2dnbGUoXCJvcGVuXCIpO1xyXG4gICAgfVxyXG59XHJcbiIsInJlcXVpcmUoXCJsZWFmbGV0XCIpO1xyXG5yZXF1aXJlKFwiQGdsYXJ0ZWsvbGVhZmxldC5tYXJrZXJjbHVzdGVyXCIpO1xyXG5cclxuaW1wb3J0ICogYXMgTCBmcm9tIFwibGVhZmxldFwiO1xyXG5pbXBvcnQgeyBWaWV3IH0gZnJvbSBcIi4vVmlld0NvbnRyb2xcIjtcclxuaW1wb3J0IHsgTWFwRGlzcGF0Y2hlciB9IGZyb20gXCIuL01hcENvbnRyb2xcIjtcclxuaW1wb3J0IHsgTWFya2VyVmlldyB9IGZyb20gXCIuL01hcmtlckxpc3RWaWV3XCI7XHJcbmltcG9ydCB7IExlYWZsZXRFdmVudCwgTGVhZmxldEV2ZW50SGFuZGxlckZuLCBMZWFmbGV0TW91c2VFdmVudCwgTGVhZmxldE1vdXNlRXZlbnRIYW5kbGVyRm4gfSBmcm9tIFwibGVhZmxldFwiO1xyXG5pbXBvcnQgeyBMYXllckRlc2NyaXB0aW9uIH0gZnJvbSBcIi4uL2NvbmYvTWFwRGVzY3JpcHRpb25cIjtcclxuaW1wb3J0IHsgY3JlYXRlQ1NTU2VsZWN0b3IgfSBmcm9tIFwiLi4vVXRpbFwiO1xyXG4vLyBpbXBvcnQge01hcmtlckNsdXN0ZXJHcm91cH0gZnJvbSBcIkBnbGFydGVrL2xlYWZsZXQubWFya2VyY2x1c3RlclwiO1xyXG5cclxuZnVuY3Rpb24gY3JlYXRlSWNvbihjb2RlOiBudW1iZXIpOiBMLkljb24ge1xyXG4gICAgcmV0dXJuIDxMLkljb24+TC5kaXZJY29uKHsgaHRtbDogJzxpIGNsYXNzPVwiYWZhc1wiPicgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpICsgXCI8L2k+XCIsIGljb25TaXplOiBuZXcgTC5Qb2ludCgyMCwgMjApLCBpY29uQW5jaG9yOiBuZXcgTC5Qb2ludCgxMCwgMTApLCBjbGFzc05hbWU6IFwibWFwRGl2SWNvblwiIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZVNlbGVjdGVkSWNvbihjb2RlOiBudW1iZXIpOiBMLkljb24ge1xyXG4gICAgcmV0dXJuIDxMLkljb24+TC5kaXZJY29uKHsgaHRtbDogJzxpIGNsYXNzPVwiYWZhc1wiPicgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpICsgXCI8L2k+XCIsIGljb25TaXplOiBuZXcgTC5Qb2ludCg0MCwgNDApLCBpY29uQW5jaG9yOiBuZXcgTC5Qb2ludCgyMCwgMjApLCBjbGFzc05hbWU6IFwibWFwRGl2SWNvbkhpZ2hsaWd0ZWRcIiB9KTtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBDYXRlZ29yeSB7XHJcbiAgICBpZDogYW55O1xyXG4gICAgcGFyZW50SWQ6IGFueTtcclxuICAgIGJlemVpY2hudW5nOiBzdHJpbmc7XHJcbiAgICBjaGlsZHM6IENhdGVnb3J5W107XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQ2F0ZWdvcmllTGF5ZXJPcHRpb25zPFQgZXh0ZW5kcyBMLkxhdExuZ0V4cHJlc3Npb24sIE4+IGV4dGVuZHMgTC5NYXJrZXJDbHVzdGVyR3JvdXBPcHRpb25zIHtcclxuICAgIGNhdGVnb3JpZVVybDogc3RyaW5nO1xyXG4gICAgdXJsOiBzdHJpbmc7XHJcbiAgICBzZWxlY3RvcjogQ2F0ZWdvcmllU2VsZWN0b3I8VCwgTj47XHJcbiAgICBwb3B1cEZhY3Rvcnk6IFBvcHVwQ3JlYXRvcjxUPjtcclxufVxyXG5cclxuZXhwb3J0IHR5cGUgUGF0aDxUPiA9IFRbXTtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQ2F0ZWdvcmllU2VsZWN0b3I8VCwgTj4ge1xyXG4gICAgaXNPZkNhdGVnb3J5KGRhdGE6IFQsIGthdElkOiBQYXRoPE4+W10pOiBib29sZWFuO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFBvcHVwQ3JlYXRvcjxUIGV4dGVuZHMgTC5MYXRMbmdFeHByZXNzaW9uPiB7XHJcbiAgICByZW5kZXJEYXRhVmlldyhsYXllcjogSW50ZXJhY3RpdmVMYXllciwgbWFya2VyOiBDYXRlZ29yeU1hcE9iamVjdDxUPik6IEhUTUxFbGVtZW50O1xyXG4gICAgcmVuZGVyTGlzdEl0ZW0obGF5ZXI6IEludGVyYWN0aXZlTGF5ZXIsIG1hcmtlcjogQ2F0ZWdvcnlNYXBPYmplY3Q8VD4pOiBIVE1MRWxlbWVudDtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBDYXRlZ29yeU1hcmtlck9wdGlvbnMgZXh0ZW5kcyBMLk1hcmtlck9wdGlvbnMge1xyXG4gICAgc2VsZWN0SWNvbj86IEwuSWNvbjtcclxuICAgIHN0YW5kYXJkSWNvbj86IEwuSWNvbjtcclxufVxyXG5cclxuLypcclxuZXhwb3J0IGNsYXNzIENhdGVnb3J5UG9wdXA8VCBleHRlbmRzIEwuTGF0TG5nRXhwcmVzc2lvbj4gZXh0ZW5kcyBMLlBvcHVwIHtcclxuICAgIG1hcmtlcjogQ2F0ZWdvcnlNYXJrZXI8VD47XHJcblxyXG4gICAgY29uc3RydWN0b3IobWFya2VyOkNhdGVnb3J5TWFya2VyPFQ+LCBvcHRpb25zOkwuUG9wdXBPcHRpb25zKSB7XHJcbiAgICAgICAgc3VwZXIob3B0aW9ucyk7XHJcbiAgICB9XHJcblxyXG59XHJcbiovXHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIENhdGVnb3J5TWFwT2JqZWN0PFQgZXh0ZW5kcyBMLkxhdExuZ0V4cHJlc3Npb24+IGV4dGVuZHMgTC5MYXllciB7XHJcbiAgICBkYXRhOiBUO1xyXG4gICAgc2VsZWN0ZWQ6IGJvb2xlYW47XHJcblxyXG4gICAgaXNWaXNpYmxlKCk6IGJvb2xlYW47XHJcblxyXG4gICAgc2V0VmlzaWJsZSh2aXNpYmxlOiBib29sZWFuKTogdm9pZDtcclxuXHJcbiAgICBoaWdobGlnaHQoaGlnaGxpZ2h0OiBib29sZWFuKTogdm9pZDtcclxuXHJcbiAgICBnZXRMYXRMbmcoKTogTC5MYXRMbmc7XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBDYXRlZ29yeUNpcmNsZU1hcmtlcjxUIGV4dGVuZHMgTC5MYXRMbmdFeHByZXNzaW9uPiBleHRlbmRzIEwuQ2lyY2xlTWFya2VyIGltcGxlbWVudHMgQ2F0ZWdvcnlNYXBPYmplY3Q8VD4ge1xyXG4gICAgdmlzaWJsZTogYm9vbGVhbiA9IGZhbHNlO1xyXG5cclxuICAgIGRhdGE6IFQ7XHJcbiAgICBwcml2YXRlIF9jbGlja0Nsb3N1cmU6IChldjogYW55KSA9PiB2b2lkO1xyXG4gICAgc2VsZWN0ZWQgPSBmYWxzZTtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnRMYXllcjogQ2F0ZWdvcmllTGF5ZXI8VCwgYW55PiB8IEludGVyYWN0aXZlTGF5ZXIsIGNvb3JkOiBMLkxhdExuZ0V4cHJlc3Npb24sIGRhdGE6IGFueSwgb3B0aW9ucz86IENhdGVnb3J5TWFya2VyT3B0aW9ucykge1xyXG4gICAgICAgIHN1cGVyKGNvb3JkLCBvcHRpb25zKTtcclxuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xyXG4gICAgfVxyXG5cclxuICAgIHNldFZpc2libGUodmlzaWJsZTogYm9vbGVhbikge1xyXG4gICAgICAgIHRoaXMudmlzaWJsZSA9IHZpc2libGU7XHJcbiAgICB9XHJcblxyXG4gICAgaXNWaXNpYmxlKCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnZpc2libGU7XHJcbiAgICB9XHJcblxyXG4gICAgaGlnaGxpZ2h0KGhpZ2hsaWdodDogYm9vbGVhbikge1xyXG4gICAgICAgIGNvbnNvbGUuaW5mbyhgQ2F0ZWdvcnlDaXJjbGVNYXJrZXIuaGlnaGxpZ2h0ICR7aGlnaGxpZ2h0fSAke3RoaXMuZGF0YVtcImlkXCJdfWApO1xyXG5cclxuICAgICAgICBpZiAoaGlnaGxpZ2h0KSB7XHJcbiAgICAgICAgICAgIHRoaXNbXCJmaWxsQ29sb3JcIl0gPSB0aGlzLm9wdGlvbnMuZmlsbENvbG9yIHx8IHRoaXMub3B0aW9ucy5jb2xvcjtcclxuICAgICAgICAgICAgdGhpcy5zZXRTdHlsZSh7IGZpbGxDb2xvcjogXCJyZWRcIiB9KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBmaWxsQ29sb3IgPSB0aGlzW1wiZmlsbENvbG9yXCJdO1xyXG4gICAgICAgICAgICB0aGlzLnNldFN0eWxlKHsgZmlsbENvbG9yOiBmaWxsQ29sb3IgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgQ2F0ZWdvcnlNYXJrZXI8VCBleHRlbmRzIEwuTGF0TG5nRXhwcmVzc2lvbj4gZXh0ZW5kcyBMLk1hcmtlciBpbXBsZW1lbnRzIENhdGVnb3J5TWFwT2JqZWN0PFQ+IHtcclxuICAgIHZpc2libGU6IGJvb2xlYW4gPSBmYWxzZTtcclxuXHJcbiAgICBzdGF0aWMgaWNvbiA9IGNyZWF0ZUljb24oMHhmMDI0KTtcclxuICAgIHN0YXRpYyBzZWxlY3RlZEljb24gPSBjcmVhdGVTZWxlY3RlZEljb24oMHhmMDI0KTtcclxuXHJcbiAgICBwYXJlbnRMYXllcjogQ2F0ZWdvcmllTGF5ZXI8VCwgYW55PiB8IEludGVyYWN0aXZlTGF5ZXI7XHJcbiAgICBkYXRhOiBUO1xyXG4gICAgLy8gcHJpdmF0ZSBfY2xpY2tDbG9zdXJlOiAoZXY6IGFueSkgPT4gdm9pZDtcclxuICAgIHNlbGVjdGVkID0gZmFsc2U7XHJcbiAgICBwcml2YXRlIF9pY29uOiBIVE1MSW1hZ2VFbGVtZW50O1xyXG4gICAgLy8gaWNvbjpMLkljb247XHJcblxyXG4gICAgY29uc3RydWN0b3IocGFyZW50TGF5ZXI6IENhdGVnb3JpZUxheWVyPFQsIGFueT4gfCBJbnRlcmFjdGl2ZUxheWVyLCBjb29yZDogTC5MYXRMbmdFeHByZXNzaW9uLCBkYXRhOiBhbnksIG9wdGlvbnM/OiBDYXRlZ29yeU1hcmtlck9wdGlvbnMpIHtcclxuICAgICAgICBzdXBlcihjb29yZCwgb3B0aW9ucyk7XHJcbiAgICAgICAgLy8gaWYgKCF0aGlzLmdldExhdExuZygpKSB7XHJcbiAgICAgICAgLy8gICAgIGRlYnVnZ2VyO1xyXG4gICAgICAgIC8vIH1cclxuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xyXG4gICAgICAgIHRoaXMucGFyZW50TGF5ZXIgPSBwYXJlbnRMYXllcjtcclxuXHJcbiAgICAgICAgaWYgKCFvcHRpb25zIHx8ICFvcHRpb25zLmljb24pIHtcclxuICAgICAgICAgICAgdGhpcy5vcHRpb25zW1wic3RhbmRhcmRJY29uXCJdID0gQ2F0ZWdvcnlNYXJrZXIuaWNvbjtcclxuICAgICAgICAgICAgdGhpcy5zZXRJY29uKENhdGVnb3J5TWFya2VyLmljb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIW9wdGlvbnMgfHwgIW9wdGlvbnMuc2VsZWN0SWNvbikge1xyXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNbXCJzZWxlY3RJY29uXCJdID0gQ2F0ZWdvcnlNYXJrZXIuc2VsZWN0ZWRJY29uO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBzZXRWaXNpYmxlKHZpc2libGU6IGJvb2xlYW4pIHtcclxuICAgICAgICB0aGlzLnZpc2libGUgPSB2aXNpYmxlO1xyXG4gICAgfVxyXG5cclxuICAgIGlzVmlzaWJsZSgpOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gdGhpcy52aXNpYmxlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGhpZ2hMaWdodChoaWdobGlnaHQ6IGJvb2xlYW4pIHtcclxuICAgIC8vICAgICBjb25zb2xlLmluZm8oJ0NhdGVnb3J5TWFya2VyLmhpZ2hsaWdodCcsIHRoaXMuZGF0YVsnaWQnXSwgaGlnaGxpZ2h0KTtcclxuICAgIC8vICAgICB0aGlzLnNlbGVjdGVkID0gaGlnaGxpZ2h0O1xyXG4gICAgLy8gICAgIHRyeSB7XHJcbiAgICAvLyAgICAgICAgIGlmIChoaWdobGlnaHQpIHtcclxuICAgIC8vICAgICAgICAgICAgICg8SFRNTEVsZW1lbnQ+KDxhbnk+dGhpcykuX2ljb24pLmNsYXNzTGlzdC5hZGQoJ2hpZ2hsaWdodCcpO1xyXG4gICAgLy8gICAgICAgICB9XHJcbiAgICAvLyAgICAgICAgIGVsc2Uge1xyXG4gICAgLy8gICAgICAgICAgICAgKDxIVE1MRWxlbWVudD4oPGFueT50aGlzKS5faWNvbikuY2xhc3NMaXN0LnJlbW92ZSgnaGlnaGxpZ2h0Jyk7XHJcbiAgICAvLyAgICAgICAgIH1cclxuICAgIC8vICAgICB9IGNhdGNoIChleCkge1xyXG4gICAgLy8gICAgICAgICAvLyBjb25zb2xlLmVycm9yKGV4KTtcclxuICAgIC8vICAgICB9XHJcbiAgICAvLyB9XHJcbiAgICBoaWdobGlnaHQoaGlnaGxpZ2h0OiBib29sZWFuKSB7XHJcbiAgICAgICAgY29uc29sZS5pbmZvKFwiQ2F0ZWdvcnlNYXJrZXIuaGlnaGxpZ2h0XCIsIHRoaXMuZGF0YVtcImlkXCJdLCBoaWdobGlnaHQpO1xyXG4gICAgICAgIHRoaXMuc2VsZWN0ZWQgPSBoaWdobGlnaHQ7XHJcbiAgICAgICAgaWYgKHRoaXMuX2ljb24pIHtcclxuICAgICAgICAgICAgaWYgKGhpZ2hsaWdodCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faWNvbi5jbGFzc0xpc3QuYWRkKFwiaWNvbi1oaWdobGlnaHRlZFwiKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2ljb24uY2xhc3NMaXN0LnJlbW92ZShcImljb24taGlnaGxpZ2h0ZWRcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc29sZS5pbmZvKFwidGhpc1wiLCB0aGlzKTtcclxuICAgICAgICAvLyBpZiAoaGlnaGxpZ2h0KSB7XHJcbiAgICAgICAgLy8gICAgIHRoaXMuc2V0SWNvbigoPENhdGVnb3J5TWFya2VyT3B0aW9ucz50aGlzLm9wdGlvbnMpLnNlbGVjdEljb24pO1xyXG4gICAgICAgIC8vIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gICAgIHRoaXMuc2V0SWNvbigoPENhdGVnb3J5TWFya2VyT3B0aW9ucz50aGlzLm9wdGlvbnMpLnN0YW5kYXJkSWNvbik7XHJcbiAgICAgICAgLy8gfVxyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEZlYXR1cmVDbGlja0V2ZW50IGV4dGVuZHMgTGVhZmxldE1vdXNlRXZlbnQge1xyXG4gICAgbGF5ZXI6IEwuTGF5ZXI7XHJcbiAgICBmZWF0dXJlOiBDYXRlZ29yeU1hcE9iamVjdDxhbnk+O1xyXG59XHJcbmV4cG9ydCB0eXBlIEZlYXR1cmVDbGlja0V2ZW50SGFuZGxlckZuID0gKGV2ZW50OiBGZWF0dXJlQ2xpY2tFdmVudCkgPT4gdm9pZDtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgSW50ZXJhY3RpdmVMYXllciB7XHJcbiAgICBtYXA/OiBMLk1hcDtcclxuICAgIHBvcHVwRmFjdG9yeT86IFBvcHVwQ3JlYXRvcjxhbnk+O1xyXG5cclxuICAgIGhpZ2hsaWdodE1hcmtlcjogKG1hcmtlcjogQ2F0ZWdvcnlNYXBPYmplY3Q8YW55PiwgaGlnaGxpZ2h0OiBib29sZWFuKSA9PiB2b2lkO1xyXG4gICAgbWFwSXRlbUNsaWNrZWQ6IChtYXJrZXI6IENhdGVnb3J5TWFwT2JqZWN0PGFueT4sIGV2OiBMLkxlYWZsZXRFdmVudCkgPT4gdm9pZDtcclxuXHJcbiAgICAvLyBvbjogKHR5cGU6ICdpdGVtY2xpY2tlZCcsIGZuOiBMZWFmbGV0TW91c2VFdmVudEhhbmRsZXJGbiwgY29udGV4dD86IGFueSk9PiB0aGlzO1xyXG4gICAgb24odHlwZTogXCJmZWF0dXJlY2xpY2tlZFwiLCBmbjogRmVhdHVyZUNsaWNrRXZlbnRIYW5kbGVyRm4gfCBMZWFmbGV0RXZlbnRIYW5kbGVyRm4sIGNvbnRleHQ/OiBhbnkpOiB0aGlzO1xyXG4gICAgb24odHlwZTogc3RyaW5nLCBmbjogTGVhZmxldEV2ZW50SGFuZGxlckZuIHwgRmVhdHVyZUNsaWNrRXZlbnRIYW5kbGVyRm4sIGNvbnRleHQ/OiBhbnkpOiB0aGlzO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEdlb2pzb25MYXllck9wdGlvbnMgZXh0ZW5kcyBMLk1hcmtlckNsdXN0ZXJHcm91cE9wdGlvbnMge1xyXG4gICAgbGF5ZXJEZXNjcmlwdGlvbjogTGF5ZXJEZXNjcmlwdGlvbjtcclxufVxyXG5cclxudmFyIG5yQ1NTU2VsZWN0b3IgPSAwO1xyXG5leHBvcnQgY2xhc3MgR2VvanNvbkxheWVyIGV4dGVuZHMgTC5NYXJrZXJDbHVzdGVyR3JvdXAgaW1wbGVtZW50cyBJbnRlcmFjdGl2ZUxheWVyIHtcclxuICAgIHNlbGVjdGVkTWFya2VyOiBDYXRlZ29yeU1hcE9iamVjdDxhbnk+O1xyXG4gICAgbGF5ZXJEZXNjcmlwdGlvbjogTGF5ZXJEZXNjcmlwdGlvbjtcclxuXHJcbiAgICBtYXJrZXJDbGFzczogc3RyaW5nO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnM/OiBHZW9qc29uTGF5ZXJPcHRpb25zKSB7XHJcbiAgICAgICAgc3VwZXIob3B0aW9ucyk7XHJcbiAgICAgICAgdGhpcy5sYXllckRlc2NyaXB0aW9uID0gb3B0aW9ucy5sYXllckRlc2NyaXB0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIGhpZ2hsaWdodE1hcmtlcihtYXJrZXI6IENhdGVnb3J5TWFwT2JqZWN0PGFueT4sIGhpZ2hsaWdodDogYm9vbGVhbikge1xyXG4gICAgICAgIG1hcmtlci5oaWdobGlnaHQoaGlnaGxpZ2h0KTtcclxuICAgIH1cclxuXHJcbiAgICBtYXBJdGVtQ2xpY2tlZChtYXJrZXI6IENhdGVnb3J5TWFwT2JqZWN0PGFueT4sIGV2OiBMLkxlYWZsZXRNb3VzZUV2ZW50KTogdm9pZCB7XHJcbiAgICAgICAgLy8gTWFwRGlzcGF0Y2hlci5vbk1hcEZlYXR1cmVDbGljay5kaXNwYXRjaChtYXJrZXIsIHsuLi5ldiwgbGF5ZXI6dGhpcywgZmVhdHVyZTptYXJrZXJ9KTtcclxuICAgICAgICBNYXBEaXNwYXRjaGVyLm9uTWFwRmVhdHVyZUNsaWNrLmRpc3BhdGNoKG1hcmtlciwgZXYpO1xyXG4gICAgfVxyXG5cclxuICAgIHJlbmRlckRhdGEobWFya2VyOiBDYXRlZ29yeU1hcE9iamVjdDxhbnk+KTogVmlldyB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBNYXJrZXJWaWV3KHRoaXMsIG1hcmtlcik7XHJcbiAgICB9XHJcblxyXG4gICAgX2RlZmF1bHRJY29uQ3JlYXRlRnVuY3Rpb24oY2x1c3RlcjogYW55KSB7XHJcbiAgICAgICAgY29uc3QgY2hpbGRDb3VudCA9IGNsdXN0ZXIuZ2V0Q2hpbGRDb3VudCgpO1xyXG5cclxuICAgICAgICAvLyB2YXIgYyA9IFwiIG1hcmtlci1jbHVzdGVyLVwiO1xyXG4gICAgICAgIC8vIGlmIChjaGlsZENvdW50IDwgMTApIHtcclxuICAgICAgICAvLyAgICAgYyArPSBcInNtYWxsXCI7XHJcbiAgICAgICAgLy8gfSBlbHNlIGlmIChjaGlsZENvdW50IDwgMTAwKSB7XHJcbiAgICAgICAgLy8gICAgIGMgKz0gXCJtZWRpdW1cIjtcclxuICAgICAgICAvLyB9IGVsc2Uge1xyXG4gICAgICAgIC8vICAgICBjICs9IFwibGFyZ2VcIjtcclxuICAgICAgICAvLyB9XHJcblxyXG4gICAgICAgIGlmICghdGhpcy5tYXJrZXJDbGFzcykge1xyXG4gICAgICAgICAgICBsZXQgYzogc3RyaW5nO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMubGF5ZXJEZXNjcmlwdGlvbi5pY29uPy5pY29uVXJsKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBjID0gXCJjbHVzdGVyX1wiICsgdGhpcy5sYXllckRlc2NyaXB0aW9uLmxhYmVsLnJlcGxhY2UoL1teXFx3XS9nLCBcIlwiKTtcclxuICAgICAgICAgICAgICAgIGMgPSBcImNsdXN0ZXJfXCIgKyBuckNTU1NlbGVjdG9yKys7XHJcbiAgICAgICAgICAgICAgICBjcmVhdGVDU1NTZWxlY3RvcihcIi5cIiArIGMsIGBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoXCIke3RoaXMubGF5ZXJEZXNjcmlwdGlvbi5pY29uLmljb25Vcmx9XCIpO2ApO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMubGF5ZXJEZXNjcmlwdGlvbi50aGVtZT8uaWNvbikge1xyXG4gICAgICAgICAgICAgICAgLy8gYyA9IFwiY2x1c3Rlcl9cIiArIHRoaXMubGF5ZXJEZXNjcmlwdGlvbi50aGVtZS50aGVtYS5yZXBsYWNlKFwiIFwiLCBcIlwiKTtcclxuICAgICAgICAgICAgICAgIGMgPSBcImNsdXN0ZXJfXCIgKyBuckNTU1NlbGVjdG9yKys7XHJcbiAgICAgICAgICAgICAgICBjcmVhdGVDU1NTZWxlY3RvcihcIi5cIiArIGMsIGBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoXCIke3RoaXMubGF5ZXJEZXNjcmlwdGlvbi50aGVtZS5pY29ufVwiKTtgKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmxheWVyRGVzY3JpcHRpb24uY2xhc3Nlcykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubGF5ZXJEZXNjcmlwdGlvbi50aGVtZT8uaWNvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGMgPSBcImNsdXN0ZXJfXCIgKyBuckNTU1NlbGVjdG9yKys7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYyA9IFwiY2x1c3Rlcl9cIiArIHRoaXMubGF5ZXJEZXNjcmlwdGlvbi50aGVtZS50aGVtYS5yZXBsYWNlKFwiIFwiLCBcIlwiKTtcclxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVDU1NTZWxlY3RvcihcIi5cIiArIGMsIGBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoXCIke3RoaXMubGF5ZXJEZXNjcmlwdGlvbi50aGVtZS5pY29ufVwiKTtgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoYykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tYXJrZXJDbGFzcyA9IFwibWFya2VyLWNsdXN0ZXIgbWFya2VyLWNsdXN0ZXItaWNvbiBtYXJrZXItY2x1c3Rlci1zbWFsbCBcIiArIGM7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1hcmtlckNsYXNzID0gXCJtYXJrZXItY2x1c3RlciBtYXJrZXItY2x1c3Rlci1zbWFsbFwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgTC5EaXZJY29uKHsgaHRtbDogXCI8ZGl2PjxzcGFuPlwiICsgY2hpbGRDb3VudCArIFwiPC9zcGFuPjwvZGl2PlwiLCBjbGFzc05hbWU6IHRoaXMubWFya2VyQ2xhc3MsIGljb25TaXplOiBuZXcgTC5Qb2ludCg0MCwgNDApIH0pO1xyXG4gICAgICAgIC8vIHJldHVybiBuZXcgTC5EaXZJY29uKHsgaHRtbDogXCI8ZGl2PjxzcGFuPlwiICsgY2hpbGRDb3VudCArIFwiPC9zcGFuPjwvZGl2PlwiLCBjbGFzc05hbWU6IFwibWFya2VyLWNsdXN0ZXIgbWFya2VyLWNsdXN0ZXItc21hbGwgXCIgKyBjLCBpY29uU2l6ZTogbmV3IEwuUG9pbnQoNDAsIDQwKSB9KTtcclxuICAgICAgICAvLyByZXR1cm4gbmV3IEwuRGl2SWNvbih7IGh0bWw6IFwiPGRpdj48c3Bhbj5cIiArIGNoaWxkQ291bnQgKyBcIjwvc3Bhbj48L2Rpdj5cIiwgY2xhc3NOYW1lOiBcIm1hcmtlci1jbHVzdGVyLXNtYWxsXCIsIGljb25TaXplOiBuZXcgTC5Qb2ludCg0MCwgNDApIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIG9uMSh0eXBlOiAnYmxsJywgZm46IEwuTGVhZmxldEV2ZW50SGFuZGxlckZuLCBjb250ZXh0PzogYW55KTogdGhpcyB7XHJcbiAgICAvLyAgICAgcmV0dXJuIHN1cGVyLm9uKHR5cGUsIGZuLCBjb250ZXh0KTtcclxuICAgIC8vIH1cclxufVxyXG5cclxuLy8gZXhwb3J0IGNsYXNzIENhdGVnb3JpZUxheWVyPFQgZXh0ZW5kcyBMLkxhdExuZ0V4cHJlc3Npb24+IGV4dGVuZHMgTC5MYXllckdyb3VwIHtcclxuZXhwb3J0IGNsYXNzIENhdGVnb3JpZUxheWVyPFQgZXh0ZW5kcyBMLkxhdExuZ0V4cHJlc3Npb24sIE4+IGV4dGVuZHMgTC5NYXJrZXJDbHVzdGVyR3JvdXAgaW1wbGVtZW50cyBJbnRlcmFjdGl2ZUxheWVyIHtcclxuICAgIGNhdGVnb3JpZVVybDogc3RyaW5nO1xyXG4gICAgdXJsOiBzdHJpbmc7XHJcblxyXG4gICAgY2F0ZWdvcmllczogQ2F0ZWdvcnlbXTtcclxuXHJcbiAgICBzZWxlY3RlZENhdGVnb3JpZXM6IFBhdGg8Tj5bXTtcclxuXHJcbiAgICBkYXRhOiBUO1xyXG4gICAgc2VsZWN0b3I6IENhdGVnb3JpZVNlbGVjdG9yPFQsIE4+O1xyXG4gICAgcG9wdXBGYWN0b3J5OiBQb3B1cENyZWF0b3I8VD47XHJcblxyXG4gICAgbWFya2VyTWFwOiB7IFtpZDogbnVtYmVyXTogQ2F0ZWdvcnlNYXBPYmplY3Q8VD4gfSA9IHt9O1xyXG4gICAgbWFya2VyczogQ2F0ZWdvcnlNYXBPYmplY3Q8VD5bXSA9IFtdO1xyXG4gICAgLy8gc2VsZWN0ZWRNYXJrZXI6IENhdGVnb3J5TWFwT2JqZWN0PFQ+O1xyXG4gICAgZm91bmRNYXJrZXJzOiBDYXRlZ29yeU1hcE9iamVjdDxUPltdO1xyXG4gICAgbWFwOiBMLk1hcDtcclxuICAgIGVucXVldWVTcGlkZXJmeTogYm9vbGVhbjtcclxuXHJcbiAgICAvL1xyXG4gICAgc2VsZWN0ZWRNYXJrZXI6IENhdGVnb3J5TWFwT2JqZWN0PFQ+O1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnM/OiBDYXRlZ29yaWVMYXllck9wdGlvbnM8VCwgTj4pIHtcclxuICAgICAgICBzdXBlcihvcHRpb25zKTtcclxuICAgICAgICB0aGlzLmNhdGVnb3JpZVVybCA9IG9wdGlvbnMuY2F0ZWdvcmllVXJsO1xyXG4gICAgICAgIHRoaXMudXJsID0gb3B0aW9ucy51cmw7XHJcbiAgICAgICAgdGhpcy5zZWxlY3RvciA9IG9wdGlvbnMuc2VsZWN0b3I7XHJcbiAgICAgICAgdGhpcy5wb3B1cEZhY3RvcnkgPSBvcHRpb25zLnBvcHVwRmFjdG9yeTtcclxuICAgIH1cclxuXHJcbiAgICBsb2FkQ2F0ZWdvcmllcygpIHtcclxuICAgICAgICB3aW5kb3cuZmV0Y2godGhpcy5jYXRlZ29yaWVVcmwpLnRoZW4oKHJlc3BvbnNlKSA9PiB7XHJcbiAgICAgICAgICAgIHJlc3BvbnNlLmpzb24oKS50aGVuKChkYXRhKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNhdGVnb3JpZXMgPSBkYXRhO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5maXJlKFwiQ2F0ZWdvcmllc0xvYWRlZFwiKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xvYWREYXRhKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcHJpdmF0ZSBfbG9hZERhdGEoKSB7XHJcbiAgICAgICAgd2luZG93LmZldGNoKHRoaXMudXJsKS50aGVuKChyZXNwb25zZSkgPT4ge1xyXG4gICAgICAgICAgICByZXNwb25zZS5qc29uKCkudGhlbigoZGF0YSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1hcmtlciA9IG5ldyBDYXRlZ29yeU1hcmtlcih0aGlzLCB7IGxhdDogZGF0YVtpXS5sYXQsIGxuZzogZGF0YVtpXS5sbmcgfSwgZGF0YVtpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXJrZXJzLnB1c2gobWFya2VyKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hcmtlck1hcFtkYXRhW2ldLmlkXSA9IG1hcmtlcjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZSgpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBvbkFkZChtYXA6IEwuTWFwKTogdGhpcyB7XHJcbiAgICAgICAgY29uc29sZS5pbmZvKFwibzBuQWRkXCIsIHRoaXMpO1xyXG4gICAgICAgIHN1cGVyLm9uQWRkKG1hcCk7XHJcbiAgICAgICAgdGhpcy5tYXAgPSBtYXA7XHJcbiAgICAgICAgbWFwLm9uKFwiem9vbWVuZFwiLCAoZXZ0KSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuZW5xdWV1ZVNwaWRlcmZ5ID0gdHJ1ZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIG9uUmVtb3ZlKG1hcDogTC5NYXApOiB0aGlzIHtcclxuICAgICAgICBzdXBlci5vblJlbW92ZShtYXApO1xyXG4gICAgICAgIHRoaXMubWFwID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgX2ZpbmRNYXJrZXIodmFsdWU6IGFueSwgcHJvcDogc3RyaW5nKSB7XHJcbiAgICAgICAgY29uc3QgbWFya2VycyA9IHRoaXMubWFya2VycztcclxuICAgICAgICBmb3IgKGxldCBpID0gMCwgY291bnQgPSBtYXJrZXJzLmxlbmd0aDsgaSA8IGNvdW50OyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgbWFya2VyID0gbWFya2Vyc1tpXTtcclxuICAgICAgICAgICAgaWYgKG1hcmtlci5kYXRhW3Byb3BdID09PSB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hcmtlcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBhc3luYyBmaW5kTWFya2VycyhhdHQ6IHN0cmluZywgdmFsdWU6IGFueSk6IFByb21pc2U8Q2F0ZWdvcnlNYXBPYmplY3Q8VD5bXT4ge1xyXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgd2luZG93LmZldGNoKHRoaXMudXJsICsgXCIvc2VhcmNoP1wiICsgYXR0ICsgXCI9XCIgKyB2YWx1ZSk7XHJcbiAgICAgICAgY29uc3QgZGF0YTogbnVtYmVyW10gPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0OiBDYXRlZ29yeU1hcE9iamVjdDxUPltdID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1hcmtlciA9IHRoaXMubWFya2VyTWFwW2RhdGFbaV1dO1xyXG4gICAgICAgICAgICBpZiAobWFya2VyKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChtYXJrZXIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFtYXJrZXIuaXNWaXNpYmxlKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZm91bmRNYXJrZXJzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZm91bmRNYXJrZXJzID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZm91bmRNYXJrZXJzLnB1c2gobWFya2VyKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZExheWVyKG1hcmtlcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICByZW1vdmVTZWFyY2hSZXN1bHRzKCkge1xyXG4gICAgICAgIGNvbnNvbGUuaW5mbyhcInJlbW92ZVNlYXJjaFJlc3VsdHNcIik7XHJcbiAgICAgICAgaWYgKHRoaXMuZm91bmRNYXJrZXJzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZm91bmRNYXJrZXJzLmZvckVhY2goKGl0ZW0pID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlTGF5ZXIoaXRlbSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLmZvdW5kTWFya2VycyA9IHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gbWFwSXRlbUNsaWNrZWRPcmcobWFya2VyOiBDYXRlZ29yeU1hcE9iamVjdDxUPiwgZXY6IEwuTGVhZmxldE1vdXNlRXZlbnQpOiB2b2lkIHtcclxuICAgIC8vICAgICBjb25zb2xlLmluZm8oXCJtYXBJdGVtQ2xpY2tlZFwiLCBtYXJrZXIuZGF0YVsnaWQnXSwgZXYpO1xyXG4gICAgLy8gICAgIE1hcERpc3BhdGNoZXIub25NYXBGZWF0dXJlQ2xpY2suZGlzcGF0Y2gobWFya2VyLCBldik7XHJcbiAgICAvLyB9XHJcblxyXG4gICAgbWFwSXRlbUNsaWNrZWQobWFya2VyOiBDYXRlZ29yeU1hcE9iamVjdDxUPiwgZXY6IEwuTGVhZmxldE1vdXNlRXZlbnQpOiB2b2lkIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKFwibWFwSXRlbUNsaWNrZWRcIiwgbWFya2VyLCBldik7XHJcblxyXG4gICAgICAgIGlmIChtYXJrZXIuc2VsZWN0ZWQpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMubWFwLmdldFpvb20oKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbGF0ID0gKDxhbnk+bWFya2VyLmRhdGEpLmxhdDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGxuZyA9ICg8YW55Pm1hcmtlci5kYXRhKS5sbmc7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjID0gbmV3IEwuTGF0TG5nKGxhdCwgbG5nKTtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXAuc2V0VmlldyhjLCAxOCk7XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5vbmNlKFwiYW5pbWF0aW9uZW5kXCIsIChldnQpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmluZm8oYGFuaW1hdGlvbmVuZD0+bWFwLnNldFZpZXcoJHtjfSlgKTtcclxuICAgICAgICAgICAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWFwLnNldFZpZXcoYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIE1hcERpc3BhdGNoZXIub25NYXBGZWF0dXJlQ2xpY2suZGlzcGF0Y2gobWFya2VyLCB7Li4uZXYsIGxheWVyOnRoaXMsIGZlYXR1cmU6bWFya2VyfSk7XHJcbiAgICAgICAgICAgICAgICAvLyBNYXBEaXNwYXRjaGVyLm9uSXRlbU9uTWFwVW5zZWxlY3Rpb24uZGlzcGF0Y2godGhpcywgbWFya2VyKTtcclxuICAgICAgICAgICAgICAgIE1hcERpc3BhdGNoZXIub25NYXBGZWF0dXJlQ2xpY2suZGlzcGF0Y2gobWFya2VyLCBldik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBNYXBEaXNwYXRjaGVyLm9uSXRlbU9uTWFwU2VsZWN0aW9uLmRpc3BhdGNoKHRoaXMsIG1hcmtlcik7XHJcbiAgICAgICAgICAgIC8vIE1hcERpc3BhdGNoZXIub25NYXBGZWF0dXJlQ2xpY2suZGlzcGF0Y2gobWFya2VyLCB7Li4uZXYsIGxheWVyOnRoaXMsIGZlYXR1cmU6bWFya2VyfSk7XHJcbiAgICAgICAgICAgIE1hcERpc3BhdGNoZXIub25NYXBGZWF0dXJlQ2xpY2suZGlzcGF0Y2gobWFya2VyLCBldik7XHJcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRNYXJrZXIgPSBtYXJrZXI7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGhpZ2hsaWdodE1hcmtlcihtYXJrZXI6IENhdGVnb3J5TWFya2VyPFQ+LCBoaWdobGlnaHQ6IGJvb2xlYW4pIHtcclxuICAgICAgICBjb25zb2xlLmluZm8oYENhdGVnb3JpZUxheWVyLmhpZ2hsaWdodE1hcmtlciAke21hcmtlci5kYXRhW1wiaWRcIl19ICR7aGlnaGxpZ2h0fWApO1xyXG5cclxuICAgICAgICBpZiAoaGlnaGxpZ2h0KSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlTGF5ZXIobWFya2VyKTtcclxuICAgICAgICAgICAgY29uc29sZS5pbmZvKFwibWFya2VyLm9wdGlvbnMucGFuZT1cIiArIG1hcmtlci5vcHRpb25zLnBhbmUpO1xyXG4gICAgICAgICAgICBtYXJrZXIub3B0aW9uc1tcIm9sZFBhbmVcIl0gPSBtYXJrZXIub3B0aW9ucy5wYW5lO1xyXG4gICAgICAgICAgICBtYXJrZXIub3B0aW9ucy5wYW5lID0gXCJoaWdobGlnaHRQYW5lXCI7XHJcbiAgICAgICAgICAgIHRoaXMuX21hcC5hZGRMYXllcihtYXJrZXIpO1xyXG4gICAgICAgICAgICBtYXJrZXIuaGlnaGxpZ2h0KGhpZ2hsaWdodCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fbWFwLnJlbW92ZUxheWVyKG1hcmtlcik7XHJcbiAgICAgICAgICAgIGNvbnN0IG9sZFBhbmUgPSBtYXJrZXIub3B0aW9uc1tcIm9sZFBhbmVcIl07XHJcbiAgICAgICAgICAgIGlmIChvbGRQYW5lKSB7XHJcbiAgICAgICAgICAgICAgICBtYXJrZXIub3B0aW9ucy5wYW5lID0gb2xkUGFuZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmFkZExheWVyKG1hcmtlcik7XHJcbiAgICAgICAgICAgIG1hcmtlci5oaWdobGlnaHQoaGlnaGxpZ2h0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZmluZE1hcmtlcih2YWx1ZTogYW55LCBwcm9wOiBzdHJpbmcpOiBDYXRlZ29yeU1hcE9iamVjdDxUPiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbmRNYXJrZXIodmFsdWUsIHByb3ApO1xyXG4gICAgfVxyXG5cclxuICAgIHNob3dNYXJrZXIodmFsdWU6IGFueSwgcHJvcDogc3RyaW5nKTogQ2F0ZWdvcnlNYXBPYmplY3Q8VD4ge1xyXG4gICAgICAgIGNvbnNvbGUuaW5mbyhcInNob3dNYXJrZXJcIik7XHJcbiAgICAgICAgY29uc3QgbWFya2VyID0gdGhpcy5fZmluZE1hcmtlcih2YWx1ZSwgcHJvcCk7XHJcbiAgICAgICAgaWYgKG1hcmtlcikge1xyXG4gICAgICAgICAgICBpZiAoIW1hcmtlci5pc1Zpc2libGUoKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRMYXllcihtYXJrZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9tYXAuZ2V0Wm9vbSgpIDwgMTIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX21hcC5zZXRab29tQXJvdW5kKG1hcmtlci5nZXRMYXRMbmcoKSwgMTIpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbWFwLnBhblRvKG1hcmtlci5nZXRMYXRMbmcoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG1hcmtlcjtcclxuICAgIH1cclxuXHJcbiAgICByZW5kZXJEYXRhKG1hcmtlcjogQ2F0ZWdvcnlNYXBPYmplY3Q8VD4pOiBWaWV3IHtcclxuICAgICAgICByZXR1cm4gbmV3IE1hcmtlclZpZXcodGhpcywgbWFya2VyKTtcclxuICAgIH1cclxuXHJcbiAgICBnZXRJdGVtcyhwYXRoOiBQYXRoPGFueT4pOiBDYXRlZ29yeU1hcE9iamVjdDxhbnk+W10ge1xyXG4gICAgICAgIGNvbnNvbGUuaW5mbyhcIl91cGRhdGVcIik7XHJcbiAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSB0aGlzLnNlbGVjdG9yO1xyXG4gICAgICAgIGNvbnN0IG1hcmtlcnMgPSB0aGlzLm1hcmtlcnM7XHJcblxyXG4gICAgICAgIGNvbnN0IHJlc3VsdHM6IENhdGVnb3J5TWFwT2JqZWN0PFQ+W10gPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMCwgY291bnQgPSBtYXJrZXJzLmxlbmd0aDsgaSA8IGNvdW50OyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgbWFya2VyID0gbWFya2Vyc1tpXTtcclxuXHJcbiAgICAgICAgICAgIGlmIChzZWxlY3Rvci5pc09mQ2F0ZWdvcnkobWFya2VyLmRhdGEsIFtwYXRoXSkpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChtYXJrZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHRzO1xyXG4gICAgfVxyXG5cclxuICAgIF91cGRhdGUoKSB7XHJcbiAgICAgICAgY29uc29sZS5pbmZvKFwiX3VwZGF0ZVwiKTtcclxuICAgICAgICBjb25zdCBzZWxlY3RvciA9IHRoaXMuc2VsZWN0b3I7XHJcbiAgICAgICAgY29uc3QgbWFya2VycyA9IHRoaXMubWFya2VycztcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRDYXRlZ29yaWVzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdGVkQ2F0cyA9IHRoaXMuc2VsZWN0ZWRDYXRlZ29yaWVzO1xyXG4gICAgICAgICAgICAvLyBsZXQgcyA9IFwiXFxuXCI7XHJcbiAgICAgICAgICAgIC8vIGZvciAobGV0IGk9MDsgaTxzZWxlY3RlZENhdHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgLy8gICAgIHMgKz0gaS50b1N0cmluZygpK1wiXFx0XCIrc2VsZWN0ZWRDYXRzW2ldK1wiXFxuXCI7XHJcbiAgICAgICAgICAgIC8vIH1cclxuICAgICAgICAgICAgLy8gY29uc29sZS5pbmZvKFwiX2NhdGVnb3JpZVNlbGVjdGVkXCIsIHMsIFwibWFya2Vycy5sZW5ndGg9XCIrbWFya2Vycy5sZW5ndGgpO1xyXG5cclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGNvdW50ID0gbWFya2Vycy5sZW5ndGg7IGkgPCBjb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBtYXJrZXIgPSBtYXJrZXJzW2ldO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rvci5pc09mQ2F0ZWdvcnkobWFya2VyLmRhdGEsIHNlbGVjdGVkQ2F0cykpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIW1hcmtlci5pc1Zpc2libGUoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmluZm8obWFya2VyLmRhdGFbXCJpZFwiXSwgc2VsZWN0b3IuaXNPZkNhdGVnb3J5KG1hcmtlci5kYXRhLCB0aGlzLnNlbGVjdGVkQ2F0ZWdvcmllcykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZExheWVyKG1hcmtlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcmtlci5zZXRWaXNpYmxlKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hcmtlci5pc1Zpc2libGUoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmluZm8obWFya2VyLmRhdGFbXCJpZFwiXSwgc2VsZWN0b3IuaXNPZkNhdGVnb3J5KG1hcmtlci5kYXRhLCB0aGlzLnNlbGVjdGVkQ2F0ZWdvcmllcykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUxheWVyKG1hcmtlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcmtlci5zZXRWaXNpYmxlKGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgY291bnQgPSBtYXJrZXJzLmxlbmd0aDsgaSA8IGNvdW50OyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG1hcmtlciA9IG1hcmtlcnNbaV07XHJcbiAgICAgICAgICAgICAgICBpZiAobWFya2VyLmlzVmlzaWJsZSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVMYXllcihtYXJrZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIG1hcmtlci5zZXRWaXNpYmxlKGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBzZXRLYXRlZ29yaWVzKGlkczogUGF0aDxOPltdKSB7XHJcbiAgICAgICAgdGhpcy5zZWxlY3RlZENhdGVnb3JpZXMgPSBpZHM7XHJcbiAgICAgICAgdGhpcy5fdXBkYXRlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0Q2F0ZWdvcmllcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jYXRlZ29yaWVzO1xyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCB7IENvbnRyb2wsIENvbnRyb2xPcHRpb25zLCBEb21FdmVudCwgTWFwIH0gZnJvbSAnbGVhZmxldCc7XHJcbmltcG9ydCB7IGNyZWF0ZUh0bWxFbGVtZW50IH0gZnJvbSAnLi4vVXRpbCc7XHJcblxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBJY29uQWN0aW9uQ3RybE9wdGlvbnMgZXh0ZW5kcyBDb250cm9sT3B0aW9ucyB7XHJcbiAgICBjbGFzc05hbWU6c3RyaW5nO1xyXG4gICAgYWN0aW9uOihjdHJsOkNvbnRyb2wpPT52b2lkO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIENoYW5nZUZvbnRTaXplQ3RybE9wdGlvbnMgZXh0ZW5kcyBDb250cm9sT3B0aW9ucyB7XHJcbiAgICB0eXBlOidpbmNyZWFzZSd8J2RlY3JlYXNlJztcclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIEljb25BY3Rpb25DdHJsIGV4dGVuZHMgQ29udHJvbCB7XHJcblxyXG4gICAgX21hcDogTWFwO1xyXG4gICAgZG9tOiBIVE1MRWxlbWVudDtcclxuXHJcbiAgICBvcHRpb25zOkljb25BY3Rpb25DdHJsT3B0aW9ucztcclxuICAgIHByaXZhdGUgX2NsaWNrRmN0OiAoZXY6IE1vdXNlRXZlbnQpID0+IGJvb2xlYW47XHJcblxyXG4gICAgY29uc3RydWN0b3Iob3B0aW9uczogSWNvbkFjdGlvbkN0cmxPcHRpb25zKSB7XHJcbiAgICAgICAgc3VwZXIob3B0aW9ucyk7XHJcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcclxuICAgIH1cclxuXHJcbiAgICBvbkFkZChtYXA6IE1hcCk6IEhUTUxFbGVtZW50IHtcclxuLy8gICAgICAgICBjb25zb2xlLmluZm8oXCJJY29uQWN0aW9uLm9uQWRkXCIpXHJcbiAgICAgICAgdGhpcy5fbWFwID0gbWFwO1xyXG4gICAgICAgIGlmICghdGhpcy5kb20pIHtcclxuICAgICAgICAgICAgY29uc3QgZGl2ID0gY3JlYXRlSHRtbEVsZW1lbnQoJ2RpdicsIHVuZGVmaW5lZCwgdGhpcy5vcHRpb25zLmNsYXNzTmFtZSsnIGN0cmwtaWNvbicpO1xyXG4gICAgICAgICAgICBjb25zdCBmID0gdGhpcy5fY2xpY2tGY3QgPSAoZXY6TW91c2VFdmVudCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgZXYuY2FuY2VsQnViYmxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmFjdGlvbih0aGlzKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9OyAgICAgXHJcbiAgICAgICAgICAgIGRpdi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZik7XHJcbiAgICAgICAgICAgIHRoaXMuZG9tID0gZGl2O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5kb207XHJcbiAgICB9XHJcblxyXG4gICAgb25SZW1vdmUobWFwOiBMLk1hcCkge1xyXG4gICAgICAgIHRoaXMuX21hcCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5kb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX2NsaWNrRmN0KTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIENoYW5nZUZvbnRTaXplQ3RybCBleHRlbmRzIENvbnRyb2wge1xyXG5cclxuICAgIF9tYXA6IE1hcDtcclxuICAgIGRvbTogSFRNTEVsZW1lbnQ7XHJcblxyXG4gICAgb3B0aW9uczpDb250cm9sT3B0aW9ucztcclxuICAgIHByaXZhdGUgX2NsaWNrRmN0OiAoZXY6IE1vdXNlRXZlbnQpID0+IGJvb2xlYW47XHJcbiAgICBkaXZNaW51czogSFRNTERpdkVsZW1lbnQ7XHJcbiAgICBkaXZQbHVzOiBIVE1MRGl2RWxlbWVudDtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zOiBDb250cm9sT3B0aW9ucykge1xyXG4gICAgICAgIHN1cGVyKG9wdGlvbnMpO1xyXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XHJcbiAgICB9XHJcblxyXG4gICAgb25BZGQobWFwOiBNYXApOiBIVE1MRWxlbWVudCB7XHJcbiAgICAgICAgLy8gY29uc29sZS5pbmZvKFwiSWNvbkFjdGlvbi5vbkFkZFwiKVxyXG4gICAgICAgIHRoaXMuX21hcCA9IG1hcDtcclxuXHJcbiAgICAgICAgaWYgKCF0aGlzLmRvbSkgeyAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBjb25zdCBkaXYgPSBjcmVhdGVIdG1sRWxlbWVudCgnZGl2JywgdW5kZWZpbmVkLCAnY3RybC1mb250c2l6ZScpOyAgICAgXHJcbiAgICAgICAgICAgIGNvbnN0IGRpdlBsdXMgPSB0aGlzLmRpdlBsdXMgPSBjcmVhdGVIdG1sRWxlbWVudCgnZGl2JywgZGl2LCAnY3RybC1pY29uIGZvbnQtcGx1cycpOyAgICAgXHJcbiAgICAgICAgICAgIC8vIGNvbnN0IHNwYW4xID0gY3JlYXRlSHRtbEVsZW1lbnQoJ3NwYW4nLCBkaXZQbHVzKTtcclxuICAgICAgICAgICAgZGl2UGx1cy5pbm5lclRleHQgPSBcIkFcIjtcclxuICAgICAgICAgICAgLy8gY29uc3Qgc3BhbjIgPSBjcmVhdGVIdG1sRWxlbWVudCgnc3VwJywgc3BhbjEpOyAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyBzcGFuMi5pbm5lclRleHQgPSAnKyc7XHJcbiAgICAgICAgICAgIERvbUV2ZW50LmRpc2FibGVDbGlja1Byb3BhZ2F0aW9uKGRpdlBsdXMpO1xyXG4gICAgICAgICAgICBjb25zdCBmUGx1cyA9IHRoaXMuX2NsaWNrRmN0ID0gKGV2Ok1vdXNlRXZlbnQpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlRm9udFNpemUodGhpcywgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfTsgICAgIFxyXG4gICAgICAgICAgICBkaXZQbHVzLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBmUGx1cyk7XHJcbiAgICAgICAgICAgIGRpdlBsdXMuYWRkRXZlbnRMaXN0ZW5lcihcImRvdWJsZWNsaWNrXCIsIGZQbHVzKTtcclxuICAgICAgICAgICAgZGl2UGx1cy5hZGRFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCBmUGx1cyk7XHJcbiAgICAgICAgICAgIGRpdlBsdXMuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLCBmUGx1cyk7XHJcblxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgY29uc3QgZGl2TWludXMgPSB0aGlzLmRpdk1pbnVzID0gY3JlYXRlSHRtbEVsZW1lbnQoJ2RpdicsIGRpdiwgJ2N0cmwtaWNvbiBmb250LW1pbnVzJyk7ICAgICBcclxuICAgICAgICAgICAgLy8gY29uc3Qgc3Bhbk1pbnVzMSA9IGNyZWF0ZUh0bWxFbGVtZW50KCdzcGFuJywgZGl2TWludXMpO1xyXG4gICAgICAgICAgICBkaXZNaW51cy5pbm5lclRleHQgPSBcIkFcIjtcclxuICAgICAgICAgICAgLy8gY29uc3Qgc3Bhbk1pbnVzMiA9IGNyZWF0ZUh0bWxFbGVtZW50KCdzdXAnLCBzcGFuTWludXMxKTtcclxuICAgICAgICAgICAgLy8gc3Bhbk1pbnVzMi5pbm5lclRleHQgPSAnLSc7XHJcbiAgICAgICAgICAgIERvbUV2ZW50LmRpc2FibGVDbGlja1Byb3BhZ2F0aW9uKGRpdk1pbnVzKTtcclxuICAgICAgICAgICAgY29uc3QgZk1pbnVzID0gdGhpcy5fY2xpY2tGY3QgPSAoZXY6TW91c2VFdmVudCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VGb250U2l6ZSh0aGlzLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfTsgICAgIFxyXG4gICAgICAgICAgICBkaXZNaW51cy5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZk1pbnVzKTtcclxuICAgICAgICAgICAgZGl2TWludXMuYWRkRXZlbnRMaXN0ZW5lcihcImRvdWJsZWNsaWNrXCIsIGZNaW51cyk7XHJcbiAgICAgICAgICAgIGRpdk1pbnVzLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIGZNaW51cyk7XHJcbiAgICAgICAgICAgIGRpdk1pbnVzLmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVydXBcIiwgZk1pbnVzKTtcclxuXHJcblxyXG4gICAgICAgICAgICB0aGlzLmRvbSA9IGRpdjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9tO1xyXG4gICAgfVxyXG5cclxuICAgIGNoYW5nZUZvbnRTaXplKG86Q2hhbmdlRm9udFNpemVDdHJsLCBpbmNyZWFzZTpib29sZWFuKSB7XHJcbiAgICAgICAgY29uc29sZS5pbmZvKCdjaGFuZ2Vmb250c2l6ZScpXHJcbiAgICAgICAgY29uc3QgaHRtbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJodG1sXCIpO1xyXG4gICAgICAgIGlmIChodG1sKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGZzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoaHRtbCkuZ2V0UHJvcGVydHlWYWx1ZSgnZm9udC1zaXplJyk7XHJcbiAgICAgICAgICAgIGxldCBmb250U2l6ZSA9IHBhcnNlSW50KGZzKTsgICAgICAgICAgICBcclxuICAgICAgICAgICAgY29uc3QgaSA9ICAoaW5jcmVhc2UpID8gMSA6IC0xO1xyXG4gICAgICAgICAgICBmb250U2l6ZSArPSBpOyAgICAgICAgICAgIFxyXG5cclxuICAgICAgICAgICAgaWYgKGZvbnRTaXplPjYgJiYgZm9udFNpemU8MzApIHsgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBodG1sLnN0eWxlLmZvbnRTaXplID0gZm9udFNpemUrJ3B4JztcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoZm9udFNpemU9PT03KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXZNaW51cy5jbGFzc0xpc3QuYWRkKCdkaXNhYmxlZCcpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpdk1pbnVzLmNsYXNzTGlzdC5yZW1vdmUoJ2Rpc2FibGVkJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoZm9udFNpemU9PT0yOSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGl2UGx1cy5jbGFzc0xpc3QuYWRkKCdkaXNhYmxlZCcpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpdlBsdXMuY2xhc3NMaXN0LnJlbW92ZSgnZGlzYWJsZWQnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgIH1cclxuXHJcbiAgICBvblJlbW92ZShtYXA6IEwuTWFwKSB7XHJcbiAgICAgICAgdGhpcy5fbWFwID0gbnVsbDtcclxuICAgICAgICB0aGlzLmRvbS5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5fY2xpY2tGY3QpO1xyXG4gICAgfVxyXG5cclxufVxyXG5cclxuIiwiaW1wb3J0ICogYXMgTCBmcm9tIFwibGVhZmxldFwiO1xyXG5pbXBvcnQgeyBUcmVlIH0gZnJvbSBcIi4uLy4uLy4uLy4uL3RyZWVjb21wb25lbnQvc3JjL3RzL1RyZWVcIjtcclxuaW1wb3J0IHsgTm9kZVJlbmRlcmVyLCBSYWRpb0dyb3VwVHJlZU5vZGUsIFNlbGVjdGlvbk1vZGUsIFNlbGVjdGlvblN0YXR1cywgVHJlZU5vZGUsIFRyZWVOb2RlUGFyYW0gfSBmcm9tIFwiLi4vLi4vLi4vLi4vdHJlZWNvbXBvbmVudC9zcmMvdHMvVHJlZU5vZGVcIjtcclxuaW1wb3J0IHsgTGF5ZXJEZXNjcmlwdGlvbiwgVGhlbWUgfSBmcm9tIFwiLi4vY29uZi9NYXBEZXNjcmlwdGlvblwiO1xyXG5cclxuaW1wb3J0IHsgQ2F0ZWdvcmllTGF5ZXIsIENhdGVnb3J5LCBDYXRlZ29yeU1hcE9iamVjdCwgUGF0aCB9IGZyb20gXCIuL0NhdGVnb3JpZUxheWVyXCI7XHJcbi8vIGltcG9ydCB7IGNyZWF0ZUxlZ2VuZExheWVySXRlbSB9IGZyb20gJy4vTGVnZW5kQ29udHJvbCc7XHJcbmltcG9ydCB7IExheWVyRXZlbnQsIExheWVyV3JhcHBlciwgTWFwRGlzcGF0Y2hlciB9IGZyb20gXCIuL01hcENvbnRyb2xcIjtcclxuXHJcbmNsYXNzIExheWVyTm9kZVJlbmRlcmVyIGltcGxlbWVudHMgTm9kZVJlbmRlcmVyIHtcclxuICAgIC8vIHNob3dMZWdlbmQgPSB0cnVlXHJcblxyXG4gICAgcmVuZGVyKG5vZGU6IFRyZWVOb2RlKSB7XHJcbiAgICAgICAgY29uc3QgbGF5ZXIgPSA8TGF5ZXJXcmFwcGVyPm5vZGUuZGF0YTtcclxuICAgICAgICBjb25zdCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG4gICAgICAgIGlmICh0eXBlb2Ygbm9kZS5kYXRhID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgIGRpdi5pbm5lckhUTUwgPSBub2RlLmRhdGE7XHJcbiAgICAgICAgICAgIGRpdi5kYXRhc2V0LnRvb2x0aXAgPSBub2RlLmRhdGE7XHJcbiAgICAgICAgICAgIGRpdi5zZXRBdHRyaWJ1dGUoXCJkYXRhLXRvb2x0aXBcIiwgbm9kZS5kYXRhKTtcclxuICAgICAgICAgICAgZGl2LnRpdGxlID0gbm9kZS5kYXRhO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHR4dCA9IG5vZGUuZGF0YS5sYXllckRlc2NyaXB0aW9uW1wibGFiZWxcIl07XHJcbiAgICAgICAgICAgIGlmICghdHh0KSB7XHJcbiAgICAgICAgICAgICAgICBkZWJ1Z2dlcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkaXYuaW5uZXJIVE1MID0gdHh0O1xyXG4gICAgICAgICAgICBkaXYuZGF0YXNldC50b29sdGlwID0gdHh0O1xyXG4gICAgICAgICAgICBkaXYuc2V0QXR0cmlidXRlKFwiZGF0YS10b29sdGlwXCIsIHR4dCk7XHJcbiAgICAgICAgICAgIGRpdi50aXRsZSA9IHR4dDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGl2LmNsYXNzTmFtZSA9IFwidG9vbHRpcFwiO1xyXG5cclxuICAgICAgICAvLyBpZiAodGhpcy5zaG93TGVnZW5kKSB7XHJcbiAgICAgICAgLy8gICAgIGNvbnN0IGxlZ2VuZEl0ZW0gPSBjcmVhdGVMZWdlbmRMYXllckl0ZW0obGF5ZXIubGF5ZXJEZXNjcmlwdGlvbik7XHJcbiAgICAgICAgLy8gICAgIGlmIChsZWdlbmRJdGVtKSB7XHJcbiAgICAgICAgLy8gICAgICAgICBkaXYuYXBwZW5kQ2hpbGQobGVnZW5kSXRlbSk7XHJcbiAgICAgICAgLy8gICAgICAgICBsZWdlbmRJdGVtLmNsYXNzTGlzdC5hZGQoJ2xlZ2VuZC1pdGVtJyk7XHJcbiAgICAgICAgLy8gICAgIH1cclxuICAgICAgICAvLyB9XHJcblxyXG4gICAgICAgIHJldHVybiBkaXY7XHJcbiAgICB9XHJcbn1cclxuXHJcbmNvbnN0IGxheWVyUmVuZGVyZXIgPSBuZXcgTGF5ZXJOb2RlUmVuZGVyZXIoKTtcclxuXHJcbmV4cG9ydCBjbGFzcyBCYXNlTGF5ZXJEZWZpbml0aW9uIHtcclxuICAgIGlkPzogc3RyaW5nIHwgbnVtYmVyO1xyXG4gICAgbGF5ZXI/OiBMLkxheWVyO1xyXG4gICAgYm91bmRzPzogTC5MYXRMbmdCb3VuZHM7XHJcbiAgICBpbWc/OiBzdHJpbmc7XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBMYXllckRlZmluaXRpb25PcHRpb25zIHtcclxuICAgIGxhYmVsQXR0cmlidXRlPzogc3RyaW5nO1xyXG4gICAgY3JlYXRlTGF5ZXI/OiAobGF5ZXJEZWZpbnRpb246IEJhc2VMYXllckRlZmluaXRpb24pID0+IFByb21pc2U8TC5MYXllcj47XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBMYXllckNvbnRyb2xPcHRpb25zIGltcGxlbWVudHMgTC5Db250cm9sT3B0aW9ucyB7XHJcbiAgICBiYXNlTGF5ZXI/OiBMLkxheWVyO1xyXG4gICAgYmFzZUxheWVycz86IEJhc2VMYXllckRlZmluaXRpb25bXTtcclxuICAgIGJhc2VMYXllcklkPzogc3RyaW5nO1xyXG4gICAgcG9zaXRpb24/OiBMLkNvbnRyb2xQb3NpdGlvbjtcclxuICAgIGNsYXNzTmFtZT86IHN0cmluZztcclxuICAgIHBhcmVudE5vZGU/OiBIVE1MRWxlbWVudDtcclxufVxyXG5cclxuZXhwb3J0IHR5cGUgTGlzdEVudHJ5PFQ+ID0ge1xyXG4gICAgaXRlbTogVDtcclxuICAgIGRvbTogSFRNTEVsZW1lbnQ7XHJcbn07XHJcblxyXG5leHBvcnQgY2xhc3MgTGF5ZXJDb250cm9sIGV4dGVuZHMgTC5Db250cm9sIHtcclxuICAgIHN0YXRpYyBjYXROb2RlUGFyYW06IFRyZWVOb2RlUGFyYW0gPSB7XHJcbiAgICAgICAgYXR0TmFtZTJSZW5kZXI6IFwiYmV6ZWljaG51bmdcIixcclxuICAgICAgICBzZWxlY3RNb2RlOiBTZWxlY3Rpb25Nb2RlLk1VTFRJLFxyXG4gICAgfTtcclxuXHJcbiAgICBiYXNlTGF5ZXJEZWZpbml0aW9uczogQmFzZUxheWVyRGVmaW5pdGlvbltdO1xyXG4gICAgYmFzZUxheWVyRGVmaW5pdGlvbjogQmFzZUxheWVyRGVmaW5pdGlvbjtcclxuXHJcbiAgICBfbWFwOiBMLk1hcDtcclxuICAgIHRyZWU6IFRyZWU7XHJcbiAgICBjbGFzc05hbWU6IHN0cmluZztcclxuXHJcbiAgICBjYXRlZ29yaWVMYXllcnM6IHsgW2lkOiBzdHJpbmddOiBDYXRlZ29yaWVMYXllcjxhbnksIGFueT4gfSA9IHt9O1xyXG4gICAgY2F0ZWdvcmllTGF5ZXJOb2RlczogeyBbaWQ6IHN0cmluZ106IFRyZWVOb2RlIH0gPSB7fTtcclxuXHJcbiAgICBvdmVybGF5czogeyBbaWQ6IHN0cmluZ106IEJhc2VMYXllckRlZmluaXRpb25bXSB9ID0ge307XHJcbiAgICBiYXNlTGF5ZXJEZWZPcHRpb25zOiBMYXllckRlZmluaXRpb25PcHRpb25zO1xyXG4gICAgdGhlbWVzOiBUaGVtZVtdO1xyXG4gICAgcGFyZW50Tm9kZTogSFRNTEVsZW1lbnQ7XHJcblxyXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucz86IExheWVyQ29udHJvbE9wdGlvbnMpIHtcclxuICAgICAgICBzdXBlcihvcHRpb25zKTtcclxuICAgICAgICBpZiAob3B0aW9ucy5jbGFzc05hbWUpIHtcclxuICAgICAgICAgICAgdGhpcy5jbGFzc05hbWUgPSBvcHRpb25zLmNsYXNzTmFtZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9wdGlvbnMuYmFzZUxheWVycykge1xyXG4gICAgICAgICAgICB0aGlzLmJhc2VMYXllckRlZmluaXRpb25zID0gb3B0aW9ucy5iYXNlTGF5ZXJzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob3B0aW9ucy5wYXJlbnROb2RlKSB7XHJcbiAgICAgICAgICAgIHRoaXMucGFyZW50Tm9kZSA9IG9wdGlvbnMucGFyZW50Tm9kZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fY3JlYXRlVHJlZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgX2xheWVyQWRkZWQoZXZ0OiBMYXllckV2ZW50KSB7XHJcbiAgICAgICAgdGhpcy50cmVlLnNlbGVjdE5vZGUoZXZ0LmxheWVyKTtcclxuICAgIH1cclxuICAgIHByaXZhdGUgX2xheWVyUmVtb3ZlZChldnQ6IExheWVyRXZlbnQpIHtcclxuICAgICAgICB0aGlzLnRyZWUudW5zZWxlY3ROb2RlKGV2dC5sYXllcik7XHJcbiAgICB9XHJcblxyXG4gICAgbm9kZUNoYW5nZWQoZ3JvdXA6IHN0cmluZywgbm9kZTogVHJlZU5vZGUsIHNlbDogU2VsZWN0aW9uU3RhdHVzKSB7XHJcbiAgICAgICAgY29uc29sZS5pbmZvKGBub2RlQ2hhbmdlZCAke2dyb3VwfSAke25vZGUuZGF0YS5uYW1lfSwgJHtTZWxlY3Rpb25TdGF0dXNbc2VsXX1gKTtcclxuICAgIH1cclxuXHJcbiAgICBfYmFzZUxheWVyQ2hhbmdlZChsYXllcjogTC5MYXllcikge1xyXG4gICAgICAgIE1hcERpc3BhdGNoZXIub25CYXNlTGF5ZXJTZWxlY3Rpb24uZGlzcGF0Y2godGhpcywgbGF5ZXIpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoZW1lTGF5ZXJDaGFuZ2VkKG5vZGU6IFRyZWVOb2RlLCBzZWw6IFNlbGVjdGlvblN0YXR1cykge1xyXG4gICAgICAgIGNvbnNvbGUuaW5mbyhgdGhlbWVMYXllckNoYW5nZWQgJHtTZWxlY3Rpb25TdGF0dXNbc2VsXX1gLCBub2RlKTtcclxuICAgICAgICBjb25zdCBpc1NlbGVjdGVkID0gc2VsID09PSBTZWxlY3Rpb25TdGF0dXMuU0VMRUNURUQ7XHJcbiAgICAgICAgY29uc3QgbGF5ZXIgPSA8TGF5ZXJXcmFwcGVyPm5vZGUuZGF0YTtcclxuICAgICAgICBsYXllci5zZXRTZWxlY3RlZChpc1NlbGVjdGVkKTtcclxuICAgIH1cclxuXHJcbiAgICBiYXNlTGF5ZXJDaGFuZ2VkKG5vZGU6IFRyZWVOb2RlLCBzZWw6IFNlbGVjdGlvblN0YXR1cykge1xyXG4gICAgICAgIGNvbnNvbGUuaW5mbyhgYmFzZUxheWVyQ2hhbmdlZCAke1NlbGVjdGlvblN0YXR1c1tzZWxdfWAsIG5vZGUpO1xyXG4gICAgICAgIGlmICghbm9kZS5kYXRhLmxheWVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYmFzZUxheWVyRGVmT3B0aW9ucy5jcmVhdGVMYXllcihub2RlLmRhdGEpLnRoZW4oKGxheWVyKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBub2RlLmRhdGEubGF5ZXIgPSBsYXllcjtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2Jhc2VMYXllckNoYW5nZWQobGF5ZXIpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9iYXNlTGF5ZXJDaGFuZ2VkKG5vZGUuZGF0YS5sYXllcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHNldEJhc2VMYXllcnMoYmFzZUxheWVyczogQmFzZUxheWVyRGVmaW5pdGlvbltdLCBvcHRpb25zPzogTGF5ZXJEZWZpbml0aW9uT3B0aW9ucykge1xyXG4gICAgICAgIHRoaXMuYmFzZUxheWVyRGVmaW5pdGlvbnMgPSBiYXNlTGF5ZXJzO1xyXG4gICAgICAgIHRoaXMuYmFzZUxheWVyRGVmT3B0aW9ucyA9IG9wdGlvbnM7XHJcbiAgICAgICAgaWYgKHRoaXMudHJlZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9hZGRCYXNlTGF5ZXJzVG9UcmVlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc2VsZWN0QmFzZUxheWVyKHRoaXMuYmFzZUxheWVyRGVmaW5pdGlvbnNbMF0pO1xyXG4gICAgfVxyXG5cclxuICAgIHNlbGVjdEJhc2VMYXllcihiYXNlTGF5ZXI6IEJhc2VMYXllckRlZmluaXRpb24gfCBudW1iZXIpIHtcclxuICAgICAgICBjb25zb2xlLmluZm8oXCJ0aGlzLnNldEJhc2VMYXllclwiLCBiYXNlTGF5ZXIpO1xyXG4gICAgICAgIGlmICh0eXBlb2YgYmFzZUxheWVyID09PSBcIm51bWJlclwiKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYmFzZUxheWVyRGVmaW5pdGlvbiA9IHRoaXMuYmFzZUxheWVyRGVmaW5pdGlvbnNbMF07XHJcbiAgICAgICAgICAgIHRoaXMudHJlZS5zZWxlY3ROb2RlKGJhc2VMYXllcik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5iYXNlTGF5ZXJEZWZpbml0aW9uID0gYmFzZUxheWVyO1xyXG4gICAgICAgICAgICB0aGlzLnRyZWUuc2VsZWN0Tm9kZShiYXNlTGF5ZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBzZWxlY3RUaGVtZUxheWVyKGxheWVyRGVzY3I6IExheWVyRGVzY3JpcHRpb24pIHtcclxuICAgICAgICBjb25zb2xlLmluZm8oXCJzZWxlY3RUaGVtZUxheWVyXCIpO1xyXG4gICAgICAgIHRoaXMudHJlZS5zZWxlY3ROb2RlKGxheWVyRGVzY3IpO1xyXG4gICAgfVxyXG5cclxuICAgIGFkZFRoZW1lcyh0aGVtZXM6IFRoZW1lW10pIHtcclxuICAgICAgICB0aGlzLnRoZW1lcyA9IHRoZW1lcztcclxuICAgICAgICBNYXBEaXNwYXRjaGVyLm9uTGF5ZXJBZGRlZC5zdWJzY3JpYmUoKHNlbmRlciwgZXZ0KSA9PiB0aGlzLl9sYXllckFkZGVkKGV2dCkpO1xyXG4gICAgICAgIE1hcERpc3BhdGNoZXIub25MYXllclJlbW92ZWQuc3Vic2NyaWJlKChzZW5kZXIsIGV2dCkgPT4gdGhpcy5fbGF5ZXJSZW1vdmVkKGV2dCkpO1xyXG4gICAgICAgIGlmICh0aGlzLnRyZWUpIHtcclxuICAgICAgICAgICAgdGhpcy5fYWRkVGhlbWVzVG9UcmVlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgX2NyZWF0ZVRyZWUoKSB7XHJcbiAgICAgICAgdGhpcy50cmVlID0gbmV3IFRyZWUobnVsbCwgeyBzZWxlY3RNb2RlOiBTZWxlY3Rpb25Nb2RlLk1VTFRJLCBleHBhbmRPbmx5T25lTm9kZTogdHJ1ZSB9KTtcclxuICAgICAgICB0aGlzLl9hZGRCYXNlTGF5ZXJzVG9UcmVlKCk7XHJcbiAgICAgICAgZm9yIChjb25zdCB0aXRsZSBpbiB0aGlzLm92ZXJsYXlzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2FkZE92ZXJsYXlUb1RyZWUodGl0bGUsIHRoaXMub3ZlcmxheXNbdGl0bGVdKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAoY29uc3QgdGl0bGUgaW4gdGhpcy5jYXRlZ29yaWVMYXllcnMpIHtcclxuICAgICAgICAgICAgdGhpcy5fYWRkQ2F0ZWdvcmllTGF5ZXJUb1RyZWUodGl0bGUsIHRoaXMuY2F0ZWdvcmllTGF5ZXJzW3RpdGxlXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgX2FkZFRoZW1lc1RvVHJlZSgpIHtcclxuICAgICAgICBpZiAodGhpcy50cmVlKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnRoZW1lcykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy50aGVtZXMuZm9yRWFjaCgodGhlbWUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0aGVtZU5vZGUgPSBuZXcgVHJlZU5vZGUodGhlbWUudGhlbWEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGVtZS5sYXllcnMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhlbWUubGF5ZXJzLmZvckVhY2goKGxheWVyKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zdCBsYXllck5vZGUgPSBuZXcgVHJlZU5vZGUobGF5ZXIsIG51bGwsIHthdHROYW1lMlJlbmRlcjonbGFiZWwnfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsYXllck5vZGUgPSBuZXcgVHJlZU5vZGUobGF5ZXIsIG51bGwsIHsgbm9kZVJlbmRlcmVyOiBsYXllclJlbmRlcmVyIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXJOb2RlLm9uU2VsZWN0aW9uQ2hhbmdlLnN1YnNjcmliZSgobm9kZSwgc2VsKSA9PiB0aGlzLnRoZW1lTGF5ZXJDaGFuZ2VkKG5vZGUsIHNlbCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlbWVOb2RlLmFkZE5vZGUobGF5ZXJOb2RlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGVtZU5vZGUuY2hpbGRzICYmIHRoZW1lTm9kZS5jaGlsZHMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRyZWUuYWRkTm9kZSh0aGVtZU5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcHJpdmF0ZSBfYWRkQmFzZUxheWVyc1RvVHJlZSgpIHtcclxuICAgICAgICBpZiAodGhpcy50cmVlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvdW50ID0gdGhpcy5iYXNlTGF5ZXJEZWZpbml0aW9ucyA/IHRoaXMuYmFzZUxheWVyRGVmaW5pdGlvbnMubGVuZ3RoIDogMDtcclxuICAgICAgICAgICAgaWYgKGNvdW50ID4gMCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYmFzZUxheWVyTm9kZXM6IFRyZWVOb2RlW10gPSBbXTtcclxuICAgICAgICAgICAgICAgIGxldCBub2RlUGFyYW06IFRyZWVOb2RlUGFyYW07XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5iYXNlTGF5ZXJEZWZPcHRpb25zLmxhYmVsQXR0cmlidXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZVBhcmFtID0geyBhdHROYW1lMlJlbmRlcjogdGhpcy5iYXNlTGF5ZXJEZWZPcHRpb25zLmxhYmVsQXR0cmlidXRlIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBiYXNlTGF5ZXJOb2RlID0gbmV3IFRyZWVOb2RlKHRoaXMuYmFzZUxheWVyRGVmaW5pdGlvbnNbaV0sIG51bGwsIG5vZGVQYXJhbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYmFzZUxheWVyTm9kZXMucHVzaChiYXNlTGF5ZXJOb2RlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhiYXNlTGF5ZXJOb2Rlcyk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBiYXNlTE5vZGUgPSBuZXcgUmFkaW9Hcm91cFRyZWVOb2RlKHsgbmFtZTogXCJHcnVuZGthcnRlXCIgfSwgYmFzZUxheWVyTm9kZXMpO1xyXG4gICAgICAgICAgICAgICAgYmFzZUxOb2RlLm9uU2VsZWN0aW9uQ2hhbmdlLnN1YnNjcmliZSgobm9kZSwgc2VsKSA9PiB0aGlzLmJhc2VMYXllckNoYW5nZWQobm9kZSwgc2VsKSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyZWUuYWRkTm9kZShiYXNlTE5vZGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcImJlZm9yZSBzZXRTZWxlZFwiKTtcclxuICAgICAgICAgICAgdGhpcy50cmVlLnNlbGVjdE5vZGUodGhpcy5iYXNlTGF5ZXJEZWZpbml0aW9uKTtcclxuICAgICAgICAgICAgdGhpcy50cmVlLm9uU2VsZWN0aW9uQ2hhbmdlLnN1YnNjcmliZSgobm9kZSwgc2VsKSA9PiB0aGlzLm5vZGVDaGFuZ2VkKFwidHJlZVwiLCBub2RlLCBzZWwpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgX2FkZENhdGVnb3JpZUxheWVyVG9UcmVlKHRpdGxlOiBzdHJpbmcsIGNhdGVnb3JpZUxheWVyOiBDYXRlZ29yaWVMYXllcjxhbnksIGFueT4pIHtcclxuICAgICAgICBpZiAodGhpcy50cmVlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNhdGVnb3JpZXMgPSBjYXRlZ29yaWVMYXllci5nZXRDYXRlZ29yaWVzKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHRyZWVOb2RlID0gbmV3IFRyZWVOb2RlKHRpdGxlKTtcclxuICAgICAgICAgICAgdGhpcy50cmVlLmFkZE5vZGUodHJlZU5vZGUpO1xyXG4gICAgICAgICAgICB0aGlzLmFkZENhdGVnb3JpZXModHJlZU5vZGUsIGNhdGVnb3JpZXMpO1xyXG4gICAgICAgICAgICB0aGlzLmNhdGVnb3JpZUxheWVyTm9kZXNbdGl0bGVdID0gdHJlZU5vZGU7XHJcbiAgICAgICAgICAgIHRyZWVOb2RlLm9uU2VsZWN0aW9uQ2hhbmdlLnN1YnNjcmliZSgobm9kZSwgc3RhdHVzKSA9PiB0aGlzLl9jYXRlZ29yaWVTZWxlY3RlZCh0aXRsZSwgdHJlZU5vZGUsIHN0YXR1cykpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBfYWRkT3ZlcmxheVRvVHJlZSh0aXRsZTogc3RyaW5nLCBvdmVybGF5czogQmFzZUxheWVyRGVmaW5pdGlvbltdKSB7XHJcbiAgICAgICAgY29uc29sZS5pbmZvKGBfYWRkQ2F0ZWdvcmllTGF5ZXJUb1RyZWUgJHt0aGlzLnRyZWV9YCk7XHJcbiAgICAgICAgaWYgKHRoaXMudHJlZSkge1xyXG4gICAgICAgICAgICBjb25zdCB0cmVlTm9kZSA9IG5ldyBUcmVlTm9kZSh0aXRsZSwgdW5kZWZpbmVkLCB7IHNlbGVjdE1vZGU6IFNlbGVjdGlvbk1vZGUuTVVMVEkgfSk7XHJcbiAgICAgICAgICAgIHRoaXMudHJlZS5hZGROb2RlKHRyZWVOb2RlKTtcclxuICAgICAgICAgICAgb3ZlcmxheXMuZm9yRWFjaCgoYmFzZUxheWVyRGVmKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0cmVlTm9kZSA9IG5ldyBUcmVlTm9kZShiYXNlTGF5ZXJEZWYsIG51bGwsIHsgc2VsZWN0TW9kZTogU2VsZWN0aW9uTW9kZS5NVUxUSSwgbm9kZVJlbmRlcmVyOiBsYXllclJlbmRlcmVyIH0pO1xyXG4gICAgICAgICAgICAgICAgdHJlZU5vZGUuYWRkTm9kZSh0cmVlTm9kZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0cmVlTm9kZS5vblNlbGVjdGlvbkNoYW5nZS5zdWJzY3JpYmUoKG5vZGUsIHN0YXR1cykgPT4gdGhpcy5fdGhlbWVTZWxlY3RlZCh0aXRsZSwgdHJlZU5vZGUsIHN0YXR1cykpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBhZGRUbyhtYXA6IEwuTWFwKTogdGhpcyB7XHJcbiAgICAgICAgLy8gY29uc29sZS5lcnJvcignTGF5ZXJDb250cm9sLmFkZFRvJyk7XHJcbiAgICAgICAgaWYgKHRoaXMucGFyZW50Tm9kZSkge1xyXG4gICAgICAgICAgICB0aGlzLnJlbW92ZSgpO1xyXG4gICAgICAgICAgICB0aGlzLl9tYXAgPSBtYXA7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbnRhaW5lciA9ICgoPGFueT50aGlzKS5fY29udGFpbmVyID0gdGhpcy5vbkFkZChtYXApKTtcclxuICAgICAgICAgICAgY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJsYXllcmN0cmwtZG9tXCIpO1xyXG4gICAgICAgICAgICB0aGlzLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcclxuICAgICAgICAgICAgdGhpcy5fbWFwLm9uKFwidW5sb2FkXCIsIHRoaXMucmVtb3ZlLCB0aGlzKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHN1cGVyLmFkZFRvKG1hcCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIG9uQWRkKG1hcDogTC5NYXApOiBIVE1MRWxlbWVudCB7XHJcbiAgICAgICAgY29uc29sZS5pbmZvKFwiTGF5ZXJDb250cm9sLm9uQWRkXCIpO1xyXG4gICAgICAgIGlmICghdGhpcy50cmVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZVRyZWUoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGNvbnNvbGUuaW5mbyhcImFkZGJhc2VMYXllclwiLCB0aGlzLmJhc2VMYXllcik7XHJcblxyXG4gICAgICAgIHRoaXMuX21hcCA9IG1hcDtcclxuICAgICAgICAvLyB0aGlzLm1hcC5hZGRFdmVudExpc3RlbmVyKFwibW92ZXN0YXJ0XCIsIChldikgPT4geyB9KTtcclxuICAgICAgICAvLyB0aGlzLm1hcC5hZGRFdmVudExpc3RlbmVyKFwibW92ZWVuZFwiLCAoZXYpID0+IHsgfSk7XHJcbiAgICAgICAgY29uc3QgZG9tID0gdGhpcy50cmVlLl9yZW5kZXIoKTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuY2xhc3NOYW1lKSB7XHJcbiAgICAgICAgICAgIGRvbS5jbGFzc0xpc3QuYWRkKHRoaXMuY2xhc3NOYW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZm5TdG9wUHJvcGFnYXRpb24gPSAoZXY6IEV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBMLkRvbUV2ZW50LmRpc2FibGVDbGlja1Byb3BhZ2F0aW9uKGRvbSk7XHJcbiAgICAgICAgLy8gTC5Eb21FdmVudC5kaXNhYmxlU2Nyb2xsUHJvcGFnYXRpb24oZG9tKTtcclxuICAgICAgICBkb20uYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJtb3ZlXCIsIGZuU3RvcFByb3BhZ2F0aW9uKTtcclxuICAgICAgICBkb20uYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCBmblN0b3BQcm9wYWdhdGlvbik7XHJcbiAgICAgICAgZG9tLmFkZEV2ZW50TGlzdGVuZXIoXCJkYmxjbGlja1wiLCBmblN0b3BQcm9wYWdhdGlvbik7XHJcbiAgICAgICAgZG9tLmFkZEV2ZW50TGlzdGVuZXIoXCJkcmFnc3RhcnRcIiwgZm5TdG9wUHJvcGFnYXRpb24pO1xyXG4gICAgICAgIGRvbS5hZGRFdmVudExpc3RlbmVyKFwiZHJhZ1wiLCBmblN0b3BQcm9wYWdhdGlvbik7XHJcbiAgICAgICAgZG9tLmFkZEV2ZW50TGlzdGVuZXIoXCJ3aGVlbFwiLCBmblN0b3BQcm9wYWdhdGlvbik7XHJcbiAgICAgICAgcmV0dXJuIGRvbTtcclxuICAgIH1cclxuICAgIG9uUmVtb3ZlKG1hcDogTC5NYXApIHtcclxuICAgICAgICBjb25zb2xlLmluZm8oXCJMYXllckNvbnRyb2wub25SZW1vdmVcIik7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gcmVtb3ZlKCkge1xyXG4gICAgLy8gICAgIGNvbnNvbGUuZXJyb3IoXCJMYXllckNvbnRyb2wucmVtb3ZlXCIpO1xyXG4gICAgLy8gICAgIHN1cGVyLnJlbW92ZSgpO1xyXG4gICAgLy8gICAgIHJldHVybiB0aGlzO1xyXG4gICAgLy8gfVxyXG5cclxuICAgIF9maW5kQmFzZUxheWVyRGVmaW5pdGlvbihiYXNlTGF5ZXJJZDogc3RyaW5nKTogQmFzZUxheWVyRGVmaW5pdGlvbiB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmJhc2VMYXllckRlZmluaXRpb25zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmJhc2VMYXllckRlZmluaXRpb25zW2ldLmlkID09PSBiYXNlTGF5ZXJJZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmFzZUxheWVyRGVmaW5pdGlvbnNbaV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuYmFzZUxheWVyRGVmaW5pdGlvbnNbaV0uaWQudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpID09PSBiYXNlTGF5ZXJJZC50b0xvd2VyQ2FzZSgpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5iYXNlTGF5ZXJEZWZpbml0aW9uc1tpXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG5cclxuICAgIGZpbmRDYXRlZ29yaWUodGl0bGU6IHN0cmluZywgaXRlbTogQ2F0ZWdvcnkpOiBUcmVlTm9kZVtdIHtcclxuICAgICAgICBjb25zb2xlLmluZm8oXCJmaW5kQ2F0ZWdvcmllXCIsIGl0ZW0pO1xyXG4gICAgICAgIGNvbnN0IG5vZGU6IFRyZWVOb2RlID0gdGhpcy5jYXRlZ29yaWVMYXllck5vZGVzW3RpdGxlXTtcclxuICAgICAgICBpZiAobm9kZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbm9kZS5maW5kTm9kZShpdGVtLmlkLCBcImlkXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmaW5kSXRlbXNPZkNhdGVnb3JpZSh0aXRsZTogc3RyaW5nLCBpdGVtOiBDYXRlZ29yeSk6IENhdGVnb3J5TWFwT2JqZWN0PGFueT5bXSB7XHJcbiAgICAgICAgY29uc29sZS5pbmZvKFwiZmluZEl0ZW1zT2ZDYXRlZ29yaWVcIiwgaXRlbSk7XHJcbiAgICAgICAgY29uc3Qgbm9kZTogVHJlZU5vZGUgPSB0aGlzLmNhdGVnb3JpZUxheWVyTm9kZXNbdGl0bGVdO1xyXG4gICAgICAgIGlmIChub2RlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5vZGVzID0gbm9kZS5maW5kTm9kZShpdGVtLmlkLCBcImlkXCIpO1xyXG4gICAgICAgICAgICBpZiAobm9kZXMpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBhdGggPSBbXTtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBub2Rlcy5sZW5ndGggLSAyOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhdGgucHVzaChub2Rlc1tpXS5kYXRhLmlkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcInBhdGhcIiwgcGF0aCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBsYXllciA9IHRoaXMuY2F0ZWdvcmllTGF5ZXJzW3RpdGxlXTtcclxuICAgICAgICAgICAgICAgIGlmIChsYXllcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsYXllci5nZXRJdGVtcyhwYXRoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBzaG93Q2F0ZWdvcmllKHRpdGxlOiBzdHJpbmcsIGl0ZW06IGFueSkge1xyXG4gICAgICAgIGNvbnNvbGUuaW5mbyhcInNob3dDYXRlZ29yaWVcIiwgaXRlbSk7XHJcbiAgICAgICAgY29uc3Qgbm9kZTogVHJlZU5vZGUgPSB0aGlzLmNhdGVnb3JpZUxheWVyTm9kZXNbdGl0bGVdO1xyXG4gICAgICAgIGlmIChub2RlKSB7XHJcbiAgICAgICAgICAgIG5vZGUuc2VsZWN0Tm9kZShpdGVtLmlkLCBcImlkXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBzaG93TWFya2VyKHRpdGxlOiBzdHJpbmcsIGlkOiBhbnksIHByb3A6IHN0cmluZykge1xyXG4gICAgICAgIGNvbnNvbGUuaW5mbyhgc2hvd21hcmtlcigke3RpdGxlfSwgJHtpZH0sICR7cHJvcH0pYCk7XHJcbiAgICAgICAgY29uc3QgbGF5ZXIgPSB0aGlzLmNhdGVnb3JpZUxheWVyc1t0aXRsZV07XHJcbiAgICAgICAgaWYgKGxheWVyKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1hcmtlciA9IGxheWVyLnNob3dNYXJrZXIoaWQsIHByb3ApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBnZXRJdGVtcyh0aXRsZTogc3RyaW5nLCBwYXRoOiBQYXRoPGFueT4pOiBDYXRlZ29yeU1hcE9iamVjdDxhbnk+W10ge1xyXG4gICAgICAgIGNvbnNvbGUuaW5mbyhgZ2V0SXRlbXMoJHt0aXRsZX0sICR7cGF0aH0pYCk7XHJcbiAgICAgICAgY29uc3QgbGF5ZXIgPSB0aGlzLmNhdGVnb3JpZUxheWVyc1t0aXRsZV07XHJcbiAgICAgICAgcmV0dXJuIGxheWVyLmdldEl0ZW1zKHBhdGgpO1xyXG4gICAgfVxyXG5cclxuICAgIGFkZENhdGVnb3JpZUxheWVyKHRpdGxlOiBzdHJpbmcsIGNhdGVnb3JpZUxheWVyOiBDYXRlZ29yaWVMYXllcjxhbnksIGFueT4sIHNob3dBbGw/OiBib29sZWFuKSB7XHJcbiAgICAgICAgdGhpcy5jYXRlZ29yaWVMYXllcnNbdGl0bGVdID0gY2F0ZWdvcmllTGF5ZXI7XHJcbiAgICAgICAgY29uc29sZS5pbmZvKFwiYWRkQ2F0ZWdvcmllTGF5ZXJcIik7XHJcbiAgICAgICAgaWYgKHRoaXMudHJlZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9hZGRDYXRlZ29yaWVMYXllclRvVHJlZSh0aXRsZSwgY2F0ZWdvcmllTGF5ZXIpO1xyXG4gICAgICAgICAgICBpZiAoc2hvd0FsbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy50cmVlLnNlbGVjdE5vZGUodGl0bGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcHJpdmF0ZSBfY2F0ZWdvcmllU2VsZWN0ZWQobGF5ZXJUaXRsZTogc3RyaW5nLCBub2RlOiBUcmVlTm9kZSwgc3RhdHVzOiBTZWxlY3Rpb25TdGF0dXMpOiB2b2lkIHtcclxuICAgICAgICBjb25zb2xlLmluZm8oXCJfY2F0ZWdvcmllU2VsZWN0ZWRcIiwgbm9kZSwgc3RhdHVzKTtcclxuICAgICAgICBjb25zdCBzZWxlY3RlZENhdHMgPSB0aGlzLl9maW5kU2VsZWN0ZWQobm9kZS5jaGlsZHMpO1xyXG4gICAgICAgIGNvbnN0IGNhdGVnb3J5TGF5ZXIgPSB0aGlzLmNhdGVnb3JpZUxheWVyc1tsYXllclRpdGxlXTtcclxuICAgICAgICBpZiAoY2F0ZWdvcnlMYXllcikge1xyXG4gICAgICAgICAgICBjYXRlZ29yeUxheWVyLnNldEthdGVnb3JpZXMoc2VsZWN0ZWRDYXRzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBfdGhlbWVTZWxlY3RlZCh0aGVtZTogc3RyaW5nLCBub2RlOiBUcmVlTm9kZSwgc3RhdHVzOiBTZWxlY3Rpb25TdGF0dXMpOiB2b2lkIHtcclxuICAgICAgICBjb25zb2xlLmluZm8oXCJfdGhlbWVTZWxlY3RlZFwiLCB0aGVtZSwgbm9kZSwgc3RhdHVzKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIF9maW5kU2VsZWN0ZWQobm9kZXM6IFRyZWVOb2RlW10pOiBudW1iZXJbXVtdIHtcclxuICAgICAgICBjb25zdCBpZHMgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChub2Rlc1tpXS5nZXRTZWxlY3Rpb25zU3RhdHVzKCkgPT09IFNlbGVjdGlvblN0YXR1cy5TRUxFQ1RFRCkge1xyXG4gICAgICAgICAgICAgICAgaWRzLnB1c2goW25vZGVzW2ldLmRhdGEuaWRdKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChub2Rlc1tpXS5nZXRTZWxlY3Rpb25zU3RhdHVzKCkgPT09IFNlbGVjdGlvblN0YXR1cy5JTkRFVEVSTUlOQVRFKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hJZHMgPSB0aGlzLl9maW5kU2VsZWN0ZWQobm9kZXNbaV0uY2hpbGRzKTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNoSWRzLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkcy5wdXNoKFtub2Rlc1tpXS5kYXRhLmlkLCAuLi5jaElkc1tqXV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaWRzO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgYWRkQ2F0ZWdvcmllcyhiYXNlOiBUcmVlIHwgVHJlZU5vZGUsIGNhdGVnb3JpZXM6IENhdGVnb3J5W10pIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNhdGVnb3JpZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgdHJlZU5vZGUgPSBuZXcgVHJlZU5vZGUoY2F0ZWdvcmllc1tpXSwgbnVsbCwgTGF5ZXJDb250cm9sLmNhdE5vZGVQYXJhbSk7XHJcbiAgICAgICAgICAgIGlmIChjYXRlZ29yaWVzW2ldLmNoaWxkcykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRDYXRlZ29yaWVzKHRyZWVOb2RlLCBjYXRlZ29yaWVzW2ldLmNoaWxkcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYmFzZS5hZGROb2RlKHRyZWVOb2RlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0ICogYXMgTCBmcm9tIFwibGVhZmxldFwiO1xyXG5pbXBvcnQgeyBDaGFuZ2VOb2RlT3JkZXJFdmVudCwgVHJlZSB9IGZyb20gXCIuLi8uLi8uLi8uLi90cmVlY29tcG9uZW50L3NyYy90cy9UcmVlXCI7XHJcbmltcG9ydCB7IE5vZGVSZW5kZXJlciwgU2VsZWN0aW9uTW9kZSwgU2VsZWN0aW9uU3RhdHVzLCBUcmVlTm9kZSwgVHJlZU5vZGVQYXJhbSB9IGZyb20gXCIuLi8uLi8uLi8uLi90cmVlY29tcG9uZW50L3NyYy90cy9UcmVlTm9kZVwiO1xyXG5pbXBvcnQgeyBMYXllckRlc2NyaXB0aW9uLCBUaGVtZSB9IGZyb20gXCIuLi9jb25mL01hcERlc2NyaXB0aW9uXCI7XHJcbmltcG9ydCB7IGNyZWF0ZUh0bWxFbGVtZW50LCBjcmVhdGVTbGlkZXIgfSBmcm9tIFwiLi4vVXRpbFwiO1xyXG5pbXBvcnQgeyBBY2NvcmRpb24sIEFjY29yZGlvbkl0ZW0gfSBmcm9tIFwiLi4vd2lkZ2V0L0FjY29yZGlvblwiO1xyXG5cclxuaW1wb3J0IHsgQ2F0ZWdvcmllTGF5ZXIsIENhdGVnb3J5LCBDYXRlZ29yeU1hcE9iamVjdCwgUGF0aCB9IGZyb20gXCIuL0NhdGVnb3JpZUxheWVyXCI7XHJcbmltcG9ydCB7IEJhc2VMYXllckRlZmluaXRpb24sIExheWVyRGVmaW5pdGlvbk9wdGlvbnMsIExheWVyQ29udHJvbE9wdGlvbnMsIExheWVyQ29udHJvbCB9IGZyb20gXCIuL0xheWVyQ29udHJvbFwiO1xyXG5cclxuaW1wb3J0IHsgTGF5ZXJFdmVudCwgTGF5ZXJXcmFwcGVyLCBNYXBDb250cm9sLCBNYXBEaXNwYXRjaGVyIH0gZnJvbSBcIi4vTWFwQ29udHJvbFwiO1xyXG5cclxuaW1wb3J0IHsgRXZlbnREaXNwYXRjaGVyIH0gZnJvbSBcInN0cm9uZ2x5LXR5cGVkLWV2ZW50c1wiO1xyXG5pbXBvcnQgeyBMYXllckxvYWRlciB9IGZyb20gXCIuLi9MYXllckxvYWRlclwiO1xyXG5cclxuY2xhc3MgVGhlbWVOb2RlUmVuZGVyZXIgaW1wbGVtZW50cyBOb2RlUmVuZGVyZXIge1xyXG4gICAgcmVuZGVyKG5vZGU6IFRyZWVOb2RlKSB7XHJcbiAgICAgICAgY29uc3QgdGhlbWUgPSA8VGhlbWU+bm9kZS5kYXRhO1xyXG4gICAgICAgIGNvbnN0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XHJcbiAgICAgICAgY29uc3QgdHh0ID0gdGhlbWUudGhlbWE7XHJcbiAgICAgICAgZGl2LmlubmVySFRNTCA9IHR4dDtcclxuICAgICAgICBkaXYuZGF0YXNldC50b29sdGlwID0gdHh0O1xyXG4gICAgICAgIGRpdi5zZXRBdHRyaWJ1dGUoXCJkYXRhLXRvb2x0aXBcIiwgdHh0KTtcclxuICAgICAgICBkaXYudGl0bGUgPSB0eHQ7XHJcbiAgICAgICAgZGl2LmNsYXNzTmFtZSA9IFwidG9vbHRpcFwiO1xyXG5cclxuICAgICAgICByZXR1cm4gZGl2O1xyXG4gICAgfVxyXG59XHJcblxyXG5jbGFzcyBUaGVtZVRyZWVOb2RlIGV4dGVuZHMgVHJlZU5vZGUge1xyXG4gICAgcmVuZGVyKGluc2V0PzogbnVtYmVyKTogSFRNTEVsZW1lbnQge1xyXG4gICAgICAgIGluc2V0ID0gaW5zZXQgPz8gMDtcclxuXHJcbiAgICAgICAgbGV0IGRvbSA9IHRoaXMuZG9tO1xyXG4gICAgICAgIGxldCB0cmVlcm93ID0gdGhpcy50cmVlcm93O1xyXG4gICAgICAgIGlmICghZG9tKSB7XHJcbiAgICAgICAgICAgIGRvbSA9IHRoaXMuZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcclxuICAgICAgICAgICAgZG9tLmNsYXNzTmFtZSA9IFwicm93LXdyYXBwZXIgcm93LXdyYXBwZXItXCIgKyBpbnNldDtcclxuICAgICAgICAgICAgdHJlZXJvdyA9IHRoaXMudHJlZXJvdyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XHJcbiAgICAgICAgICAgIHRyZWVyb3cuY2xhc3NOYW1lID0gXCJ0cmVlcm93XCI7XHJcblxyXG4gICAgICAgICAgICBkb20uYXBwZW5kQ2hpbGQodHJlZXJvdyk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBjaGlsZENvdW50ID0gdGhpcy5jaGlsZHMgPyB0aGlzLmNoaWxkcy5sZW5ndGggOiAwO1xyXG4gICAgICAgICAgICAvLyBjb25zdCBzZWxlY3RNb2RlID0gdGhpcy5nZXRTZWxlY3RNb2RlKCk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCB0aGVtZSA9IDxUaGVtZT50aGlzLmRhdGE7XHJcblxyXG4gICAgICAgICAgICBpZiAodGhlbWUuaWNvbikge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaW1nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImltZ1wiKTtcclxuICAgICAgICAgICAgICAgIGltZy5zcmMgPSB0aGVtZS5pY29uO1xyXG4gICAgICAgICAgICAgICAgaW1nLmFsdCA9IFwiSWNvbiBcIiArIHRoZW1lLnRoZW1hO1xyXG4gICAgICAgICAgICAgICAgdHJlZXJvdy5hcHBlbmRDaGlsZChpbWcpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjb25zdCBsYWJlbERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XHJcbiAgICAgICAgICAgIGxhYmVsRGl2LmNsYXNzTmFtZSA9IFwidHJlZWxhYmVsXCI7XHJcbiAgICAgICAgICAgIC8vIGNvbnN0IGxhYmVsID0gdGhpcy5ub2RlUmVuZGVyZXIucmVuZGVyKHRoaXMpXHJcbiAgICAgICAgICAgIGNvbnN0IGxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcclxuICAgICAgICAgICAgY29uc3QgdHh0ID0gdGhlbWUudGhlbWE7XHJcbiAgICAgICAgICAgIGxhYmVsLmlubmVySFRNTCA9IHR4dDtcclxuICAgICAgICAgICAgbGFiZWwuZGF0YXNldC50b29sdGlwID0gdHh0O1xyXG4gICAgICAgICAgICBsYWJlbC5zZXRBdHRyaWJ1dGUoXCJkYXRhLXRvb2x0aXBcIiwgdHh0KTtcclxuICAgICAgICAgICAgbGFiZWwudGl0bGUgPSB0eHQ7XHJcbiAgICAgICAgICAgIGxhYmVsLmNsYXNzTmFtZSA9IFwidG9vbHRpcFwiO1xyXG4gICAgICAgICAgICAvLyBpZiAobGFiZWwpIHtcclxuICAgICAgICAgICAgbGFiZWxEaXYuYXBwZW5kQ2hpbGQobGFiZWwpO1xyXG4gICAgICAgICAgICB0cmVlcm93LmFwcGVuZENoaWxkKGxhYmVsRGl2KTtcclxuICAgICAgICAgICAgLy8gfVxyXG5cclxuICAgICAgICAgICAgaWYgKGluc2V0ID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzcGFuT3BlbkNsb3NlID0gKHRoaXMuc3Bhbk9wZW5DbG9zZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpKTtcclxuICAgICAgICAgICAgICAgIHRyZWVyb3cuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIChldikgPT4gdGhpcy5vblRyZWVJY29uQ2xpY2soZXYpKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb2xsYXBzZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRvbS5jbGFzc0xpc3QuYWRkKFwiY2xvc2VkXCIpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRvbS5jbGFzc0xpc3QuYWRkKFwib3BlbmVkXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChjaGlsZENvdW50ID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbGxhcHNlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNwYW5PcGVuQ2xvc2UuY2xhc3NMaXN0LmFkZChcImNsb3NlZFwiKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNwYW5PcGVuQ2xvc2UuY2xhc3NMaXN0LmFkZChcIm9wZW5lZFwiKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRleHROb2RlID0gc3Bhbk9wZW5DbG9zZTtcclxuICAgICAgICAgICAgICAgIHRyZWVyb3cuYXBwZW5kQ2hpbGQoc3Bhbk9wZW5DbG9zZSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRvbS5jbGFzc0xpc3QuYWRkKFwib3BlbmVkXCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBsZXQgbm9kZWNvbnRhaW5lciA9IHRoaXMuY2hpbGREb207XHJcbiAgICAgICAgICAgIGlmIChub2RlY29udGFpbmVyKSB7XHJcbiAgICAgICAgICAgICAgICBub2RlY29udGFpbmVyLmlubmVySFRNTCA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChjaGlsZENvdW50ID4gMCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFub2RlY29udGFpbmVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZWNvbnRhaW5lciA9IHRoaXMuY2hpbGREb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGVjb250YWluZXIuY2xhc3NOYW1lID0gXCJub2RlY29udGFpbmVyXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgZG9tLmFwcGVuZENoaWxkKG5vZGVjb250YWluZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gY29uc3QgY2hpbGRJbnNldCA9IHRoaXMuc2hvd09ubHlDaGlsZHMgPyBpbnNldCA6IChpbnNldCArIGluc2V0U2VsZik7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2hpbGRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZWNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmNoaWxkc1tpXS5yZW5kZXIoaW5zZXQgKyAxKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5kb20uc3R5bGUuZGlzcGxheSA9IHRoaXMuaGlkZUVtcHR5Tm9kZSAmJiBjaGlsZENvdW50ID09PSAwID8gXCJub25lXCIgOiBcImZsZXhcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5pbnNldENoaWxkcyA9IHRoaXMuc2hvd09ubHlDaGlsZHMgPyBpbnNldCA6IGluc2V0ICsgMTtcclxuICAgICAgICByZXR1cm4gZG9tO1xyXG4gICAgfVxyXG59XHJcblxyXG5sZXQgc2NhbGVEb206IGFueSA9IHVuZGVmaW5lZDtcclxuZnVuY3Rpb24gY3JlYXRlWm9vbVNjYWxlKCkge1xyXG4gICAgaWYgKCFzY2FsZURvbSkge1xyXG4gICAgICAgIC8qXHJcbiAgICAgICAgY29uc3QgczEgPSBgXHJcbiAgICAgICAgPHN2ZyB3aWR0aD1cIjI0OFwiIGhlaWdodD1cIjgwXCIgdmVyc2lvbj1cIjEuMVwiIHByZXNlcnZlQXNwZWN0UmF0aW89XCJub25lXCIgdmlld0JveD1cIjEwIDAgMjIzIDYwXCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPlxyXG4gICAgICAgIDxnIGZvbnQtZmFtaWx5PVwic2Fucy1zZXJpZlwiIGZvbnQtc2l6ZT1cIjhweFwiIGxldHRlci1zcGFjaW5nPVwiMHB4XCIgc3Ryb2tlLXdpZHRoPVwiLjI2NDU4XCIgd29yZC1zcGFjaW5nPVwiMHB4XCI+XHJcbiAgICAgICAgICAgIDx0ZXh0IGNsYXNzPVwicDAxXCIgeD1cIjIwXCIgeT1cIjEyXCI+MTwvdGV4dD5cclxuICAgICAgICAgICAgPHRleHQgY2xhc3M9XCJwMDJcIiB4PVwiNDBcIiB5PVwiMTJcIj4yPC90ZXh0PlxyXG4gICAgICAgICAgICA8dGV4dCBjbGFzcz1cInAwM1wiIHg9XCI2MFwiIHk9XCIxMlwiPjM8L3RleHQ+XHJcbiAgICAgICAgICAgIDx0ZXh0IGNsYXNzPVwicDA0XCIgeD1cIjgwXCIgeT1cIjEyXCI+NDwvdGV4dD5cclxuICAgICAgICAgICAgPHRleHQgY2xhc3M9XCJwMDVcIiB4PVwiMTAwXCIgeT1cIjEyXCI+NTwvdGV4dD5cclxuICAgICAgICAgICAgPHRleHQgY2xhc3M9XCJwMDZcIiB4PVwiMTIwXCIgeT1cIjEyXCI+NjwvdGV4dD5cclxuICAgICAgICAgICAgPHRleHQgY2xhc3M9XCJwMDdcIiB4PVwiMTQwXCIgeT1cIjEyXCI+NzwvdGV4dD5cclxuICAgICAgICAgICAgPHRleHQgY2xhc3M9XCJwMDhcIiB4PVwiMTYwXCIgeT1cIjEyXCI+ODwvdGV4dD5cclxuICAgICAgICAgICAgPHRleHQgY2xhc3M9XCJwMDlcIiB4PVwiMTgwXCIgeT1cIjEyXCI+OTwvdGV4dD5cclxuICAgICAgICAgICAgPHRleHQgY2xhc3M9XCJwMTBcIiB4PVwiMjAwXCIgeT1cIjEyXCI+MTA8L3RleHQ+XHJcbiAgICAgICAgICAgIDx0ZXh0IGNsYXNzPVwicDExXCIgeD1cIjIyMFwiIHk9XCIxMlwiPjExPC90ZXh0PlxyXG4gICAgICAgIDwvZz5cclxuICAgICAgICA8cGF0aCBjbGFzcz1cInAwMVwiIGQ9XCJNIDEyIDM1IGwgMjAgMSBsIDAgIC04IGwgLTIwIDEgbCAwICA2XCIgc3Ryb2tlPVwiZ3JheVwiIGZpbGw9XCJsaWdodGdyYXlcIiAvPlxyXG4gICAgICAgIDxwYXRoIGNsYXNzPVwicDAyXCIgZD1cIk0gMzIgMzYgbCAyMCAxIGwgMCAtMTAgbCAtMjAgMSBsIDAgIDhcIiBzdHJva2U9XCJncmF5XCIgZmlsbD1cImxpZ2h0Z3JheVwiIC8+XHJcbiAgICAgICAgPHBhdGggY2xhc3M9XCJwMDNcIiBkPVwiTSA1MiAzNyBsIDIwIDEgbCAwIC0xMiBsIC0yMCAxIGwgMCAxMFwiIHN0cm9rZT1cImdyYXlcIiBmaWxsPVwibGlnaHRncmF5XCIgLz5cclxuICAgICAgICA8cGF0aCBjbGFzcz1cInAwNFwiIGQ9XCJNIDcyIDM4IGwgMjAgMSBsIDAgLTE0IGwgLTIwIDEgbCAwIDEyXCIgc3Ryb2tlPVwiZ3JheVwiIGZpbGw9XCJsaWdodGdyYXlcIiAvPlxyXG4gICAgICAgIDxwYXRoIGNsYXNzPVwicDA1XCIgZD1cIk0gOTIgMzkgbCAyMCAxIGwgMCAtMTYgbCAtMjAgMSBsIDAgMTRcIiBzdHJva2U9XCJncmF5XCIgZmlsbD1cImxpZ2h0Z3JheVwiIC8+XHJcbiAgICAgICAgPHBhdGggY2xhc3M9XCJwMDZcIiBkPVwiTSAxMTIgNDAgbCAyMCAxIGwgMCAtMTggbCAtMjAgMSBsIDAgMTZcIiBzdHJva2U9XCJncmF5XCIgZmlsbD1cImxpZ2h0Z3JheVwiIC8+XHJcbiAgICAgICAgPHBhdGggY2xhc3M9XCJwMDdcIiBkPVwiTSAxMzIgNDEgbCAyMCAxIGwgMCAtMjAgbCAtMjAgMSBsIDAgMThcIiBzdHJva2U9XCJncmF5XCIgZmlsbD1cImxpZ2h0Z3JheVwiIC8+XHJcbiAgICAgICAgPHBhdGggY2xhc3M9XCJwMDhcIiBkPVwiTSAxNTIgNDIgbCAyMCAxIGwgMCAtMjIgbCAtMjAgMSBsIDAgMjBcIiBzdHJva2U9XCJncmF5XCIgZmlsbD1cImxpZ2h0Z3JheVwiIC8+XHJcbiAgICAgICAgPHBhdGggY2xhc3M9XCJwMDlcIiBkPVwiTSAxNzIgNDMgbCAyMCAxIGwgMCAtMjQgbCAtMjAgMSBsIDAgMjJcIiBzdHJva2U9XCJncmF5XCIgZmlsbD1cImxpZ2h0Z3JheVwiIC8+XHJcbiAgICAgICAgPHBhdGggY2xhc3M9XCJwMTBcIiBkPVwiTSAxOTIgNDQgbCAyMCAxIGwgMCAtMjYgbCAtMjAgMSBsIDAgMjRcIiBzdHJva2U9XCJncmF5XCIgZmlsbD1cImxpZ2h0Z3JheVwiIC8+XHJcbiAgICAgICAgPHBhdGggY2xhc3M9XCJwMTFcIiBkPVwiTSAyMTIgNDUgbCAyMCAxIGwgMCAtMjggbCAtMjAgMSBsIDAgMjZcIiBzdHJva2U9XCJncmF5XCIgZmlsbD1cImxpZ2h0Z3JheVwiIC8+XHJcblxyXG4gICAgICAgIDxwYXRoIGNsYXNzPVwiejAxXCIgZD1cIk0gMTIgMzUgbCAyMCAxIGwgMCAgLTggbCAtMjAgMSBsIDAgIDZcIiB2aXNpYmlsaXR5PVwiaGlkZGVuXCIgLz5cclxuICAgICAgICA8cGF0aCBjbGFzcz1cInowMlwiIGQ9XCJNIDMyIDM2IGwgMjAgMSBsIDAgLTEwIGwgLTIwIDEgbCAwICA4XCIgdmlzaWJpbGl0eT1cImhpZGRlblwiIC8+XHJcbiAgICAgICAgPHBhdGggY2xhc3M9XCJ6MDNcIiBkPVwiTSA1MiAzNyBsIDIwIDEgbCAwIC0xMiBsIC0yMCAxIGwgMCAxMFwiIHZpc2liaWxpdHk9XCJoaWRkZW5cIiAvPlxyXG4gICAgICAgIDxwYXRoIGNsYXNzPVwiejA0XCIgZD1cIk0gNzIgMzggbCAyMCAxIGwgMCAtMTQgbCAtMjAgMSBsIDAgMTJcIiB2aXNpYmlsaXR5PVwiaGlkZGVuXCIgLz5cclxuICAgICAgICA8cGF0aCBjbGFzcz1cInowNVwiIGQ9XCJNIDkyIDM5IGwgMjAgMSBsIDAgLTE2IGwgLTIwIDEgbCAwIDE0XCIgdmlzaWJpbGl0eT1cImhpZGRlblwiIC8+XHJcbiAgICAgICAgPHBhdGggY2xhc3M9XCJ6MDZcIiBkPVwiTSAxMTIgNDAgbCAyMCAxIGwgMCAtMTggbCAtMjAgMSBsIDAgMTZcIiB2aXNpYmlsaXR5PVwiaGlkZGVuXCIgLz5cclxuICAgICAgICA8cGF0aCBjbGFzcz1cInowN1wiIGQ9XCJNIDEzMiA0MSBsIDIwIDEgbCAwIC0yMCBsIC0yMCAxIGwgMCAxOFwiIHZpc2liaWxpdHk9XCJoaWRkZW5cIiAvPlxyXG4gICAgICAgIDxwYXRoIGNsYXNzPVwiejA4XCIgZD1cIk0gMTUyIDQyIGwgMjAgMSBsIDAgLTIyIGwgLTIwIDEgbCAwIDIwXCIgdmlzaWJpbGl0eT1cImhpZGRlblwiIC8+XHJcbiAgICAgICAgPHBhdGggY2xhc3M9XCJ6MDlcIiBkPVwiTSAxNzIgNDMgbCAyMCAxIGwgMCAtMjQgbCAtMjAgMSBsIDAgMjJcIiB2aXNpYmlsaXR5PVwiaGlkZGVuXCIgLz5cclxuICAgICAgICA8cGF0aCBjbGFzcz1cInoxMFwiIGQ9XCJNIDE5MiA0NCBsIDIwIDEgbCAwIC0yNiBsIC0yMCAxIGwgMCAyNFwiIHZpc2liaWxpdHk9XCJoaWRkZW5cIiAvPlxyXG4gICAgICAgIDxwYXRoIGNsYXNzPVwiejExXCIgZD1cIk0gMjEyIDQ1IGwgMjAgMSBsIDAgLTI4IGwgLTIwIDEgbCAwIDI2XCIgdmlzaWJpbGl0eT1cImhpZGRlblwiIC8+XHJcblxyXG4gICAgPC9zdmc+XHJcbiAgICBgOyovXHJcbiAgICAgICAgY29uc3QgcyA9IGBcclxuICAgIDxzdmcgd2lkdGg9XCIyNDhcIiBoZWlnaHQ9XCI4MFwiIHZlcnNpb249XCIxLjFcIiBwcmVzZXJ2ZUFzcGVjdFJhdGlvPVwibm9uZVwiIHZpZXdCb3g9XCIxMCAwIDIyMyA2MFwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj5cclxuICAgIDxnIGZvbnQtZmFtaWx5PVwic2Fucy1zZXJpZlwiIGZvbnQtc2l6ZT1cIjhweFwiIGxldHRlci1zcGFjaW5nPVwiMHB4XCIgc3Ryb2tlLXdpZHRoPVwiLjI2NDU4XCIgd29yZC1zcGFjaW5nPVwiMHB4XCI+XHJcbiAgICAgICAgPHRleHQgY2xhc3M9XCJwMDFcIiB4PVwiMjBcIiB5PVwiMTJcIj4xPC90ZXh0Pjx0ZXh0IGNsYXNzPVwicDAyXCIgeD1cIjQwXCIgeT1cIjEyXCI+MjwvdGV4dD48dGV4dCBjbGFzcz1cInAwM1wiIHg9XCI2MFwiIHk9XCIxMlwiPjM8L3RleHQ+XHJcbiAgICAgICAgPHRleHQgY2xhc3M9XCJwMDRcIiB4PVwiODBcIiB5PVwiMTJcIj40PC90ZXh0Pjx0ZXh0IGNsYXNzPVwicDA1XCIgeD1cIjEwMFwiIHk9XCIxMlwiPjU8L3RleHQ+PHRleHQgY2xhc3M9XCJwMDZcIiB4PVwiMTIwXCIgeT1cIjEyXCI+NjwvdGV4dD5cclxuICAgICAgICA8dGV4dCBjbGFzcz1cInAwN1wiIHg9XCIxNDBcIiB5PVwiMTJcIj43PC90ZXh0Pjx0ZXh0IGNsYXNzPVwicDA4XCIgeD1cIjE2MFwiIHk9XCIxMlwiPjg8L3RleHQ+PHRleHQgY2xhc3M9XCJwMDlcIiB4PVwiMTgwXCIgeT1cIjEyXCI+OTwvdGV4dD5cclxuICAgICAgICA8dGV4dCBjbGFzcz1cInAxMFwiIHg9XCIyMDBcIiB5PVwiMTJcIj4xMDwvdGV4dD48dGV4dCBjbGFzcz1cInAxMVwiIHg9XCIyMjBcIiB5PVwiMTJcIj4xMTwvdGV4dD5cclxuICAgIDwvZz5cclxuICAgIDxwYXRoIGNsYXNzPVwicDAxXCIgZD1cIk0gIDEyIDM1IGwgMjAgMCBsIDAgIC02IGwgLTIwIDAgbCAwICA2XCIgc3Ryb2tlPVwiZ3JheVwiIGZpbGw9XCJsaWdodGdyYXlcIiAvPlxyXG4gICAgPHBhdGggY2xhc3M9XCJwMDJcIiBkPVwiTSAgMzIgMzYgbCAyMCAwIGwgMCAgLTggbCAtMjAgMCBsIDAgIDhcIiBzdHJva2U9XCJncmF5XCIgZmlsbD1cImxpZ2h0Z3JheVwiIC8+XHJcbiAgICA8cGF0aCBjbGFzcz1cInAwM1wiIGQ9XCJNICA1MiAzNyBsIDIwIDAgbCAwIC0xMCBsIC0yMCAwIGwgMCAxMFwiIHN0cm9rZT1cImdyYXlcIiBmaWxsPVwibGlnaHRncmF5XCIgLz5cclxuICAgIDxwYXRoIGNsYXNzPVwicDA0XCIgZD1cIk0gIDcyIDM4IGwgMjAgMCBsIDAgLTEyIGwgLTIwIDAgbCAwIDEyXCIgc3Ryb2tlPVwiZ3JheVwiIGZpbGw9XCJsaWdodGdyYXlcIiAvPlxyXG4gICAgPHBhdGggY2xhc3M9XCJwMDVcIiBkPVwiTSAgOTIgMzkgbCAyMCAwIGwgMCAtMTQgbCAtMjAgMCBsIDAgMTRcIiBzdHJva2U9XCJncmF5XCIgZmlsbD1cImxpZ2h0Z3JheVwiIC8+XHJcbiAgICA8cGF0aCBjbGFzcz1cInAwNlwiIGQ9XCJNIDExMiA0MCBsIDIwIDAgbCAwIC0xNiBsIC0yMCAwIGwgMCAxNlwiIHN0cm9rZT1cImdyYXlcIiBmaWxsPVwibGlnaHRncmF5XCIgLz5cclxuICAgIDxwYXRoIGNsYXNzPVwicDA3XCIgZD1cIk0gMTMyIDQxIGwgMjAgMCBsIDAgLTE4IGwgLTIwIDAgbCAwIDE4XCIgc3Ryb2tlPVwiZ3JheVwiIGZpbGw9XCJsaWdodGdyYXlcIiAvPlxyXG4gICAgPHBhdGggY2xhc3M9XCJwMDhcIiBkPVwiTSAxNTIgNDIgbCAyMCAwIGwgMCAtMjAgbCAtMjAgMCBsIDAgMjBcIiBzdHJva2U9XCJncmF5XCIgZmlsbD1cImxpZ2h0Z3JheVwiIC8+XHJcbiAgICA8cGF0aCBjbGFzcz1cInAwOVwiIGQ9XCJNIDE3MiA0MyBsIDIwIDAgbCAwIC0yMiBsIC0yMCAwIGwgMCAyMlwiIHN0cm9rZT1cImdyYXlcIiBmaWxsPVwibGlnaHRncmF5XCIgLz5cclxuICAgIDxwYXRoIGNsYXNzPVwicDEwXCIgZD1cIk0gMTkyIDQ0IGwgMjAgMCBsIDAgLTI0IGwgLTIwIDAgbCAwIDI0XCIgc3Ryb2tlPVwiZ3JheVwiIGZpbGw9XCJsaWdodGdyYXlcIiAvPlxyXG4gICAgPHBhdGggY2xhc3M9XCJwMTFcIiBkPVwiTSAyMTIgNDUgbCAyMCAwIGwgMCAtMjYgbCAtMjAgMCBsIDAgMjZcIiBzdHJva2U9XCJncmF5XCIgZmlsbD1cImxpZ2h0Z3JheVwiIC8+XHJcblxyXG4gICAgPHBhdGggY2xhc3M9XCJ6MDFcIiBkPVwiTSAgMTIgMzUgbCAyMCAwIGwgMCAgLTYgbCAtMjAgMCBsIDAgIDZcIiB2aXNpYmlsaXR5PVwiaGlkZGVuXCIgLz5cclxuICAgIDxwYXRoIGNsYXNzPVwiejAyXCIgZD1cIk0gIDMyIDM2IGwgMjAgMCBsIDAgIC04IGwgLTIwIDAgbCAwICA4XCIgdmlzaWJpbGl0eT1cImhpZGRlblwiIC8+XHJcbiAgICA8cGF0aCBjbGFzcz1cInowM1wiIGQ9XCJNICA1MiAzNyBsIDIwIDAgbCAwIC0xMCBsIC0yMCAwIGwgMCAxMFwiIHZpc2liaWxpdHk9XCJoaWRkZW5cIiAvPlxyXG4gICAgPHBhdGggY2xhc3M9XCJ6MDRcIiBkPVwiTSAgNzIgMzggbCAyMCAwIGwgMCAtMTIgbCAtMjAgMCBsIDAgMTJcIiB2aXNpYmlsaXR5PVwiaGlkZGVuXCIgLz5cclxuICAgIDxwYXRoIGNsYXNzPVwiejA1XCIgZD1cIk0gIDkyIDM5IGwgMjAgMCBsIDAgLTE0IGwgLTIwIDAgbCAwIDE0XCIgdmlzaWJpbGl0eT1cImhpZGRlblwiIC8+XHJcbiAgICA8cGF0aCBjbGFzcz1cInowNlwiIGQ9XCJNIDExMiA0MCBsIDIwIDAgbCAwIC0xNiBsIC0yMCAwIGwgMCAxNlwiIHZpc2liaWxpdHk9XCJoaWRkZW5cIiAvPlxyXG4gICAgPHBhdGggY2xhc3M9XCJ6MDdcIiBkPVwiTSAxMzIgNDEgbCAyMCAwIGwgMCAtMTggbCAtMjAgMCBsIDAgMThcIiB2aXNpYmlsaXR5PVwiaGlkZGVuXCIgLz5cclxuICAgIDxwYXRoIGNsYXNzPVwiejA4XCIgZD1cIk0gMTUyIDQyIGwgMjAgMCBsIDAgLTIwIGwgLTIwIDAgbCAwIDIwXCIgdmlzaWJpbGl0eT1cImhpZGRlblwiIC8+XHJcbiAgICA8cGF0aCBjbGFzcz1cInowOVwiIGQ9XCJNIDE3MiA0MyBsIDIwIDAgbCAwIC0yMiBsIC0yMCAwIGwgMCAyMlwiIHZpc2liaWxpdHk9XCJoaWRkZW5cIiAvPlxyXG4gICAgPHBhdGggY2xhc3M9XCJ6MTBcIiBkPVwiTSAxOTIgNDQgbCAyMCAwIGwgMCAtMjQgbCAtMjAgMCBsIDAgMjRcIiB2aXNpYmlsaXR5PVwiaGlkZGVuXCIgLz5cclxuICAgIDxwYXRoIGNsYXNzPVwiejExXCIgZD1cIk0gMjEyIDQ1IGwgMjAgMCBsIDAgLTI2IGwgLTIwIDAgbCAwIDI2XCIgdmlzaWJpbGl0eT1cImhpZGRlblwiIC8+XHJcblxyXG48L3N2Zz5cclxuYDtcclxuICAgICAgICBjb25zdCBwYXJzZXIgPSBuZXcgRE9NUGFyc2VyKCk7XHJcbiAgICAgICAgY29uc3QgZG9jID0gcGFyc2VyLnBhcnNlRnJvbVN0cmluZyhzLCBcInRleHQvaHRtbFwiKTtcclxuICAgICAgICBjb25zdCBmcmFnbWVudCA9IGRvYy5xdWVyeVNlbGVjdG9yKFwic3ZnXCIpO1xyXG4gICAgICAgIGNvbnN0IGQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG4gICAgICAgIGQuaW5uZXJIVE1MID0gcztcclxuICAgICAgICBzY2FsZURvbSA9IGZyYWdtZW50OyAvLy5xdWVyeVNlbGVjdG9yKFwic3ZnXCIpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHNjYWxlRG9tLmNsb25lTm9kZSh0cnVlKTtcclxufVxyXG5cclxuY29uc3QgU0NBTEVTID1cclxuICAgIC8vIFs1OTE2NTc1NTAuNSwgMjk1ODI4Nzc1LjMsIDE0NzkxNDM4Ny42LCA3Mzk1NzE5My44MiwgMzY5Nzg1OTYuOTEsIDE4NDg5Mjk4LjQ1LCA5MjQ0NjQ5LjIyNywgNDYyMjMyNC42MTQsIDIzMTExNjIuMzA3LCAxMTU1NTgxLjE1MywgNTc3NzkwLjU3NjcsIDI4ODg5NS4yODg0LCAxNDQ0NDcuNjQ0MiwgNzIyMjMuODIyMDksIDM2MTExLjkxMTA0LCAxODA1NS45NTU1MiwgOTAyNy45Nzc3NjEsIDQ1MTMuOTg4ODgsIDIyNTYuOTk0NDQsIDExMjguNDk3MjJdO1xyXG4gICAgWzAsIDAsIDAsIDAsIDAsIDE3NDcxMzIwLjc1MDksIDg3MzU2NjAuMzc1NDUsIDQzNjc4MzAuMTg3NzIsIDIxODM5MTUuMDkzODYsIDEwOTE5NTcuNTQ2OTMsIDU0NTk3OC43NzM0NjYsIDI3Mjk4OS4zODY3MzMsIDEzNjQ5NC42OTMzNjYsIDY4MjQ3LjM0NjY4MzIsIDM0MTIzLjY3MzM0MTQsIDE3MDYxLjgzNjY3MDcsIDg1MzAuOTE4MzM1MzYsIDQyNjUuNDU5MTY3ODYsIDIxMzIuNzI5NTgzOTMsIDEwNjYuMzY0NzkxNzldO1xyXG5cclxuY2xhc3MgTGF5ZXJOb2RlIGV4dGVuZHMgVHJlZU5vZGUge1xyXG4gICAgaW5mb0ljb246IEhUTUxTcGFuRWxlbWVudDtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihsYXllcjogTGF5ZXJXcmFwcGVyKSB7XHJcbiAgICAgICAgc3VwZXIobGF5ZXIpO1xyXG4gICAgfVxyXG5cclxuICAgIHJlbmRlcihpbnNldD86IG51bWJlcik6IEhUTUxFbGVtZW50IHtcclxuICAgICAgICAvLyBjb25zdCBjb2wgPSBUcmVlTm9kZS5nZXRUcmVlUGF0aCh0aGlzKS5sZW5ndGg7XHJcbiAgICAgICAgaWYgKCFpbnNldCkge1xyXG4gICAgICAgICAgICBpbnNldCA9IDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgZG9tID0gdGhpcy5kb207XHJcbiAgICAgICAgbGV0IHRyZWVyb3cgPSB0aGlzLnRyZWVyb3c7XHJcbiAgICAgICAgaWYgKCFkb20pIHtcclxuICAgICAgICAgICAgZG9tID0gdGhpcy5kb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG4gICAgICAgICAgICBkb20uY2xhc3NOYW1lID0gXCJyb3ctd3JhcHBlciByb3ctd3JhcHBlci1cIiArIGluc2V0O1xyXG4gICAgICAgICAgICB0cmVlcm93ID0gdGhpcy50cmVlcm93ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcclxuICAgICAgICAgICAgZG9tLmFwcGVuZENoaWxkKHRyZWVyb3cpO1xyXG4gICAgICAgICAgICAvLyB0cmVlcm93LmlkID0gXCJ0cmVlcm93XCIgKyBUcmVlTm9kZS5ub2RlQ291bnRlcisrXHJcbiAgICAgICAgICAgIHRyZWVyb3cuY2xhc3NOYW1lID0gXCJ0cmVlcm93XCI7XHJcbiAgICAgICAgICAgIC8vIGNvbnN0IGNiOiBIVE1MSW5wdXRFbGVtZW50ID0gdGhpcy5fY3JlYXRlQ2Vja0JveCgpO1xyXG4gICAgICAgICAgICBjb25zdCBjYiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XHJcbiAgICAgICAgICAgIGNiLmNsYXNzTmFtZSA9IFwiY2JfbGF5ZXJcIjtcclxuXHJcbiAgICAgICAgICAgIGxldCBjaEJveDogSFRNTElucHV0RWxlbWVudDtcclxuICAgICAgICAgICAgY2hCb3ggPSB0aGlzLmNoQm94ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xyXG4gICAgICAgICAgICBjaEJveC50eXBlID0gXCJjaGVja2JveFwiO1xyXG4gICAgICAgICAgICBjaEJveC5pZCA9IFwiY2JcIiArIHRoaXMuZGF0YS5pZDtcclxuICAgICAgICAgICAgLy8gY2hCb3guY2xhc3NOYW1lID0gXCJyZWd1bGFyLWNoZWNrYm94XCI7XHJcbiAgICAgICAgICAgIC8vIGNoQm94LnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgKTtcclxuICAgICAgICAgICAgLy8gY2hCb3guY2hlY2tlZCA9IHRoaXMuc2VsZWN0aW9uU3RhdHVzID09PSBTZWxlY3Rpb25TdGF0dXMuU0VMRUNURUQgfHwgdGhpcy5zZWxlY3Rpb25TdGF0dXMgPT09IFNlbGVjdGlvblN0YXR1cy5JTkRFVEVSTUlOQVRFO1xyXG4gICAgICAgICAgICAvLyBjaEJveC5pbmRldGVybWluYXRlID0gdGhpcy5zZWxlY3Rpb25TdGF0dXMgPT09IFNlbGVjdGlvblN0YXR1cy5JTkRFVEVSTUlOQVRFO1xyXG4gICAgICAgICAgICBjaEJveC5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIChldikgPT4gdGhpcy5vbmNoQm94Q2hhbmdlKGV2KSk7XHJcbiAgICAgICAgICAgIGNiLmFwcGVuZENoaWxkKGNoQm94KTtcclxuICAgICAgICAgICAgdHJlZXJvdy5hcHBlbmRDaGlsZChjYik7XHJcbiAgICAgICAgICAgIGNvbnN0IGxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxhYmVsXCIpO1xyXG4gICAgICAgICAgICBsYWJlbC5odG1sRm9yID0gXCJjYlwiICsgdGhpcy5kYXRhLmlkO1xyXG4gICAgICAgICAgICAvLyB0cmVlcm93LmFwcGVuZENoaWxkKGxhYmVsKTtcclxuICAgICAgICAgICAgY2IuYXBwZW5kQ2hpbGQobGFiZWwpO1xyXG4gICAgICAgICAgICAvLyBsYWJlbC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAvLyAgICAgY2IuY2xpY2soKTtcclxuICAgICAgICAgICAgLy8gfSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGxheWVyID0gPExheWVyV3JhcHBlcj50aGlzLmRhdGE7XHJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUuaW5mbygnTGF5ZXJDb250cm9sVmFyLkxheWVyTm9kZVJlbmRlcmVyLnJlbmRlcicsIGxheWVyKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGxheWVyVGl0bGUgPSBjcmVhdGVIdG1sRWxlbWVudChcImRpdlwiLCB0cmVlcm93LCBcImxheWVyLXRpdGxlIHRvb2x0aXBcIik7XHJcblxyXG4gICAgICAgICAgICBjb25zdCB0eHQgPSBsYXllci5sYXllckRlc2NyaXB0aW9uLmxhYmVsO1xyXG4gICAgICAgICAgICBpZiAoIXR4dCkge1xyXG4gICAgICAgICAgICAgICAgZGVidWdnZXI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGF5ZXJUaXRsZS5pbm5lckhUTUwgPSB0eHQ7XHJcbiAgICAgICAgICAgIGxheWVyVGl0bGUuZGF0YXNldC50b29sdGlwID0gdHh0O1xyXG4gICAgICAgICAgICBsYXllclRpdGxlLnNldEF0dHJpYnV0ZShcImRhdGEtdG9vbHRpcFwiLCB0eHQpO1xyXG4gICAgICAgICAgICBsYXllclRpdGxlLnRpdGxlID0gdHh0O1xyXG5cclxuICAgICAgICAgICAgaWYgKGxheWVyLmxheWVyRGVzY3JpcHRpb24udHlwZSA9PT0gXCJXTVNcIikge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZiA9IChldjogRXZlbnQpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmluZm8oXCJzZXRPcGFjaXR5XCIsICg8YW55PmxheWVyLmxheWVyKS5vcHRpb25zLm9wYWNpdHkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHYgPSAwLjAxICogcGFyc2VJbnQoKDxhbnk+ZXYudGFyZ2V0KS52YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxheWVyLmxheWVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICg8YW55PmxheWVyLmxheWVyKS5zZXRPcGFjaXR5KHYpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxheWVyLmxheWVyRGVzY3JpcHRpb24ub3B0aW9uc1tcIm9wYWNpdHlcIl0gPSB2O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvLyBjb25zdCB2ID0gbGF5ZXIubGF5ZXI/LltcIm9wdGlvbnNcIl0ub3BhY2l0eSA/PyBsYXllci5sYXllckRlc2NyaXB0aW9uPy5vcHRpb25zPy5bXCJvcGFjaXR5XCJdIHx8IDE7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB2ID0gbGF5ZXIubGF5ZXJEZXNjcmlwdGlvbj8ub3B0aW9ucz8uW1wib3BhY2l0eVwiXSA/PyAxO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZFYgPSAxMDAgKiBwYXJzZUZsb2F0KHYpO1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnN0IHNsaWRlciA9IGNyZWF0ZVNsaWRlcihcIjBcIiwgXCIxMDBcIiwgZFYudG9TdHJpbmcoKSwgZiwgXCJvcGFjaXR5LXNsaWRlclwiKTtcclxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUuaW5mbyhcInNsaWRlclwiLCBsYXllci5sYXllckRlc2NyaXB0aW9uLmxhYmVsLCB2LCBkVik7XHJcbiAgICAgICAgICAgICAgICAvLyBsYXllclRpdGxlLmFwcGVuZENoaWxkKHNsaWRlcik7XHJcbiAgICAgICAgICAgICAgICBkb20uYXBwZW5kQ2hpbGQoc2xpZGVyKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGxheWVyLmxheWVyRGVzY3JpcHRpb24ubWluU2NhbGUgfHwgbGF5ZXIubGF5ZXJEZXNjcmlwdGlvbi5tYXhTY2FsZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gY29uc3QgaW1nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImltZ1wiKTtcclxuICAgICAgICAgICAgICAgIC8vIGltZy5zcmMgPSBcImltYWdlcy9zY2FsZTIuc3ZnXCI7XHJcbiAgICAgICAgICAgICAgICAvLyBsYXllclRpdGxlLmFwcGVuZENoaWxkKGltZyk7XHJcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmluZm8oXCJNaW5NYXhcIiwgbGF5ZXIpO1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSA4OyBpIDw9IDE5OyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmVycm9yKFwiem9vbSBcIiArIGkgKyBcIiAgc2NhbGU9XCIgKyBMLkNSU1tcInNjYWxlXCJdKGkpKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzY2FsZSA9IFNDQUxFU1tpXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobGF5ZXIubGF5ZXJEZXNjcmlwdGlvbi5taW5TY2FsZSAmJiBzY2FsZSA8IGxheWVyLmxheWVyRGVzY3JpcHRpb24ubWluU2NhbGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZG9tLmNsYXNzTGlzdC5hZGQoXCJ6XCIgKyBpICsgXCJkaXNhYmxlZFwiKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxheWVyLmxheWVyRGVzY3JpcHRpb24ubWF4U2NhbGUgJiYgc2NhbGUgPiBsYXllci5sYXllckRlc2NyaXB0aW9uLm1heFNjYWxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbS5jbGFzc0xpc3QuYWRkKFwielwiICsgaSArIFwiZGlzYWJsZWRcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZG9tLmFwcGVuZENoaWxkKGNyZWF0ZVpvb21TY2FsZSgpKTtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcInpvb21TY2FsZVwiLCBsYXllci5sYXllckRlc2NyaXB0aW9uLmxhYmVsLCBkb20pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjb25zdCBpbmZvSWNvbiA9ICh0aGlzLmluZm9JY29uID0gY3JlYXRlSHRtbEVsZW1lbnQoXCJzcGFuXCIsIHRyZWVyb3csIFwiaW5mby1pY29uXCIpKTtcclxuXHJcbiAgICAgICAgICAgIGluZm9JY29uLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoZXYpID0+IHtcclxuICAgICAgICAgICAgICAgIE1hcERpc3BhdGNoZXIub25TaG93TGF5ZXJJbmZvUmVxdWVzdC5kaXNwYXRjaCh0aGlzLCBsYXllcik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZG9tO1xyXG4gICAgfVxyXG5cclxuICAgIHNldFN0YXR1cyhzdGF0dXM6IFwid2FpdGluZ1wiIHwgXCJlcnJvclwiIHwgXCJva1wiKSB7XHJcbiAgICAgICAgc3dpdGNoIChzdGF0dXMpIHtcclxuICAgICAgICAgICAgY2FzZSBcIndhaXRpbmdcIjpcclxuICAgICAgICAgICAgICAgIHRoaXMuaW5mb0ljb24uY2xhc3NMaXN0LnJlbW92ZShcImVycm9yXCIpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbmZvSWNvbi5jbGFzc0xpc3QuYWRkKFwid2FpdGluZ1wiKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwiZXJyb3JcIjpcclxuICAgICAgICAgICAgICAgIHRoaXMuaW5mb0ljb24uY2xhc3NMaXN0LnJlbW92ZShcIndhaXRpbmdcIik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmluZm9JY29uLmNsYXNzTGlzdC5hZGQoXCJlcnJvclwiKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdGhpcy5pbmZvSWNvbi5jbGFzc0xpc3QucmVtb3ZlKFwiZXJyb3JcIik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmluZm9JY29uLmNsYXNzTGlzdC5yZW1vdmUoXCJ3YWl0aW5nXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKipcclxuICogIE5vZGVzIGZvciBUcmVlIFwiTWVpbmUgS2FydGVuYXVzd2FobFwiXHJcbiAqL1xyXG5jbGFzcyBUcmVlMk5vZGUgZXh0ZW5kcyBUcmVlTm9kZSB7XHJcbiAgICBmQ2hhbmdlTm9kZU9yZGVyOiAoZXZ0OiBDaGFuZ2VOb2RlT3JkZXJFdmVudCkgPT4gdm9pZDtcclxuXHJcbiAgICBvblRyZWVEZWxldGVJY29uQ2xpY2sgPSBuZXcgRXZlbnREaXNwYXRjaGVyPFRyZWVOb2RlLCBhbnk+KCk7XHJcbiAgICBpbmZvSWNvbjogSFRNTFNwYW5FbGVtZW50O1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGRhdGE6IExheWVyV3JhcHBlciwgY2hpbGRzPzogQXJyYXk8VHJlZU5vZGU+LCBwYXJhbXM/OiBUcmVlTm9kZVBhcmFtKSB7XHJcbiAgICAgICAgc3VwZXIoZGF0YSwgY2hpbGRzLCBwYXJhbXMpO1xyXG4gICAgICAgIHRoaXMuZkNoYW5nZU5vZGVPcmRlciA9IHBhcmFtcy5mQ2hhbmdlTm9kZU9yZGVyO1xyXG4gICAgfVxyXG5cclxuICAgIHJlbmRlcihpbnNldDogbnVtYmVyKTogSFRNTEVsZW1lbnQge1xyXG4gICAgICAgIGNvbnNvbGUuaW5mbyhgVHJlZTJOb2RlLnJlbmRlciBzZWxlY3RNb2RlPSR7dGhpcy5nZXRTZWxlY3RNb2RlKCl9YCk7XHJcbiAgICAgICAgbGV0IGRvbSA9IHRoaXMuZG9tO1xyXG4gICAgICAgIC8vIGxldCB0cmVlcm93ID0gdGhpcy50cmVlcm93XHJcbiAgICAgICAgaWYgKCFkb20pIHtcclxuICAgICAgICAgICAgZG9tID0gdGhpcy5kb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG4gICAgICAgICAgICBkb20uY2xhc3NOYW1lID0gXCJyb3ctd3JhcHBlclwiO1xyXG4gICAgICAgICAgICBjb25zdCB0cmVlcm93ID0gKHRoaXMudHJlZXJvdyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpO1xyXG4gICAgICAgICAgICAvLyAgdHJlZXJvdy5pZCA9IFwidHJlZXJvd1wiICsgbm9kZUNvdW50ZXJcclxuICAgICAgICAgICAgdHJlZXJvdy5jbGFzc05hbWUgPSBcInRyZWVyb3dcIjtcclxuXHJcbiAgICAgICAgICAgIGRvbS5hcHBlbmRDaGlsZCh0cmVlcm93KTtcclxuXHJcbiAgICAgICAgICAgIC8vIGNvbnN0IHNlbGVjdE1vZGUgPSB0aGlzLmdldFNlbGVjdE1vZGUoKTtcclxuICAgICAgICAgICAgY29uc3Qgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XHJcbiAgICAgICAgICAgIHNwYW4uY2xhc3NOYW1lID0gXCJ0cmVlaWNvblwiO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgZGVsZXRlSWNvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpXCIpO1xyXG4gICAgICAgICAgICBkZWxldGVJY29uLmNsYXNzTmFtZSA9IFwiY2xlYXItaWNvblwiO1xyXG4gICAgICAgICAgICBkZWxldGVJY29uLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoZXYpID0+IHRoaXMub25UcmVlRGVsZXRlSWNvbkNsaWNrLmRpc3BhdGNoKHRoaXMsIHVuZGVmaW5lZCkpO1xyXG5cclxuICAgICAgICAgICAgY29uc3Qgc3Bhbk9wZW5DbG9zZSA9ICh0aGlzLnNwYW5PcGVuQ2xvc2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKSk7XHJcbiAgICAgICAgICAgIHNwYW5PcGVuQ2xvc2UuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIChldikgPT4gdGhpcy5vblRyZWVJY29uQ2xpY2soZXYpKTtcclxuXHJcbiAgICAgICAgICAgIC8vIGlmIChzZWxlY3RNb2RlID09PSBTZWxlY3Rpb25Nb2RlLlNJTkdMRSkge1xyXG4gICAgICAgICAgICAvLyAgICAgdHJlZXJvdy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChldikgPT4gdGhpcy5pdGVtQ2xpY2tlZChldikpO1xyXG4gICAgICAgICAgICAvLyB9XHJcblxyXG4gICAgICAgICAgICB0cmVlcm93LmNsYXNzTmFtZSA9IFwidHJlZXJvdyBsZWFmXCI7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnRleHROb2RlID0gc3Bhbk9wZW5DbG9zZTtcclxuICAgICAgICAgICAgc3Bhbi5hcHBlbmRDaGlsZChkZWxldGVJY29uKTtcclxuICAgICAgICAgICAgc3Bhbi5hcHBlbmRDaGlsZChzcGFuT3BlbkNsb3NlKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGNiOiBIVE1MSW5wdXRFbGVtZW50ID0gdGhpcy5fY3JlYXRlQ2Vja0JveCgpO1xyXG4gICAgICAgICAgICBzcGFuLmFwcGVuZENoaWxkKGNiKTtcclxuICAgICAgICAgICAgY29uc3QgbGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGFiZWxcIik7XHJcbiAgICAgICAgICAgIHNwYW4uYXBwZW5kQ2hpbGQobGFiZWwpO1xyXG4gICAgICAgICAgICBsYWJlbC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgY2IuY2xpY2soKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICB0cmVlcm93LmFwcGVuZENoaWxkKHNwYW4pO1xyXG4gICAgICAgICAgICBjb25zdCBsYWJlbERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XHJcbiAgICAgICAgICAgIGxhYmVsRGl2LmNsYXNzTmFtZSA9IFwidHJlZWxhYmVsXCI7XHJcbiAgICAgICAgICAgIC8vIGNvbnN0IGxhYmVsID0gdGhpcy5ub2RlUmVuZGVyZXIucmVuZGVyKHRoaXMpXHJcblxyXG4gICAgICAgICAgICBjb25zdCB0eHQgPSB0aGlzLmRhdGEubGF5ZXJEZXNjcmlwdGlvbltcImxhYmVsXCJdO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgbGF5ZXJUaXRsZSA9IGNyZWF0ZUh0bWxFbGVtZW50KFwic3BhblwiLCB0cmVlcm93LCBcImxheWVyLXRpdGxlIHRvb2x0aXBcIik7XHJcbiAgICAgICAgICAgIGxheWVyVGl0bGUuaW5uZXJIVE1MID0gdHh0O1xyXG4gICAgICAgICAgICBsYXllclRpdGxlLmRhdGFzZXQudG9vbHRpcCA9IHR4dDtcclxuICAgICAgICAgICAgbGF5ZXJUaXRsZS5zZXRBdHRyaWJ1dGUoXCJkYXRhLXRvb2x0aXBcIiwgdHh0KTtcclxuICAgICAgICAgICAgbGF5ZXJUaXRsZS50aXRsZSA9IHR4dDtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGluZm9JY29uID0gKHRoaXMuaW5mb0ljb24gPSBjcmVhdGVIdG1sRWxlbWVudChcInNwYW5cIiwgdHJlZXJvdywgXCJpbmZvLWljb25cIikpO1xyXG4gICAgICAgICAgICAvLyBpbmZvSWNvbi5pbm5lckhUTUwgPSAnJiN4ZjA1YTsnO1xyXG4gICAgICAgICAgICBpbmZvSWNvbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKGV2KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBNYXBEaXNwYXRjaGVyLm9uU2hvd0xheWVySW5mb1JlcXVlc3QuZGlzcGF0Y2godGhpcywgdGhpcy5kYXRhKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5mQ2hhbmdlTm9kZU9yZGVyKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBkaXZVcERvd24gPSBjcmVhdGVIdG1sRWxlbWVudChcImRpdlwiLCB0cmVlcm93LCBcImNoYW5nZS1sYXllci1vcmRlclwiKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHVwID0gY3JlYXRlSHRtbEVsZW1lbnQoXCJkaXZcIiwgZGl2VXBEb3duLCBcInVwXCIpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZG93biA9IGNyZWF0ZUh0bWxFbGVtZW50KFwiZGl2XCIsIGRpdlVwRG93biwgXCJkb3duXCIpO1xyXG4gICAgICAgICAgICAgICAgdXAuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIChldikgPT4gdGhpcy5ub2RlVXAoKSk7XHJcbiAgICAgICAgICAgICAgICBkb3duLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoZXYpID0+IHRoaXMubm9kZURvd24oKSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmFjdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgIHRyZWVyb3cuYXBwZW5kQ2hpbGQodGhpcy5yZW5kZXJBY3Rpb25zKCkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBsZXQgbm9kZWNvbnRhaW5lciA9IHRoaXMuY2hpbGREb207XHJcbiAgICAgICAgICAgIGlmIChub2RlY29udGFpbmVyKSB7XHJcbiAgICAgICAgICAgICAgICBub2RlY29udGFpbmVyLmlubmVySFRNTCA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5kb20uc3R5bGUuZGlzcGxheSA9IFwiZmxleFwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZG9tO1xyXG4gICAgfVxyXG4gICAgbm9kZVVwKCk6IGFueSB7XHJcbiAgICAgICAgY29uc29sZS5pbmZvKFwiVHJlZTJOb2RlLmxheWVyVXBcIiwgdGhpcyk7XHJcbiAgICAgICAgdGhpcy5mQ2hhbmdlTm9kZU9yZGVyKHsgbm9kZTogdGhpcywgdXA6IHRydWUgfSk7XHJcbiAgICB9XHJcbiAgICBub2RlRG93bigpOiBhbnkge1xyXG4gICAgICAgIGNvbnNvbGUuaW5mbyhcIlRyZWUyTm9kZS5sYXllckRvd25cIiwgdGhpcyk7XHJcbiAgICAgICAgdGhpcy5mQ2hhbmdlTm9kZU9yZGVyKHsgbm9kZTogdGhpcywgdXA6IGZhbHNlIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHNldFN0YXR1cyhzdGF0dXM6IFwid2FpdGluZ1wiIHwgXCJlcnJvclwiIHwgXCJva1wiKSB7XHJcbiAgICAgICAgc3dpdGNoIChzdGF0dXMpIHtcclxuICAgICAgICAgICAgY2FzZSBcIndhaXRpbmdcIjpcclxuICAgICAgICAgICAgICAgIHRoaXMuaW5mb0ljb24uY2xhc3NMaXN0LnJlbW92ZShcImVycm9yXCIpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbmZvSWNvbi5jbGFzc0xpc3QuYWRkKFwid2FpdGluZ1wiKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwiZXJyb3JcIjpcclxuICAgICAgICAgICAgICAgIHRoaXMuaW5mb0ljb24uY2xhc3NMaXN0LnJlbW92ZShcIndhaXRpbmdcIik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmluZm9JY29uLmNsYXNzTGlzdC5hZGQoXCJlcnJvclwiKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdGhpcy5pbmZvSWNvbi5jbGFzc0xpc3QucmVtb3ZlKFwiZXJyb3JcIik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmluZm9JY29uLmNsYXNzTGlzdC5yZW1vdmUoXCJ3YWl0aW5nXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBzZXRTdGF0dXNXYWl0KGlzV2FpdGluZzpib29sZWFuKTp2b2lkIHtcclxuICAgIC8vICAgICBpZiAoaXNXYWl0aW5nKSB7XHJcbiAgICAvLyAgICAgICAgIHRoaXMuaW5mb0ljb24uY2xhc3NMaXN0LmFkZChcInJvdGF0ZVwiKTtcclxuICAgIC8vICAgICAgICAgdGhpcy5pbmZvSWNvbi5pbm5lckhUTUwgPSAnJiN4ZjAyMTsnO1xyXG4gICAgLy8gICAgIH0gZWxzZSB7XHJcbiAgICAvLyAgICAgICAgIHRoaXMuaW5mb0ljb24uY2xhc3NMaXN0LnJlbW92ZShcInJvdGF0ZVwiKTtcclxuICAgIC8vICAgICAgICAgdGhpcy5pbmZvSWNvbi5pbm5lckhUTUwgPSAnJiN4ZjA1YTsnO1xyXG4gICAgLy8gICAgIH1cclxuICAgIC8vIH1cclxufVxyXG5cclxuY29uc3QgdGhlbWVOb2RlUmVuZGVyID0gbmV3IFRoZW1lTm9kZVJlbmRlcmVyKCk7XHJcblxyXG5leHBvcnQgY2xhc3MgTGF5ZXJDb250cm9sVmFyIGV4dGVuZHMgTC5Db250cm9sIHtcclxuICAgIHN0YXRpYyBjYXROb2RlUGFyYW06IFRyZWVOb2RlUGFyYW0gPSB7XHJcbiAgICAgICAgYXR0TmFtZTJSZW5kZXI6IFwiYmV6ZWljaG51bmdcIixcclxuICAgICAgICBzZWxlY3RNb2RlOiBTZWxlY3Rpb25Nb2RlLk1VTFRJLFxyXG4gICAgfTtcclxuXHJcbiAgICBfZG9tOiBIVE1MRWxlbWVudDtcclxuXHJcbiAgICBfbWFwOiBMLk1hcDtcclxuICAgIHRyZWU6IFRyZWU7XHJcbiAgICBjbGFzc05hbWU6IHN0cmluZztcclxuXHJcbiAgICBjYXRlZ29yaWVMYXllcnM6IHsgW2lkOiBzdHJpbmddOiBDYXRlZ29yaWVMYXllcjxhbnksIGFueT4gfSA9IHt9O1xyXG4gICAgY2F0ZWdvcmllTGF5ZXJOb2RlczogeyBbaWQ6IHN0cmluZ106IFRyZWVOb2RlIH0gPSB7fTtcclxuXHJcbiAgICBtYXBMYXllcklkMk92ZXJsYXlOb2RlczogeyBbaWQ6IHN0cmluZ106IExheWVyTm9kZSB9ID0ge307XHJcblxyXG4gICAgbWFwTGF5ZXJJZDJNeUxheWVyTm9kZXM6IHsgW2lkOiBzdHJpbmddOiBUcmVlMk5vZGUgfSA9IHt9O1xyXG5cclxuICAgIGJhc2VMYXllckRlZk9wdGlvbnM6IExheWVyRGVmaW5pdGlvbk9wdGlvbnM7XHJcbiAgICB0aGVtZXM6IFRoZW1lW107XHJcbiAgICBwYXJlbnROb2RlOiBIVE1MRWxlbWVudDtcclxuXHJcbiAgICB0cmVlMjogVHJlZTtcclxuXHJcbiAgICBmQ2hhbmdlTGF5ZXJPcmRlcjogKGV2dDogQ2hhbmdlTm9kZU9yZGVyRXZlbnQpID0+IHZvaWQ7XHJcbiAgICBmVGhlbWVMYXllckNoYW5nZWQ6IChub2RlOiBUcmVlTm9kZSwgc2VsOiBTZWxlY3Rpb25TdGF0dXMpID0+IHZvaWQ7XHJcbiAgICBmTXlUaGVtZXNMYXllckNoYW5nZWQ6IChub2RlOiBUcmVlTm9kZSwgc2VsOiBTZWxlY3Rpb25TdGF0dXMpID0+IHZvaWQ7XHJcbiAgICBmTXlUaGVtZXNEZWxldGVMYXllcjogKG5vZGU6IFRyZWUyTm9kZSkgPT4gdm9pZDtcclxuXHJcbiAgICBhY2NvcmRpb246IEFjY29yZGlvbjtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zPzogTGF5ZXJDb250cm9sT3B0aW9ucykge1xyXG4gICAgICAgIHN1cGVyKG9wdGlvbnMpO1xyXG4gICAgICAgIC8vIGNvbnNvbGUuaW5mbyhcIkxheWVyQ29udHJvbFZhci5jb25zdHJ1Y3RcIilcclxuICAgICAgICBpZiAob3B0aW9ucy5jbGFzc05hbWUpIHtcclxuICAgICAgICAgICAgdGhpcy5jbGFzc05hbWUgPSBvcHRpb25zLmNsYXNzTmFtZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9wdGlvbnMucGFyZW50Tm9kZSkge1xyXG4gICAgICAgICAgICB0aGlzLnBhcmVudE5vZGUgPSBvcHRpb25zLnBhcmVudE5vZGU7XHJcbiAgICAgICAgICAgIC8vIGxheWVyUmVuZGVyZXIuc2hvd0xlZ2VuZCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9jcmVhdGVUcmVlKCk7XHJcbiAgICAgICAgdGhpcy5fY3JlYXRlVHJlZTIoKTtcclxuXHJcbiAgICAgICAgdGhpcy5mQ2hhbmdlTGF5ZXJPcmRlciA9IChldjogQ2hhbmdlTm9kZU9yZGVyRXZlbnQpID0+IHRoaXMuY2hhbmdlTGF5ZXJPcmRlcihldik7XHJcbiAgICAgICAgdGhpcy5mVGhlbWVMYXllckNoYW5nZWQgPSAobm9kZTogVHJlZU5vZGUsIHNlbDogU2VsZWN0aW9uU3RhdHVzKSA9PiB0aGlzLnRoZW1lTGF5ZXJDaGFuZ2VkKG5vZGUsIHNlbCk7XHJcblxyXG4gICAgICAgIHRoaXMuZk15VGhlbWVzTGF5ZXJDaGFuZ2VkID0gKG5vZGU6IFRyZWVOb2RlLCBzZWw6IFNlbGVjdGlvblN0YXR1cykgPT4gdGhpcy5teVRoZW1lc0xheWVyQ2hhbmdlZChub2RlLCBzZWwpO1xyXG4gICAgICAgIHRoaXMuZk15VGhlbWVzRGVsZXRlTGF5ZXIgPSAobm9kZTogVHJlZTJOb2RlKSA9PiB0aGlzLm15VGhlbWVzRGVsZXRlTGF5ZXIobm9kZSk7XHJcblxyXG4gICAgICAgIE1hcERpc3BhdGNoZXIub25MYXllclJlcXVlc3Quc3Vic2NyaWJlKChzZW5kZXIsIGV2KSA9PiB0aGlzLm9uTGF5ZXJSZXF1ZXN0ZWQoc2VuZGVyLCBldikpO1xyXG4gICAgICAgIE1hcERpc3BhdGNoZXIub25MYXllclJlYWR5LnN1YnNjcmliZSgoc2VuZGVyLCBldikgPT4gdGhpcy5vbkxheWVyUmVhZHkoc2VuZGVyLCBldikpO1xyXG4gICAgICAgIE1hcERpc3BhdGNoZXIub25MYXllckVycm9yLnN1YnNjcmliZSgoc2VuZGVyLCBldikgPT4gdGhpcy5vbkxheWVyRXJyb3Ioc2VuZGVyLCBldikpO1xyXG4gICAgfVxyXG5cclxuICAgIGNoYW5nZUxheWVyT3JkZXIoZXY6IENoYW5nZU5vZGVPcmRlckV2ZW50KTogdm9pZCB7XHJcbiAgICAgICAgY29uc29sZS5pbmZvKFwiamtkc2Zoc2hma1wiKTtcclxuICAgICAgICBpZiAoZXYudXApIHtcclxuICAgICAgICAgICAgdGhpcy50cmVlMi5tb3ZlTm9kZVVwKGV2Lm5vZGUpO1xyXG4gICAgICAgICAgICBldi5ub2RlLmRhdGEubGF5ZXIuYnJpbmdUb0JhY2soKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnRyZWUyLm1vdmVOb2RlRG93bihldi5ub2RlKTtcclxuICAgICAgICAgICAgZXYubm9kZS5kYXRhLmxheWVyLmJyaW5nVG9Gcm9udCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjb25zdCBsd0FycmF5OkxheWVyV3JhcHBlcltdID0gW107XHJcbiAgICAgICAgLy8gY29uc3Qgbm9kZXMgPSB0aGlzLnRyZWUyLm5vZGVzO1xyXG4gICAgICAgIC8vIGZvciAobGV0IGk9MDsgaTxub2Rlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIC8vICAgICAoPGFueT5ub2Rlc1tpXS5kYXRhLmxheWVyKS5zZXRaSW5kZXgoaSsxKTtcclxuICAgICAgICAvLyB9O1xyXG4gICAgICAgIC8vIE1hcERpc3BhdGNoZXIub25MYXllck9yZGVyQ2hhbmdlZC5kaXNwYXRjaCh0aGlzLCB7dHlwZTonb3JkZXItY2hhbmdlZCcsIGxheWVyczpsd0FycmF5fSlcclxuICAgICAgICBjb25zb2xlLmluZm8oXCJjaGFuZ2VMYXllck9yZGVyXCIsIGV2KTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIF9sYXllckFkZGVkKGV2dDogTGF5ZXJFdmVudCkge1xyXG4gICAgICAgIHRoaXMudHJlZS5zZWxlY3ROb2RlKGV2dC5sYXllcik7XHJcbiAgICB9XHJcbiAgICBwcml2YXRlIF9sYXllclJlbW92ZWQoZXZ0OiBMYXllckV2ZW50KSB7XHJcbiAgICAgICAgdGhpcy50cmVlLnVuc2VsZWN0Tm9kZShldnQubGF5ZXIpO1xyXG4gICAgfVxyXG5cclxuICAgIG5vZGVDaGFuZ2VkKGdyb3VwOiBzdHJpbmcsIG5vZGU6IFRyZWVOb2RlLCBzZWw6IFNlbGVjdGlvblN0YXR1cykge1xyXG4gICAgICAgIGNvbnNvbGUuaW5mbyhgbm9kZUNoYW5nZWQgJHtncm91cH0gJHtub2RlLmRhdGEubmFtZX0sICR7U2VsZWN0aW9uU3RhdHVzW3NlbF19YCk7XHJcbiAgICB9XHJcblxyXG4gICAgX2Jhc2VMYXllckNoYW5nZWQobGF5ZXI6IEwuTGF5ZXIpIHtcclxuICAgICAgICBNYXBEaXNwYXRjaGVyLm9uQmFzZUxheWVyU2VsZWN0aW9uLmRpc3BhdGNoKDxhbnk+dGhpcywgbGF5ZXIpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoZW1lTGF5ZXJDaGFuZ2VkKG5vZGU6IFRyZWVOb2RlLCBzZWw6IFNlbGVjdGlvblN0YXR1cykge1xyXG4gICAgICAgIGNvbnNvbGUuaW5mbyhgTGF5ZXJDb250cm9sVmFyLnRoZW1lTGF5ZXJDaGFuZ2VkICR7U2VsZWN0aW9uU3RhdHVzW3NlbF19YCwgbm9kZSk7XHJcbiAgICAgICAgY29uc3QgaXNTZWxlY3RlZCA9IHNlbCA9PT0gU2VsZWN0aW9uU3RhdHVzLlNFTEVDVEVEO1xyXG4gICAgICAgIGNvbnN0IGxheWVyID0gPExheWVyV3JhcHBlcj5ub2RlLmRhdGE7XHJcblxyXG4gICAgICAgIGxldCB0cmVlMm5vZGUgPSB0aGlzLm1hcExheWVySWQyTXlMYXllck5vZGVzW2xheWVyLmlkXTtcclxuICAgICAgICBpZiAodHJlZTJub2RlKSB7XHJcbiAgICAgICAgICAgIHRyZWUybm9kZS5zZXRTZWxlY3RlZChpc1NlbGVjdGVkKTtcclxuICAgICAgICAgICAgLy8gcnRyIFRPRE9cclxuICAgICAgICAgICAgLy8gfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gICAgIHRyZWUybm9kZSA9IG5ldyBUcmVlMk5vZGUobGF5ZXIsIG51bGwsIHsgZkNoYW5nZU5vZGVPcmRlcjogdGhpcy5mQ2hhbmdlTGF5ZXJPcmRlciB9KTtcclxuICAgICAgICAgICAgLy8gICAgIHRyZWUybm9kZS5vblNlbGVjdGlvbkNoYW5nZS5zdWJzY3JpYmUodGhpcy5mTXlUaGVtZXNMYXllckNoYW5nZWQpO1xyXG4gICAgICAgICAgICAvLyAgICAgdHJlZTJub2RlLm9uVHJlZURlbGV0ZUljb25DbGljay5zdWJzY3JpYmUodGhpcy5mTXlUaGVtZXNEZWxldGVMYXllcik7XHJcbiAgICAgICAgICAgIC8vICAgICB0aGlzLnRyZWUyLmFkZE5vZGUodHJlZTJub2RlKTtcclxuICAgICAgICAgICAgLy8gICAgIHRoaXMubWFwTGF5ZXJJZDJNeUxheWVyTm9kZXNbbGF5ZXIuaWRdID0gdHJlZTJub2RlO1xyXG4gICAgICAgICAgICAvLyAgICAgdHJlZTJub2RlLnNldFNlbGVjdGVkKGlzU2VsZWN0ZWQpO1xyXG4gICAgICAgICAgICAvLyAgICAgdGhpcy5hY2NvcmRpb24uaXRlbXNbMV0uc2V0Q29sbGFwc2VkKGZhbHNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGF5ZXIuc2V0U2VsZWN0ZWQoaXNTZWxlY3RlZCk7XHJcbiAgICB9XHJcblxyXG4gICAgbXlUaGVtZXNMYXllckNoYW5nZWQobm9kZTogVHJlZU5vZGUsIHNlbDogU2VsZWN0aW9uU3RhdHVzKSB7XHJcbiAgICAgICAgY29uc3QgaXNTZWxlY3RlZCA9IHNlbCA9PT0gU2VsZWN0aW9uU3RhdHVzLlNFTEVDVEVEO1xyXG4gICAgICAgIGNvbnN0IGxheWVyID0gPExheWVyV3JhcHBlcj5ub2RlLmRhdGE7XHJcbiAgICAgICAgbGF5ZXIuc2V0U2VsZWN0ZWQoaXNTZWxlY3RlZCk7XHJcbiAgICB9XHJcblxyXG4gICAgY2xlYXJUaGVtZXMoKSB7XHJcbiAgICAgICAgZm9yIChsZXQgayBpbiB0aGlzLm1hcExheWVySWQyTXlMYXllck5vZGVzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRyZWUybm9kZSA9IHRoaXMubWFwTGF5ZXJJZDJNeUxheWVyTm9kZXNba107XHJcbiAgICAgICAgICAgIHRoaXMubXlUaGVtZXNEZWxldGVMYXllcih0cmVlMm5vZGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnRyZWUubm9kZXMuZm9yRWFjaCgoaXRlbSkgPT4gaXRlbS5jb2xsYXBzZSgpKTtcclxuICAgIH1cclxuXHJcbiAgICBteVRoZW1lc0RlbGV0ZUxheWVyKG5vZGU6IFRyZWVOb2RlKSB7XHJcbiAgICAgICAgY29uc3QgbGF5ZXIgPSA8TGF5ZXJXcmFwcGVyPm5vZGUuZGF0YTtcclxuICAgICAgICBjb25zdCB0cmVlMm5vZGUgPSB0aGlzLm1hcExheWVySWQyTXlMYXllck5vZGVzW2xheWVyLmlkXTtcclxuICAgICAgICBjb25zb2xlLmluZm8oYG15VGhlbWVzRGVsZXRlTGF5ZXIgJHt0cmVlMm5vZGUgPT09IG5vZGV9YCk7XHJcbiAgICAgICAgaWYgKHRyZWUybm9kZSkge1xyXG4gICAgICAgICAgICB0cmVlMm5vZGUuc2V0U2VsZWN0ZWQoZmFsc2UpO1xyXG4gICAgICAgICAgICB0aGlzLnRyZWUyLnJlbW92ZU5vZGUodHJlZTJub2RlKTtcclxuICAgICAgICAgICAgZGVsZXRlIHRoaXMubWFwTGF5ZXJJZDJNeUxheWVyTm9kZXNbbGF5ZXIuaWRdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBiYXNlTGF5ZXJDaGFuZ2VkKG5vZGU6IFRyZWVOb2RlLCBzZWw6IFNlbGVjdGlvblN0YXR1cykge1xyXG4gICAgICAgIC8vIGNvbnNvbGUuaW5mbyhgYmFzZUxheWVyQ2hhbmdlZCAke1NlbGVjdGlvblN0YXR1c1tzZWxdfWAsIG5vZGUpO1xyXG4gICAgICAgIGlmICghbm9kZS5kYXRhLmxheWVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYmFzZUxheWVyRGVmT3B0aW9ucy5jcmVhdGVMYXllcihub2RlLmRhdGEpLnRoZW4oKGxheWVyKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBub2RlLmRhdGEubGF5ZXIgPSBsYXllcjtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2Jhc2VMYXllckNoYW5nZWQobGF5ZXIpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9iYXNlTGF5ZXJDaGFuZ2VkKG5vZGUuZGF0YS5sYXllcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHNlbGVjdFRoZW1lTGF5ZXIobGF5ZXJEZXNjcjogTGF5ZXJEZXNjcmlwdGlvbikge1xyXG4gICAgICAgIC8vIGNvbnNvbGUuaW5mbyhcInNlbGVjdFRoZW1lTGF5ZXJcIik7XHJcbiAgICAgICAgdGhpcy50cmVlLnNlbGVjdE5vZGUobGF5ZXJEZXNjcik7XHJcbiAgICB9XHJcblxyXG4gICAgYWRkVGhlbWVzKHRoZW1lczogVGhlbWVbXSkge1xyXG4gICAgICAgIHRoaXMudGhlbWVzID0gdGhlbWVzO1xyXG4gICAgICAgIE1hcERpc3BhdGNoZXIub25MYXllckFkZGVkLnN1YnNjcmliZSgoc2VuZGVyLCBldnQpID0+IHRoaXMuX2xheWVyQWRkZWQoZXZ0KSk7XHJcbiAgICAgICAgTWFwRGlzcGF0Y2hlci5vbkxheWVyUmVtb3ZlZC5zdWJzY3JpYmUoKHNlbmRlciwgZXZ0KSA9PiB0aGlzLl9sYXllclJlbW92ZWQoZXZ0KSk7XHJcbiAgICAgICAgaWYgKHRoaXMudHJlZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9hZGRUaGVtZXNUb1RyZWUoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBfY3JlYXRlVHJlZTIoKSB7XHJcbiAgICAgICAgdGhpcy50cmVlMiA9IG5ldyBUcmVlKG51bGwsIHsgc2VsZWN0TW9kZTogU2VsZWN0aW9uTW9kZS5NVUxUSSwgZXhwYW5kT25seU9uZU5vZGU6IHRydWUgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBfY3JlYXRlVHJlZSgpIHtcclxuICAgICAgICBjb25zb2xlLmluZm8oXCJMYXllckNvbnRyb2xWYXIuX2NyZWF0ZVRyZWVcIik7XHJcbiAgICAgICAgdGhpcy50cmVlID0gbmV3IFRyZWUobnVsbCwgeyBzZWxlY3RNb2RlOiBTZWxlY3Rpb25Nb2RlLk1VTFRJLCBleHBhbmRPbmx5T25lTm9kZTogdHJ1ZSB9KTtcclxuICAgICAgICAvLyBmb3IgKGNvbnN0IHRpdGxlIGluIHRoaXMub3ZlcmxheXMpIHtcclxuICAgICAgICAvLyAgICAgdGhpcy5fYWRkT3ZlcmxheVRvVHJlZSh0aXRsZSwgdGhpcy5vdmVybGF5c1t0aXRsZV0pO1xyXG4gICAgICAgIC8vIH1cclxuXHJcbiAgICAgICAgLy8gZm9yIChjb25zdCB0aXRsZSBpbiB0aGlzLmNhdGVnb3JpZUxheWVycykge1xyXG4gICAgICAgIC8vICAgICB0aGlzLl9hZGRDYXRlZ29yaWVMYXllclRvVHJlZSh0aXRsZSwgdGhpcy5jYXRlZ29yaWVMYXllcnNbdGl0bGVdKTtcclxuICAgICAgICAvLyB9XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBfY3JlYXRlVGhlbU5vZGUodGhlbWU6IFRoZW1lKTogVGhlbWVUcmVlTm9kZSB7XHJcbiAgICAgICAgY29uc3QgdGhlbWVOb2RlID0gbmV3IFRoZW1lVHJlZU5vZGUodGhlbWUsIG51bGwsIHsgbm9kZVJlbmRlcmVyOiB0aGVtZU5vZGVSZW5kZXIgfSk7XHJcbiAgICAgICAgaWYgKHRoZW1lLnRoZW1lcykge1xyXG4gICAgICAgICAgICB0aGVtZS50aGVtZXMuZm9yRWFjaCgodGhlbWUpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRoZW1lTm9kZTIgPSB0aGlzLl9jcmVhdGVUaGVtTm9kZSh0aGVtZSk7XHJcbiAgICAgICAgICAgICAgICB0aGVtZU5vZGUuYWRkTm9kZSh0aGVtZU5vZGUyKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGVtZS5sYXllcnMpIHtcclxuICAgICAgICAgICAgdGhlbWUubGF5ZXJzLmZvckVhY2goKGxheWVyKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBsYXllck5vZGUgPSBuZXcgTGF5ZXJOb2RlKGxheWVyKTtcclxuICAgICAgICAgICAgICAgIHRoaXMubWFwTGF5ZXJJZDJPdmVybGF5Tm9kZXNbbGF5ZXIuaWRdID0gbGF5ZXJOb2RlO1xyXG4gICAgICAgICAgICAgICAgbGF5ZXJOb2RlLm9uU2VsZWN0aW9uQ2hhbmdlLnN1YnNjcmliZSh0aGlzLmZUaGVtZUxheWVyQ2hhbmdlZCk7XHJcbiAgICAgICAgICAgICAgICB0aGVtZU5vZGUuYWRkTm9kZShsYXllck5vZGUpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoZW1lTm9kZTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIF9hZGRUaGVtZXNUb1RyZWUoKSB7XHJcbiAgICAgICAgY29uc29sZS5pbmZvKGBfYWRkVGhlbWVzVG9UcmVlICR7dGhpcy50cmVlfWApO1xyXG4gICAgICAgIGlmICh0aGlzLnRyZWUpIHtcclxuICAgICAgICAgICAgY29uc3QgdGhlbWVOb2RlczogVHJlZU5vZGVbXSA9IFtdO1xyXG4gICAgICAgICAgICBpZiAodGhpcy50aGVtZXMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudGhlbWVzLmZvckVhY2goKHRoZW1lKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGhlbWVOb2RlID0gdGhpcy5fY3JlYXRlVGhlbU5vZGUodGhlbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGVtZU5vZGUuY2hpbGRzICYmIHRoZW1lTm9kZS5jaGlsZHMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGVtZU5vZGVzLnB1c2godGhlbWVOb2RlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcy50cmVlLmFkZE5vZGUodGhlbWVOb2RlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHRoaXMudHJlZS5hZGROb2Rlcyh0aGVtZU5vZGVzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBfYWRkQ2F0ZWdvcmllTGF5ZXJUb1RyZWUodGl0bGU6IHN0cmluZywgY2F0ZWdvcmllTGF5ZXI6IENhdGVnb3JpZUxheWVyPGFueSwgYW55Pikge1xyXG4gICAgICAgIGNvbnNvbGUuaW5mbyhgX2FkZENhdGVnb3JpZUxheWVyVG9UcmVlICR7dGhpcy50cmVlfWApO1xyXG4gICAgICAgIGlmICh0aGlzLnRyZWUpIHtcclxuICAgICAgICAgICAgY29uc3QgY2F0ZWdvcmllcyA9IGNhdGVnb3JpZUxheWVyLmdldENhdGVnb3JpZXMoKTtcclxuICAgICAgICAgICAgY29uc3QgdHJlZU5vZGUgPSBuZXcgVHJlZU5vZGUodGl0bGUpO1xyXG4gICAgICAgICAgICB0aGlzLnRyZWUuYWRkTm9kZSh0cmVlTm9kZSk7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkQ2F0ZWdvcmllcyh0cmVlTm9kZSwgY2F0ZWdvcmllcyk7XHJcbiAgICAgICAgICAgIHRoaXMuY2F0ZWdvcmllTGF5ZXJOb2Rlc1t0aXRsZV0gPSB0cmVlTm9kZTtcclxuICAgICAgICAgICAgdHJlZU5vZGUub25TZWxlY3Rpb25DaGFuZ2Uuc3Vic2NyaWJlKChub2RlLCBzdGF0dXMpID0+IHRoaXMuX2NhdGVnb3JpZVNlbGVjdGVkKHRpdGxlLCB0cmVlTm9kZSwgc3RhdHVzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIF9hZGRPdmVybGF5VG9UcmVlKHRpdGxlOiBzdHJpbmcsIG92ZXJsYXlzOiBCYXNlTGF5ZXJEZWZpbml0aW9uW10pIHtcclxuICAgICAgICAvLyBjb25zb2xlLndhcm4oYF9hZGRDYXRlZ29yaWVMYXllclRvVHJlZSAke3RoaXMudHJlZX1gKTtcclxuICAgICAgICBpZiAodGhpcy50cmVlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRyZWVOb2RlID0gbmV3IFRyZWVOb2RlKHRpdGxlLCB1bmRlZmluZWQsIHsgc2VsZWN0TW9kZTogU2VsZWN0aW9uTW9kZS5NVUxUSSB9KTtcclxuICAgICAgICAgICAgdGhpcy50cmVlLmFkZE5vZGUodHJlZU5vZGUpO1xyXG4gICAgICAgICAgICBvdmVybGF5cy5mb3JFYWNoKChiYXNlTGF5ZXJEZWYpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRyZWVOb2RlID0gbmV3IFRyZWVOb2RlKGJhc2VMYXllckRlZiwgbnVsbCwgeyBzZWxlY3RNb2RlOiBTZWxlY3Rpb25Nb2RlLk1VTFRJIH0pO1xyXG4gICAgICAgICAgICAgICAgdHJlZU5vZGUuYWRkTm9kZSh0cmVlTm9kZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAvLyB0cmVlTm9kZS5vblNlbGVjdGlvbkNoYW5nZS5zdWJzY3JpYmUoKG5vZGUsIHN0YXR1cykgPT4gdGhpcy5fdGhlbWVTZWxlY3RlZCh0aXRsZSwgdHJlZU5vZGUsIHN0YXR1cykpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBhZGRUbyhtYXA6IEwuTWFwKTogdGhpcyB7XHJcbiAgICAgICAgLy8gY29uc29sZS5lcnJvcignTGF5ZXJDb250cm9sLmFkZFRvJyk7XHJcbiAgICAgICAgaWYgKHRoaXMucGFyZW50Tm9kZSkge1xyXG4gICAgICAgICAgICB0aGlzLnJlbW92ZSgpO1xyXG4gICAgICAgICAgICB0aGlzLl9tYXAgPSBtYXA7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbnRhaW5lciA9ICgoPGFueT50aGlzKS5fY29udGFpbmVyID0gdGhpcy5vbkFkZChtYXApKTtcclxuICAgICAgICAgICAgY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJsYXllcmN0cmwtZG9tXCIpO1xyXG4gICAgICAgICAgICB0aGlzLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcclxuICAgICAgICAgICAgdGhpcy5fbWFwLm9uKFwidW5sb2FkXCIsIHRoaXMucmVtb3ZlLCB0aGlzKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHN1cGVyLmFkZFRvKG1hcCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIG9uQWRkKG1hcDogTC5NYXApOiBIVE1MRWxlbWVudCB7XHJcbiAgICAgICAgY29uc29sZS5pbmZvKFwiTGF5ZXJDb250cm9sLm9uQWRkXCIpO1xyXG4gICAgICAgIHRoaXMuX21hcCA9IG1hcDtcclxuICAgICAgICBsZXQgZG9tID0gdGhpcy5fZG9tO1xyXG4gICAgICAgIGlmICghZG9tKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRvbVRyZWUgPSB0aGlzLnRyZWUuX3JlbmRlcigpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jbGFzc05hbWUpIHtcclxuICAgICAgICAgICAgICAgIGRvbVRyZWUuY2xhc3NMaXN0LmFkZCh0aGlzLmNsYXNzTmFtZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgaXRlbTEgPSBuZXcgQWNjb3JkaW9uSXRlbShcIlRoZW1lblwiLCBkb21UcmVlKTtcclxuICAgICAgICAgICAgY29uc3QgZG9tVHJlZTIgPSB0aGlzLnRyZWUyLl9yZW5kZXIoKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuY2xhc3NOYW1lKSB7XHJcbiAgICAgICAgICAgICAgICBkb21UcmVlMi5jbGFzc0xpc3QuYWRkKHRoaXMuY2xhc3NOYW1lKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBhY2NvcmRpb24gPSAodGhpcy5hY2NvcmRpb24gPSBuZXcgQWNjb3JkaW9uKFtuZXcgQWNjb3JkaW9uSXRlbShcIkthcnRlbmF1c3dhaGxcIiwgZG9tVHJlZSksIG5ldyBBY2NvcmRpb25JdGVtKFwiTWVpbmUgS2FydGVuYXVzd2FobFwiLCBkb21UcmVlMildKSk7XHJcbiAgICAgICAgICAgIGRvbSA9IGFjY29yZGlvbi5yZW5kZXIoKTtcclxuICAgICAgICAgICAgLy8gZG9tLmFwcGVuZENoaWxkKGRvbVRyZWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBUT0RPIGRpc2FibGVFdnRQcm9wYWdhdGlvbihkb20pO1xyXG4gICAgICAgIHJldHVybiBkb207XHJcbiAgICB9XHJcbiAgICBvblJlbW92ZShtYXA6IEwuTWFwKSB7XHJcbiAgICAgICAgLy8gY29uc29sZS5lcnJvcihcIkxheWVyQ29udHJvbC5vblJlbW92ZVwiKTtcclxuICAgIH1cclxuXHJcbiAgICBmaW5kQ2F0ZWdvcmllKHRpdGxlOiBzdHJpbmcsIGl0ZW06IENhdGVnb3J5KTogVHJlZU5vZGVbXSB7XHJcbiAgICAgICAgY29uc29sZS5pbmZvKFwiZmluZENhdGVnb3JpZVwiLCBpdGVtKTtcclxuICAgICAgICBjb25zdCBub2RlOiBUcmVlTm9kZSA9IHRoaXMuY2F0ZWdvcmllTGF5ZXJOb2Rlc1t0aXRsZV07XHJcbiAgICAgICAgaWYgKG5vZGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5vZGUuZmluZE5vZGUoaXRlbS5pZCwgXCJpZFwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZmluZEl0ZW1zT2ZDYXRlZ29yaWUodGl0bGU6IHN0cmluZywgaXRlbTogQ2F0ZWdvcnkpOiBDYXRlZ29yeU1hcE9iamVjdDxhbnk+W10ge1xyXG4gICAgICAgIGNvbnNvbGUuaW5mbyhcImZpbmRJdGVtc09mQ2F0ZWdvcmllXCIsIGl0ZW0pO1xyXG4gICAgICAgIGNvbnN0IG5vZGU6IFRyZWVOb2RlID0gdGhpcy5jYXRlZ29yaWVMYXllck5vZGVzW3RpdGxlXTtcclxuICAgICAgICBpZiAobm9kZSkge1xyXG4gICAgICAgICAgICBjb25zdCBub2RlcyA9IG5vZGUuZmluZE5vZGUoaXRlbS5pZCwgXCJpZFwiKTtcclxuICAgICAgICAgICAgaWYgKG5vZGVzKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwYXRoID0gW107XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gbm9kZXMubGVuZ3RoIC0gMjsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXRoLnB1c2gobm9kZXNbaV0uZGF0YS5pZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmluZm8oXCJwYXRoXCIsIHBhdGgpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbGF5ZXIgPSB0aGlzLmNhdGVnb3JpZUxheWVyc1t0aXRsZV07XHJcbiAgICAgICAgICAgICAgICBpZiAobGF5ZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGF5ZXIuZ2V0SXRlbXMocGF0aCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgc2hvd0NhdGVnb3JpZSh0aXRsZTogc3RyaW5nLCBpdGVtOiBhbnkpIHtcclxuICAgICAgICBjb25zb2xlLmluZm8oXCJzaG93Q2F0ZWdvcmllXCIsIGl0ZW0pO1xyXG4gICAgICAgIGNvbnN0IG5vZGU6IFRyZWVOb2RlID0gdGhpcy5jYXRlZ29yaWVMYXllck5vZGVzW3RpdGxlXTtcclxuICAgICAgICBpZiAobm9kZSkge1xyXG4gICAgICAgICAgICBub2RlLnNlbGVjdE5vZGUoaXRlbS5pZCwgXCJpZFwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgc2hvd01hcmtlcih0aXRsZTogc3RyaW5nLCBpZDogYW55LCBwcm9wOiBzdHJpbmcpIHtcclxuICAgICAgICBjb25zb2xlLmluZm8oYHNob3dtYXJrZXIoJHt0aXRsZX0sICR7aWR9LCAke3Byb3B9KWApO1xyXG4gICAgICAgIGNvbnN0IGxheWVyID0gdGhpcy5jYXRlZ29yaWVMYXllcnNbdGl0bGVdO1xyXG4gICAgICAgIGlmIChsYXllcikge1xyXG4gICAgICAgICAgICBjb25zdCBtYXJrZXIgPSBsYXllci5zaG93TWFya2VyKGlkLCBwcm9wKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0SXRlbXModGl0bGU6IHN0cmluZywgcGF0aDogUGF0aDxhbnk+KTogQ2F0ZWdvcnlNYXBPYmplY3Q8YW55PltdIHtcclxuICAgICAgICBjb25zb2xlLmluZm8oYGdldEl0ZW1zKCR7dGl0bGV9LCAke3BhdGh9KWApO1xyXG4gICAgICAgIGNvbnN0IGxheWVyID0gdGhpcy5jYXRlZ29yaWVMYXllcnNbdGl0bGVdO1xyXG4gICAgICAgIHJldHVybiBsYXllci5nZXRJdGVtcyhwYXRoKTtcclxuICAgIH1cclxuXHJcbiAgICBhZGRDYXRlZ29yaWVMYXllcih0aXRsZTogc3RyaW5nLCBjYXRlZ29yaWVMYXllcjogQ2F0ZWdvcmllTGF5ZXI8YW55LCBhbnk+LCBzaG93QWxsPzogYm9vbGVhbikge1xyXG4gICAgICAgIHRoaXMuY2F0ZWdvcmllTGF5ZXJzW3RpdGxlXSA9IGNhdGVnb3JpZUxheWVyO1xyXG4gICAgICAgIGNvbnNvbGUuaW5mbyhcImFkZENhdGVnb3JpZUxheWVyXCIpO1xyXG4gICAgICAgIGlmICh0aGlzLnRyZWUpIHtcclxuICAgICAgICAgICAgdGhpcy5fYWRkQ2F0ZWdvcmllTGF5ZXJUb1RyZWUodGl0bGUsIGNhdGVnb3JpZUxheWVyKTtcclxuICAgICAgICAgICAgaWYgKHNob3dBbGwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudHJlZS5zZWxlY3ROb2RlKHRpdGxlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHByaXZhdGUgX2NhdGVnb3JpZVNlbGVjdGVkKGxheWVyVGl0bGU6IHN0cmluZywgbm9kZTogVHJlZU5vZGUsIHN0YXR1czogU2VsZWN0aW9uU3RhdHVzKTogdm9pZCB7XHJcbiAgICAgICAgY29uc29sZS5pbmZvKFwiX2NhdGVnb3JpZVNlbGVjdGVkXCIsIG5vZGUsIHN0YXR1cyk7XHJcbiAgICAgICAgY29uc3Qgc2VsZWN0ZWRDYXRzID0gdGhpcy5fZmluZFNlbGVjdGVkKG5vZGUuY2hpbGRzKTtcclxuICAgICAgICBjb25zdCBjYXRlZ29yeUxheWVyID0gdGhpcy5jYXRlZ29yaWVMYXllcnNbbGF5ZXJUaXRsZV07XHJcbiAgICAgICAgaWYgKGNhdGVnb3J5TGF5ZXIpIHtcclxuICAgICAgICAgICAgY2F0ZWdvcnlMYXllci5zZXRLYXRlZ29yaWVzKHNlbGVjdGVkQ2F0cyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIHByaXZhdGUgX3RoZW1lU2VsZWN0ZWQodGhlbWU6IHN0cmluZywgbm9kZTogVHJlZU5vZGUsIHN0YXR1czogU2VsZWN0aW9uU3RhdHVzKTogdm9pZCB7XHJcbiAgICAvLyAgICAgY29uc29sZS5lcnJvcihcIl90aGVtZVNlbGVjdGVkXCIsIHRoZW1lLCBub2RlLCBzdGF0dXMpO1xyXG4gICAgLy8gfVxyXG5cclxuICAgIHByaXZhdGUgX2ZpbmRTZWxlY3RlZChub2RlczogVHJlZU5vZGVbXSk6IG51bWJlcltdW10ge1xyXG4gICAgICAgIGNvbnN0IGlkcyA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKG5vZGVzW2ldLmdldFNlbGVjdGlvbnNTdGF0dXMoKSA9PT0gU2VsZWN0aW9uU3RhdHVzLlNFTEVDVEVEKSB7XHJcbiAgICAgICAgICAgICAgICBpZHMucHVzaChbbm9kZXNbaV0uZGF0YS5pZF0pO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKG5vZGVzW2ldLmdldFNlbGVjdGlvbnNTdGF0dXMoKSA9PT0gU2VsZWN0aW9uU3RhdHVzLklOREVURVJNSU5BVEUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaElkcyA9IHRoaXMuX2ZpbmRTZWxlY3RlZChub2Rlc1tpXS5jaGlsZHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY2hJZHMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWRzLnB1c2goW25vZGVzW2ldLmRhdGEuaWQsIC4uLmNoSWRzW2pdXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBpZHM7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBhZGRDYXRlZ29yaWVzKGJhc2U6IFRyZWUgfCBUcmVlTm9kZSwgY2F0ZWdvcmllczogQ2F0ZWdvcnlbXSkge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2F0ZWdvcmllcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCB0cmVlTm9kZSA9IG5ldyBUcmVlTm9kZShjYXRlZ29yaWVzW2ldLCBudWxsLCBMYXllckNvbnRyb2wuY2F0Tm9kZVBhcmFtKTtcclxuICAgICAgICAgICAgaWYgKGNhdGVnb3JpZXNbaV0uY2hpbGRzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFkZENhdGVnb3JpZXModHJlZU5vZGUsIGNhdGVnb3JpZXNbaV0uY2hpbGRzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBiYXNlLmFkZE5vZGUodHJlZU5vZGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBvbkxheWVyUmVhZHkoc2VuZGVyOiBMYXllckxvYWRlciwgZXY6IExheWVyRXZlbnQpOiB2b2lkIHtcclxuICAgICAgICBjb25zb2xlLmluZm8oYG9uTGF5ZXJSZWFkeWAsIHNlbmRlciwgZXYpO1xyXG4gICAgICAgIHRoaXMubWFwTGF5ZXJJZDJPdmVybGF5Tm9kZXNbZXYubGF5ZXIuaWRdPy5zZXRTdGF0dXMoXCJva1wiKTtcclxuICAgICAgICBpZiAodGhpcy5tYXBMYXllcklkMk15TGF5ZXJOb2Rlc1tldi5sYXllci5pZF0pIHtcclxuICAgICAgICAgICAgdGhpcy5tYXBMYXllcklkMk15TGF5ZXJOb2Rlc1tldi5sYXllci5pZF0/LnNldFN0YXR1cyhcIm9rXCIpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRyZWUybm9kZSA9IG5ldyBUcmVlMk5vZGUoZXYubGF5ZXIsIG51bGwsIHsgZkNoYW5nZU5vZGVPcmRlcjogdGhpcy5mQ2hhbmdlTGF5ZXJPcmRlciB9KTtcclxuICAgICAgICAgICAgdHJlZTJub2RlLm9uU2VsZWN0aW9uQ2hhbmdlLnN1YnNjcmliZSh0aGlzLmZNeVRoZW1lc0xheWVyQ2hhbmdlZCk7XHJcbiAgICAgICAgICAgIHRyZWUybm9kZS5vblRyZWVEZWxldGVJY29uQ2xpY2suc3Vic2NyaWJlKHRoaXMuZk15VGhlbWVzRGVsZXRlTGF5ZXIpO1xyXG4gICAgICAgICAgICB0aGlzLnRyZWUyLmFkZE5vZGUodHJlZTJub2RlKTtcclxuICAgICAgICAgICAgdGhpcy5tYXBMYXllcklkMk15TGF5ZXJOb2Rlc1tldi5sYXllci5pZF0gPSB0cmVlMm5vZGU7XHJcbiAgICAgICAgICAgIHRyZWUybm9kZS5zZXRTZWxlY3RlZCh0cnVlKTtcclxuICAgICAgICAgICAgdHJlZTJub2RlLnNldFN0YXR1cyhcIm9rXCIpO1xyXG4gICAgICAgICAgICB0aGlzLmFjY29yZGlvbi5pdGVtc1sxXS5zZXRDb2xsYXBzZWQoZmFsc2UpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG9uTGF5ZXJSZXF1ZXN0ZWQoc2VuZGVyOiBNYXBDb250cm9sLCBldjogTGF5ZXJFdmVudCk6IHZvaWQge1xyXG4gICAgICAgIGNvbnNvbGUuaW5mbyhgb25MYXllclJlcXVlc3RlZGAsIHNlbmRlciwgZXYpO1xyXG4gICAgICAgIHRoaXMubWFwTGF5ZXJJZDJPdmVybGF5Tm9kZXNbZXYubGF5ZXIuaWRdPy5zZXRTdGF0dXMoXCJ3YWl0aW5nXCIpO1xyXG4gICAgICAgIHRoaXMubWFwTGF5ZXJJZDJNeUxheWVyTm9kZXNbZXYubGF5ZXIuaWRdPy5zZXRTdGF0dXMoXCJ3YWl0aW5nXCIpO1xyXG4gICAgfVxyXG4gICAgb25MYXllckVycm9yKHNlbmRlcjogTGF5ZXJMb2FkZXIsIGV2OiBMYXllckV2ZW50KTogdm9pZCB7XHJcbiAgICAgICAgY29uc29sZS5pbmZvKGBvbkxheWVyUmVxdWVzdGVkYCwgc2VuZGVyLCBldik7XHJcbiAgICAgICAgdGhpcy5tYXBMYXllcklkMk92ZXJsYXlOb2Rlc1tldi5sYXllci5pZF0/LnNldFN0YXR1cyhcImVycm9yXCIpO1xyXG4gICAgICAgIHRoaXMubWFwTGF5ZXJJZDJNeUxheWVyTm9kZXNbZXYubGF5ZXIuaWRdPy5zZXRTdGF0dXMoXCJlcnJvclwiKTtcclxuICAgICAgICB0aGlzLm1hcExheWVySWQyT3ZlcmxheU5vZGVzW2V2LmxheWVyLmlkXT8uc2V0U2VsZWN0ZWQoZmFsc2UpO1xyXG4gICAgICAgIHRoaXMubWFwTGF5ZXJJZDJNeUxheWVyTm9kZXNbZXYubGF5ZXIuaWRdPy5zZXRTZWxlY3RlZChmYWxzZSk7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0ICogYXMgTCBmcm9tIFwibGVhZmxldFwiO1xyXG5pbXBvcnQgKiBhcyBzdmcgZnJvbSBcIi4uL3N2Zy9zdmdcIjtcclxuaW1wb3J0IHsgZ2V0TWFwRGVzY3JpcHRpb24sIExheWVyQ2xhc3MsIExheWVyRGVzY3JpcHRpb24sIFBhdGhPcHRpb25zLCBTdGFuZGFyZENpcmNsZU1hcmtlck9wdGlvbnMsIFN0YW5kYXJkUGF0aE9wdGlvbnMgfSBmcm9tIFwiLi4vY29uZi9NYXBEZXNjcmlwdGlvblwiO1xyXG5pbXBvcnQgeyBjcmVhdGVDbG9zZUJ1dHRvbiwgY3JlYXRlSHRtbEVsZW1lbnQgfSBmcm9tIFwiLi4vVXRpbFwiO1xyXG5pbXBvcnQgeyBMYXllckV2ZW50LCBMYXllcldyYXBwZXIsIE1hcENvbnRyb2wsIE1hcERpc3BhdGNoZXIgfSBmcm9tIFwiLi9NYXBDb250cm9sXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgTGVnZW5kQ29udHJvbCBleHRlbmRzIEwuQ29udHJvbCB7XHJcbiAgICBfbWFwOiBMLk1hcDtcclxuICAgIGRvbTogSFRNTEVsZW1lbnQ7XHJcblxyXG4gICAgbGF5ZXJzOiBMYXllcldyYXBwZXJbXSA9IFtdO1xyXG4gICAgbmF2aWdhdGlvbkFyZWE6IEhUTUxFbGVtZW50O1xyXG4gICAgZG9tTGVnZW5kOiBIVE1MRGl2RWxlbWVudDtcclxuICAgIGlubmVyTGVnZW5kOiBIVE1MRWxlbWVudDtcclxuICAgIGZjdEhpZGVMZWdlbmQ6IChldjogTW91c2VFdmVudCkgPT4gdm9pZDtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zOiBMLkNvbnRyb2xPcHRpb25zKSB7XHJcbiAgICAgICAgc3VwZXIob3B0aW9ucyk7XHJcbiAgICAgICAgY29uc3QgZiA9IChzZW5kZXI6IE1hcENvbnRyb2wsIGxheWVyU2VsZWN0RXZ0OiBMYXllckV2ZW50KSA9PiB0aGlzLl9vbkxheWVyQ2hhbmdlZChzZW5kZXIsIGxheWVyU2VsZWN0RXZ0KTtcclxuICAgICAgICBNYXBEaXNwYXRjaGVyLm9uTGF5ZXJBZGRlZC5zdWJzY3JpYmUoZik7XHJcbiAgICAgICAgTWFwRGlzcGF0Y2hlci5vbkxheWVyUmVtb3ZlZC5zdWJzY3JpYmUoZik7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBfb25MYXllckNoYW5nZWQoc2VuZGVyOiBNYXBDb250cm9sLCBldnQ6IExheWVyRXZlbnQpOiB2b2lkIHtcclxuICAgICAgICBjb25zb2xlLmluZm8oXCJvbkxheWVyQWRkZWRcIiwgZXZ0KTtcclxuICAgICAgICBpZiAoZXZ0LmxheWVyLmlzU2VsZWN0ZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5sYXllcnMucHVzaChldnQubGF5ZXIpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGlkeCA9IHRoaXMubGF5ZXJzLmluZGV4T2YoZXZ0LmxheWVyKTtcclxuICAgICAgICAgICAgaWYgKGlkeCA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxheWVycy5zcGxpY2UoaWR4LCAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl91cGRhdGVMZWdlbmQoKTtcclxuICAgIH1cclxuXHJcbiAgICBvbkFkZChtYXA6IEwuTWFwKTogSFRNTEVsZW1lbnQge1xyXG4gICAgICAgIHRoaXMuX21hcCA9IG1hcDtcclxuICAgICAgICBpZiAoIXRoaXMuZG9tKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRpdiA9IGNyZWF0ZUh0bWxFbGVtZW50KFwiZGl2XCIsIHVuZGVmaW5lZCwgXCJsZWdlbmRjdHJsIGN0cmwtaWNvblwiKTtcclxuICAgICAgICAgICAgLy8gY29uc3QgaWNvbiA9IGNyZWF0ZUh0bWxFbGVtZW50KCdkaXYnLCBkaXYsIFwibGVnZW5kY3RybC1pY29uXCIpO1xyXG4gICAgICAgICAgICBjb25zdCBzcGFuID0gY3JlYXRlSHRtbEVsZW1lbnQoXCJzcGFuXCIsIGRpdik7XHJcbiAgICAgICAgICAgIGRpdi50aXRsZSA9IFwiTGVnZW5kZVwiO1xyXG4gICAgICAgICAgICBzcGFuLmlubmVyVGV4dCA9IFwiTGVnZW5kZVwiO1xyXG4gICAgICAgICAgICBkaXYuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIChldikgPT4ge1xyXG4gICAgICAgICAgICAgICAgZXYuY2FuY2VsQnViYmxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy50b2dnbGVMZWdlbmQoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy5kb20gPSBkaXY7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmZjdEhpZGVMZWdlbmQgPSAoZXY6IE1vdXNlRXZlbnQpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMudG9nZ2xlTGVnZW5kKCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmRvbTtcclxuICAgIH1cclxuXHJcbiAgICB0b2dnbGVMZWdlbmQoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmRvbUxlZ2VuZCkge1xyXG4gICAgICAgICAgICB0aGlzLnNob3dMZWdlbmQoKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmRvbUxlZ2VuZC5jbGFzc0xpc3QudG9nZ2xlKFwiY2xvc2VkXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBfY3JlYXRlTGVnZW5kQ29udGVudCgpOiBIVE1MRWxlbWVudCB7XHJcbiAgICAgICAgY29uc29sZS5pbmZvKFwiX2NyZWF0ZUxlZ2VuZENvbnRlbnRcIik7XHJcbiAgICAgICAgY29uc3QgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcclxuICAgICAgICBkaXYuY2xhc3NOYW1lID0gXCJsZWdlbmRjdHJsLWxlZ2VuZC1jb250ZW50XCI7XHJcbiAgICAgICAgY29uc3QgdGFibGUgPSBjcmVhdGVIdG1sRWxlbWVudChcImRpdlwiLCBkaXYsIFwibGVnZW5kLWxheWVyLWVudHJ5XCIpO1xyXG4gICAgICAgIGlmICh0aGlzLmxheWVycz8ubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICB0aGlzLmxheWVycy5mb3JFYWNoKChsYXllciwgaWR4KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmluZm8oYGxheWVyICR7aWR4fWAsIGxheWVyKTtcclxuICAgICAgICAgICAgICAgIGFwcGVuZExlZ2VuZExheWVyRW50cnkobGF5ZXIubGF5ZXJEZXNjcmlwdGlvbiwgdGFibGUpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjcmVhdGVIdG1sRWxlbWVudChcInBcIiwgZGl2LCB1bmRlZmluZWQsIHtcclxuICAgICAgICAgICAgICAgIGlubmVySFRNTDogXCJFcyB3dXJkZW4ga2VpbmUgVGhlbWVuIGdld8OkaGx0LlwiLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRpdjtcclxuICAgIH1cclxuXHJcbiAgICBfY3JlYXRlTGVnZW5kRG9tKCk6IEhUTUxEaXZFbGVtZW50IHtcclxuICAgICAgICBjb25zdCBkb20gPSBjcmVhdGVIdG1sRWxlbWVudChcImRpdlwiLCB1bmRlZmluZWQsIFwibGVnZW5kY3RybC1sZWdlbmRcIik7XHJcbiAgICAgICAgY29uc3QgaGVhZEFyZWEgPSAodGhpcy5uYXZpZ2F0aW9uQXJlYSA9IGNyZWF0ZUh0bWxFbGVtZW50KFwiZGl2XCIsIGRvbSwgXCJsZWdlbmRjdHJsLWxlZ2VuZC1oZWFkXCIpKTtcclxuICAgICAgICBjb25zdCBoZWFkU3BhbiA9IGNyZWF0ZUh0bWxFbGVtZW50KFwic3BhblwiLCBoZWFkQXJlYSk7XHJcbiAgICAgICAgaGVhZFNwYW4uaW5uZXJUZXh0ID0gXCJMZWdlbmRlXCI7XHJcbiAgICAgICAgY29uc3QgYW5jaG9yQmFjayA9IGNyZWF0ZUh0bWxFbGVtZW50KFwiYVwiLCBoZWFkQXJlYSwgXCJjbG9zZVwiKTtcclxuICAgICAgICBhbmNob3JCYWNrLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoZXYpID0+IHRoaXMuX2Nsb3NlQnR0bkNsaWNrZWQoKSk7XHJcbiAgICAgICAgY29uc3QgdGFibGUgPSAodGhpcy5pbm5lckxlZ2VuZCA9IHRoaXMuX2NyZWF0ZUxlZ2VuZENvbnRlbnQoKSk7XHJcbiAgICAgICAgZG9tLmFwcGVuZENoaWxkKHRhYmxlKTtcclxuICAgICAgICBkb20uYXBwZW5kQ2hpbGQoY3JlYXRlQ2xvc2VCdXR0b24odGhpcy5mY3RIaWRlTGVnZW5kKSk7XHJcbiAgICAgICAgcmV0dXJuIGRvbTtcclxuICAgIH1cclxuXHJcbiAgICBfdXBkYXRlTGVnZW5kKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmlubmVyTGVnZW5kKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRhYmxlID0gdGhpcy5fY3JlYXRlTGVnZW5kQ29udGVudCgpO1xyXG4gICAgICAgICAgICB0aGlzLmlubmVyTGVnZW5kLnJlcGxhY2VXaXRoKHRhYmxlKTtcclxuICAgICAgICAgICAgdGhpcy5pbm5lckxlZ2VuZCA9IHRhYmxlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBzaG93TGVnZW5kKCkge1xyXG4gICAgICAgIGNvbnNvbGUuaW5mbyhcInNob3dMZWdlbmRcIiwgdGhpcy5sYXllcnMpO1xyXG4gICAgICAgIGNvbnN0IGRvbSA9ICh0aGlzLmRvbUxlZ2VuZCA9IHRoaXMuX2NyZWF0ZUxlZ2VuZERvbSgpKTtcclxuICAgICAgICBkb20uY2xhc3NMaXN0LnJlbW92ZShcImNsb3NlZFwiKTtcclxuICAgICAgICBMLkRvbUV2ZW50LmRpc2FibGVDbGlja1Byb3BhZ2F0aW9uKGRvbSk7XHJcbiAgICAgICAgTC5Eb21FdmVudC5kaXNhYmxlU2Nyb2xsUHJvcGFnYXRpb24oZG9tKTtcclxuICAgICAgICB0aGlzLl9tYXAuZ2V0Q29udGFpbmVyKCkuYXBwZW5kQ2hpbGQoZG9tKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIF9jbG9zZUJ0dG5DbGlja2VkKCk6IGFueSB7XHJcbiAgICAgICAgY29uc29sZS5pbmZvKFwiY2xvc2VMZWdlbmRcIik7XHJcbiAgICAgICAgaWYgKHRoaXMuZG9tTGVnZW5kICYmIHRoaXMuX21hcCkge1xyXG4gICAgICAgICAgICAvLyB0aGlzLl9tYXAuZ2V0Q29udGFpbmVyKCkucmVtb3ZlQ2hpbGQodGhpcy5kb21MZWdlbmQpO1xyXG4gICAgICAgICAgICAvLyB0aGlzLmRvbUxlZ2VuZCA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgdGhpcy5kb21MZWdlbmQuY2xhc3NMaXN0LmFkZChcImNsb3NlZFwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgb25SZW1vdmUobWFwOiBMLk1hcCkge1xyXG4gICAgICAgIHRoaXMuX21hcCA9IG51bGw7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBhcHBlbmRMZWdlbmRMYXllckVudHJ5KGxEZXNjcjogTGF5ZXJEZXNjcmlwdGlvbiwgZGl2OiBIVE1MRGl2RWxlbWVudCkge1xyXG4gICAgY29uc29sZS5pbmZvKFwiYXBwZW5kTGVnZW5kTGF5ZXJFbnRyeVwiLCBsRGVzY3IpO1xyXG4gICAgY3JlYXRlSHRtbEVsZW1lbnQoXCJoMVwiLCBkaXYsIHVuZGVmaW5lZCwge1xyXG4gICAgICAgIGlubmVySFRNTDogbERlc2NyLmxhYmVsLFxyXG4gICAgfSk7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGlmIChsRGVzY3IudHlwZSA9PT0gXCJHZW9KU09OXCIpIHtcclxuICAgICAgICAgICAgaWYgKGxEZXNjci5jbGFzc2VzKSB7XHJcbiAgICAgICAgICAgICAgICBsRGVzY3IuY2xhc3Nlcy5mb3JFYWNoKChsYXllckNsYXNzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgcm93ID0gY3JlYXRlSHRtbEVsZW1lbnQoXCJkaXZcIiwgZGl2LCBcInN1YmVsZW1lbnRcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3BhbkNsYXNzSWNvbiA9IGNyZWF0ZUh0bWxFbGVtZW50KFwic3BhblwiLCByb3csIFwiaWNvblwiKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmluZm8oJ2xheWVyJywgbGF5ZXIsIGxheWVyLmdlb21UeXBlKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBjb25zdCBsZWdlbmRJdGVtID0gY3JlYXRlTGVnZW5kQ2lyY2xlKGxheWVyQ2xhc3Muc3R5bGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBsZWdlbmRJdGVtID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChsRGVzY3IuZ2VvbVR5cGUgPT09IFwiUG9pbnRcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBsZWdlbmRJdGVtID0gY3JlYXRlTGVnZW5kQ2lyY2xlKGxheWVyQ2xhc3Muc3R5bGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWdlbmRJdGVtID0gY3JlYXRlTGVnZW5kT2ZQb2ludChsYXllckNsYXNzKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxEZXNjci5nZW9tVHlwZSA9PT0gXCJQb2x5Z29uXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGVnZW5kSXRlbSA9IGNyZWF0ZUxlZ2VuZFBvbHlnb24obGF5ZXJDbGFzcy5zdHlsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChsRGVzY3IuZ2VvbVR5cGUgPT09IFwiTGluZXN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZ2VuZEl0ZW0gPSBjcmVhdGVMZWdlbmRMaW5lc3RyaW5nKGxheWVyQ2xhc3Muc3R5bGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAobGVnZW5kSXRlbSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzcGFuQ2xhc3NJY29uLmFwcGVuZENoaWxkKGxlZ2VuZEl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzcGFuQ2xhc3NOYW1lID0gY3JlYXRlSHRtbEVsZW1lbnQoXCJzcGFuXCIsIHJvdyk7XHJcbiAgICAgICAgICAgICAgICAgICAgc3BhbkNsYXNzTmFtZS5pbm5lckhUTUwgPSBsYXllckNsYXNzLm5hbWU7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGxldCBsZWdlbmRJdGVtOiBFbGVtZW50O1xyXG4gICAgICAgICAgICAgICAgaWYgKGxEZXNjci5nZW9tVHlwZSA9PT0gXCJQb2ludFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxEZXNjci5zdHlsZT8ucGllY2hhcnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlTGVnZW5kUGllY2hhcnQoZGl2LCBsRGVzY3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZ2VuZEl0ZW0gPSBjcmVhdGVMZWdlbmRPZlBvaW50KGxEZXNjcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChsRGVzY3IuZ2VvbVR5cGUgPT09IFwiUG9seWdvblwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGVnZW5kSXRlbSA9IGNyZWF0ZUxlZ2VuZFBvbHlnb24obERlc2NyLnN0eWxlKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobERlc2NyLmdlb21UeXBlID09PSBcIkxpbmVzdHJpbmdcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIGxlZ2VuZEl0ZW0gPSBjcmVhdGVMZWdlbmRMaW5lc3RyaW5nKGxEZXNjci5zdHlsZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAobGVnZW5kSXRlbSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJvdyA9IGNyZWF0ZUh0bWxFbGVtZW50KFwiZGl2XCIsIGRpdiwgXCJzdWJlbGVtZW50XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNwYW5DbGFzc0ljb24gPSBjcmVhdGVIdG1sRWxlbWVudChcInNwYW5cIiwgcm93LCBcImljb25cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgc3BhbkNsYXNzSWNvbi5hcHBlbmRDaGlsZChsZWdlbmRJdGVtKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBjb25zdCBzeW1ib2wgPSBjcmVhdGVIdG1sRWxlbWVudCgnZGl2JywgZGl2KTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBzeW1ib2wuYXBwZW5kQ2hpbGQobGVnZW5kSXRlbSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2UgaWYgKGxEZXNjci50eXBlID09PSBcIldNU1wiKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJvdyA9IGNyZWF0ZUh0bWxFbGVtZW50KFwiZGl2XCIsIGRpdiwgXCJzdWJlbGVtZW50XCIpO1xyXG4gICAgICAgICAgICBjb25zdCBsZWdlbmRVcmwgPSBjcmVhdGVMZWdlbmRVcmwobERlc2NyKTtcclxuICAgICAgICAgICAgY29uc3QgaW1nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImltZ1wiKTtcclxuICAgICAgICAgICAgaW1nLmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCAoZXZ0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBtc2cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcclxuICAgICAgICAgICAgICAgIG1zZy5pbm5lckhUTUwgPSBcIkRlciBEaWVuc3Qgc3RlbGx0IGtlaW5lIExlZ2VuZGUgenVyIFZlcmbDvGd1bmcuXCI7XHJcbiAgICAgICAgICAgICAgICBpbWcucGFyZW50RWxlbWVudC5yZW1vdmVDaGlsZChpbWcpO1xyXG4gICAgICAgICAgICAgICAgcm93LmFwcGVuZENoaWxkKG1zZyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpbWcuc3JjID0gbGVnZW5kVXJsO1xyXG4gICAgICAgICAgICByb3cuYXBwZW5kQ2hpbGQoaW1nKTtcclxuICAgICAgICB9XHJcbiAgICB9IGNhdGNoIChleCkge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXgpO1xyXG4gICAgICAgIGNvbnN0IHJvdyA9IGNyZWF0ZUh0bWxFbGVtZW50KFwiZGl2XCIsIGRpdiwgXCJzdWJlbGVtZW50XCIpO1xyXG4gICAgICAgIGNvbnN0IG1zZyA9IGNyZWF0ZUh0bWxFbGVtZW50KFwic3BhblwiLCByb3cpO1xyXG4gICAgICAgIG1zZy5pbm5lckhUTUwgPSBcIkZlaGxlciBiZWltIEVyemV1Z2VuIGRlciBMZWdlbmRlLlwiO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKlxyXG5mdW5jdGlvbiBhcHBlbmRMZWdlbmRFbnRyeVRhYmxlKGxheWVyOkxheWVyRGVzY3JpcHRpb24sIHRhYmxlOkhUTUxUYWJsZUVsZW1lbnQpIHtcclxuICAgIGNvbnN0IHJvdyA9IGNyZWF0ZUh0bWxFbGVtZW50KFwidHJcIiwgdGFibGUpO1xyXG4gICAgY29uc3QgdGQwMSA9IGNyZWF0ZUh0bWxFbGVtZW50KCd0ZCcsIHJvdyk7XHJcbiAgICB0ZDAxLmlubmVySFRNTCA9IGxheWVyLmxhYmVsO1xyXG4gICAgY29uc3QgdGQwMiA9IGNyZWF0ZUh0bWxFbGVtZW50KCd0ZCcsIHJvdyk7XHJcbiAgICBpZiAobGF5ZXIudHlwZSA9PT0gJ0dlb0pTT04nKSB7XHJcbiAgICAgICAgaWYgKGxheWVyLmNsYXNzZXMpIHtcclxuICAgICAgICAgICAgbGF5ZXIuY2xhc3Nlcy5mb3JFYWNoKGxheWVyQ2xhc3M9PntcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJvdyA9IGNyZWF0ZUh0bWxFbGVtZW50KFwidHJcIiwgdGFibGUsICdzdWJlbGVtZW50Jyk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0ZDAxID0gY3JlYXRlSHRtbEVsZW1lbnQoJ3RkJywgcm93KTtcclxuICAgICAgICAgICAgICAgIHRkMDEuaW5uZXJIVE1MID0gbGF5ZXJDbGFzcy5uYW1lO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdGQwMiA9IGNyZWF0ZUh0bWxFbGVtZW50KCd0ZCcsIHJvdyk7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmluZm8oJ2xheWVyJywgbGF5ZXIsIGxheWVyLmdlb21UeXBlKTtcclxuICAgICAgICAgICAgICAgIC8vIGNvbnN0IGxlZ2VuZEl0ZW0gPSBjcmVhdGVMZWdlbmRDaXJjbGUobGF5ZXJDbGFzcy5zdHlsZSk7XHJcbiAgICAgICAgICAgICAgICBsZXQgbGVnZW5kSXRlbSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgIGlmIChsYXllci5nZW9tVHlwZSA9PT0gJ1BvaW50Jykge1xyXG4gICAgICAgICAgICAgICAgICAgIGxlZ2VuZEl0ZW0gPSBjcmVhdGVMZWdlbmRDaXJjbGUobGF5ZXJDbGFzcy5zdHlsZSk7ICAgICAgICBcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobGF5ZXIuZ2VvbVR5cGUgPT09ICdQb2x5Z29uJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGxlZ2VuZEl0ZW0gPSBjcmVhdGVMZWdlbmRQb2x5Z29uKGxheWVyQ2xhc3Muc3R5bGUpO1xyXG4gICAgICAgICAgICAgICAgfSBcclxuICAgICAgICAgICAgICAgIGlmIChsZWdlbmRJdGVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGQwMi5hcHBlbmRDaGlsZChsZWdlbmRJdGVtKTtcclxuICAgICAgICAgICAgICAgIH0gICAgICAgIFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGxlZ2VuZEl0ZW0gPSBjcmVhdGVMZWdlbmRJdGVtKGxheWVyKTtcclxuICAgICAgICAgICAgaWYgKGxlZ2VuZEl0ZW0pIHtcclxuICAgICAgICAgICAgICAgIHRkMDIuYXBwZW5kQ2hpbGQobGVnZW5kSXRlbSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKGxheWVyLnR5cGUgPT09ICdXTVMnKSB7XHJcbiAgICAgICAgY29uc3Qgcm93ID0gY3JlYXRlSHRtbEVsZW1lbnQoXCJ0clwiLCB0YWJsZSwgJ3N1YmVsZW1lbnQnKTtcclxuICAgICAgICBjb25zdCB0ZCA9IGNyZWF0ZUh0bWxFbGVtZW50KFwidGRcIiwgcm93KTtcclxuICAgICAgICB0ZC5jb2xTcGFuID0gMjtcclxuICAgICAgICBjb25zdCBsZWdlbmRVcmwgPSBjcmVhdGVMZWdlbmRVcmwobGF5ZXIpO1xyXG4gICAgICAgIGNvbnN0IGltZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpOyAgICBcclxuICAgICAgICBpbWcuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBldnQ9PntcclxuICAgICAgICAgICAgY29uc3QgbXNnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xyXG4gICAgICAgICAgICBtc2cuaW5uZXJIVE1MID0gJ0RlciBEaWVuc3Qgc3RlbGx0IGtlaW5lIExlZ2VuZGUgenVyIFZlcmbDvGd1bmcuJztcclxuICAgICAgICAgICAgaW1nLnBhcmVudEVsZW1lbnQucmVtb3ZlQ2hpbGQoaW1nKTtcclxuICAgICAgICAgICAgdGQuYXBwZW5kQ2hpbGQobXNnKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBpbWcuc3JjID0gbGVnZW5kVXJsO1xyXG4gICAgICAgIHRkLmFwcGVuZENoaWxkKGltZyk7XHJcbiAgICB9XHJcbn1cclxuKi9cclxuXHJcbi8vIGV4cG9ydCBmdW5jdGlvbiBjcmVhdGVMZWdlbmRJdGVtKERlc2NyOkxheWVyRGVzY3JpcHRpb24pOkVsZW1lbnR8dW5kZWZpbmVkIHtcclxuLy8gICAgIGlmIChEZXNjci50eXBlID09PSAgJ0dlb0pTT04nKSB7XHJcbi8vICAgICAgICAgaWYgKERlc2NyLmdlb21UeXBlID09PSAnUG9pbnQnKSB7XHJcbi8vICAgICAgICAgICAgIHJldHVybiBjcmVhdGVMZWdlbmRPZlBvaW50KERlc2NyKTtcclxuLy8gICAgICAgICB9IGVsc2UgaWYgKERlc2NyLmdlb21UeXBlID09PSAnUG9seWdvbicpIHtcclxuLy8gICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUxlZ2VuZE9mUG9seWdvbihEZXNjcik7XHJcbi8vICAgICAgICAgfSBlbHNlIGlmIChEZXNjci5nZW9tVHlwZSA9PT0gJ0xpbmVzdHJpbmcnKSB7XHJcbi8vICAgICAgICAgICAgIHJldHVybiBjcmVhdGVMZWdlbmRPZkxpbmVzdHJpbmcoRGVzY3IpO1xyXG4vLyAgICAgICAgIH1cclxuLy8gICAgIH0gZWxzZSBpZiAoRGVzY3IudHlwZSA9PT0gJ1dNUycpIHtcclxuLy8gICAgICAgICByZXR1cm4gY3JlYXRlV01TTGVnZW5kSXRlbShEZXNjcik7XHJcbi8vICAgICB9XHJcbi8vICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4vLyB9XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTGVnZW5kT2ZQb2ludChsYXllcjogTGF5ZXJEZXNjcmlwdGlvbiB8IExheWVyQ2xhc3MpOiBFbGVtZW50IHwgdW5kZWZpbmVkIHtcclxuICAgIC8vIGlmIChsYXllci5jbGFzc2VzKSB7XHJcbiAgICAvLyAgICAgcmV0dXJuIGNyZWF0ZUxlZ2VuZENsYXNzZXMobGF5ZXIpO1xyXG4gICAgLy8gfVxyXG4gICAgY29uc29sZS5pbmZvKFwiY3JlYXRlTGVnZW5kT2ZQb2ludFwiLCBsYXllcik7XHJcbiAgICBpZiAobGF5ZXIuaWNvbiAmJiBsYXllci5pY29uLmljb25VcmwpIHtcclxuICAgICAgICBjb25zdCBpbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpO1xyXG4gICAgICAgIGltZy5zcmMgPSBsYXllci5pY29uLmljb25Vcmw7XHJcbiAgICAgICAgaW1nLndpZHRoID0gbGF5ZXIuaWNvbi5pY29uU2l6ZVswXTtcclxuICAgICAgICBpbWcuaGVpZ2h0ID0gbGF5ZXIuaWNvbi5pY29uU2l6ZVsxXTtcclxuICAgICAgICByZXR1cm4gaW1nO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgc3R5bGUgPSBsYXllci5zdHlsZSA/IGxheWVyLnN0eWxlIDogbGF5ZXI7XHJcbiAgICByZXR1cm4gY3JlYXRlTGVnZW5kQ2lyY2xlKHN0eWxlKTtcclxufVxyXG5cclxuLy8gZnVuY3Rpb24gY3JlYXRlTGVnZW5kQ2xhc3NlcyhsYXllckRlc2NyOkxheWVyRGVzY3JpcHRpb24pIHtcclxuLy8gICAgIGNvbnN0IHNyYyA9IFwiZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCb1pXbG5hSFE5SnpNd01IQjRKeUIzYVdSMGFEMG5NekF3Y0hnbklDQm1hV3hzUFNJak1EQXdNREF3SWlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhodGJHNXpPbmhzYVc1clBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHhPVGs1TDNoc2FXNXJJaUIyWlhKemFXOXVQU0l4TGpFaUlIZzlJakJ3ZUNJZ2VUMGlNSEI0SWlCMmFXVjNRbTk0UFNJd0lEQWdNVEF3SURFd01DSWdaVzVoWW14bExXSmhZMnRuY205MWJtUTlJbTVsZHlBd0lEQWdNVEF3SURFd01DSWdlRzFzT25Od1lXTmxQU0p3Y21WelpYSjJaU0krUEdjK1BIQmhkR2dnWkQwaVRUTTFMamNzTWpjdU1tZzFPQzQxWXpFc01Dd3hMamd0TUM0NExERXVPQzB4TGpoekxUQXVPQzB4TGpndE1TNDRMVEV1T0Vnek5TNDNZeTB4TERBdE1TNDRMREF1T0MweExqZ3NNUzQ0VXpNMExqY3NNamN1TWl3ek5TNDNMREkzTGpKNklqNDhMM0JoZEdnK1BIQmhkR2dnWkQwaVRUazBMakVzTkRjdU0wZ3pOUzQzWXkweExEQXRNUzQ0TERBdU9DMHhMamdzTVM0NGN6QXVPQ3d4TGpnc01TNDRMREV1T0dnMU9DNDFZekVzTUN3eExqZ3RNQzQ0TERFdU9DMHhMamhUT1RVdU1TdzBOeTR6TERrMExqRXNORGN1TTNvaVBqd3ZjR0YwYUQ0OGNHRjBhQ0JrUFNKTk9UUXVNU3czTUM0NVNETTFMamRqTFRFc01DMHhMamdzTUM0NExURXVPQ3d4TGpoek1DNDRMREV1T0N3eExqZ3NNUzQ0YURVNExqVmpNU3d3TERFdU9DMHdMamdzTVM0NExURXVPRk01TlM0eExEY3dMamtzT1RRdU1TdzNNQzQ1ZWlJK1BDOXdZWFJvUGp4d1lYUm9JR1E5SWsweU1pNDNMRE01TGpkSU55NDFZeTB4TERBdE1TNDRMREF1T0MweExqZ3NNUzQ0ZGpFMUxqSmpNQ3d4TERBdU9Dd3hMamdzTVM0NExERXVPR2d4TlM0eVl6RXNNQ3d4TGpndE1DNDRMREV1T0MweExqaFdOREV1TlNBZ0lFTXlOQzQwTERRd0xqVXNNak11Tml3ek9TNDNMREl5TGpjc016a3VOM29pUGp3dmNHRjBhRDQ4Y0dGMGFDQmtQU0pOTnk0eExETTBhREUxTGpaak1DNDJMREFzTVM0eUxUQXVNeXd4TGpVdE1DNDVjekF1TXkweExqSXNNQzB4TGpoc0xUY3VPQzB4TXk0MVl5MHdMak10TUM0MUxUQXVPUzB3TGprdE1TNDFMVEF1T1hNdE1TNHlMREF1TXkweExqVXNNQzQ1VERVdU5pd3pNUzQwSUNBZ1l5MHdMak1zTUM0MUxUQXVNeXd4TGpJc01Dd3hMamhUTmk0MUxETTBMRGN1TVN3ek5Ib2lQand2Y0dGMGFENDhjR0YwYUNCa1BTSk5NVFV1TkN3Mk1pNDJZeTAxTGpVc01DMHhNQ3cwTGpVdE1UQXNNVEJ6TkM0MUxERXdMREV3TERFd2N6RXdMVFF1TlN3eE1DMHhNRk15TUM0NUxEWXlMallzTVRVdU5DdzJNaTQyZWlJK1BDOXdZWFJvUGp3dlp6NDhMM04yWno0PVwiO1xyXG4vLyAgICAgY29uc3QgaW1nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImltZ1wiKTtcclxuLy8gICAgIGltZy5zcmMgPSBzcmM7XHJcbi8vICAgICBpbWcuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBldnQ9PntcclxuLy8gICAgICAgICBzaG93TGVnZW5kT2ZDbGFzc2VzKGV2dCwgbGF5ZXJEZXNjcik7XHJcbi8vICAgICB9KTtcclxuLy8gICAgIHJldHVybiBpbWc7XHJcbi8vIH1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZVdNU0xlZ2VuZEl0ZW0obGF5ZXI6IExheWVyRGVzY3JpcHRpb24pOiBFbGVtZW50IHwgdW5kZWZpbmVkIHtcclxuICAgIGxldCBsZWdlbmRJdGVtOiBFbGVtZW50ID0gdW5kZWZpbmVkO1xyXG4gICAgY29uc3Qgc3ltYm9sID0gZ2V0TWFwRGVzY3JpcHRpb24oKS5kZWZhdWx0X3dtc19sZWdlbmRfaWNvbjtcclxuICAgIGNvbnN0IGxlZ2VuZFVybCA9IGNyZWF0ZUxlZ2VuZFVybChsYXllcik7XHJcbiAgICAvLyBpZiAoIWxlZ2VuZFVybCkge1xyXG4gICAgLy8gICAgIGNyZWF0ZUxlZ2VuZFVybChsYXllcik7XHJcbiAgICAvLyB9XHJcbiAgICBpZiAoc3ltYm9sICYmIGxlZ2VuZFVybCkge1xyXG4gICAgICAgIC8vIGNvbnN0IGl0ZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICAvLyBjb25zdCBpbWcgPSBjcmVhdGVIdG1sRWxlbWVudCgnaW1nJywgaXRlbSk7XHJcbiAgICAgICAgY29uc3QgaW1nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImltZ1wiKTtcclxuICAgICAgICBpbWcuc3JjID0gc3ltYm9sO1xyXG4gICAgICAgIGltZy5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKGV2dCkgPT4ge1xyXG4gICAgICAgICAgICBzaG93TGVnZW5kVXJsKGV2dCwgbGVnZW5kVXJsKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBpbWcuc3R5bGUucG9zaXRpb24gPSBcInJlbGF0aXZlXCI7XHJcbiAgICAgICAgaW1nLnN0eWxlLndpZHRoID0gXCIyMHB4XCI7XHJcbiAgICAgICAgaW1nLnRpdGxlID0gXCJMZWdlbmRlIGFuemVpZ2VuLlwiO1xyXG4gICAgICAgIC8vIGFkZFRvb2x0aXAoaXRlbSwgXCJMZWdlbmRlIGFuemVpZ2VuXCIpO1xyXG4gICAgICAgIGxlZ2VuZEl0ZW0gPSBpbWc7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbGVnZW5kSXRlbTtcclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlTGVnZW5kVXJsKGxheWVyOiBMYXllckRlc2NyaXB0aW9uKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcclxuICAgIGxldCB1cmwgPSB1bmRlZmluZWQ7XHJcbiAgICBpZiAobGF5ZXIudXJsX2xlZ2VuZCkge1xyXG4gICAgICAgIHJldHVybiBsYXllci51cmxfbGVnZW5kO1xyXG4gICAgfVxyXG4gICAgaWYgKGxheWVyLnVybCkge1xyXG4gICAgICAgIGlmIChsYXllci51cmwuZW5kc1dpdGgoXCImXCIpKSB7XHJcbiAgICAgICAgICAgIHVybCA9IGxheWVyLnVybCArIFwiU0VSVklDRT1XTVMmVkVSU0lPTj0xLjMuMCZSRVFVRVNUPUdldExlZ2VuZEdyYXBoaWMmTEFZRVI9XCIgKyBsYXllci5vcHRpb25zW1wibGF5ZXJzXCJdICsgXCImRk9STUFUPWltYWdlL3BuZyZTTERfVkVSU0lPTj0xLjEuMFwiO1xyXG4gICAgICAgICAgICByZXR1cm4gdXJsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGF5ZXIudXJsLmluZGV4T2YoXCI/XCIpID4gMCkge1xyXG4gICAgICAgICAgICB1cmwgPSBsYXllci51cmwgKyBcIiZTRVJWSUNFPVdNUyZWRVJTSU9OPTEuMy4wJlJFUVVFU1Q9R2V0TGVnZW5kR3JhcGhpYyZMQVlFUj1cIiArIGxheWVyLm9wdGlvbnNbXCJsYXllcnNcIl0gKyBcIiZGT1JNQVQ9aW1hZ2UvcG5nJlNMRF9WRVJTSU9OPTEuMS4wXCI7XHJcbiAgICAgICAgICAgIHJldHVybiB1cmw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHVybCA9IGxheWVyLnVybCArIFwiP1NFUlZJQ0U9V01TJlZFUlNJT049MS4zLjAmUkVRVUVTVD1HZXRMZWdlbmRHcmFwaGljJkxBWUVSPVwiICsgbGF5ZXIub3B0aW9uc1tcImxheWVyc1wiXSArIFwiJkZPUk1BVD1pbWFnZS9wbmcmU0xEX1ZFUlNJT049MS4xLjBcIjtcclxuICAgICAgICByZXR1cm4gdXJsO1xyXG4gICAgfVxyXG59XHJcbi8vIGZ1bmN0aW9uIHNob3dMZWdlbmRPZkNsYXNzZXMoZXZ0Ok1vdXNlRXZlbnQsIGxheWVyRGVzY3I6TGF5ZXJEZXNjcmlwdGlvbikge1xyXG4vLyAgICAgY29uc3QgY29udGVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RhYmxlJyk7XHJcbi8vICAgICBhcHBlbmRMZWdlbmRMYXllckVudHJ5KGxheWVyRGVzY3IsIGNvbnRlbnQpO1xyXG4vLyAgICAgc2hvd0NvbnRlbnQoZXZ0LCBjb250ZW50KTtcclxuLy8gfVxyXG5mdW5jdGlvbiBzaG93TGVnZW5kVXJsKGV2dDogTW91c2VFdmVudCwgdXJsOiBzdHJpbmcpIHtcclxuICAgIGNvbnN0IGNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG4gICAgY29uc3QgaW1nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImltZ1wiKTtcclxuXHJcbiAgICBpbWcuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIChldnQpID0+IHtcclxuICAgICAgICBjb25zdCBtc2cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcclxuICAgICAgICBtc2cuaW5uZXJIVE1MID0gXCJEZXIgRGllbnN0IHN0ZWxsdCBrZWluZSBMZWdlbmRlIHp1ciBWZXJmw7xndW5nLlwiO1xyXG4gICAgICAgIGltZy5wYXJlbnRFbGVtZW50LnJlbW92ZUNoaWxkKGltZyk7XHJcbiAgICAgICAgY29udGVudC5hcHBlbmRDaGlsZChtc2cpO1xyXG4gICAgfSk7XHJcbiAgICBpbWcuc3JjID0gdXJsO1xyXG4gICAgY29udGVudC5hcHBlbmRDaGlsZChpbWcpO1xyXG4gICAgc2hvd0NvbnRlbnQoZXZ0LCBjb250ZW50KTtcclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlU3ZnU3R5bGUoc3R5bGU6IFBhdGhPcHRpb25zKTogc3ZnLlN2Z1N0eWxlIHtcclxuICAgIGNvbnNvbGUuaW5mbyhcImNyZWF0ZVN0eWxlXCIsIHN0eWxlLCBzdHlsZS5zdHJva2UpO1xyXG4gICAgY29uc3Qgc3Q6IHN2Zy5TdmdTdHlsZSA9IHt9O1xyXG4gICAgaWYgKHN0eWxlLnN0cm9rZSkge1xyXG4gICAgICAgIHN0LnN0cm9rZSA9IHN0eWxlLmNvbG9yO1xyXG4gICAgICAgIHN0LnN0cm9rZU9wYWNpdHkgPSAoc3R5bGUub3BhY2l0eSB8fCAxKS50b1N0cmluZygpO1xyXG4gICAgICAgIHN0LnN0cm9rZVdpZHRoID0gKHN0eWxlLndlaWdodCB8fCAzKS50b1N0cmluZygpO1xyXG4gICAgICAgIHN0LnN0cm9rZUxpbmVjYXAgPSBzdHlsZS5saW5lQ2FwIHx8IFwiXCI7XHJcbiAgICAgICAgc3Quc3Ryb2tlTGluZWpvaW4gPSBzdHlsZS5saW5lSm9pbiB8fCBcIlwiO1xyXG4gICAgICAgIHN0LnN0cm9rZURhc2hhcnJheSA9IHN0eWxlLmRhc2hBcnJheSB8fCBcIlwiO1xyXG4gICAgICAgIHN0LnN0cm9rZURhc2hvZmZzZXQgPSBzdHlsZS5kYXNoT2Zmc2V0IHx8IFwiXCI7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHN0LnN0cm9rZSA9IFwibm9uZVwiO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChzdHlsZS5maWxsKSB7XHJcbiAgICAgICAgc3QuZmlsbCA9IHN0eWxlLmZpbGxDb2xvciB8fCBzdHlsZS5jb2xvcjtcclxuICAgICAgICBpZiAoc3R5bGUuZmlsbE9wYWNpdHkpIHtcclxuICAgICAgICAgICAgc3Qub3BhY2l0eSA9IHN0eWxlLmZpbGxPcGFjaXR5LnRvU3RyaW5nKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN0LmZpbGxSdWxlID0gc3R5bGUuZmlsbFJ1bGUgfHwgXCJldmVub2RkXCI7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHN0LmZpbGwgPSBcIm5vbmVcIjtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gc3Q7XHJcbn1cclxuXHJcbi8vIGZ1bmN0aW9uIGNyZWF0ZUxlZ2VuZE9mTGluZXN0cmluZyhsYXllcjpMYXllckRlc2NyaXB0aW9uKTpFbGVtZW50IHtcclxuLy8gICAgIGNvbnNvbGUuaW5mbygnY3JlYXRlTGVnZW5kT2ZMaW5lc3RyaW5nJyk7XHJcbi8vICAgICAvLyBpZiAobGF5ZXIuY2xhc3Nlcykge1xyXG4vLyAgICAgLy8gICAgIHJldHVybiBjcmVhdGVMZWdlbmRDbGFzc2VzKGxheWVyKTtcclxuLy8gICAgIC8vIH1cclxuLy8gICAgIGNvbnN0IHN0eWxlID0gey4uLlN0YW5kYXJkUGF0aE9wdGlvbnMsIC4uLmxheWVyLnN0eWxlfTtcclxuLy8gICAgIGNvbnN0IHN2Z0VsID0gbmV3IHN2Zy5TVkcoe3g6MCwgeTowLCB3aWR0aDoyMCwgaGVpZ2h0OjIwfSk7XHJcblxyXG4vLyAgICAgY29uc3Qgc3QgPSBjcmVhdGVTdmdTdHlsZShzdHlsZSk7XHJcbi8vICAgICBzdmdFbC5hZGRMaW5lKDAsIDEwLCAyMCwgMTAsIHN0KTtcclxuLy8gICAgIHJldHVybiBzdmdFbC5zdmc7XHJcbi8vIH1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZUxlZ2VuZExpbmVzdHJpbmcoc3R5bGU6IGFueSk6IEVsZW1lbnQge1xyXG4gICAgY29uc29sZS5pbmZvKFwiY3JlYXRlTGVnZW5kTGluZXN0cmluZ1wiLCBzdHlsZSk7XHJcbiAgICBjb25zdCBzdmdFbCA9IG5ldyBzdmcuU1ZHKHsgeDogMCwgeTogMCwgd2lkdGg6IDIwLCBoZWlnaHQ6IDIwIH0pO1xyXG4gICAgY29uc3Qgc3QgPSBjcmVhdGVTdmdTdHlsZSh7IC4uLlN0YW5kYXJkUGF0aE9wdGlvbnMsIC4uLnN0eWxlIH0pO1xyXG4gICAgc3ZnRWwuYWRkTGluZSgwLCAxMCwgMjAsIDEwLCBzdCk7XHJcbiAgICByZXR1cm4gc3ZnRWwuc3ZnO1xyXG59XHJcblxyXG4vLyBmdW5jdGlvbiBjcmVhdGVMZWdlbmRPZlBvbHlnb24obGF5ZXI6TGF5ZXJEZXNjcmlwdGlvbik6RWxlbWVudCB7XHJcbi8vICAgICAvLyBpZiAobGF5ZXIuY2xhc3Nlcykge1xyXG4vLyAgICAgLy8gICAgIHJldHVybiBjcmVhdGVMZWdlbmRDbGFzc2VzKGxheWVyKTtcclxuLy8gICAgIC8vIH1cclxuLy8gICAgIGNvbnN0IHN0eWxlID0gbGF5ZXIuc3R5bGU7XHJcbi8vICAgICBjb25zdCBzdmdFbCA9IG5ldyBzdmcuU1ZHKHt4OjAsIHk6MCwgd2lkdGg6MjAsIGhlaWdodDoyMH0pO1xyXG4vLyAgICAgY29uc3Qgc3QgPSB7XHJcbi8vICAgICAgICAgc3Ryb2tlOiBzdHlsZSAmJiBzdHlsZS5jb2xvciA/IHN0eWxlLmNvbG9yIDogXCIjMzM4OGZmXCIsXHJcbi8vICAgICAgICAgc3Ryb2tlT3BhY2l0eTogXCIxXCIsXHJcbi8vICAgICAgICAgc3Ryb2tlV2lkdGg6IHN0eWxlICYmIHN0eWxlLndlaWdodCA/IHN0eWxlLndlaWdodCA6IFwiM1wiLFxyXG4vLyAgICAgICAgIHN0cm9rZUxpbmVjYXA6IFwicm91bmRcIixcclxuLy8gICAgICAgICBzdHJva2VMaW5lam9pbjogXCJyb3VuZFwiLFxyXG4vLyAgICAgICAgIGZpbGw6IHN0eWxlICYmIHN0eWxlLmNvbG9yID8gc3R5bGUuY29sb3IgOiBcIiMzMzg4ZmZcIixcclxuLy8gICAgICAgICBmaWxsT3BhY2l0eTogXCIwLjJcIixcclxuLy8gICAgICAgICBmaWxsUnVsZTogXCJldmVub2RkXCJcclxuLy8gICAgIH1cclxuLy8gICAgIHN2Z0VsLmFkZFBvbHlnR29uKFwiMSwxIDE5LDEgMTksMTkgMSwxOVwiLCBzdCk7XHJcbi8vICAgICBzdmdFbC5zdmcuc3R5bGUud2lkdGggPSAnMnJlbSc7XHJcbi8vICAgICByZXR1cm4gc3ZnRWwuc3ZnO1xyXG4vLyB9XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVMZWdlbmRQb2x5Z29uKHN0eWxlOiBhbnkpOiBFbGVtZW50IHtcclxuICAgIGNvbnNvbGUuaW5mbyhcImNyZWF0ZUxlZ2VuZFBvbHlnb25cIiwgc3R5bGUpO1xyXG4gICAgY29uc3Qgc3ZnRWwgPSBuZXcgc3ZnLlNWRyh7IHg6IDAsIHk6IDAsIHdpZHRoOiAyMCwgaGVpZ2h0OiAyMCB9KTtcclxuICAgIGNvbnN0IHN0ID0ge1xyXG4gICAgICAgIHN0cm9rZTogc3R5bGUgJiYgc3R5bGUuY29sb3IgPyBzdHlsZS5jb2xvciA6IFwiIzMzODhmZlwiLFxyXG4gICAgICAgIHN0cm9rZU9wYWNpdHk6IFwiMVwiLFxyXG4gICAgICAgIHN0cm9rZVdpZHRoOiBzdHlsZSAmJiBzdHlsZS53ZWlnaHQgPyBzdHlsZS53ZWlnaHQgOiBcIjNcIixcclxuICAgICAgICBzdHJva2VMaW5lY2FwOiBcInJvdW5kXCIsXHJcbiAgICAgICAgc3Ryb2tlTGluZWpvaW46IFwicm91bmRcIixcclxuICAgICAgICAvLyBmaWxsOiBzdHlsZSAmJiBzdHlsZS5maWxsQ29sb3IgPyBzdHlsZS5maWxsQ29sb3IgOiBcIiMzMzg4ZmZcIixcclxuICAgICAgICBmaWxsOiBzdHlsZT8uZmlsbENvbG9yLFxyXG4gICAgICAgIGZpbGxPcGFjaXR5OiBzdHlsZSAmJiBzdHlsZS5maWxsT3BhY2l0eSA/IHN0eWxlLmZpbGxPcGFjaXR5IDogXCIwLjJcIixcclxuICAgICAgICBmaWxsUnVsZTogXCJldmVub2RkXCIsXHJcbiAgICB9O1xyXG4gICAgc3ZnRWwuYWRkUG9seWdHb24oXCIxLDEgMTksMSAxOSwxOSAxLDE5XCIsIHN0KTtcclxuICAgIHJldHVybiBzdmdFbC5zdmc7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZUxlZ2VuZFBpZWNoYXJ0KGRpdjogSFRNTEVsZW1lbnQsIGxEZXNjcjogTGF5ZXJEZXNjcmlwdGlvbikge1xyXG4gICAgLypcclxuICAgIFwic3R5bGVcIjoge1xyXG4gICAgICAgIFwicmFkaXVzXCI6IDE1LFxyXG4gICAgICAgIFwiZmlsbE9wYWNpdHlcIjogMC42LFxyXG4gICAgICAgIFwic3Ryb2tlT3BhY2l0eVwiOiAwLjIsXHJcbiAgICAgICAgXCJzdHJva2VXZWlnaHRcIjogMyxcclxuICAgICAgICBcInBpZWNoYXJ0XCI6IHtcclxuICAgICAgICAgIFwiY2FzYV9ldl9xbV9rbDFcIjogXCJyZ2IoMTYyIDIwMyAyNTUpXCIsXHJcbiAgICAgICAgICBcImNhc2FfZXZfcW1fa2wyXCI6IFwicmdiKDE4MiAyNDcgMjU1KVwiLFxyXG4gICAgICAgICAgXCJjYXNhX2V2X3FtX2tsM1wiOiBcInJnYigxNjggMjU1IDE4OClcIixcclxuICAgICAgICAgIFwiY2FzYV9ldl9xbV9rbDRcIjogXCJyZ2IoMjQwIDI1NSAxNzUpXCIsXHJcbiAgICAgICAgICBcImNhc2FfZXZfcW1fa2w1XCI6IFwicmdiKDI1NSAyMTUgMTY1KVwiLFxyXG4gICAgICAgICAgXCJjYXNhX2V2X3FtX2tsOThcIjogXCJyZ2IoMjU1IDE5NCAxODYpXCIsXHJcbiAgICAgICAgICBcImNhc2FfZXZfcW1fa2w5OVwiOiBcInJnYigyNTUgMTU0IDIzMClcIlxyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuICAgICAgKi9cclxuICAgIGZvciAobGV0IGsgaW4gbERlc2NyLnN0eWxlLnBpZWNoYXJ0KSB7XHJcbiAgICAgICAgY29uc3Qgcm93ID0gY3JlYXRlSHRtbEVsZW1lbnQoXCJkaXZcIiwgZGl2LCBcInN1YmVsZW1lbnRcIik7XHJcbiAgICAgICAgY29uc3Qgc3BhbkNsYXNzSWNvbiA9IGNyZWF0ZUh0bWxFbGVtZW50KFwic3BhblwiLCByb3csIFwiaWNvblwiKTtcclxuICAgICAgICBjb25zdCBsZWdlbmRJdGVtID0gY3JlYXRlTGVnZW5kUG9seWdvbih7IGZpbGxDb2xvcjogbERlc2NyLnN0eWxlLnBpZWNoYXJ0W2tdLCBjb2xvcjogXCIjMDAwXCIsIHdlaWdodDogMSB9KTtcclxuICAgICAgICBzcGFuQ2xhc3NJY29uLmFwcGVuZENoaWxkKGxlZ2VuZEl0ZW0pO1xyXG4gICAgICAgIGNvbnN0IHNwYW5DbGFzc05hbWUgPSBjcmVhdGVIdG1sRWxlbWVudChcInNwYW5cIiwgcm93KTtcclxuICAgICAgICBzcGFuQ2xhc3NOYW1lLmlubmVySFRNTCA9IGxEZXNjci5sYXllckF0dHJpYnV0ZXM/LltrXSA/PyBrO1xyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVMZWdlbmRDaXJjbGUoc3R5bGU6IGFueSk6IEVsZW1lbnQge1xyXG4gICAgY29uc3Qgc3ZnRWwgPSBuZXcgc3ZnLlNWRyh7IHg6IDAsIHk6IDAsIHdpZHRoOiAyNCwgaGVpZ2h0OiAyNCB9KTtcclxuICAgIGNvbnNvbGUuaW5mbyhcImNyZWF0ZUxlZ2VuZENpcmNsZVwiLCBzdHlsZSk7XHJcbiAgICBjb25zdCBzdCA9IGNyZWF0ZVN2Z1N0eWxlKHsgLi4uU3RhbmRhcmRDaXJjbGVNYXJrZXJPcHRpb25zLCAuLi5zdHlsZSB9KTtcclxuICAgIHN2Z0VsLmFkZENpcmNsZSgxMiwgMTIsIDEwLCBzdCk7XHJcbiAgICByZXR1cm4gc3ZnRWwuc3ZnO1xyXG59XHJcblxyXG5mdW5jdGlvbiBzaG93Q29udGVudChldnQ6IE1vdXNlRXZlbnQsIGNvbnRlbnQ6IEhUTUxFbGVtZW50KSB7XHJcbiAgICBjb25zdCBkb20gPSBjcmVhdGVIdG1sRWxlbWVudChcImRpdlwiLCB1bmRlZmluZWQsIFwibGVnZW5kY3RybC1sZWdlbmRcIik7XHJcbiAgICBjb25zdCBoZWFkQXJlYSA9IGNyZWF0ZUh0bWxFbGVtZW50KFwiZGl2XCIsIGRvbSwgXCJsZWdlbmRjdHJsLWxlZ2VuZC1oZWFkXCIpO1xyXG4gICAgY29uc3QgaGVhZFNwYW4gPSBjcmVhdGVIdG1sRWxlbWVudChcInNwYW5cIiwgaGVhZEFyZWEpO1xyXG4gICAgaGVhZFNwYW4uaW5uZXJUZXh0ID0gXCJMZWdlbmRlXCI7XHJcbiAgICBjb25zdCBhbmNob3JCYWNrID0gY3JlYXRlSHRtbEVsZW1lbnQoXCJhXCIsIGhlYWRBcmVhLCBcImNsb3NlXCIpO1xyXG4gICAgYW5jaG9yQmFjay5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKGV2KSA9PiB7XHJcbiAgICAgICAgaWYgKGRvbS5wYXJlbnRFbGVtZW50KSB7XHJcbiAgICAgICAgICAgIGRvbS5wYXJlbnRFbGVtZW50LnJlbW92ZUNoaWxkKGRvbSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBkb20uYXBwZW5kQ2hpbGQoY29udGVudCk7XHJcblxyXG4gICAgZG9tLnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xyXG4gICAgZG9tLnN0eWxlLmxlZnQgPSBldnQuY2xpZW50WCArIFwicHhcIjtcclxuICAgIGRvbS5zdHlsZS50b3AgPSBldnQuY2xpZW50WSArIFwicHhcIjtcclxuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZG9tKTtcclxufVxyXG4iLCJpbXBvcnQgKiBhcyBMIGZyb20gXCJsZWFmbGV0XCI7XHJcbmltcG9ydCB7IEV2ZW50RGlzcGF0Y2hlciB9IGZyb20gXCJzdHJvbmdseS10eXBlZC1ldmVudHNcIjtcclxuaW1wb3J0IGF1dG9jb21wbGV0ZSBmcm9tIFwiLi4vdXRpbC9BdXRvY29tcGxldGVyXCI7XHJcbmltcG9ydCB7IGNyZWF0ZUh0bWxFbGVtZW50IH0gZnJvbSBcIi4uL1V0aWxcIjtcclxuaW1wb3J0IHsgQ2F0ZWdvcmllTGF5ZXIsIENhdGVnb3J5TWFwT2JqZWN0LCBHZW9qc29uTGF5ZXIsIEludGVyYWN0aXZlTGF5ZXIgfSBmcm9tIFwiLi9DYXRlZ29yaWVMYXllclwiO1xyXG5pbXBvcnQgeyBMYXllckNvbnRyb2wgfSBmcm9tIFwiLi9MYXllckNvbnRyb2xcIjtcclxuaW1wb3J0IHsgVmlldywgVmlld0NvbnRyb2wgfSBmcm9tIFwiLi9WaWV3Q29udHJvbFwiO1xyXG5pbXBvcnQgeyBNYXJrZXJMaXN0VmlldywgTWFya2VyVmlldyB9IGZyb20gXCIuL01hcmtlckxpc3RWaWV3XCI7XHJcbmltcG9ydCB7IExheWVyRGVzY3JpcHRpb24gfSBmcm9tIFwiLi4vY29uZi9NYXBEZXNjcmlwdGlvblwiO1xyXG5pbXBvcnQgeyBMYXllckxvYWRlciB9IGZyb20gXCIuLi9MYXllckxvYWRlclwiO1xyXG5pbXBvcnQgeyBMZWFmbGV0TW91c2VFdmVudCB9IGZyb20gXCJsZWFmbGV0XCI7XHJcbmltcG9ydCB7IEJhc2VMYXllclNlbGVjdG9yQ3RybCB9IGZyb20gXCIuL0Jhc2VsYXllclNlbGVjdG9yQ3RybFwiO1xyXG5pbXBvcnQgeyBMYXllckNvbnRyb2xWYXIgfSBmcm9tIFwiLi9MYXllckNvbnRyb2xWYXJcIjtcclxuaW1wb3J0IHsgU2VhcmNoQ29udHJvbCB9IGZyb20gXCIuL1NlYXJjaEN0cmxcIjtcclxuaW1wb3J0IHsgQ2hhbmdlRm9udFNpemVDdHJsLCBJY29uQWN0aW9uQ3RybCB9IGZyb20gXCIuL0ljb25BY3Rpb25cIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBNZW51Q29udHJvbE9wdGlvbnMgaW1wbGVtZW50cyBMLkNvbnRyb2xPcHRpb25zIHtcclxuICAgIHBvc2l0aW9uPzogTC5Db250cm9sUG9zaXRpb247XHJcbiAgICBwYXJlbnROb2RlPzogSFRNTEVsZW1lbnQ7XHJcbiAgICBzZWFyY2hGY3Q/OiAoczogc3RyaW5nKSA9PiBQcm9taXNlPGFueVtdPjtcclxuICAgIHJlc2V0TWFwPzogKCkgPT4gdm9pZDtcclxufVxyXG5cclxuZXhwb3J0IHR5cGUgTGF5ZXJFdmVudCA9IHtcclxuICAgIHR5cGU6IFwic2VsZWN0XCIgfCBcInJlcXVlc3QtbGF5ZXJcIiB8IFwibGF5ZXItcmVhZHlcIiB8IFwiY3JlYXRlLXN0YXJ0XCIgfCBcImNyZWF0ZWRcIiB8IFwiYWRkZWQtdG8tbWFwXCIgfCBcInJlbW92ZWQtZnJvbS1tYXBcIiB8IFwibGF5ZXItZXJyb3JcIjtcclxuICAgIGxheWVyOiBMYXllcldyYXBwZXI7XHJcbn07XHJcblxyXG5leHBvcnQgdHlwZSBMYXllck9yZGVyQ2hhbmdlRXZlbnQgPSB7XHJcbiAgICB0eXBlOiBcIm9yZGVyLWNoYW5nZWRcIjtcclxuICAgIGxheWVyczogTGF5ZXJXcmFwcGVyW107XHJcbn07XHJcblxyXG5leHBvcnQgY2xhc3MgTGF5ZXJXcmFwcGVyIHtcclxuICAgIHByaXZhdGUgc3RhdGljIGlkQ291bnRlciA9IDA7XHJcblxyXG4gICAgbGF5ZXI6IEwuTGF5ZXI7XHJcbiAgICBsYXllckRlc2NyaXB0aW9uOiBMYXllckRlc2NyaXB0aW9uO1xyXG4gICAgaXNTZWxlY3RlZCA9IGZhbHNlO1xyXG5cclxuICAgIGlkOiBudW1iZXI7XHJcbiAgICAvKipcclxuICAgICAqIG9yZGVyIDEgaXN0IHVudGVuIC4uLlxyXG4gICAgICovXHJcbiAgICBpZHg6IG51bWJlciA9IC0xO1xyXG4gICAgbG9hZEVycm9yOiBib29sZWFuO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGxheWVyRGVzY3JpcHRpb246IExheWVyRGVzY3JpcHRpb24pIHtcclxuICAgICAgICB0aGlzLmxheWVyRGVzY3JpcHRpb24gPSBsYXllckRlc2NyaXB0aW9uO1xyXG4gICAgICAgIHRoaXMuaWQgPSBMYXllcldyYXBwZXIuaWRDb3VudGVyKys7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0U2VsZWN0ZWQoc2VsZWN0ZWQ6IGJvb2xlYW4pOiB2b2lkIHtcclxuICAgICAgICAvLyBjb25zb2xlLmVycm9yKGBMYXllcldyYXBwZXIuc2V0U2VsZWN0ZWQoJHtzZWxlY3RlZH0pYClcclxuICAgICAgICBpZiAodGhpcy5pc1NlbGVjdGVkICE9PSBzZWxlY3RlZCkge1xyXG4gICAgICAgICAgICB0aGlzLmlzU2VsZWN0ZWQgPSBzZWxlY3RlZDtcclxuICAgICAgICAgICAgTWFwRGlzcGF0Y2hlci5vblRoZW1lTGF5ZXJTZWxlY3Rpb24uZGlzcGF0Y2godGhpcywge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJzZWxlY3RcIixcclxuICAgICAgICAgICAgICAgIGxheWVyOiB0aGlzLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbmNsYXNzIERpc3BhdGNoZXIge1xyXG4gICAgLy8gbWFwOiBMLk1hcDtcclxuXHJcbiAgICBvbkxpc3RWaWV3SXRlbVNlbGVjdGlvbiA9IG5ldyBFdmVudERpc3BhdGNoZXI8TWFya2VyTGlzdFZpZXcsIENhdGVnb3J5TWFwT2JqZWN0PGFueT4+KCk7XHJcblxyXG4gICAgb25WaWV3UmVtb3ZlID0gbmV3IEV2ZW50RGlzcGF0Y2hlcjxWaWV3Q29udHJvbCwgVmlldz4oKTtcclxuXHJcbiAgICBvbk1hcEZlYXR1cmVDbGljayA9IG5ldyBFdmVudERpc3BhdGNoZXI8YW55LCBMZWFmbGV0TW91c2VFdmVudD4oKTtcclxuXHJcbiAgICBvbkJhc2VMYXllclNlbGVjdGlvbiA9IG5ldyBFdmVudERpc3BhdGNoZXI8TGF5ZXJDb250cm9sLCBMLkxheWVyPigpO1xyXG4gICAgb25UaGVtZUxheWVyU2VsZWN0aW9uID0gbmV3IEV2ZW50RGlzcGF0Y2hlcjxMYXllcldyYXBwZXIsIExheWVyRXZlbnQ+KCk7XHJcblxyXG4gICAgb25MYXllckNyZWF0aW9uU3RhcnQgPSBuZXcgRXZlbnREaXNwYXRjaGVyPExheWVyTG9hZGVyLCBMYXllckV2ZW50PigpO1xyXG5cclxuICAgIG9uTGF5ZXJDcmVhdGlvbkVuZCA9IG5ldyBFdmVudERpc3BhdGNoZXI8TGF5ZXJMb2FkZXIsIExheWVyRXZlbnQ+KCk7XHJcblxyXG4gICAgb25MYXllckFkZGVkID0gbmV3IEV2ZW50RGlzcGF0Y2hlcjxNYXBDb250cm9sLCBMYXllckV2ZW50PigpO1xyXG4gICAgb25MYXllclJlbW92ZWQgPSBuZXcgRXZlbnREaXNwYXRjaGVyPE1hcENvbnRyb2wsIExheWVyRXZlbnQ+KCk7XHJcblxyXG4gICAgb25MYXllck9yZGVyQ2hhbmdlZCA9IG5ldyBFdmVudERpc3BhdGNoZXI8YW55LCBMYXllck9yZGVyQ2hhbmdlRXZlbnQ+KCk7XHJcblxyXG4gICAgb25MYXllclJlcXVlc3QgPSBuZXcgRXZlbnREaXNwYXRjaGVyPE1hcENvbnRyb2wsIExheWVyRXZlbnQ+KCk7XHJcblxyXG4gICAgb25MYXllclJlYWR5ID0gbmV3IEV2ZW50RGlzcGF0Y2hlcjxMYXllckxvYWRlciwgTGF5ZXJFdmVudD4oKTtcclxuXHJcbiAgICBvbkxheWVyRXJyb3IgPSBuZXcgRXZlbnREaXNwYXRjaGVyPExheWVyTG9hZGVyLCBMYXllckV2ZW50PigpO1xyXG5cclxuICAgIG9uU2hvd0xheWVySW5mb1JlcXVlc3QgPSBuZXcgRXZlbnREaXNwYXRjaGVyPGFueSwgTGF5ZXJXcmFwcGVyPigpO1xyXG59XHJcblxyXG5leHBvcnQgY29uc3QgTWFwRGlzcGF0Y2hlciA9IG5ldyBEaXNwYXRjaGVyKCk7XHJcblxyXG5jb25zdCBMYXllckluZm9BdHRyOiBBcnJheTx7IGF0dHJOYW1lOiBzdHJpbmc7IGF0dHJMYWJlbDogc3RyaW5nIH0+ID0gW1xyXG4gICAgeyBhdHRyTmFtZTogXCJjb250YWN0UGVyc29uTmFtZVwiLCBhdHRyTGFiZWw6IFwiQW5zcHJlY2hwYXJ0bmVyOlwiIH0sXHJcbiAgICB7IGF0dHJOYW1lOiBcImNvbnRhY3RFTWFpbFwiLCBhdHRyTGFiZWw6IFwiRS1NYWlsOlwiIH0sXHJcbiAgICB7IGF0dHJOYW1lOiBcImNvbnRhY3RQaG9uXCIsIGF0dHJMYWJlbDogXCJUZWw6XCIgfSxcclxuICAgIHsgYXR0ck5hbWU6IFwiYWN0dWFsaXR5XCIsIGF0dHJMYWJlbDogXCJBa3R1YWxpdMOkdDpcIiB9LFxyXG4gICAgeyBhdHRyTmFtZTogXCJhY3R1YWxpdHlDaXJjbGVcIiwgYXR0ckxhYmVsOiBcIkFrdHVhbGlzaWVydW5nc3p5a2x1czpcIiB9LFxyXG5dO1xyXG5cclxuZXhwb3J0IGNsYXNzIE1hcENvbnRyb2wgZXh0ZW5kcyBMLkNvbnRyb2wge1xyXG4gICAgbWFwOiBMLk1hcDtcclxuICAgIGRvbTogSFRNTEVsZW1lbnQ7XHJcbiAgICBiYXNlTGF5ZXJDdHJsOiBMYXllckNvbnRyb2wgfCBCYXNlTGF5ZXJTZWxlY3RvckN0cmw7XHJcbiAgICBjYXRlZ29yaWVMYXllckN0cmw6IExheWVyQ29udHJvbCB8IExheWVyQ29udHJvbFZhcjtcclxuXHJcbiAgICBzZWFyY2hGY3Q6IChzOiBzdHJpbmcpID0+IFByb21pc2U8YW55W10+O1xyXG4gICAgcmVzZXRNYXA6ICgpID0+IHZvaWQ7XHJcblxyXG4gICAgY2xvc2VkOiBib29sZWFuID0gdHJ1ZTtcclxuICAgIGNhdGVnb3JpZUxheWVyczogeyBbaWQ6IHN0cmluZ106IENhdGVnb3JpZUxheWVyPGFueSwgYW55PiB9ID0ge307XHJcblxyXG4gICAgdmlld0N0cmw6IFZpZXdDb250cm9sO1xyXG4gICAgdG9wRGl2OiBIVE1MRWxlbWVudDtcclxuXHJcbiAgICBzZWFyY2hCb3g6IEhUTUxJbnB1dEVsZW1lbnQ7XHJcbiAgICBpc01lbnVPcGVuOiBib29sZWFuO1xyXG5cclxuICAgIGZvdW5kQXJlYTogTC5HZW9KU09OPGFueT47XHJcblxyXG4gICAgYmFzZUxheWVyOiBMLkxheWVyO1xyXG5cclxuICAgIHNlbGVjdGVkSXRlbTogeyBmZWF0dXJlTGF5ZXI6IEludGVyYWN0aXZlTGF5ZXI7IGZlYXR1cmU6IENhdGVnb3J5TWFwT2JqZWN0PGFueT4gfTtcclxuXHJcbiAgICBwYXJlbnROb2RlOiBIVE1MRWxlbWVudDtcclxuXHJcbiAgICBsYXllck9uTWFwTGlzdDogTGF5ZXJXcmFwcGVyW10gPSBbXTtcclxuXHJcbiAgICBtYXBDdHJsQ29udGVudENvbnRhaW5lcjogSFRNTERpdkVsZW1lbnQ7XHJcbiAgICBfc2lkZWJhckNsb3NlZDogYm9vbGVhbjtcclxuICAgIGN1cnJab29tQ2xhc3M6IHN0cmluZztcclxuICAgIHNlYXJjaEN0cmw6IFNlYXJjaENvbnRyb2w7XHJcblxyXG4gICAgY29uc3RydWN0b3Iob3B0aW9uczogTWVudUNvbnRyb2xPcHRpb25zKSB7XHJcbiAgICAgICAgc3VwZXIob3B0aW9ucyk7XHJcblxyXG4gICAgICAgIGlmIChvcHRpb25zLnBhcmVudE5vZGUpIHtcclxuICAgICAgICAgICAgdGhpcy5wYXJlbnROb2RlID0gb3B0aW9ucy5wYXJlbnROb2RlO1xyXG4gICAgICAgICAgICBvcHRpb25zLnBhcmVudE5vZGUuY2xhc3NMaXN0LmFkZChcIm1hcGN0cmxfcGFyZW50XCIpO1xyXG4gICAgICAgICAgICB0aGlzLmNhdGVnb3JpZUxheWVyQ3RybCA9IG5ldyBMYXllckNvbnRyb2xWYXIoeyBwYXJlbnROb2RlOiBvcHRpb25zLnBhcmVudE5vZGUgfSk7XHJcbiAgICAgICAgICAgIHRoaXMuYmFzZUxheWVyQ3RybCA9IG5ldyBCYXNlTGF5ZXJTZWxlY3RvckN0cmwoeyBwb3NpdGlvbjogXCJib3R0b21yaWdodFwiIH0pO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgY29udGFpbmVyID0gKHRoaXMubWFwQ3RybENvbnRlbnRDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKTtcclxuICAgICAgICAgICAgY29udGFpbmVyLmNsYXNzTmFtZSA9IFwibWFwY3RybF9jb250ZW50XCI7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5jYXRlZ29yaWVMYXllckN0cmwgPSBuZXcgTGF5ZXJDb250cm9sKHsgcG9zaXRpb246IFwidG9wbGVmdFwiIH0pO1xyXG4gICAgICAgICAgICB0aGlzLmJhc2VMYXllckN0cmwgPSBuZXcgTGF5ZXJDb250cm9sKHtcclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBcInRvcGxlZnRcIixcclxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogXCJmbGV4LW5vLXNocmlua1wiLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuc2VhcmNoRmN0ID0gb3B0aW9ucy5zZWFyY2hGY3Q7XHJcbiAgICAgICAgdGhpcy5yZXNldE1hcCA9IG9wdGlvbnMucmVzZXRNYXA7XHJcbiAgICAgICAgdGhpcy5fc3Vic2NyaWJlKCk7XHJcbiAgICB9XHJcbiAgICBwcml2YXRlIF9zdWJzY3JpYmUoKSB7XHJcbiAgICAgICAgTWFwRGlzcGF0Y2hlci5vbk1hcEZlYXR1cmVDbGljay5zdWJzY3JpYmUoKHNlbmRlciwgZXZ0KSA9PiB0aGlzLm9uTWFwRmVhdHVyZUNsaWNrKHNlbmRlciwgZXZ0KSk7XHJcblxyXG4gICAgICAgIE1hcERpc3BhdGNoZXIub25CYXNlTGF5ZXJTZWxlY3Rpb24uc3Vic2NyaWJlKChzZW5kZXIsIGxheWVyKSA9PiB0aGlzLm9uQmFzZUxheWVyU2VsZWN0aW9uKHNlbmRlciwgbGF5ZXIpKTtcclxuICAgICAgICBNYXBEaXNwYXRjaGVyLm9uVGhlbWVMYXllclNlbGVjdGlvbi5zdWJzY3JpYmUoKHNlbmRlciwgbGF5ZXJTZWxlY3RFdnQpID0+IHRoaXMub25UaGVtZUxheWVyU2VsZWN0aW9uKHNlbmRlciwgbGF5ZXJTZWxlY3RFdnQpKTtcclxuXHJcbiAgICAgICAgTWFwRGlzcGF0Y2hlci5vbkxheWVyUmVhZHkuc3Vic2NyaWJlKChzZW5kZXIsIGV2dCkgPT4gdGhpcy5vbkxheWVyUmVhZHkoc2VuZGVyLCBldnQpKTtcclxuXHJcbiAgICAgICAgTWFwRGlzcGF0Y2hlci5vblZpZXdSZW1vdmUuc3Vic2NyaWJlKChzZW5kZXIsIGV2dCkgPT4gdGhpcy5vblZpZXdSZW1vdmUoc2VuZGVyLCBldnQpKTtcclxuXHJcbiAgICAgICAgTWFwRGlzcGF0Y2hlci5vblNob3dMYXllckluZm9SZXF1ZXN0LnN1YnNjcmliZSgoc2VuZGVyLCBsYXllckRlc2NyKSA9PiB0aGlzLm9uU2hvd0xheWVySW5mb1JlcXVlc3Qoc2VuZGVyLCBsYXllckRlc2NyKSk7XHJcbiAgICB9XHJcblxyXG4gICAgYWRkQ2F0ZWdvcmllTGF5ZXIoY2F0ZWdvcmllTGF5ZXI6IENhdGVnb3JpZUxheWVyPGFueSwgYW55Piwgc2hvd0FsbDogYm9vbGVhbikge1xyXG4gICAgICAgIGNhdGVnb3JpZUxheWVyLm9uY2UoXCJDYXRlZ29yaWVzTG9hZGVkXCIsIChldnQpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5jYXRlZ29yaWVMYXllckN0cmwuYWRkQ2F0ZWdvcmllTGF5ZXIoXCJLYXRlZ29yaWVzXCIsIGNhdGVnb3JpZUxheWVyLCBzaG93QWxsKTtcclxuICAgICAgICAgICAgdGhpcy5tYXAuYWRkTGF5ZXIoY2F0ZWdvcmllTGF5ZXIpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNhdGVnb3JpZUxheWVyLmxvYWRDYXRlZ29yaWVzKCk7XHJcbiAgICAgICAgdGhpcy5jYXRlZ29yaWVMYXllcnNbXCJLYXRlZ29yaWVzXCJdID0gY2F0ZWdvcmllTGF5ZXI7XHJcbiAgICB9XHJcbiAgICBpdGVtU2VsZWN0ZWQoZXY6IEwuTGVhZmxldEV2ZW50KTogdm9pZCB7XHJcbiAgICAgICAgY29uc3QgbGF5ZXI6IENhdGVnb3JpZUxheWVyPGFueSwgYW55PiA9IGV2LnRhcmdldDtcclxuICAgICAgICBjb25zdCBtYXJrZXI6IENhdGVnb3J5TWFwT2JqZWN0PGFueT4gPSAoPGFueT5ldikubWFya2VyO1xyXG4gICAgICAgIHRoaXMuc2hvd0RhdGEobGF5ZXIsIG1hcmtlcik7XHJcbiAgICB9XHJcbiAgICBpdGVtVW5zZWxlY3RlZChldjogTC5MZWFmbGV0RXZlbnQpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLnZpZXdDdHJsLmdvQmFjaygpO1xyXG4gICAgfVxyXG5cclxuICAgIHNldENvbnRlbnRWaWV3KHY6IFZpZXcsIHJlcGxhY2U6IGJvb2xlYW4pOiB2b2lkIHtcclxuICAgICAgICB0aGlzLnZpZXdDdHJsLnNldENvbnRlbnRWaWV3KHYsIHJlcGxhY2UpO1xyXG4gICAgfVxyXG5cclxuICAgIG9uU2hvd0xheWVySW5mb1JlcXVlc3Qoc2VuZGVyOiBhbnksIGxheWVyOiBMYXllcldyYXBwZXIpOiB2b2lkIHtcclxuICAgICAgICBjb25zb2xlLmluZm8oXCJvblNob3dMYXllckluZm9SZXF1ZXN0XCIsIHNlbmRlciwgbGF5ZXIpO1xyXG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIGNvbnN0IHY6IFZpZXcgPSB7XHJcbiAgICAgICAgICAgIGdldERvbTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5pbmZvKFwiZ2V0RG9tXCIsIHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmRvbSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGQgPSAodGhpcy5kb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKTtcclxuICAgICAgICAgICAgICAgICAgICBkLmNsYXNzTmFtZSA9IFwibGF5ZXJpbmZvXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxheWVyLmxheWVyRGVzY3JpcHRpb24ubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlSHRtbEVsZW1lbnQoXCJzcGFuXCIsIGQsIFwibGF5ZXJpbmZvLXRpdGxlXCIsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlubmVyVGV4dDogbGF5ZXIubGF5ZXJEZXNjcmlwdGlvbi5sYWJlbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChsYXllci5sb2FkRXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdHh0ID0gbGF5ZXIubGF5ZXJEZXNjcmlwdGlvbi50eXBlID09PSBcIldNU1wiID8gXCJCZWltIFp1Z3JpZmYgYXVmIGRlbiBleHRlcm5lbiBEaWVuc3QgaXN0IGVpbiBGZWhsZXIgYXVmZ2V0cmV0ZW4uIFZlcnN1Y2hlbiBTaWUgZXMgc3DDpHRlciBlcm5ldXQuXCIgOiBcIkJlaW0gTGFkZW4gZGVzIFRoZW1hcyBpc3QgZWluIEZlaGxlciBhdWZnZXRyZXRlbi4gVmVyc3VjaGVuIFNpZSBlcyBzcMOkdGVyIGVybmV1dC5cIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlSHRtbEVsZW1lbnQoXCJzcGFuXCIsIGQsIFwibGF5ZXJpbmZvLWVycm9yXCIsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlubmVyVGV4dDogdHh0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGF5ZXJEZXNjciA9IGxheWVyLmxheWVyRGVzY3JpcHRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxheWVyRGVzY3IuYWJzdHJhY3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlSHRtbEVsZW1lbnQoXCJzcGFuXCIsIGQsIFwibGF5ZXJpbmZvLXN1YnRpdGxlXCIsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlubmVyVGV4dDogXCJCZXNjaHJlaWJ1bmc6XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVIdG1sRWxlbWVudChcInNwYW5cIiwgZCwgXCJsYXllcmluZm8tdGV4dFwiLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbm5lclRleHQ6IGxheWVyRGVzY3IuYWJzdHJhY3QsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAobGF5ZXJEZXNjci5jb250YWN0T3JnYW5pc2F0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZUh0bWxFbGVtZW50KFwic3BhblwiLCBkLCBcImxheWVyaW5mby1zdWJ0aXRsZVwiLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbm5lclRleHQ6IFwiUXVlbGxlOlwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlSHRtbEVsZW1lbnQoXCJzcGFuXCIsIGQsIFwibGF5ZXJpbmZvLXRleHRcIiwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5uZXJUZXh0OiBsYXllckRlc2NyLmNvbnRhY3RPcmdhbmlzYXRpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgY291bnQgPSBMYXllckluZm9BdHRyLmxlbmd0aDsgaSA8IGNvdW50OyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbGF5ZXJJbmZvQXR0ciA9IExheWVySW5mb0F0dHJbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsYXllckRlc2NyW2xheWVySW5mb0F0dHIuYXR0ck5hbWVdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwID0gY3JlYXRlSHRtbEVsZW1lbnQoXCJwXCIsIGQsIFwibGF5ZXJpbmZvLXJvd1wiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZUh0bWxFbGVtZW50KFwic3BhblwiLCBwLCBcImxheWVyaW5mby1yb3ctaGVhZFwiLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5uZXJUZXh0OiBsYXllckluZm9BdHRyLmF0dHJMYWJlbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlSHRtbEVsZW1lbnQoXCJzcGFuXCIsIHAsIFwibGF5ZXJpbmZvLXJvdy1jb250ZW50XCIsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbm5lclRleHQ6IGxheWVyRGVzY3JbbGF5ZXJJbmZvQXR0ci5hdHRyTmFtZV0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHR4dDogc3RyaW5nO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBmOiAoZXZ0OiBNb3VzZUV2ZW50KSA9PiB2b2lkO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZjID0gdGhpcy52aWV3Q3RjO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChsYXllci5pc1NlbGVjdGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR4dCA9IFwiYXVzYmxlbmRlblwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmID0gKGV2dCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXIuc2V0U2VsZWN0ZWQoZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gIE1hcERpc3BhdGNoZXIub25UaGVtZUxheWVyU2VsZWN0aW9uLmRpc3BhdGNoKGxheWVyLCB7dHlwZToncmVtb3ZlZC1mcm9tLW1hcCcsIGxheWVyOmxheWVyfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYudmlld0N0cmwuZ29CYWNrKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHh0ID0gXCJlaW5ibGVuZGVuXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGYgPSAoZXZ0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXllci5zZXRTZWxlY3RlZCh0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYudmlld0N0cmwuZ29CYWNrKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNYXBEaXNwYXRjaGVyLm9uVGhlbWVMYXllclNlbGVjdGlvbi5kaXNwYXRjaChsYXllciwge3R5cGU6J3NlbGVjdCcsIGxheWVyOmxheWVyfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYnR0bkRpdiA9IGNyZWF0ZUh0bWxFbGVtZW50KFwiZGl2XCIsIGQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJ0dG4gPSBjcmVhdGVIdG1sRWxlbWVudChcImJ1dHRvblwiLCBidHRuRGl2KTtcclxuICAgICAgICAgICAgICAgICAgICBidHRuLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBmKTtcclxuICAgICAgICAgICAgICAgICAgICBidHRuLmlubmVyVGV4dCA9IHR4dDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRvbTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuc2hvd1ZpZXcodik7XHJcbiAgICB9XHJcblxyXG4gICAgb25WaWV3UmVtb3ZlKHNlbmRlcjogVmlld0NvbnRyb2wsIHZpZXc6IFZpZXcpOiB2b2lkIHtcclxuICAgICAgICBjb25zb2xlLmluZm8oXCJvblZpZXdSZW1vdmVcIiwgc2VuZGVyLCB2aWV3KTtcclxuICAgICAgICBpZiAodmlldyAmJiB2aWV3IGluc3RhbmNlb2YgTWFya2VyVmlldykge1xyXG4gICAgICAgICAgICBpZiAodmlldy5sYXllcj8uaGlnaGxpZ2h0TWFya2VyKSB7XHJcbiAgICAgICAgICAgICAgICB2aWV3LmxheWVyLmhpZ2hsaWdodE1hcmtlcih2aWV3Lm1hcmtlciwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRJdGVtICYmIHRoaXMuc2VsZWN0ZWRJdGVtLmZlYXR1cmUgPT09IHZpZXcubWFya2VyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZEl0ZW0gPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMucGFyZW50Tm9kZSkge1xyXG4gICAgICAgICAgICB0aGlzLm1hcC5yZW1vdmVDb250cm9sKHRoaXMudmlld0N0cmwpO1xyXG4gICAgICAgICAgICB0aGlzLm1hcC5hZGRDb250cm9sKHRoaXMuY2F0ZWdvcmllTGF5ZXJDdHJsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuX3NpZGViYXJDbG9zZWQpIHtcclxuICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJtYWluXCIpLmNsYXNzTGlzdC5hZGQoXCJzaWRlYmFyLWNvbGxhcHNlZFwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgb25NYXBGZWF0dXJlQ2xpY2soc2VuZGVyOiBhbnksIGV2dDogTGVhZmxldE1vdXNlRXZlbnQpIHtcclxuICAgICAgICBjb25zb2xlLmluZm8oXCJvbk1hcEZlYXR1cmVDbGlja1wiLCBldnQpO1xyXG4gICAgICAgIGNvbnN0IGxheWVyID0gZXZ0LnByb3BhZ2F0ZWRGcm9tO1xyXG4gICAgICAgIGNvbnN0IGdlb0pzb25MID0gZXZ0LnRhcmdldDtcclxuICAgICAgICBsZXQgaXNPdGhlckl0ZW0gPSB0cnVlO1xyXG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGVkSXRlbSkge1xyXG4gICAgICAgICAgICBpc090aGVySXRlbSA9IHRoaXMuc2VsZWN0ZWRJdGVtLmZlYXR1cmUgIT09IGxheWVyO1xyXG4gICAgICAgICAgICBpZiAoZ2VvSnNvbkwuZmN0UG9wdXApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRJdGVtLmZlYXR1cmVMYXllci5oaWdobGlnaHRNYXJrZXIodGhpcy5zZWxlY3RlZEl0ZW0uZmVhdHVyZSwgZmFsc2UpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy52aWV3Q3RybC5nb0JhY2soKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNPdGhlckl0ZW0pIHtcclxuICAgICAgICAgICAgZ2VvSnNvbkwuaGlnaGxpZ2h0TWFya2VyKGxheWVyLCB0cnVlKTtcclxuICAgICAgICAgICAgaWYgKGdlb0pzb25MLmZjdFBvcHVwKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzID0gZ2VvSnNvbkwuZmN0UG9wdXAobGF5ZXIuZmVhdHVyZS5wcm9wZXJ0aWVzKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBvcHVwID0gTC5wb3B1cCgpLnNldENvbnRlbnQocykuc2V0TGF0TG5nKGV2dC5sYXRsbmcpLm9wZW5PbihnZW9Kc29uTC5fbWFwKTtcclxuICAgICAgICAgICAgICAgIHBvcHVwLm9uY2UoXCJyZW1vdmVcIiwgKGV2dCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGdlb0pzb25MLmhpZ2hsaWdodE1hcmtlcihsYXllciwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNob3dEYXRhKGdlb0pzb25MLCBsYXllcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZEl0ZW0gPSB7IGZlYXR1cmVMYXllcjogZ2VvSnNvbkwsIGZlYXR1cmU6IGxheWVyIH07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIG9uQmFzZUxheWVyU2VsZWN0aW9uKHNlbmRlcjogTGF5ZXJDb250cm9sLCBuQmFzZUxheWVyOiBMLkxheWVyKTogdm9pZCB7XHJcbiAgICAgICAgY29uc29sZS5pbmZvKFwib25CYXNlTGF5ZXJTZWxlY3Rpb25cIiwgc2VuZGVyLCBuQmFzZUxheWVyKTtcclxuICAgICAgICBpZiAodGhpcy5iYXNlTGF5ZXIpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuYmFzZUxheWVyID09PSBuQmFzZUxheWVyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5iYXNlTGF5ZXIucmVtb3ZlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLm1hcCkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmluZm8oXCJiYXNlTGF5ZXJDaGFuZ2VkIG5ld1wiLCBuQmFzZUxheWVyKTtcclxuICAgICAgICAgICAgY29uc29sZS5pbmZvKFwiYmVmb3JlIGFkZExheWVyXCIsIG5CYXNlTGF5ZXIpO1xyXG4gICAgICAgICAgICAoPGFueT5uQmFzZUxheWVyKS5zZXRaSW5kZXgoMCk7XHJcbiAgICAgICAgICAgIHRoaXMubWFwLmFkZExheWVyKG5CYXNlTGF5ZXIpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmluZm8oXCJsYXllciBhZGRlZFwiLCBuQmFzZUxheWVyKTtcclxuICAgICAgICAgICAgdGhpcy5iYXNlTGF5ZXIgPSBuQmFzZUxheWVyO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcImJhc2VMYXllckNoYW5nZWQgbWFwPT1udWxsXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBhZGRPdmVybGF5VG9NYXAobHc6IExheWVyV3JhcHBlcik6IHZvaWQge1xyXG4gICAgICAgIGNvbnNvbGUuaW5mbyhcIk1hcENvbnRyb2wuYWRkT3ZlcmxheVRvTWFwXCIpO1xyXG4gICAgICAgIHRoaXMubWFwLmFkZExheWVyKGx3LmxheWVyKTtcclxuICAgICAgICBsdy5pZHggPSB0aGlzLmxheWVyT25NYXBMaXN0Lmxlbmd0aDtcclxuICAgICAgICB0aGlzLmxheWVyT25NYXBMaXN0LnB1c2gobHcpO1xyXG4gICAgICAgIE1hcERpc3BhdGNoZXIub25MYXllckFkZGVkLmRpc3BhdGNoKHRoaXMsIHtcclxuICAgICAgICAgICAgdHlwZTogXCJhZGRlZC10by1tYXBcIixcclxuICAgICAgICAgICAgbGF5ZXI6IGx3LFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIHRoaXMucHJpbnRMYXllckluZm8oKTtcclxuICAgIH1cclxuXHJcbiAgICBvbkxheWVyUmVhZHkoc2VuZGVyOiBMYXllckxvYWRlciwgZXZ0OiBMYXllckV2ZW50KTogdm9pZCB7XHJcbiAgICAgICAgY29uc29sZS5pbmZvKFwiTWFwQ29udHJvbC5vbkxheWVyUmVhZHlcIik7XHJcbiAgICAgICAgaWYgKGV2dC5sYXllci5pc1NlbGVjdGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkT3ZlcmxheVRvTWFwKGV2dC5sYXllcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJlbW92ZUxheWVyRnJvbU1hcChsdzogTGF5ZXJXcmFwcGVyKSB7XHJcbiAgICAgICAgdGhpcy5tYXAucmVtb3ZlTGF5ZXIobHcubGF5ZXIpO1xyXG4gICAgICAgIE1hcERpc3BhdGNoZXIub25MYXllclJlbW92ZWQuZGlzcGF0Y2godGhpcywge1xyXG4gICAgICAgICAgICB0eXBlOiBcInJlbW92ZWQtZnJvbS1tYXBcIixcclxuICAgICAgICAgICAgbGF5ZXI6IGx3LFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNvbnN0IGFycjogTGF5ZXJXcmFwcGVyW10gPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGF5ZXJPbk1hcExpc3QubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGx3ICE9PSB0aGlzLmxheWVyT25NYXBMaXN0W2ldKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxheWVyT25NYXBMaXN0W2ldLmlkeCA9IGFyci5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBhcnIucHVzaCh0aGlzLmxheWVyT25NYXBMaXN0W2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBsdy5pZHggPSAtMTtcclxuICAgICAgICB0aGlzLmxheWVyT25NYXBMaXN0ID0gYXJyO1xyXG4gICAgICAgIC8vIHRoaXMucHJpbnRMYXllckluZm8oKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBwcmludExheWVySW5mbygpIHtcclxuICAgIC8vICAgICBjb25zb2xlLmVycm9yKCdwcmludExheWVySW5mbycpO1xyXG4gICAgLy8gICAgIHRoaXMubWFwLmVhY2hMYXllcihpdGVtID0+IHtcclxuICAgIC8vICAgICAgICAgY29uc29sZS53YXJuKGl0ZW0pO1xyXG4gICAgLy8gICAgIH0pXHJcbiAgICAvLyAgICAgY29uc29sZS5lcnJvcigncHJpbnRMYXllckluZm8yJyk7XHJcbiAgICAvLyAgICAgdGhpcy5sYXllck9uTWFwTGlzdC5mb3JFYWNoKGl0ZW0gPT4ge1xyXG4gICAgLy8gICAgICAgICBjb25zb2xlLndhcm4oaXRlbSk7XHJcbiAgICAvLyAgICAgfSlcclxuICAgIC8vIH1cclxuXHJcbiAgICBvblRoZW1lTGF5ZXJTZWxlY3Rpb24oc2VuZGVyOiBMYXllcldyYXBwZXIsIGV2dDogTGF5ZXJFdmVudCk6IHZvaWQge1xyXG4gICAgICAgIC8vIGNvbnNvbGUuZXJyb3IoXCJvblRoZW1lTGF5ZXJTZWxlY3Rpb25cIiwgZXZ0KTtcclxuICAgICAgICBpZiAodGhpcy5tYXApIHtcclxuICAgICAgICAgICAgaWYgKGV2dC5sYXllci5pc1NlbGVjdGVkKSB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChldnQubGF5ZXIgJiYgZXZ0LmxheWVyLmxheWVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkT3ZlcmxheVRvTWFwKGV2dC5sYXllcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgTWFwRGlzcGF0Y2hlci5vbkxheWVyUmVxdWVzdC5kaXNwYXRjaCh0aGlzLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInJlcXVlc3QtbGF5ZXJcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxheWVyOiBldnQubGF5ZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5pbmZvKGBlcnJvciBhZGRpbmcgbGF5ZXIgXCIke2V2dC5sYXllci5sYXllckRlc2NyaXB0aW9uLmxhYmVsfVwiYCwgZXgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKGV2dC5sYXllci5sYXllcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlTGF5ZXJGcm9tTWFwKGV2dC5sYXllcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgc2hvd1ZpZXcodmlldzogVmlldykge1xyXG4gICAgICAgIGlmICh0aGlzLnBhcmVudE5vZGUpIHtcclxuICAgICAgICAgICAgY29uc29sZS5pbmZvKFwiTWFwQ3RybC5zaG93RGF0YVwiKTtcclxuICAgICAgICAgICAgdGhpcy5jYXRlZ29yaWVMYXllckN0cmwucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgIHRoaXMubWFwLmFkZENvbnRyb2wodGhpcy52aWV3Q3RybCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5jbG9zZU1lbnUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy52aWV3Q3RybC5zZXRDb250ZW50Vmlldyh2aWV3LCB0cnVlKTtcclxuICAgICAgICBpZiAoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJtYWluXCIpPy5jbGFzc0xpc3QuY29udGFpbnMoXCJzaWRlYmFyLWNvbGxhcHNlZFwiKSkge1xyXG4gICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIm1haW5cIikuY2xhc3NMaXN0LnJlbW92ZShcInNpZGViYXItY29sbGFwc2VkXCIpO1xyXG4gICAgICAgICAgICB0aGlzLl9zaWRlYmFyQ2xvc2VkID0gdHJ1ZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9zaWRlYmFyQ2xvc2VkID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHNob3dEYXRhKGxheWVyOiBDYXRlZ29yaWVMYXllcjxhbnksIGFueT4gfCBHZW9qc29uTGF5ZXIsIG1hcmtlcjogQ2F0ZWdvcnlNYXBPYmplY3Q8YW55PiB8IGFueSkge1xyXG4gICAgICAgIGlmIChsYXllcj8ucmVuZGVyRGF0YSkge1xyXG4gICAgICAgICAgICB0aGlzLnNob3dWaWV3KGxheWVyLnJlbmRlckRhdGEobWFya2VyKSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKG1hcmtlcj8uZmVhdHVyZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zaG93VmlldyhuZXcgTWFya2VyVmlldyhsYXllciwgbWFya2VyKSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmluZm8obGF5ZXIsIG1hcmtlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgYWRkVG8obWFwOiBMLk1hcCk6IHRoaXMge1xyXG4gICAgICAgIC8vIGNvbnNvbGUuZXJyb3IoXCJNYXBDb250cm9sLmFkZFRvXCIsIHRoaXMucGFyZW50Tm9kZSk7XHJcbiAgICAgICAgaWYgKHRoaXMucGFyZW50Tm9kZSkge1xyXG4gICAgICAgICAgICB0aGlzLnJlbW92ZSgpO1xyXG4gICAgICAgICAgICB0aGlzLm1hcCA9IG1hcDtcclxuICAgICAgICAgICAgY29uc3QgY29udGFpbmVyID0gKCg8YW55PnRoaXMpLl9jb250YWluZXIgPSB0aGlzLm9uQWRkKG1hcCkpO1xyXG4gICAgICAgICAgICB0aGlzLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcclxuICAgICAgICAgICAgdGhpcy5tYXAub24oXCJ1bmxvYWRcIiwgdGhpcy5yZW1vdmUsIHRoaXMpO1xyXG4gICAgICAgICAgICB0aGlzLm1hcC5hZGRDb250cm9sKHRoaXMuYmFzZUxheWVyQ3RybCk7XHJcbiAgICAgICAgICAgIHRoaXMubWFwLmFkZENvbnRyb2wodGhpcy5jYXRlZ29yaWVMYXllckN0cmwpO1xyXG4gICAgICAgICAgICAvLyB0aGlzLm1hcC5hZGRDb250cm9sKHRoaXMuYmFzZUxheWVyQ3RybDIpO1xyXG4gICAgICAgICAgICB0aGlzLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQodGhpcy5tYXBDdHJsQ29udGVudENvbnRhaW5lcik7XHJcbiAgICAgICAgICAgIC8vIHRoaXMucGFyZW50Tm9kZS5hcHBlbmRDaGlsZCh0aGlzLmxheUN0cmxDb250YWluZXIpO1xyXG4gICAgICAgICAgICAvLyB0aGlzLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQodGhpcy52aWV3Q3RybENvbnRhaW5lcik7XHJcbiAgICAgICAgICAgIC8vIHRoaXMudmlld0N0cmxDb250YWluZXIuc3R5bGUuZGlzcGxheSA9ICdub25lJztcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gcmV0dXJuIHN1cGVyLmFkZFRvKG1hcCk7XHJcbiAgICAgICAgICAgIHN1cGVyLmFkZFRvKG1hcCk7XHJcbiAgICAgICAgICAgIHRoaXMuc2VhcmNoQm94LmZvY3VzKCk7XHJcbiAgICAgICAgICAgIG1hcC5hZGRDb250cm9sKHRoaXMudmlld0N0cmwpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgb25BZGQobWFwOiBMLk1hcCk6IEhUTUxFbGVtZW50IHtcclxuICAgICAgICBjb25zb2xlLmluZm8oXCJNZW51Q29udHJvbC5vbkFkZFwiKTtcclxuICAgICAgICAvLyBNYXBEaXNwYXRjaGVyLm1hcCA9IG1hcDtcclxuICAgICAgICB0aGlzLm1hcCA9IG1hcDtcclxuICAgICAgICBpZiAoIXRoaXMuZG9tKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRpdiA9IGNyZWF0ZUh0bWxFbGVtZW50KFwiZGl2XCIsIHVuZGVmaW5lZCwgXCJtYXBjdHJsXCIpO1xyXG4gICAgICAgICAgICBjb25zdCBkaXZUb3AgPSAodGhpcy50b3BEaXYgPSBjcmVhdGVIdG1sRWxlbWVudChcImRpdlwiLCBkaXYsIFwibWFwY3RybC10b3AgY2xvc2VkXCIpKTtcclxuICAgICAgICAgICAgY29uc3Qgc2VhcmNoVG9wID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzZWFyY2h3cmFwcGVyXCIpO1xyXG5cclxuICAgICAgICAgICAgaWYgKCF0aGlzLnBhcmVudE5vZGUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGFuY2hvciA9IGNyZWF0ZUh0bWxFbGVtZW50KFwiYVwiLCBkaXZUb3AsIFwibWVudS1idXR0b25cIik7XHJcbiAgICAgICAgICAgICAgICBhbmNob3IuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLCAocCkgPT4gdGhpcy5fbWVudUNsaWNrZWQocCkpO1xyXG4gICAgICAgICAgICAgICAgY3JlYXRlSHRtbEVsZW1lbnQoXCJkaXZcIiwgYW5jaG9yKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNlYXJjaFdyYXBwZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG4gICAgICAgICAgICAgICAgTC5Eb21FdmVudC5kaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbihzZWFyY2hXcmFwcGVyKTtcclxuICAgICAgICAgICAgICAgIEwuRG9tRXZlbnQuZGlzYWJsZVNjcm9sbFByb3BhZ2F0aW9uKHNlYXJjaFdyYXBwZXIpO1xyXG4gICAgICAgICAgICAgICAgc2VhcmNoV3JhcHBlci5jbGFzc05hbWUgPSBcInNlYXJjaC13cmFwcGVyXCI7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHNlYXJjaFRvcCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlYXJjaFRvcC5hcHBlbmRDaGlsZChzZWFyY2hXcmFwcGVyKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGl2VG9wLmFwcGVuZENoaWxkKHNlYXJjaFdyYXBwZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGNvbnN0IHNlYXJjaEJveCA9ICh0aGlzLnNlYXJjaEJveCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKSk7XHJcbiAgICAgICAgICAgICAgICBzZWFyY2hXcmFwcGVyLmFwcGVuZENoaWxkKHNlYXJjaEJveCk7XHJcbiAgICAgICAgICAgICAgICBzZWFyY2hCb3gudHlwZSA9IFwidGV4dFwiO1xyXG4gICAgICAgICAgICAgICAgLy8gc2VhcmNoQm94LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgKGV2KT0+dGhpcy5fc2VhcmNoSW5wdXQoZXYpKTtcclxuICAgICAgICAgICAgICAgIHNlYXJjaEJveC5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNpblwiLCAoZXYpID0+IHRoaXMuX3NlYXJjaEZvY3VzSW4oZXYpKTtcclxuICAgICAgICAgICAgICAgIHNlYXJjaEJveC5wbGFjZWhvbGRlciA9IFwiU3VjaGVcIjtcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBzZWFyY2hCb3hDbGVhciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpXCIpO1xyXG4gICAgICAgICAgICAgICAgc2VhcmNoQm94Q2xlYXIuY2xhc3NOYW1lID0gXCJzZWFyY2gtaW5wdXQtY2xlYXJcIjtcclxuICAgICAgICAgICAgICAgIHNlYXJjaFdyYXBwZXIuYXBwZW5kQ2hpbGQoc2VhcmNoQm94Q2xlYXIpO1xyXG4gICAgICAgICAgICAgICAgc2VhcmNoQm94Q2xlYXIuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIChldikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlYXJjaEJveC52YWx1ZSA9IFwiXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aWV3Q3RybC5jbGVhcigpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgYXV0b2NvbXBsZXRlKHNlYXJjaEJveCwge1xyXG4gICAgICAgICAgICAgICAgICAgIG9uU2VsZWN0OiAoaXRlbTogYW55LCBpbnB1dDogSFRNTElucHV0RWxlbWVudCkgPT4gdGhpcy5fZm91bmQoaXRlbSwgaW5wdXQpLFxyXG4gICAgICAgICAgICAgICAgICAgIG9uU2VhcmNoU3RhcnQ6IChpbnB1dDogSFRNTElucHV0RWxlbWVudCkgPT4gdGhpcy5fc2VhcmNoU3RhcnQoaW5wdXQpLFxyXG4gICAgICAgICAgICAgICAgICAgIGZldGNoOiB0aGlzLnNlYXJjaEZjdCxcclxuICAgICAgICAgICAgICAgICAgICBtaW5MZW5ndGg6IDMsXHJcbiAgICAgICAgICAgICAgICAgICAgc2hvd09uRm9jdXM6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgbGFiZWxBdHRyOiBcIm5hbWVcIixcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2VhcmNoQ3RybCA9ICh0aGlzLnNlYXJjaEN0cmwgPSBuZXcgU2VhcmNoQ29udHJvbCh7XHJcbiAgICAgICAgICAgICAgICAgICAgb25TZWxlY3Q6IChpdGVtOiBhbnksIGlucHV0OiBIVE1MSW5wdXRFbGVtZW50KSA9PiB0aGlzLl9mb3VuZChpdGVtLCBpbnB1dCksXHJcbiAgICAgICAgICAgICAgICAgICAgb25TZWFyY2hTdGFydDogKGlucHV0OiBIVE1MSW5wdXRFbGVtZW50KSA9PiB0aGlzLl9zZWFyY2hTdGFydChpbnB1dCksXHJcbiAgICAgICAgICAgICAgICAgICAgZmV0Y2g6IHRoaXMuc2VhcmNoRmN0LFxyXG4gICAgICAgICAgICAgICAgICAgIG1pbkxlbmd0aDogMyxcclxuICAgICAgICAgICAgICAgICAgICBzaG93T25Gb2N1czogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICBsYWJlbEF0dHI6IFwibmFtZVwiLFxyXG4gICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICAgICAgbWFwLmFkZENvbnRyb2woc2VhcmNoQ3RybCk7XHJcbiAgICAgICAgICAgICAgICBtYXAuYWRkQ29udHJvbChcclxuICAgICAgICAgICAgICAgICAgICBuZXcgSWNvbkFjdGlvbkN0cmwoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogXCJ0b3ByaWdodFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU6IFwiaG9tZS1pY29uXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogKGN0cmwpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2hvd0hvbWUoY3RybCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICBtYXAuYWRkQ29udHJvbChcclxuICAgICAgICAgICAgICAgICAgICBuZXcgQ2hhbmdlRm9udFNpemVDdHJsKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IFwidG9wcmlnaHRcIixcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgTC5Eb21FdmVudC5kaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbihkaXYpO1xyXG4gICAgICAgICAgICBMLkRvbUV2ZW50LmRpc2FibGVTY3JvbGxQcm9wYWdhdGlvbihkaXYpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5kb20gPSBkaXY7XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5wYXJlbnROb2RlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdDdHJsID0gbmV3IFZpZXdDb250cm9sKHsgcGFyZW50Tm9kZTogdGhpcy5tYXBDdHJsQ29udGVudENvbnRhaW5lciB9KTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudmlld0N0cmwgPSBuZXcgVmlld0NvbnRyb2woeyBwb3NpdGlvbjogXCJ0b3BsZWZ0XCIgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IGN1cnJab29tQ2xhc3MgPSAodGhpcy5jdXJyWm9vbUNsYXNzID0gXCJ6b29tXCIgKyBtYXAuZ2V0Wm9vbSgpKTtcclxuICAgICAgICB0aGlzLnBhcmVudE5vZGUuY2xhc3NMaXN0LmFkZChjdXJyWm9vbUNsYXNzKTtcclxuICAgICAgICBtYXAuYWRkRXZlbnRMaXN0ZW5lcihcInpvb21lbmRcIiwgKGV2KSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMucGFyZW50Tm9kZS5jbGFzc0xpc3QucmVtb3ZlKHRoaXMuY3Vyclpvb21DbGFzcyk7XHJcbiAgICAgICAgICAgIGNvbnN0IGN1cnJab29tQ2xhc3MgPSAodGhpcy5jdXJyWm9vbUNsYXNzID0gXCJ6b29tXCIgKyBtYXAuZ2V0Wm9vbSgpKTtcclxuICAgICAgICAgICAgdGhpcy5wYXJlbnROb2RlLmNsYXNzTGlzdC5hZGQoY3Vyclpvb21DbGFzcyk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLmRvbTtcclxuICAgIH1cclxuICAgIHNob3dIb21lKGN0cmw6IEwuQ29udHJvbCkge1xyXG4gICAgICAgIGNvbnNvbGUuaW5mbyhcInNob3dIb21lXCIsIHRoaXMpO1xyXG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiaG9tZS1vdmVybGF5XCIpLnN0eWxlLmRpc3BsYXkgPSBcIlwiO1xyXG4gICAgICAgIGlmICh0aGlzLmNhdGVnb3JpZUxheWVyQ3RybCBpbnN0YW5jZW9mIExheWVyQ29udHJvbFZhcikge1xyXG4gICAgICAgICAgICB0aGlzLmNhdGVnb3JpZUxheWVyQ3RybC5jbGVhclRoZW1lcygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNlYXJjaEN0cmwuY2xlYXJDbGlja2VkKCk7XHJcbiAgICAgICAgdGhpcy52aWV3Q3RybC5jbGVhcigpO1xyXG4gICAgICAgIGlmICh0aGlzLnJlc2V0TWFwKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVzZXRNYXAoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5iYXNlTGF5ZXJDdHJsLnNlbGVjdEJhc2VMYXllcigwKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIF9zZWFyY2hTdGFydChpbnB1dDogSFRNTElucHV0RWxlbWVudCk6IHZvaWQge1xyXG4gICAgICAgIGNvbnNvbGUuaW5mbyhcIl9zZWFyY2hTdGFydFwiKTtcclxuICAgICAgICB0aGlzLmNsZWFyUmVzdWx0cygpO1xyXG4gICAgfVxyXG4gICAgY2xlYXJSZXN1bHRzKCkge1xyXG4gICAgICAgIGNvbnNvbGUuaW5mbyhcImNsZWFyUmVzdWx0c1wiKTtcclxuICAgICAgICB0aGlzLnZpZXdDdHJsLmNsZWFyKCk7XHJcbiAgICAgICAgaWYgKHRoaXMuY2F0ZWdvcmllTGF5ZXJDdHJsLmNhdGVnb3JpZUxheWVyc1tcIkthdGVnb3JpZXNcIl0pIHtcclxuICAgICAgICAgICAgdGhpcy5jYXRlZ29yaWVMYXllckN0cmwuY2F0ZWdvcmllTGF5ZXJzW1wiS2F0ZWdvcmllc1wiXS5yZW1vdmVTZWFyY2hSZXN1bHRzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmZvdW5kQXJlYSkge1xyXG4gICAgICAgICAgICB0aGlzLmZvdW5kQXJlYS5yZW1vdmUoKTtcclxuICAgICAgICAgICAgdGhpcy5mb3VuZEFyZWEgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qIFRPRE8gKi9cclxuICAgIHByaXZhdGUgX2ZvdW5kKGl0ZW06IGFueSwgaW5wdXQ6IEhUTUxJbnB1dEVsZW1lbnQpOiB2b2lkIHtcclxuICAgICAgICAvLyBjb25zb2xlLmVycm9yKFwiX2ZvdW5kXCIpO1xyXG5cclxuICAgICAgICB0aGlzLmNsZWFyUmVzdWx0cygpO1xyXG5cclxuICAgICAgICB0aGlzLmNsb3NlTWVudSgpO1xyXG4gICAgICAgIGlmIChpdGVtPy5ncm91cCA9PT0gXCJUaGVtYVwiKSB7XHJcbiAgICAgICAgICAgIE1hcERpc3BhdGNoZXIub25TaG93TGF5ZXJJbmZvUmVxdWVzdC5kaXNwYXRjaCh0aGlzLCBpdGVtLmxheWVyKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGl0ZW0pIHtcclxuICAgICAgICAgICAgY29uc3QgZ2VvSiA9IHRoaXMuc2hvd0dlb2pzb24oaXRlbSk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcImZvdW5kXCIsIGl0ZW0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gaWYgKGl0ZW0uZ3JvdXA9PT0nS2F0ZWdvcmllJykge1xyXG4gICAgICAgIC8vIH0gZWxzZSBpZiAoaXRlbS5ncm91cD09PSdPcnQnKSB7XHJcbiAgICAgICAgLy8gfSBlbHNlIGlmIChpdGVtLmdyb3VwPT09J0VpbnJpY2h0dW5nJykge1xyXG4gICAgICAgIC8vICAgICBjb25zb2xlLmluZm8oJ19mb3VuZEVpbnJpY2h0dW5nJywgaXRlbSk7XHJcbiAgICAgICAgLy8gICAgIGNvbnN0IGxheWVyID0gdGhpcy5jYXRlZ29yaWVMYXllckN0cmwuY2F0ZWdvcmllTGF5ZXJzW1wiS2F0ZWdvcmllc1wiXTtcclxuICAgICAgICAvLyAgICAgaWYgKGxheWVyKSB7XHJcbiAgICAgICAgLy8gICAgICAgICBjb25zdCBtYXJrZXIgPSBsYXllci5maW5kTWFya2VyKGl0ZW0uaWQsIFwiaWRcIik7XHJcbiAgICAgICAgLy8gICAgICAgICBpZiAobWFya2VyKSB7XHJcbiAgICAgICAgLy8gICAgICAgICAgICAgdGhpcy5zaG93RGF0YShsYXllciwgbWFya2VyKTtcclxuICAgICAgICAvLyAgICAgICAgIH1cclxuICAgICAgICAvLyAgICAgfVxyXG4gICAgICAgIC8vIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gICAgIGNvbnN0IGdlb0ogPSB0aGlzLnNob3dPcnRzY2hhZnQoaXRlbSk7XHJcbiAgICAgICAgLy8gICAgIGNvbnNvbGUuaW5mbygnZm91bmQnLCBpdGVtKTtcclxuICAgICAgICAvLyAgICAgY29uc3QgY2F0TCA9IHRoaXMuY2F0ZWdvcmllTGF5ZXJDdHJsLmNhdGVnb3JpZUxheWVyc1tcIkthdGVnb3JpZXNcIl07XHJcbiAgICAgICAgLy8gICAgIGNhdEwuZmluZE1hcmtlcnMoaXRlbS50YWJsZSwgaXRlbS5pZCkudGhlbihcclxuICAgICAgICAvLyAgICAgICAgIG1hcmtlcnM9PntcclxuICAgICAgICAvLyAgICAgICAgICAgICBjb25zdCB2aWV3ID0gbmV3IE1hcmtlckxpc3RWaWV3KGdlb0osIGNhdEwsIG1hcmtlcnMpO1xyXG4gICAgICAgIC8vICAgICAgICAgICAgIHRoaXMuc2V0Q29udGVudFZpZXcodmlldyk7XHJcbiAgICAgICAgLy8gICAgICAgICB9XHJcbiAgICAgICAgLy8gICAgICk7XHJcbiAgICAgICAgLy8gfVxyXG4gICAgfVxyXG5cclxuICAgIHNob3dHZW9qc29uKGl0ZW06IGFueSk6IEwuR2VvSlNPTiB7XHJcbiAgICAgICAgY29uc29sZS5pbmZvKFwic2hvd0dlb2pzb25cIik7XHJcbiAgICAgICAgY29uc3QgZ2VvSiA9ICh0aGlzLmZvdW5kQXJlYSA9IEwuZ2VvSlNPTihpdGVtLmZlYXR1cmUuZ2VvbWV0cnksIHtcclxuICAgICAgICAgICAgc3R5bGU6IGZ1bmN0aW9uIChmZWF0dXJlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geyBjb2xvcjogXCIjMDAwXCIsIGRhc2hBcnJheTogXCIxMCA4XCIsIGZpbGxDb2xvcjogXCIjNTU1XCIgfTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9KSk7XHJcbiAgICAgICAgdGhpcy5tYXAuYWRkTGF5ZXIoZ2VvSik7XHJcbiAgICAgICAgdGhpcy5tYXAuZml0Qm91bmRzKGdlb0ouZ2V0Qm91bmRzKCkpO1xyXG4gICAgICAgIHJldHVybiBnZW9KO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgX3NlYXJjaEZvY3VzSW4oZXY6IEZvY3VzRXZlbnQpOiBhbnkge1xyXG4gICAgICAgIGNvbnNvbGUuaW5mbyhcIl9zZWFyY2hGb2N1c0luXCIsIGV2KTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIF9tZW51Q2xpY2tlZChwOiBQb2ludGVyRXZlbnQpOiBhbnkge1xyXG4gICAgICAgIGNvbnNvbGUuaW5mbyhcIl9tZW51Q2xpY2tlZFwiKTtcclxuICAgICAgICBpZiAodGhpcy5jbG9zZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5vcGVuTWVudSgpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2xvc2VNZW51KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNsb3NlTWVudSgpIHtcclxuICAgICAgICBpZiAodGhpcy5pc01lbnVPcGVuKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2xvc2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy50b3BEaXYuY2xhc3NMaXN0LnJlcGxhY2UoXCJvcGVuZWRcIiwgXCJjbG9zZWRcIik7XHJcbiAgICAgICAgICAgIHRoaXMubWFwLnJlbW92ZUNvbnRyb2wodGhpcy5iYXNlTGF5ZXJDdHJsKTtcclxuICAgICAgICAgICAgdGhpcy5tYXAucmVtb3ZlQ29udHJvbCh0aGlzLmNhdGVnb3JpZUxheWVyQ3RybCk7XHJcbiAgICAgICAgICAgIC8vIHRoaXMuY29udGVudEFyZWEuc3R5bGUuZGlzcGxheSA9ICcnO1xyXG4gICAgICAgICAgICB0aGlzLm1hcC5hZGRDb250cm9sKHRoaXMudmlld0N0cmwpO1xyXG4gICAgICAgICAgICB0aGlzLmlzTWVudU9wZW4gPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBvcGVuTWVudSgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaXNNZW51T3Blbikge1xyXG4gICAgICAgICAgICB0aGlzLmNsb3NlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLnRvcERpdi5jbGFzc0xpc3QucmVwbGFjZShcImNsb3NlZFwiLCBcIm9wZW5lZFwiKTtcclxuICAgICAgICAgICAgdGhpcy5tYXAuYWRkQ29udHJvbCh0aGlzLmJhc2VMYXllckN0cmwpO1xyXG4gICAgICAgICAgICB0aGlzLm1hcC5hZGRDb250cm9sKHRoaXMuY2F0ZWdvcmllTGF5ZXJDdHJsKTtcclxuICAgICAgICAgICAgLy8gdGhpcy5jb250ZW50QXJlYS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xyXG4gICAgICAgICAgICB0aGlzLm1hcC5yZW1vdmVDb250cm9sKHRoaXMudmlld0N0cmwpO1xyXG4gICAgICAgICAgICB0aGlzLmlzTWVudU9wZW4gPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBvblJlbW92ZShtYXA6IEwuTWFwKSB7XHJcbiAgICAgICAgY29uc29sZS5pbmZvKFwiTWVudUNvbnRyb2wub25SZW1vdmVcIik7XHJcbiAgICAgICAgdGhpcy5tYXAgPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIHNldEJhc2VMYXllcnMoYmFzZUxheWVyczogTGF5ZXJEZXNjcmlwdGlvbltdLCBvcHRpb25zOiB7IGxhYmVsQXR0cmlidXRlOiBzdHJpbmcgfSkge1xyXG4gICAgICAgIHRoaXMuYmFzZUxheWVyQ3RybC5zZXRCYXNlTGF5ZXJzKGJhc2VMYXllcnMsIG9wdGlvbnMpO1xyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCB7IENhdGVnb3JpZUxheWVyLCBDYXRlZ29yeU1hcE9iamVjdCwgSW50ZXJhY3RpdmVMYXllciB9IGZyb20gXCIuL0NhdGVnb3JpZUxheWVyXCI7XHJcbmltcG9ydCB7IE1hcERpc3BhdGNoZXIgfSBmcm9tIFwiLi9NYXBDb250cm9sXCI7XHJcbmltcG9ydCB7IFZpZXcsIFZpZXdDb250cm9sIH0gZnJvbSBcIi4vVmlld0NvbnRyb2xcIjtcclxuaW1wb3J0IHsgY3JlYXRlSHRtbEVsZW1lbnQsIGNyZWF0ZVJvdyB9IGZyb20gXCIuLi9VdGlsXCI7XHJcbmltcG9ydCB7IExheWVyRGVzY3JpcHRpb24gfSBmcm9tIFwiLi4vY29uZi9NYXBEZXNjcmlwdGlvblwiO1xyXG5cclxuZnVuY3Rpb24gcHJlcGFyZUxpbmtzKHM6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgICBsZXQgcmVzdWx0ID0gXCJcIjtcclxuICAgIGlmIChzKSB7XHJcbiAgICAgICAgaWYgKHMuc3BsaXQoL1s+XS8pLmxlbmd0aCA+IDEgJiYgcy5zcGxpdCgvWz5dLykubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICAvLyB2aWVsbGVpY2h0IEhUTUwga2VpbmUgw4RuZGVydW5nXHJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGAvWz48XSsvZy5leGVjKHMpLmxlbmd0aD0nJHsvWz48XSsvZy5leGVjKHMpPy5sZW5ndGh9J2ApO1xyXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhgcy5zcGxpdCgvWz48XS8pLmxlbmd0aD0nJHtzLnNwbGl0KC9bPjxdLykubGVuZ3RofSdgKTtcclxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2cocy5zcGxpdCgvWz48XS8pKTtcclxuICAgICAgICAgICAgcmVzdWx0ID0gcztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBzQSA9IHMuc3BsaXQoL1tcXHNdKy8pO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgY291bnQgPSBzQS5sZW5ndGg7IGkgPCBjb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJ0ID0gc0FbaV07XHJcbiAgICAgICAgICAgICAgICBpZiAoaSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCIgXCI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAocGFydC5pbmRleE9mKFwiaHR0cFwiKSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnPGEgaHJlZj1cIic7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IHBhcnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9ICdcIj4nO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBwYXJ0O1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcIjwvYT5cIjtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IHBhcnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG5leHBvcnQgdHlwZSBMaXN0RW50cnk8VD4gPSB7XHJcbiAgICBpdGVtOiBUO1xyXG4gICAgZG9tOiBIVE1MRWxlbWVudDtcclxufTtcclxuXHJcbmV4cG9ydCBjbGFzcyBNYXJrZXJWaWV3IGltcGxlbWVudHMgVmlldyB7XHJcbiAgICBsYXllcjogSW50ZXJhY3RpdmVMYXllcjtcclxuICAgIG1hcmtlcjogQ2F0ZWdvcnlNYXBPYmplY3Q8YW55PjtcclxuXHJcbiAgICBkb206IEhUTUxFbGVtZW50O1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGxheWVyOiBJbnRlcmFjdGl2ZUxheWVyLCBtYXJrZXI6IENhdGVnb3J5TWFwT2JqZWN0PGFueT4pIHtcclxuICAgICAgICBjb25zb2xlLmluZm8oXCJNYXJrZXJ2aWV3IGNyZWF0ZVwiKTtcclxuICAgICAgICB0aGlzLmxheWVyID0gbGF5ZXI7XHJcbiAgICAgICAgdGhpcy5tYXJrZXIgPSBtYXJrZXI7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0VGl0bGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubGF5ZXJbXCJMYXllckRlc2NyaXB0aW9uXCJdPy5sYWJlbDtcclxuICAgIH1cclxuXHJcbiAgICBnZXREb20oKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmRvbSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5sYXllcj8ucG9wdXBGYWN0b3J5KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRvbSA9IHRoaXMubGF5ZXIucG9wdXBGYWN0b3J5LnJlbmRlckRhdGFWaWV3KHRoaXMubGF5ZXIsIHRoaXMubWFya2VyKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZG9tID0gdGhpcy5yZW5kZXJEYXRhVmlldygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmRvbTtcclxuICAgIH1cclxuXHJcbiAgICByZW5kZXJEYXRhVmlldygpIHtcclxuICAgICAgICBjb25zb2xlLmluZm8oXCJyZW5kZXJkYXRhVmlld1wiLCB0aGlzKTtcclxuICAgICAgICBjb25zdCBkb20gPSBjcmVhdGVIdG1sRWxlbWVudChcImRpdlwiLCB1bmRlZmluZWQsIFwiZGF0YS12aWV3XCIpO1xyXG4gICAgICAgIGNyZWF0ZUh0bWxFbGVtZW50KFwiaDFcIiwgZG9tLCBcImRhdGFpbmZvLXRpdGxlXCIsIHtcclxuICAgICAgICAgICAgaW5uZXJIVE1MOiB0aGlzLmxheWVyW1wiTGF5ZXJEZXNjcmlwdGlvblwiXT8ubGFiZWwsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY29uc29sZS5pbmZvKHRoaXMubGF5ZXJbXCJMYXllckRlc2NyaXB0aW9uXCJdPy5sYWJlbCk7XHJcbiAgICAgICAgLy8gY29uc3QgdGFibGUgPSBjcmVhdGVIdG1sRWxlbWVudCgndGFibGUnLCBkb20pO1xyXG5cclxuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5tYXJrZXIuZGF0YSA/IHRoaXMubWFya2VyLmRhdGEgOiAoPGFueT50aGlzLm1hcmtlcik/LmZlYXR1cmU/LnByb3BlcnRpZXM7XHJcblxyXG4gICAgICAgIGNvbnN0IGxheWVyRGVzOiBMYXllckRlc2NyaXB0aW9uID0gdGhpcy5sYXllcltcIkxheWVyRGVzY3JpcHRpb25cIl07XHJcbiAgICAgICAgaWYgKGxheWVyRGVzPy5sYXllckF0dHJpYnV0ZXMpIHtcclxuICAgICAgICAgICAgbGV0IGkgPSAwO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBrIGluIGxheWVyRGVzLmxheWVyQXR0cmlidXRlcykge1xyXG4gICAgICAgICAgICAgICAgbGV0IHYgPSBkYXRhW2tdO1xyXG4gICAgICAgICAgICAgICAgaWYgKHYgfHwgIWxheWVyRGVzLmhpZGVFbXB0eUxheWVyQXR0cmlidXRlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHAgPSBjcmVhdGVIdG1sRWxlbWVudChcInBcIiwgZG9tLCBcImRhdGFpbmZvLXJvd1wiKTtcclxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVIdG1sRWxlbWVudChcInNwYW5cIiwgcCwgXCJkYXRhaW5mby1yb3ctaGVhZFwiLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlubmVySFRNTDogbGF5ZXJEZXMubGF5ZXJBdHRyaWJ1dGVzW2tdLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHYgPT09IFwic3RyaW5nXCIgJiYgdi5pbmRleE9mKFwiaHR0cFwiKSA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHYgPSBwcmVwYXJlTGlua3Modik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUh0bWxFbGVtZW50KFwic3BhblwiLCBwLCBcImRhdGFpbmZvLXJvdy1jb250ZW50XCIsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5uZXJIVE1MOiB2LFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGkrKztcclxuICAgICAgICAgICAgICAgICAgICAvLyBjcmVhdGVSb3cobGF5ZXJEZXMubGF5ZXJBdHRyaWJ1dGVzW2tdLCB2LCB0YWJsZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGkgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIGNyZWF0ZUh0bWxFbGVtZW50KFwicFwiLCBkb20sIFwiZGF0YWluZm8tcm93LWhlYWRcIiwge1xyXG4gICAgICAgICAgICAgICAgICAgIGlubmVySFRNTDogXCJFcyBsaWVnZW4ga2VpbmUgd2VpdGVyZW4gRGF0ZW4gdm9yLlwiLFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gaWYgKGxheWVyRGVzPy5nZW9tVHlwZSA9PT0gXCJDaGFydFwiKSB7XHJcbiAgICAgICAgICAgIC8vICAgICBjb25zdCBtID0gPFBpZWNoYXJ0TWFya2VyPGFueT4+dGhpcy5tYXJrZXI7XHJcbiAgICAgICAgICAgIC8vICAgICBjb25zdCBkaXYgPSBjcmVhdGVIdG1sRWxlbWVudChcImRpdlwiLCBkb20pO1xyXG4gICAgICAgICAgICAvLyAgICAgZGl2LmFwcGVuZENoaWxkKG0uZ2V0UGllY2hhcnQoKSk7XHJcbiAgICAgICAgICAgIC8vIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBjcmVhdGVSb3coaywgZGF0YVtrXSwgdGFibGUpO1xyXG4gICAgICAgICAgICBjcmVhdGVIdG1sRWxlbWVudChcInBcIiwgZG9tLCBcImRhdGFpbmZvLXJvdy1oZWFkXCIsIHtcclxuICAgICAgICAgICAgICAgIGlubmVySFRNTDogXCJFcyBsaWVnZW4ga2VpbmUgd2VpdGVyZW4gRGF0ZW4gdm9yLlwiLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRvbTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIE1hcmtlckxpc3RWaWV3IGltcGxlbWVudHMgVmlldyB7XHJcbiAgICBsYXllcjogQ2F0ZWdvcmllTGF5ZXI8YW55LCBhbnk+O1xyXG4gICAgbWFya2VyczogQ2F0ZWdvcnlNYXBPYmplY3Q8YW55PltdO1xyXG4gICAgc2VsZWN0ZWRMaXN0RW50cnk6IExpc3RFbnRyeTxhbnk+O1xyXG4gICAgZG9tOiBIVE1MRGl2RWxlbWVudDtcclxuICAgIGdlb0pzb246IEwuR2VvSlNPTjxhbnk+O1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGdlb0o6IEwuR2VvSlNPTiwgbGF5ZXI6IENhdGVnb3JpZUxheWVyPGFueSwgYW55PiwgbWFya2VyczogQ2F0ZWdvcnlNYXBPYmplY3Q8YW55PltdKSB7XHJcbiAgICAgICAgY29uc29sZS5pbmZvKFwiTWFya2VyTGlzdGlld1wiKTtcclxuICAgICAgICB0aGlzLmxheWVyID0gbGF5ZXI7XHJcbiAgICAgICAgdGhpcy5tYXJrZXJzID0gbWFya2VycztcclxuICAgICAgICB0aGlzLmdlb0pzb24gPSBnZW9KO1xyXG4gICAgfVxyXG5cclxuICAgIGdldERvbSgpOiBIVE1MRWxlbWVudCB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmRvbSkge1xyXG4gICAgICAgICAgICBjb25zdCBkaXZMaXN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcclxuICAgICAgICAgICAgZGl2TGlzdC5jbGFzc05hbWUgPSBcImxpc3QtaXRlbS12aWV3XCI7XHJcbiAgICAgICAgICAgIGNvbnN0IG1hcmtlcnMgPSB0aGlzLm1hcmtlcnM7XHJcbiAgICAgICAgICAgIGNvbnN0IHBvcCA9IHRoaXMubGF5ZXIucG9wdXBGYWN0b3J5O1xyXG5cclxuICAgICAgICAgICAgaWYgKG1hcmtlcnMgJiYgbWFya2Vycy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBtYXJrZXJzLmZvckVhY2goKG1hcmtlcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW1Eb20gPSBwb3AucmVuZGVyTGlzdEl0ZW0odGhpcy5sYXllciwgbWFya2VyKTtcclxuICAgICAgICAgICAgICAgICAgICBkaXZMaXN0LmFwcGVuZENoaWxkKGl0ZW1Eb20pO1xyXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1Eb20uY2xhc3NOYW1lID0gXCJsaXN0LWl0ZW1cIjtcclxuICAgICAgICAgICAgICAgICAgICBpdGVtRG9tLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoZXYpID0+IHRoaXMubGlzdEVudHJ5Q2xpY2tlZCh7IGRvbTogPEhUTUxFbGVtZW50PmV2LnRhcmdldCwgaXRlbTogbWFya2VyIH0pKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY3JlYXRlSHRtbEVsZW1lbnQoXCJwXCIsIGRpdkxpc3QpLmlubmVySFRNTCA9IFwiRXMgd3VyZGUgbmljaHRzIGdlZnVuZGVuXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5kb20gPSBkaXZMaXN0O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5kb207XHJcbiAgICB9XHJcblxyXG4gICAgbGlzdEVudHJ5Q2xpY2tlZChlbnRyeTogTGlzdEVudHJ5PGFueT4pOiBhbnkge1xyXG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGVkTGlzdEVudHJ5KSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRMaXN0RW50cnkuZG9tLmNsYXNzTGlzdC5yZW1vdmUoXCJzZWxlY3RlZFwiKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRMaXN0RW50cnkgPT09IGVudHJ5KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkTGlzdEVudHJ5ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgTWFwRGlzcGF0Y2hlci5vbkxpc3RWaWV3SXRlbVNlbGVjdGlvbi5kaXNwYXRjaCh0aGlzLCB1bmRlZmluZWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc2VsZWN0ZWRMaXN0RW50cnkgPSBlbnRyeTtcclxuICAgICAgICBNYXBEaXNwYXRjaGVyLm9uTGlzdFZpZXdJdGVtU2VsZWN0aW9uLmRpc3BhdGNoKHRoaXMsIGVudHJ5Lml0ZW0pO1xyXG4gICAgICAgIGNvbnNvbGUuaW5mbyhcImxpc3RFbnRyeUNsaWNrZWRcIiwgZW50cnkpO1xyXG4gICAgfVxyXG5cclxuICAgIG9uQWRkKHBhcmVudDogVmlld0NvbnRyb2wpIHtcclxuICAgICAgICBjb25zb2xlLmluZm8oXCJNYXJrZXJMaXN0Vmlldy5vbkFkZFwiKTtcclxuICAgIH1cclxuICAgIG9uUmVtb3ZlKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmdlb0pzb24pIHtcclxuICAgICAgICAgICAgdGhpcy5nZW9Kc29uLnJlbW92ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zb2xlLmluZm8oXCJNYXJrZXJMaXN0Vmlldy5vblJlbW92ZVwiKTtcclxuICAgIH1cclxufVxyXG4iLCIvLyBpbXBvcnQgKiBhcyBMIGZyb20gXCJsZWFmbGV0XCI7XHJcbmltcG9ydCB7IENvbnRyb2wsIERvbUV2ZW50IH0gZnJvbSBcImxlYWZsZXRcIjtcclxuaW1wb3J0IHsgRXZlbnREaXNwYXRjaGVyIH0gZnJvbSBcInN0ZS1ldmVudHNcIjtcclxuaW1wb3J0IHsgY3JlYXRlSHRtbEVsZW1lbnQgfSBmcm9tIFwiLi4vVXRpbFwiO1xyXG5pbXBvcnQgYXV0b2NvbXBsZXRlLCB7IEF1dG9jb21wbGV0ZUl0ZW0sIEF1dG9jb21wbGV0ZVNldHRpbmdzIH0gZnJvbSBcIi4uL3V0aWwvQXV0b2NvbXBsZXRlclwiO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBTZWFyY2hDb250cm9sT3B0aW9uczxUIGV4dGVuZHMgQXV0b2NvbXBsZXRlSXRlbT4gZXh0ZW5kcyBBdXRvY29tcGxldGVTZXR0aW5nczxUPiB7XHJcbiAgICBwb3NpdGlvbj86IEwuQ29udHJvbFBvc2l0aW9uO1xyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgU2VhcmNoQ29udHJvbCBleHRlbmRzIENvbnRyb2wge1xyXG4gICAgb25TaG93U2VhcmNoRmllbGQgPSBuZXcgRXZlbnREaXNwYXRjaGVyPFNlYXJjaENvbnRyb2wsIGJvb2xlYW4+KCk7XHJcblxyXG4gICAgX2NvbnRhaW5lcjogSFRNTERpdkVsZW1lbnQ7XHJcbiAgICBfQnR0bjogSFRNTEJ1dHRvbkVsZW1lbnQ7XHJcblxyXG4gICAgX2NsaWNrRmN0OiAoZXZ0OiBNb3VzZUV2ZW50KSA9PiB2b2lkO1xyXG4gICAgc2VhcmNoRG9tOiBIVE1MRGl2RWxlbWVudDtcclxuICAgIHNlYXJjaEJveDogSFRNTElucHV0RWxlbWVudDtcclxuXHJcbiAgICBwYXJhbXM6IFNlYXJjaENvbnRyb2xPcHRpb25zPGFueT47XHJcbiAgICBjbG9zZUJ0dG46IEhUTUxEaXZFbGVtZW50O1xyXG4gICAgaW5wdXRGaWVsZDogSFRNTElucHV0RWxlbWVudDtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihwYXJhbXM6IFNlYXJjaENvbnRyb2xPcHRpb25zPGFueT4pIHtcclxuICAgICAgICBzdXBlcihwYXJhbXMpO1xyXG4gICAgICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xyXG4gICAgICAgIHBhcmFtcy5vblNlYXJjaEZpbmlzaGVkID0gKGV2KSA9PiB0aGlzLmlzU2VhcmNoaW5nKGZhbHNlKTtcclxuICAgICAgICBwYXJhbXMub25TZWFyY2hTdGFydFJ1bm5pbmcgPSAoZXYpID0+IHRoaXMuaXNTZWFyY2hpbmcodHJ1ZSk7XHJcbiAgICB9XHJcbiAgICBpc1NlYXJjaGluZyhzZWFyY2hpbmc6IGJvb2xlYW4pOiB2b2lkIHtcclxuICAgICAgICBpZiAodGhpcy5zZWFyY2hEb20pIHtcclxuICAgICAgICAgICAgaWYgKHNlYXJjaGluZykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZWFyY2hEb20uY2xhc3NMaXN0LmFkZChcInNlYXJjaGluZ1wiKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2VhcmNoRG9tLmNsYXNzTGlzdC5yZW1vdmUoXCJzZWFyY2hpbmdcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgb25BZGQobWFwOiBMLk1hcCk6IEhUTUxFbGVtZW50IHtcclxuICAgICAgICBjb25zb2xlLmluZm8oXCJTZWFyY2hDb250cm9sLm9uQWRkXCIpO1xyXG4gICAgICAgIHRoaXMuX2NvbnRhaW5lciA9IGNyZWF0ZUh0bWxFbGVtZW50KFwiZGl2XCIsIHVuZGVmaW5lZCwgXCJjb250cm9sLXNlYXJjaFwiKTtcclxuICAgICAgICBjb25zdCBidHRuID0gKHRoaXMuX0J0dG4gPSBjcmVhdGVIdG1sRWxlbWVudChcImJ1dHRvblwiLCB0aGlzLl9jb250YWluZXIsIFwic2VhcmNoLWJ1dHRvbiBjdHJsLWljb25cIikpO1xyXG4gICAgICAgIGJ0dG4uYXJpYUxhYmVsID0gXCJTdWNoZmVsZCDDtmZmbmVuXCI7XHJcbiAgICAgICAgY3JlYXRlSHRtbEVsZW1lbnQoXCJpXCIsIGJ0dG4pO1xyXG5cclxuICAgICAgICB0aGlzLl9jbGlja0ZjdCA9IChldnQ6IE1vdXNlRXZlbnQpID0+IHtcclxuICAgICAgICAgICAgLy8gdGhpcy5vblNob3dTZWFyY2hGaWVsZC5kaXNwYXRjaCh0aGlzLCAhY2xvc2VkKTtcclxuICAgICAgICAgICAgdGhpcy5zaG93U2VhcmNoRmllbGQoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGJ0dG4uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX2NsaWNrRmN0KTtcclxuICAgICAgICBEb21FdmVudC5kaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbih0aGlzLl9jb250YWluZXIpO1xyXG5cclxuICAgICAgICB0aGlzLmNyZWF0ZVNlYXJjaEZpZWxkKCk7XHJcbiAgICAgICAgdGhpcy5fY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuc2VhcmNoRG9tKTtcclxuXHJcbiAgICAgICAgLy8gdGhpcy5fY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCAoKT0+e1xyXG4gICAgICAgIC8vICAgY29uc29sZS5pbmZvKFwiZWxlbWVudC5fY29udGFpbmVyOlwiLHRoaXMuX2NvbnRhaW5lcik7XHJcbiAgICAgICAgLy8gICBjb25zb2xlLmluZm8oXCJlbGVtZW50Lm9mZnNldFRvcDpcIit0aGlzLl9jb250YWluZXIub2Zmc2V0VG9wKTtcclxuICAgICAgICAvLyAgIGNvbnNvbGUuaW5mbyhcImVsZW1lbnQub2Zmc2V0TGVmdDpcIit0aGlzLl9jb250YWluZXIub2Zmc2V0TGVmdCk7XHJcbiAgICAgICAgLy8gICBjb25zb2xlLmluZm8oXCJlbGVtZW50Lm9mZnNldFdpZHRoOlwiK3RoaXMuX2NvbnRhaW5lci5vZmZzZXRXaWR0aCk7XHJcbiAgICAgICAgLy8gICBjb25zb2xlLmluZm8oXCJlbGVtZW50Lm9mZnNldEhlaWdodDpcIit0aGlzLl9jb250YWluZXIub2Zmc2V0SGVpZ2h0KTtcclxuICAgICAgICAvLyAgIGNvbnNvbGUuaW5mbyhcImVsZW1lbnQub2Zmc2V0UGFyZW50OlwiLHRoaXMuX2NvbnRhaW5lci5vZmZzZXRQYXJlbnQpO1xyXG4gICAgICAgIC8vICAgY29uc29sZS5pbmZvKFwiZWxlbWVudC5vZmZzZXRQYXJlbnQub2Zmc2V0UGFyZW50OlwiLCAoPGFueT50aGlzLl9jb250YWluZXIub2Zmc2V0UGFyZW50KS5vZmZzZXRQYXJlbnQpO1xyXG4gICAgICAgIC8vIH0pXHJcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgKGV2dDogS2V5Ym9hcmRFdmVudCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZXZ0LmN0cmxLZXkgJiYgZXZ0LmtleSA9PT0gXCJmXCIpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhldnQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zaG93U2VhcmNoRmllbGQoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuaW5wdXRGaWVsZC5mb2N1cygpO1xyXG4gICAgICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcclxuICAgIH1cclxuXHJcbiAgICBvblJlbW92ZShtYXA6IEwuTWFwKSB7XHJcbiAgICAgICAgdGhpcy5fQnR0bi5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5fY2xpY2tGY3QpO1xyXG4gICAgfVxyXG5cclxuICAgIGNyZWF0ZVNlYXJjaEZpZWxkKCkge1xyXG4gICAgICAgIGNvbnN0IHNlYXJjaERvbSA9ICh0aGlzLnNlYXJjaERvbSA9IGNyZWF0ZUh0bWxFbGVtZW50KFwiZGl2XCIsIHVuZGVmaW5lZCwgXCJzZWFyY2hcIikpO1xyXG4gICAgICAgIGNyZWF0ZUh0bWxFbGVtZW50KFwiZGl2XCIsIHNlYXJjaERvbSwgXCJzZWFyY2gtYW5pbWF0aW9uXCIpO1xyXG4gICAgICAgIGNvbnN0IHNlYXJjaFdyYXBwZXIgPSBjcmVhdGVIdG1sRWxlbWVudChcImRpdlwiLCBzZWFyY2hEb20sIFwic2VhcmNoLXdyYXBwZXJcIik7XHJcbiAgICAgICAgY29uc3QgY2xvc2VCdHRuID0gKHRoaXMuY2xvc2VCdHRuID0gY3JlYXRlSHRtbEVsZW1lbnQoXCJkaXZcIiwgc2VhcmNoRG9tLCBcImFuZ2Vscy11cFwiKSk7XHJcbiAgICAgICAgY2xvc2VCdHRuLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoZXYpID0+IHRoaXMuY2xvc2VCdHRuQ2xpY2tlZChldikpO1xyXG5cclxuICAgICAgICBjb25zdCBzZWFyY2hCb3ggPSAodGhpcy5pbnB1dEZpZWxkID0gdGhpcy5zZWFyY2hCb3ggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIikpO1xyXG4gICAgICAgIHNlYXJjaFdyYXBwZXIuYXBwZW5kQ2hpbGQoc2VhcmNoQm94KTtcclxuICAgICAgICBzZWFyY2hCb3gudHlwZSA9IFwidGV4dFwiO1xyXG5cclxuICAgICAgICBzZWFyY2hCb3gucGxhY2Vob2xkZXIgPSBcIk9ydCwgQWRyZXNzZSwgVGhlbWEuLlwiO1xyXG5cclxuICAgICAgICBjb25zdCBzZWFyY2hCb3hDbGVhciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpXCIpO1xyXG4gICAgICAgIHNlYXJjaEJveENsZWFyLmNsYXNzTmFtZSA9IFwic2VhcmNoLWlucHV0LWNsZWFyXCI7XHJcbiAgICAgICAgc2VhcmNoV3JhcHBlci5hcHBlbmRDaGlsZChzZWFyY2hCb3hDbGVhcik7XHJcbiAgICAgICAgc2VhcmNoQm94Q2xlYXIuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIChldikgPT4ge1xyXG4gICAgICAgICAgICBzZWFyY2hCb3gudmFsdWUgPSBcIlwiO1xyXG4gICAgICAgICAgICB0aGlzLmNsZWFyQ2xpY2tlZCgpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBhdXRvY29tcGxldGUoc2VhcmNoQm94LCB0aGlzLnBhcmFtcyk7XHJcbiAgICB9XHJcblxyXG4gICAgc2hvd1NlYXJjaEZpZWxkKCkge1xyXG4gICAgICAgIHRoaXMuX2NvbnRhaW5lci5jbGFzc0xpc3QudG9nZ2xlKFwib3BlbmVkXCIpO1xyXG4gICAgICAgIHRoaXMuc2VhcmNoQm94LmZvY3VzKCk7XHJcbiAgICB9XHJcbiAgICBjbG9zZUJ0dG5DbGlja2VkKGV2OiBNb3VzZUV2ZW50KTogYW55IHtcclxuICAgICAgICB0aGlzLl9jb250YWluZXIuY2xhc3NMaXN0LnRvZ2dsZShcIm9wZW5lZFwiKTtcclxuICAgIH1cclxuXHJcbiAgICBjbGVhckNsaWNrZWQoKSB7XHJcbiAgICAgICAgdGhpcy5pbnB1dEZpZWxkLnZhbHVlID0gXCJcIjtcclxuICAgICAgICB0aGlzLnBhcmFtcy5vblNlbGVjdCh1bmRlZmluZWQsIHRoaXMuaW5wdXRGaWVsZCk7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0ICogYXMgTCBmcm9tICdsZWFmbGV0JztcclxuaW1wb3J0IHsgY3JlYXRlSHRtbEVsZW1lbnQgfSBmcm9tICcuLi9VdGlsJztcclxuaW1wb3J0IHsgTWFwRGlzcGF0Y2hlciB9IGZyb20gJy4vTWFwQ29udHJvbCc7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFZpZXcge1xyXG4gICAgZ2V0RG9tKCk6SFRNTEVsZW1lbnQ7XHJcbiAgICBvbkFkZD8ocGFyZW50OlZpZXdDb250cm9sKTp2b2lkO1xyXG4gICAgb25SZW1vdmU/KCk6dm9pZDtcclxuICAgIGdldFRpdGxlPygpOnN0cmluZztcclxufVxyXG5cclxuaW50ZXJmYWNlIFZpZXdDdHJsT3B0aW9ucyBleHRlbmRzIEwuQ29udHJvbE9wdGlvbnMge1xyXG4gICAgcGFyZW50Tm9kZT8gOiBIVE1MRWxlbWVudFxyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgVmlld0NvbnRyb2wgZXh0ZW5kcyBMLkNvbnRyb2wge1xyXG5cclxuICAgIGRvbTogSFRNTEVsZW1lbnQ7XHJcbiAgICBuYXZpZ2F0aW9uQXJlYTogSFRNTEVsZW1lbnQ7XHJcbiAgICBjb250ZW50QXJlYTogSFRNTEVsZW1lbnQ7XHJcblxyXG4gICAgY29udGVudEhpc3Rvcnk6Vmlld1tdID0gW107XHJcbiAgICBjb3VudGVyOiBudW1iZXIgPSAwO1xyXG4gICAgbmF2QnR0bjogSFRNTEVsZW1lbnQ7XHJcbiAgICBhbmNob3JCYWNrOiBIVE1MQW5jaG9yRWxlbWVudDtcclxuICAgIG5hdlRpdGxlOiBIVE1MU3BhbkVsZW1lbnQ7XHJcbiAgICBwYXJlbnROb2RlOiBIVE1MRWxlbWVudDtcclxuICAgIHByaXZhdGUgX21hcDogTC5NYXA7XHJcblxyXG4gICAgY29uc3RydWN0b3Iob3B0aW9uczpWaWV3Q3RybE9wdGlvbnMpIHtcclxuICAgICAgICBzdXBlcihvcHRpb25zKTtcclxuICAgICAgICB0aGlzLnBhcmVudE5vZGUgPSBvcHRpb25zLnBhcmVudE5vZGU7XHJcbiAgICAgICAgY29uc3QgZGl2ID0gdGhpcy5kb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICBkaXYuY2xhc3NOYW1lID0gJ3ZpZXdjdHJsJztcclxuICAgICAgICBjb25zdCBuYXZBcmVhID0gdGhpcy5uYXZpZ2F0aW9uQXJlYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgIG5hdkFyZWEuY2xhc3NOYW1lID0gJ3ZpZXdjdHJsLW5hdic7ICAgICAgICBcclxuICAgICAgICB0aGlzLm5hdlRpdGxlID0gY3JlYXRlSHRtbEVsZW1lbnQoJ3NwYW4nLCBuYXZBcmVhKTsgICAgICAgIFxyXG4gICAgICAgIGNvbnN0IG5hdlNwYW4gPSB0aGlzLm5hdkJ0dG4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XHJcbiAgICAgICAgbmF2QXJlYS5hcHBlbmRDaGlsZChuYXZTcGFuKTtcclxuICAgICAgICBjb25zdCBhbmNob3JCYWNrID0gdGhpcy5hbmNob3JCYWNrID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpIDtcclxuICAgICAgICBhbmNob3JCYWNrLmNsYXNzTmFtZSA9ICdjbG9zZSc7XHJcbiAgICAgICAgbmF2U3Bhbi5hcHBlbmRDaGlsZChhbmNob3JCYWNrKTtcclxuICAgICAgICAvLyBjb25zdCBhbmNob3JDbG9zZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKSA7XHJcbiAgICAgICAgLy8gYW5jaG9yQ2xvc2UuY2xhc3NOYW1lID0gJ2JhY2snO1xyXG4gICAgICAgIC8vIG5hdlNwYW4uYXBwZW5kQ2hpbGQoYW5jaG9yQ2xvc2UpO1xyXG4gICAgICAgIC8vIG5hdkJ0dG4uaW5uZXJIVE1MID0gJyZsYXF1bzsgenVyw7xjayc7XHJcblxyXG4gICAgICAgIG5hdlNwYW4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZXYpPT50aGlzLl9iYWNrQnR0bkNsaWNrZWQoKSk7XHJcbiAgICAgICAgLy8gZGl2LmFwcGVuZENoaWxkKHRoaXMubmF2aWdhdGlvbkFyZWEpO1xyXG4gICAgICAgIHRoaXMuY29udGVudEFyZWEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICB0aGlzLmNvbnRlbnRBcmVhLmNsYXNzTmFtZSA9ICd2aWV3Y3RybC1jb250ZW50JztcclxuICAgICAgICBkaXYuYXBwZW5kQ2hpbGQodGhpcy5jb250ZW50QXJlYSk7XHJcblxyXG4gICAgICAgIGNvbnN0IGZuU3RvcFByb3BhZ2F0aW9uID0gKGV2KT0+IHtcclxuICAgICAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgTC5Eb21FdmVudC5kaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbihkaXYpO1xyXG4gICAgICAgIEwuRG9tRXZlbnQuZGlzYWJsZVNjcm9sbFByb3BhZ2F0aW9uKGRpdik7XHJcbiAgICAgICAgLy8gZGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVybW92ZVwiLCBmblN0b3BQcm9wYWdhdGlvbik7IFxyXG4gICAgICAgIC8vIGRpdi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZm5TdG9wUHJvcGFnYXRpb24pO1xyXG4gICAgICAgIC8vIGRpdi5hZGRFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCBmblN0b3BQcm9wYWdhdGlvbik7XHJcbiAgICAgICAgLy8gZGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVydXBcIiwgZm5TdG9wUHJvcGFnYXRpb24pO1xyXG4gICAgICAgIC8vIGRpdi5hZGRFdmVudExpc3RlbmVyKFwid2hlZWxcIiwgZm5TdG9wUHJvcGFnYXRpb24pO1xyXG4gICAgfVxyXG4gICAgcHJpdmF0ZSBfYmFja0J0dG5DbGlja2VkKCk6IGFueSB7XHJcbiAgICAgICAgdGhpcy5nb0JhY2soKTtcclxuICAgIH1cclxuXHJcbiAgICBhZGRUbyhtYXA6IEwuTWFwKTp0aGlzIHtcclxuICAgICAgICAvLyBjb25zb2xlLmVycm9yKCdWaWV3Q29udHJvbC5hZGRUbycpO1xyXG4gICAgICAgIGlmICh0aGlzLnBhcmVudE5vZGUpIHtcclxuICAgICAgICAgICAgdGhpcy5yZW1vdmUoKTtcclxuICBcdFx0ICAgIHRoaXMuX21hcCA9IG1hcDtcclxuICBcdFx0ICAgIGNvbnN0IGNvbnRhaW5lciA9ICg8YW55PnRoaXMpLl9jb250YWluZXIgPSB0aGlzLm9uQWRkKG1hcCk7ICBcdFx0ICAgIFxyXG4gICAgICAgICAgICB0aGlzLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTsgICAgICAgICAgICBcclxuICBcdFx0ICAgIHRoaXMuX21hcC5vbigndW5sb2FkJywgdGhpcy5yZW1vdmUsIHRoaXMpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gc3VwZXIuYWRkVG8obWFwKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgb25BZGQobWFwOkwuTWFwKTpIVE1MRWxlbWVudCB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9tO1xyXG4gICAgfVx0XHJcblxyXG4gICAgLy8gb25SZW1vdmUobWFwOkwuTWFwKSB7XHJcbiAgICAvLyAgICAgLy8gY29uc29sZS5lcnJvcihcIlZpZXdDb250cm9sLm9uUmVtb3ZlXCIpO1xyXG4gICAgLy8gfVxyXG5cclxuICAgIGNsZWFyKCkge1xyXG4gICAgICAgIGNvbnNvbGUuaW5mbyhcImNsZWFyXCIpO1xyXG4gICAgICAgIGxldCB2aWV3OlZpZXc7XHJcbiAgICAgICAgd2hpbGUgKHZpZXc9dGhpcy5jb250ZW50SGlzdG9yeS5wb3AoKSkge1xyXG4gICAgICAgICAgICBpZiAodmlldy5vblJlbW92ZSkge1xyXG4gICAgICAgICAgICAgICAgdmlldy5vblJlbW92ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIE1hcERpc3BhdGNoZXIub25WaWV3UmVtb3ZlLmRpc3BhdGNoKHRoaXMsIHZpZXcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNvbnRlbnRIaXN0b3J5ID0gW107XHJcbiAgICAgICAgaWYgKHRoaXMuY29udGVudEFyZWEuZmlyc3RDaGlsZCkge1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRlbnRBcmVhLnJlbW92ZUNoaWxkKHRoaXMuY29udGVudEFyZWEuZmlyc3RDaGlsZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmRvbS5jb250YWlucyh0aGlzLm5hdmlnYXRpb25BcmVhKSkge1xyXG4gICAgICAgICAgICB0aGlzLmRvbS5yZW1vdmVDaGlsZCh0aGlzLm5hdmlnYXRpb25BcmVhKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgc2V0Q29udGVudFZpZXcodjpWaWV3LCByZXBsYWNlOmJvb2xlYW4pOnZvaWQge1xyXG4gICAgICAgIGNvbnNvbGUuaW5mbyhgc2V0Vmlld2AsIHYpOyBcclxuICAgICAgICBpZiAocmVwbGFjZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9yZXBsYWNlQ29udGVudCh2KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9zZXRDb250ZW50KHYpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodi5vbkFkZCkge1xyXG4gICAgICAgICAgICB2Lm9uQWRkKHRoaXMpO1xyXG4gICAgICAgIH0gXHJcbiAgICB9XHJcbiAgICBcclxuICAgIHByaXZhdGUgX3JlcGxhY2VDb250ZW50KHZpZXc6Vmlldyk6dm9pZCB7XHJcbiAgICAgICAgY29uc29sZS5pbmZvKFwiX3JlcGxhY2VDb250ZW50XCIpO1xyXG4gICAgICAgIGxldCBvbGRWaWV3OlZpZXc7XHJcbiAgICAgICAgd2hpbGUgKG9sZFZpZXc9dGhpcy5jb250ZW50SGlzdG9yeS5wb3AoKSkge1xyXG4gICAgICAgICAgICBpZiAob2xkVmlldy5vblJlbW92ZSkge1xyXG4gICAgICAgICAgICAgICAgb2xkVmlldy5vblJlbW92ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGRvbSA9IHZpZXcuZ2V0RG9tKCk7XHJcbiAgICAgICAgaWYgKHRoaXMuY29udGVudEFyZWEuZmlyc3RDaGlsZCkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmluZm8oXCJfcmVwbGFjZUNvbnRlbnQwMVwiLCB0aGlzLmNvbnRlbnRBcmVhLmZpcnN0Q2hpbGQpO1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRlbnRBcmVhLnJlcGxhY2VDaGlsZChkb20sIHRoaXMuY29udGVudEFyZWEuZmlyc3RDaGlsZCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY29uc29sZS5pbmZvKFwiX3JlcGxhY2VDb250ZW50MDJcIik7XHJcbiAgICAgICAgICAgIHRoaXMuZG9tLmluc2VydEJlZm9yZSh0aGlzLm5hdmlnYXRpb25BcmVhLCB0aGlzLmNvbnRlbnRBcmVhKTtcclxuICAgICAgICAgICAgdGhpcy5jb250ZW50QXJlYS5hcHBlbmRDaGlsZChkb20pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNvbnRlbnRIaXN0b3J5ID0gW3ZpZXddO1xyXG4gICAgfVxyXG4gICAgcHJpdmF0ZSBfc2V0Q29udGVudCh2aWV3OlZpZXcpOnZvaWQgeyAgICAgICAgXHJcbiAgICAgICAgY29uc3QgZG9tID0gdmlldy5nZXREb20oKTtcclxuICAgICAgICBjb25zb2xlLmluZm8oJ1ZpZXdDb250cm9sLl9zZXRDb250ZW50MDEnLCBkb20pO1xyXG4gICAgICAgIGRvbS5pZD0ndmlld18nK3RoaXMuY291bnRlcjtcclxuICAgICAgICB0aGlzLmNvdW50ZXIrKztcclxuICAgICAgICBpZiAodGhpcy5jb250ZW50QXJlYS5maXJzdENoaWxkKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhgc2V0Q29udGVudCAke3RoaXMuY29udGVudEFyZWEuZmlyc3RDaGlsZFsnaWQnXX0gPT4gJHtkb20uaWR9YCk7XHJcbiAgICAgICAgICAgIHRoaXMuY29udGVudEFyZWEucmVwbGFjZUNoaWxkKGRvbSwgdGhpcy5jb250ZW50QXJlYS5maXJzdENoaWxkKTtcclxuICAgICAgICAgICAgdGhpcy5jb250ZW50SGlzdG9yeS5wdXNoKHZpZXcpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhgc2V0Q29udGVudCBub25lID0+ICR7ZG9tLmlkfSAoYWRkTmF2QXJlYSlgKVxyXG4gICAgICAgICAgICB0aGlzLmRvbS5pbnNlcnRCZWZvcmUodGhpcy5uYXZpZ2F0aW9uQXJlYSwgdGhpcy5jb250ZW50QXJlYSk7XHJcbiAgICAgICAgICAgIHRoaXMuY29udGVudEFyZWEuYXBwZW5kQ2hpbGQoZG9tKTtcclxuICAgICAgICAgICAgdGhpcy5jb250ZW50SGlzdG9yeS5wdXNoKHZpZXcpOyAgICAgICAgICAgIFxyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB2aWV3VGV4dCA9IHZpZXcuZ2V0VGl0bGUgPyB2aWV3LmdldFRpdGxlKCkgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5uYXZUaXRsZS5pbm5lclRleHQgPSAodmlld1RleHQpID8gdmlld1RleHQgOiAnJztcclxuXHJcbiAgICAgICAgY29uc29sZS5pbmZvKGBzZXRDb250ZW50IGRvbmUgJHt0aGlzLmNvbnRlbnRIaXN0b3J5Lmxlbmd0aH1gLCB0aGlzLmNvbnRlbnRIaXN0b3J5KTtcclxuICAgICAgICBpZiAodGhpcy5jb250ZW50SGlzdG9yeS5sZW5ndGg9PT0xKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYW5jaG9yQmFjay5jbGFzc0xpc3QucmVwbGFjZSgnYmFjaycsICdjbG9zZScpO1xyXG4gICAgICAgICAgICB0aGlzLmFuY2hvckJhY2sudGl0bGUgPSBcInNjaGxpZcOfZW5cIjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmFuY2hvckJhY2suY2xhc3NMaXN0LnJlcGxhY2UoJ2Nsb3NlJywgJ2JhY2snKTtcclxuICAgICAgICAgICAgdGhpcy5hbmNob3JCYWNrLnRpdGxlID0gXCJ6dXLDvGNrXCI7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGdvQmFjaygpOnZvaWQge1xyXG4gICAgICAgIGNvbnNvbGUuaW5mbyhgZ29CYWNrICR7dGhpcy5jb250ZW50SGlzdG9yeS5sZW5ndGh9YCwgdGhpcy5jb250ZW50SGlzdG9yeSk7XHJcbiAgICAgICAgaWYgKHRoaXMuY29udGVudEFyZWEuZmlyc3RDaGlsZCkge1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgY29uc3QgY3VycmVudENvbnRlbnQgPSB0aGlzLmNvbnRlbnRIaXN0b3J5LnBvcCgpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmluZm8oYGdvQmFjayAke3RoaXMuY29udGVudEhpc3RvcnkubGVuZ3RofWAsIHRoaXMuY29udGVudEhpc3RvcnkpO1xyXG4gICAgICAgICAgICBpZiAoY3VycmVudENvbnRlbnQpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbnRlbnRIaXN0b3J5Lmxlbmd0aD4wKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGFzdENvbnRlbnQgPSB0aGlzLmNvbnRlbnRIaXN0b3J5W3RoaXMuY29udGVudEhpc3RvcnkubGVuZ3RoLTFdO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhgZ29CYWNrICR7Y3VycmVudENvbnRlbnQuZ2V0RG9tKClbJ2lkJ119ID0+ICR7bGFzdENvbnRlbnQuZ2V0RG9tKClbJ2lkJ119YCwgY3VycmVudENvbnRlbnQsIGxhc3RDb250ZW50KTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRlbnRBcmVhLnJlcGxhY2VDaGlsZChsYXN0Q29udGVudC5nZXREb20oKSwgdGhpcy5jb250ZW50QXJlYS5maXJzdENoaWxkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhgZ29CYWNrICR7Y3VycmVudENvbnRlbnRbJ2lkJ119ID0+IG5vbmUgcmVtb3ZlTmF2QXJlYWApO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGVudEFyZWEucmVtb3ZlQ2hpbGQoY3VycmVudENvbnRlbnQuZ2V0RG9tKCkpOyAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb20ucmVtb3ZlQ2hpbGQodGhpcy5uYXZpZ2F0aW9uQXJlYSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudENvbnRlbnQub25SZW1vdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q29udGVudC5vblJlbW92ZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgTWFwRGlzcGF0Y2hlci5vblZpZXdSZW1vdmUuZGlzcGF0Y2godGhpcywgY3VycmVudENvbnRlbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnNvbGUuaW5mbygnZ29CYWNrIHRoaXMuYW5jaG9yQmFjay5jbGFzc0xpc3QnLCB0aGlzLmFuY2hvckJhY2suY2xhc3NOYW1lKTtcclxuICAgICAgICBpZiAodGhpcy5jb250ZW50SGlzdG9yeS5sZW5ndGg8PTEpIHtcclxuICAgICAgICAgICAgdGhpcy5hbmNob3JCYWNrLmNsYXNzTGlzdC5yZXBsYWNlKCdiYWNrJywgJ2Nsb3NlJyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5hbmNob3JCYWNrLmNsYXNzTGlzdC5yZXBsYWNlKCdjbG9zZScsICdiYWNrJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfSAgXHJcbn1cclxuIiwiaW1wb3J0IHsgU3ZnTGluZVBhcmFtLCBTdmdQYXRoUGFyYW0sIFN2Z1N0eWxlIH0gZnJvbSBcIi4vc3ZnXCI7XHJcblxyXG5leHBvcnQgdHlwZSBQaWVDaGFydFBhcmFtID0ge1xyXG4gICAgcmFkaXVzOiBudW1iZXI7XHJcbiAgICBjb2xvcj86IHN0cmluZztcclxuICAgIHN0cm9rZU9wYWNpdHk/OiBudW1iZXI7XHJcbiAgICBzdHJva2VXZWlnaHQ/OiBudW1iZXI7XHJcbiAgICBzZWdtZW50czogeyB2YWx1ZTogbnVtYmVyOyBzdHlsZTogU3ZnU3R5bGUgfVtdO1xyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVBpZWNoYXJ0KHBhcmFtOiBQaWVDaGFydFBhcmFtKTogU1ZHU1ZHRWxlbWVudCB7XHJcbiAgICBjb25zdCBzdmcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBcInN2Z1wiKTtcclxuICAgIGNvbnN0IGQgPSAyICogcGFyYW0ucmFkaXVzO1xyXG4gICAgaWYgKHN2Zy52aWV3Qm94LmJhc2VWYWwpIHtcclxuICAgICAgICBzdmcudmlld0JveC5iYXNlVmFsLnggPSAwO1xyXG4gICAgICAgIHN2Zy52aWV3Qm94LmJhc2VWYWwueSA9IDA7XHJcbiAgICAgICAgc3ZnLnZpZXdCb3guYmFzZVZhbC53aWR0aCA9IGQ7XHJcbiAgICAgICAgc3ZnLnZpZXdCb3guYmFzZVZhbC5oZWlnaHQgPSBkO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBjb25zdCB2aWV3Ym94U3RyaW5nID0gXCIwIDAgXCIgKyBkLnRvU3RyaW5nKCkgKyBcIiBcIiArIGQudG9TdHJpbmcoKTtcclxuICAgICAgICBzdmcuc2V0QXR0cmlidXRlKFwidmlld0JveFwiLCB2aWV3Ym94U3RyaW5nKTtcclxuICAgIH1cclxuXHJcbiAgICBzdmcuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgZC50b1N0cmluZygpKTtcclxuICAgIHN2Zy5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgZC50b1N0cmluZygpKTtcclxuXHJcbiAgICAvLyBjYWxjdWxhdGUgc3VtIG9mIHZhbHVlc1xyXG4gICAgbGV0IHN1bSA9IDA7XHJcbiAgICBsZXQgcmFkaXVzID0gcGFyYW0ucmFkaXVzO1xyXG4gICAgZm9yIChsZXQgZSA9IDA7IGUgPCBwYXJhbS5zZWdtZW50cy5sZW5ndGg7IGUrKykge1xyXG4gICAgICAgIHN1bSArPSBwYXJhbS5zZWdtZW50c1tlXS52YWx1ZTtcclxuICAgIH1cclxuICAgIC8vIGdlbmVyYXRlIHByb3BvcnRpb25hbCBwaWUgZm9yIGFsbCBzZWdtZW50c1xyXG4gICAgbGV0IHN0YXJ0QW5nbGUgPSAwLFxyXG4gICAgICAgIGVuZEFuZ2xlID0gMDtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyYW0uc2VnbWVudHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBlbGVtZW50ID0gcGFyYW0uc2VnbWVudHNbaV07XHJcbiAgICAgICAgY29uc3QgYW5nbGUgPSAoZWxlbWVudC52YWx1ZSAqIDIgKiBNYXRoLlBJKSAvIHN1bTtcclxuICAgICAgICBlbmRBbmdsZSArPSBhbmdsZTtcclxuICAgICAgICBjb25zdCBzdmdMaW5lID0gbWFrZVNWRyhcImxpbmVcIiwge1xyXG4gICAgICAgICAgICB4MTogcmFkaXVzLFxyXG4gICAgICAgICAgICB5MTogcmFkaXVzLFxyXG4gICAgICAgICAgICB4MjogTWF0aC5jb3MoZW5kQW5nbGUpICogcmFkaXVzICsgcmFkaXVzLFxyXG4gICAgICAgICAgICB5MjogTWF0aC5zaW4oZW5kQW5nbGUpICogcmFkaXVzICsgcmFkaXVzLFxyXG4gICAgICAgICAgICBzdHJva2U6IHBhcmFtLmNvbG9yLFxyXG4gICAgICAgICAgICBzdHJva2VPcGFjaXR5OiBwYXJhbS5zdHJva2VPcGFjaXR5LFxyXG4gICAgICAgICAgICBzdHJva2VXaWR0aDogcGFyYW0uc3Ryb2tlV2VpZ2h0LFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHN2Zy5hcHBlbmQoc3ZnTGluZSk7XHJcbiAgICAgICAgY29uc3QgcGF0aFN0ciA9IFwiTSBcIiArIHJhZGl1cyArIFwiLFwiICsgcmFkaXVzICsgXCIgXCIgKyBcIkwgXCIgKyAoTWF0aC5jb3Moc3RhcnRBbmdsZSkgKiByYWRpdXMgKyByYWRpdXMpICsgXCIsXCIgKyAoTWF0aC5zaW4oc3RhcnRBbmdsZSkgKiByYWRpdXMgKyByYWRpdXMpICsgXCIgXCIgKyBcIkEgXCIgKyByYWRpdXMgKyBcIixcIiArIHJhZGl1cyArIFwiIDAgXCIgKyAoYW5nbGUgPCBNYXRoLlBJID8gXCIwXCIgOiBcIjFcIikgKyBcIiAxIFwiICsgKE1hdGguY29zKGVuZEFuZ2xlKSAqIHJhZGl1cyArIHJhZGl1cykgKyBcIixcIiArIChNYXRoLnNpbihlbmRBbmdsZSkgKiByYWRpdXMgKyByYWRpdXMpICsgXCIgXCIgKyBcIlpcIjtcclxuICAgICAgICBjb25zdCBzdmdQYXRoID0gbWFrZVNWRyhcInBhdGhcIiwge1xyXG4gICAgICAgICAgICBkOiBwYXRoU3RyLFxyXG4gICAgICAgICAgICBmaWxsOiBlbGVtZW50LnN0eWxlLmZpbGwsXHJcbiAgICAgICAgICAgIG9wYWNpdHk6IGVsZW1lbnQuc3R5bGUub3BhY2l0eSxcclxuICAgICAgICAgICAgc3Ryb2tlOiBwYXJhbS5jb2xvciA/PyBcIiNiYmJcIixcclxuICAgICAgICAgICAgc3Ryb2tlT3BhY2l0eTogcGFyYW0uc3Ryb2tlT3BhY2l0eSA/PyBcIjAuNlwiLFxyXG4gICAgICAgICAgICBzdHJva2VXaWR0aDogcGFyYW0uc3Ryb2tlV2VpZ2h0ID8/IFwiMVwiLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHN2Zy5hcHBlbmQoc3ZnUGF0aCk7XHJcbiAgICAgICAgc3RhcnRBbmdsZSArPSBhbmdsZTtcclxuICAgIH1cclxuICAgIHJldHVybiBzdmc7XHJcbn1cclxuXHJcbi8vIFNWRyBNYWtlciAtIHRvIGRyYXcgU1ZHIGJ5IHNjcmlwdFxyXG5mdW5jdGlvbiBtYWtlU1ZHKHRhZzogc3RyaW5nLCBhdHRyczogU3ZnUGF0aFBhcmFtIHwgU3ZnTGluZVBhcmFtKTogU1ZHRWxlbWVudCB7XHJcbiAgICBjb25zdCBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIHRhZyk7XHJcbiAgICBmb3IgKGxldCBrIGluIGF0dHJzKSB7XHJcbiAgICAgICAgZWwuc2V0QXR0cmlidXRlKGssIGF0dHJzW2tdKTtcclxuICAgIH1cclxuICAgIHJldHVybiBlbDtcclxufVxyXG4iLCJmdW5jdGlvbiBhcHBseVN0eWxlKGVsOiBTVkdFbGVtZW50LCBzdHlsZTogU3ZnU3R5bGUpIHtcclxuICAgIGZvciAobGV0IGsgaW4gc3R5bGUpIHtcclxuICAgICAgICBlbC5zdHlsZVtrXSA9IHN0eWxlW2tdO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFN2Z1N0eWxlIHtcclxuICAgIC8vIGV4dGVuZHMgQ1NTU3R5bGVEZWNsYXJhdGlvblxyXG4gICAgZmlsbD86IHN0cmluZztcclxuICAgIG9wYWNpdHk/OiBzdHJpbmcgfCBudW1iZXI7XHJcbiAgICBzdHJva2U/OiBzdHJpbmc7XHJcbiAgICBzdHJva2VPcGFjaXR5Pzogc3RyaW5nIHwgbnVtYmVyO1xyXG4gICAgc3Ryb2tlV2lkdGg/OiBzdHJpbmcgfCBudW1iZXI7XHJcbiAgICBzdHJva2VEYXNoYXJyYXk/OiBzdHJpbmc7XHJcbiAgICBzdHJva2VEYXNob2Zmc2V0Pzogc3RyaW5nO1xyXG4gICAgc3Ryb2tlTGluZWNhcD86IHN0cmluZztcclxuICAgIHN0cm9rZUxpbmVqb2luPzogc3RyaW5nO1xyXG4gICAgZmlsbFJ1bGU/OiBzdHJpbmc7XHJcbiAgICB0cmFuc2Zvcm1PcmlnaW4/OiBzdHJpbmc7XHJcbiAgICB0cmFuc2Zvcm0/OiBzdHJpbmc7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgU3ZnUGF0aFBhcmFtIGV4dGVuZHMgU3ZnU3R5bGUge1xyXG4gICAgZDogc3RyaW5nO1xyXG59XHJcbmV4cG9ydCBpbnRlcmZhY2UgU3ZnTGluZVBhcmFtIGV4dGVuZHMgU3ZnU3R5bGUge1xyXG4gICAgeDE6IHN0cmluZyB8IG51bWJlcjtcclxuICAgIHkxOiBzdHJpbmcgfCBudW1iZXI7XHJcbiAgICB4Mjogc3RyaW5nIHwgbnVtYmVyO1xyXG4gICAgeTI6IHN0cmluZyB8IG51bWJlcjtcclxufVxyXG5leHBvcnQgaW50ZXJmYWNlIFN2Z0NpcmNsZVBhcmFtIGV4dGVuZHMgU3ZnU3R5bGUge1xyXG4gICAgY3g6IHN0cmluZyB8IG51bWJlcjtcclxuICAgIGN5OiBzdHJpbmcgfCBudW1iZXI7XHJcbiAgICByOiBzdHJpbmcgfCBudW1iZXI7XHJcbn1cclxuZXhwb3J0IGludGVyZmFjZSBTdmdSZWN0YW5nbGVQYXJhbSBleHRlbmRzIFN2Z1N0eWxlIHtcclxuICAgIHg6IHN0cmluZyB8IG51bWJlcjtcclxuICAgIHk6IHN0cmluZyB8IG51bWJlcjtcclxuICAgIHdpZHRoOiBzdHJpbmcgfCBudW1iZXI7XHJcbiAgICBoZWlnaHQ6IHN0cmluZyB8IG51bWJlcjtcclxuICAgIHJ4Pzogc3RyaW5nIHwgbnVtYmVyO1xyXG4gICAgcnk/OiBzdHJpbmcgfCBudW1iZXI7XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBTdmdCYXNlRWxlbWVudDxLIGV4dGVuZHMgU1ZHR2VvbWV0cnlFbGVtZW50PiB7XHJcbiAgICBzdmc6IEs7XHJcblxyXG4gICAgY29uc3RydWN0b3IoZWw6IEssIHN0eWxlPzogU3ZnU3R5bGUpIHtcclxuICAgICAgICB0aGlzLnN2ZyA9IGVsO1xyXG4gICAgICAgIGlmIChzdHlsZSkge1xyXG4gICAgICAgICAgICBhcHBseVN0eWxlKGVsLCBzdHlsZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHVwZGF0ZVN0eWxlKHN0eWxlPzogU3ZnU3R5bGUpIHtcclxuICAgICAgICBhcHBseVN0eWxlKHRoaXMuc3ZnLCBzdHlsZSk7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0U1ZHKCk6IEsge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnN2ZztcclxuICAgIH1cclxuXHJcbiAgICBnZXRQYXRoTGVuZ3RoKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnN2Zy5wYXRoTGVuZ3RoO1xyXG4gICAgfVxyXG5cclxuICAgIGlzUG9pbnRJbkZpbGwocG9pbnQ6IERPTVBvaW50KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3ZnLmlzUG9pbnRJbkZpbGwocG9pbnQpO1xyXG4gICAgfVxyXG4gICAgaXNQb2ludEluU3Ryb2tlKHBvaW50OiBET01Qb2ludCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnN2Zy5pc1BvaW50SW5TdHJva2UocG9pbnQpO1xyXG4gICAgfVxyXG4gICAgZ2V0VG90YWxMZW5ndGgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3ZnLmdldFRvdGFsTGVuZ3RoKCk7XHJcbiAgICB9XHJcbiAgICBnZXRQb2ludEF0TGVuZ3RoKGRpc3RhbmNlOiBudW1iZXIpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zdmcuZ2V0UG9pbnRBdExlbmd0aChkaXN0YW5jZSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBDaXJjbGUgZXh0ZW5kcyBTdmdCYXNlRWxlbWVudDxTVkdDaXJjbGVFbGVtZW50PiB7XHJcbiAgICBjb25zdHJ1Y3RvcihjeDogbnVtYmVyLCBjeTogbnVtYmVyLCByYWRpdXM6IG51bWJlciwgc3R5bGU/OiBTdmdTdHlsZSkge1xyXG4gICAgICAgIHN1cGVyKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIFwiY2lyY2xlXCIpLCBzdHlsZSk7XHJcbiAgICAgICAgdGhpcy51cGRhdGUoY3gsIGN5LCByYWRpdXMpO1xyXG4gICAgfVxyXG5cclxuICAgIHVwZGF0ZShjeDogbnVtYmVyLCBjeTogbnVtYmVyLCByYWRpdXM6IG51bWJlcikge1xyXG4gICAgICAgIHRoaXMuc3ZnLnNldEF0dHJpYnV0ZShcInJcIiwgU3RyaW5nKHJhZGl1cykpO1xyXG4gICAgICAgIHRoaXMuc3ZnLnNldEF0dHJpYnV0ZShcImN4XCIsIFN0cmluZyhjeCkpO1xyXG4gICAgICAgIHRoaXMuc3ZnLnNldEF0dHJpYnV0ZShcImN5XCIsIFN0cmluZyhjeSkpO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgTGluZSBleHRlbmRzIFN2Z0Jhc2VFbGVtZW50PFNWR0xpbmVFbGVtZW50PiB7XHJcbiAgICBjb25zdHJ1Y3Rvcih4MTogbnVtYmVyLCB5MTogbnVtYmVyLCB4MjogbnVtYmVyLCB5MjogbnVtYmVyLCBzdHlsZT86IFN2Z1N0eWxlKSB7XHJcbiAgICAgICAgc3VwZXIoZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgXCJsaW5lXCIpLCBzdHlsZSk7XHJcbiAgICAgICAgdGhpcy51cGRhdGUoeDEsIHkxLCB4MiwgeTIpO1xyXG4gICAgfVxyXG5cclxuICAgIHVwZGF0ZSh4MTogbnVtYmVyLCB5MTogbnVtYmVyLCB4MjogbnVtYmVyLCB5MjogbnVtYmVyKSB7XHJcbiAgICAgICAgdGhpcy5zdmcuc2V0QXR0cmlidXRlKFwieDFcIiwgU3RyaW5nKHgxKSk7XHJcbiAgICAgICAgdGhpcy5zdmcuc2V0QXR0cmlidXRlKFwieTFcIiwgU3RyaW5nKHkxKSk7XHJcbiAgICAgICAgdGhpcy5zdmcuc2V0QXR0cmlidXRlKFwieDJcIiwgU3RyaW5nKHgyKSk7XHJcbiAgICAgICAgdGhpcy5zdmcuc2V0QXR0cmlidXRlKFwieTJcIiwgU3RyaW5nKHkyKSk7XHJcblxyXG4gICAgICAgIHRoaXMuc3ZnLnN0eWxlW1wieDFcIl0gPSBTdHJpbmcoeDEpO1xyXG4gICAgICAgIHRoaXMuc3ZnLnN0eWxlW1wieTFcIl0gPSBTdHJpbmcoeTEpO1xyXG4gICAgICAgIHRoaXMuc3ZnLnN0eWxlW1wieDJcIl0gPSBTdHJpbmcoeDIpO1xyXG4gICAgICAgIHRoaXMuc3ZnLnN0eWxlW1wieTJcIl0gPSBTdHJpbmcoeTIpO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgUG9seUxpbmUgZXh0ZW5kcyBTdmdCYXNlRWxlbWVudDxTVkdQb2x5bGluZUVsZW1lbnQ+IHtcclxuICAgIGNvbnN0cnVjdG9yKHBvaW50czogc3RyaW5nIHwgbnVtYmVyW11bXSwgc3R5bGU/OiBTdmdTdHlsZSkge1xyXG4gICAgICAgIHN1cGVyKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIFwicG9seWxpbmVcIiksIHN0eWxlKTtcclxuICAgICAgICB0aGlzLnVwZGF0ZShwb2ludHMpO1xyXG4gICAgfVxyXG5cclxuICAgIHVwZGF0ZShwb2ludHM6IHN0cmluZyB8IG51bWJlcltdW10pIHtcclxuICAgICAgICAvLyBwb2ludHM9XCIxMDAsMTAgNDAsMTk4IDE5MCw3OCAxMCw3OCAxNjAsMTk4XCJcclxuICAgICAgICBpZiAocG9pbnRzKSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcG9pbnRzID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN2Zy5zZXRBdHRyaWJ1dGUoXCJwb2ludHNcIiwgcG9pbnRzKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChwb2ludHMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBzID0gcG9pbnRzWzBdWzBdICsgXCIsXCIgKyBwb2ludHNbMF1bMV07XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDEsIGNvdW50ID0gcG9pbnRzLmxlbmd0aDsgaSA8IGNvdW50OyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcyArPSBcIiBcIiArIHBvaW50c1tpXVswXSArIFwiLFwiICsgcG9pbnRzW2ldWzFdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN2Zy5zZXRBdHRyaWJ1dGUoXCJwb2ludHNcIiwgcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBQb2x5Z29uIGV4dGVuZHMgU3ZnQmFzZUVsZW1lbnQ8U1ZHUG9seWdvbkVsZW1lbnQ+IHtcclxuICAgIGNvbnN0cnVjdG9yKHBvaW50czogc3RyaW5nIHwgbnVtYmVyW11bXSwgc3R5bGU/OiBTdmdTdHlsZSkge1xyXG4gICAgICAgIHN1cGVyKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIFwicG9seWdvblwiKSwgc3R5bGUpO1xyXG4gICAgICAgIHRoaXMudXBkYXRlKHBvaW50cyk7XHJcbiAgICB9XHJcblxyXG4gICAgdXBkYXRlKHBvaW50czogc3RyaW5nIHwgbnVtYmVyW11bXSkge1xyXG4gICAgICAgIC8vIHBvaW50cz1cIjEwMCwxMCA0MCwxOTggMTkwLDc4IDEwLDc4IDE2MCwxOThcIlxyXG4gICAgICAgIGlmIChwb2ludHMpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBwb2ludHMgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3ZnLnNldEF0dHJpYnV0ZShcInBvaW50c1wiLCBwb2ludHMpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKHBvaW50cy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHMgPSBwb2ludHNbMF1bMF0gKyBcIixcIiArIHBvaW50c1swXVsxXTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMSwgY291bnQgPSBwb2ludHMubGVuZ3RoOyBpIDwgY291bnQ7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzICs9IFwiIFwiICsgcG9pbnRzW2ldWzBdICsgXCIsXCIgKyBwb2ludHNbaV1bMV07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3ZnLnNldEF0dHJpYnV0ZShcInBvaW50c1wiLCBzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIFNWRyB7XHJcbiAgICBzdmc6IFNWR1NWR0VsZW1lbnQ7XHJcbiAgICBnOiBTVkdHRWxlbWVudDtcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcih2aWV3Ym94PzogeyB4OiBudW1iZXI7IHk6IG51bWJlcjsgd2lkdGg6IG51bWJlcjsgaGVpZ2h0OiBudW1iZXIgfSkge1xyXG4gICAgICAgIGNvbnN0IHN2ZzogU1ZHU1ZHRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIFwic3ZnXCIpO1xyXG4gICAgICAgIGlmICh2aWV3Ym94KSB7XHJcbiAgICAgICAgICAgIGlmIChzdmcudmlld0JveC5iYXNlVmFsKSB7XHJcbiAgICAgICAgICAgICAgICBzdmcudmlld0JveC5iYXNlVmFsLnggPSB2aWV3Ym94Lng7XHJcbiAgICAgICAgICAgICAgICBzdmcudmlld0JveC5iYXNlVmFsLnkgPSB2aWV3Ym94Lnk7XHJcbiAgICAgICAgICAgICAgICBzdmcudmlld0JveC5iYXNlVmFsLndpZHRoID0gdmlld2JveC53aWR0aDtcclxuICAgICAgICAgICAgICAgIHN2Zy52aWV3Qm94LmJhc2VWYWwuaGVpZ2h0ID0gdmlld2JveC5oZWlnaHQ7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBzdmcuc2V0QXR0cmlidXRlKFwidmlld0JveFwiLCBcIng6dmlld2JveC54LCB5OnZpZXdib3gueSwgd2lkdGg6dmlld2JveC53aWR0aCwgaGVpZ2h0OnZpZXdib3guaGVpZ2h0XCIpO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgdmlld2JveFN0cmluZyA9IFwiXCIgKyB2aWV3Ym94LngudG9TdHJpbmcoKSArIFwiIFwiICsgdmlld2JveC55LnRvU3RyaW5nKCkgKyBcIiBcIiArIHZpZXdib3gud2lkdGgudG9TdHJpbmcoKSArIFwiIFwiICsgdmlld2JveC5oZWlnaHQudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgIHN2Zy5zZXRBdHRyaWJ1dGUoXCJ2aWV3Qm94XCIsIHZpZXdib3hTdHJpbmcpO1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5kZWJ1ZyhcInN2Zy52aWV3Qm94XCIsIHN2Zy52aWV3Qm94KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnN2ZyA9IHN2ZztcclxuICAgIH1cclxuXHJcbiAgICBnZXRHRWxlbWVudCgpOiBTVkdHRWxlbWVudCB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmcpIHtcclxuICAgICAgICAgICAgdGhpcy5nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgXCJnXCIpO1xyXG4gICAgICAgICAgICB0aGlzLnN2Zy5hcHBlbmRDaGlsZCh0aGlzLmcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5nO1xyXG4gICAgfVxyXG5cclxuICAgIGFkZENpcmNsZShjeDogbnVtYmVyLCBjeTogbnVtYmVyLCByYWRpdXM6IG51bWJlciwgc3R5bGU/OiBTdmdTdHlsZSk6IENpcmNsZSB7XHJcbiAgICAgICAgY29uc3QgY2lyY2xlID0gbmV3IENpcmNsZShjeCwgY3ksIHJhZGl1cywgc3R5bGUpO1xyXG4gICAgICAgIHRoaXMuZ2V0R0VsZW1lbnQoKS5hcHBlbmRDaGlsZChjaXJjbGUuc3ZnKTtcclxuICAgICAgICByZXR1cm4gY2lyY2xlO1xyXG4gICAgfVxyXG5cclxuICAgIGFkZExpbmUoeDE6IG51bWJlciwgeTE6IG51bWJlciwgeDI6IG51bWJlciwgeTI6IG51bWJlciwgc3R5bGU/OiBTdmdTdHlsZSk6IExpbmUge1xyXG4gICAgICAgIGNvbnN0IGxpbmUgPSBuZXcgTGluZSh4MSwgeTEsIHgyLCB5Miwgc3R5bGUpO1xyXG4gICAgICAgIHRoaXMuZ2V0R0VsZW1lbnQoKS5hcHBlbmRDaGlsZChsaW5lLnN2Zyk7XHJcbiAgICAgICAgcmV0dXJuIGxpbmU7XHJcbiAgICB9XHJcblxyXG4gICAgYWRkUG9seUxpbmUocG9pbnRzOiBzdHJpbmcgfCBudW1iZXJbXVtdLCBzdHlsZT86IFN2Z1N0eWxlKTogUG9seUxpbmUge1xyXG4gICAgICAgIGNvbnN0IHBvbHlnb24gPSBuZXcgUG9seUxpbmUocG9pbnRzLCBzdHlsZSk7XHJcbiAgICAgICAgdGhpcy5nZXRHRWxlbWVudCgpLmFwcGVuZENoaWxkKHBvbHlnb24uc3ZnKTtcclxuICAgICAgICByZXR1cm4gcG9seWdvbjtcclxuICAgIH1cclxuXHJcbiAgICBhZGRQb2x5Z0dvbihwb2ludHM6IHN0cmluZyB8IG51bWJlcltdW10sIHN0eWxlPzogU3ZnU3R5bGUpOiBQb2x5Z29uIHtcclxuICAgICAgICBjb25zdCBwb2x5Z29uID0gbmV3IFBvbHlnb24ocG9pbnRzLCBzdHlsZSk7XHJcbiAgICAgICAgdGhpcy5nZXRHRWxlbWVudCgpLmFwcGVuZENoaWxkKHBvbHlnb24uc3ZnKTtcclxuICAgICAgICByZXR1cm4gcG9seWdvbjtcclxuICAgIH1cclxufVxyXG4iLCIgLypcclxuICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9rcmFhZGVuL2F1dG9jb21wbGV0ZVxyXG4gICogQ29weXJpZ2h0IChjKSAyMDE2IERlbnlzIEtyYXNub3NoY2hva1xyXG4gICogTUlUIExpY2Vuc2VcclxuICAqL1xyXG5cclxuaW1wb3J0IHsgZGl2SWNvbiB9IGZyb20gXCJsZWFmbGV0XCI7XHJcbmltcG9ydCB7IExheWVyV3JhcHBlciB9IGZyb20gXCIuLi9jb250cm9scy9NYXBDb250cm9sXCI7XHJcblxyXG4gZXhwb3J0IGNvbnN0IGVudW0gRXZlbnRUcmlnZ2VyIHtcclxuICAgIEtleWJvYXJkID0gMCxcclxuICAgIEZvY3VzID0gMVxyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEF1dG9jb21wbGV0ZUl0ZW0ge1xyXG4gICAgLy8gbGFiZWw/OiBzdHJpbmc7XHJcbiAgICAvLyBncm91cD86IHN0cmluZztcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBBdXRvY29tcGxldGVTZXR0aW5nczxUIGV4dGVuZHMgQXV0b2NvbXBsZXRlSXRlbT4ge1xyXG4gICAgXHJcbiAgICByZW5kZXI/OiAoaXRlbTogVCwgY3VycmVudFZhbHVlOiBzdHJpbmcpID0+IEhUTUxEaXZFbGVtZW50IHwgdW5kZWZpbmVkO1xyXG4gICAgcmVuZGVyR3JvdXA/OiAobmFtZTogc3RyaW5nLCBjdXJyZW50VmFsdWU6IHN0cmluZykgPT4gSFRNTERpdkVsZW1lbnQgfCB1bmRlZmluZWQ7XHJcbiAgICBjbGFzc05hbWU/OiBzdHJpbmc7XHJcbiAgICBtaW5MZW5ndGg/OiBudW1iZXI7XHJcbiAgICBlbXB0eU1zZz86IHN0cmluZztcclxuICAgIG9uU2VsZWN0OiAoaXRlbTogVCwgaW5wdXQ6IEhUTUxJbnB1dEVsZW1lbnQpID0+IHZvaWQ7XHJcbiAgICBvblNlYXJjaFN0YXJ0OiAoaW5wdXQ6IEhUTUxJbnB1dEVsZW1lbnQpID0+IHZvaWQ7XHJcbiAgICBvblNlYXJjaFN0YXJ0UnVubmluZz86IChpbnB1dDogSFRNTElucHV0RWxlbWVudCkgPT4gdm9pZDtcclxuICAgIG9uU2VhcmNoRmluaXNoZWQ/OiAoaW5wdXQ6IEhUTUxJbnB1dEVsZW1lbnQpID0+IHZvaWQ7XHJcblxyXG4gICAgaW5pdGlhbEl0ZW1zPzpUW107XHJcbiAgICAvKipcclxuICAgICAqIFNob3cgYXV0b2NvbXBsZXRlIG9uIGZvY3VzIGV2ZW50LiBGb2N1cyBldmVudCB3aWxsIGlnbm9yZSB0aGUgYG1pbkxlbmd0aGAgcHJvcGVydHkgYW5kIHdpbGwgYWx3YXlzIGNhbGwgYGZldGNoYC5cclxuICAgICAqL1xyXG4gICAgc2hvd09uRm9jdXM/OiBib29sZWFuO1xyXG4gICAgLy8gZmV0Y2g6ICh0ZXh0OiBzdHJpbmcsIHVwZGF0ZTogKGl0ZW1zOiBUW10gfCBmYWxzZSkgPT4gdm9pZCwgdHJpZ2dlcjogRXZlbnRUcmlnZ2VyKSA9PiB2b2lkO1xyXG4gICAgZmV0Y2g6ICh0ZXh0OiBzdHJpbmcpID0+IFByb21pc2U8VFtdPjtcclxuICAgIGRlYm91bmNlV2FpdE1zPzogbnVtYmVyO1xyXG5cclxuICAgIGxhYmVsQXR0cj86IHN0cmluZztcclxuICAgIC8qKlxyXG4gICAgICogQ2FsbGJhY2sgZm9yIGFkZGl0aW9uYWwgYXV0b2NvbXBsZXRlIGN1c3RvbWl6YXRpb25cclxuICAgICAqIEBwYXJhbSB7SFRNTElucHV0RWxlbWVudH0gaW5wdXQgLSBpbnB1dCBib3ggYXNzb2NpYXRlZCB3aXRoIGF1dG9jb21wbGV0ZVxyXG4gICAgICogQHBhcmFtIHtDbGllbnRSZWN0IHwgRE9NUmVjdH0gaW5wdXRSZWN0IC0gc2l6ZSBvZiB0aGUgaW5wdXQgYm94IGFuZCBpdHMgcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIHZpZXdwb3J0XHJcbiAgICAgKiBAcGFyYW0ge0hUTUxEaXZFbGVtZW50fSBjb250YWluZXIgLSBjb250YWluZXIgd2l0aCBzdWdnZXN0aW9uc1xyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1heEhlaWdodCAtIG1heCBoZWlnaHQgdGhhdCBjYW4gYmUgdXNlZCBieSBhdXRvY29tcGxldGVcclxuICAgICAqL1xyXG4gICAgY3VzdG9taXplPzogKGlucHV0OiBIVE1MSW5wdXRFbGVtZW50LCBpbnB1dFJlY3Q6IENsaWVudFJlY3QgfCBET01SZWN0LCBjb250YWluZXI6IEhUTUxEaXZFbGVtZW50LCBtYXhIZWlnaHQ6IG51bWJlcikgPT4gdm9pZDtcclxuICAgIC8qKlxyXG4gICAgICogUHJldmVudHMgYXV0b21hdGljIGZvcm0gc3VibWl0IHdoZW4gRU5URVIgaXMgcHJlc3NlZFxyXG4gICAgICovXHJcbiAgICBwcmV2ZW50U3VibWl0PzogYm9vbGVhbjtcclxuXHJcbiAgICB2YWx1ZT86IFQ7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQXV0b2NvbXBsZXRlUmVzdWx0IHtcclxuICAgIGRlc3Ryb3k6ICgpID0+IHZvaWQ7XHJcbn1cclxuXHJcbmNvbnN0IGVudW0gS2V5cyB7XHJcbiAgICBFbnRlciA9IDEzLFxyXG4gICAgRXNjID0gMjcsXHJcbiAgICBVcCA9IDM4LFxyXG4gICAgRG93biA9IDQwLFxyXG4gICAgTGVmdCA9IDM3LFxyXG4gICAgUmlnaHQgPSAzOSxcclxuICAgIFNoaWZ0ID0gMTYsXHJcbiAgICBDdHJsID0gMTcsXHJcbiAgICBBbHQgPSAxOCxcclxuICAgIENhcHNMb2NrID0gMjAsXHJcbiAgICBXaW5kb3dzS2V5ID0gOTEsXHJcbiAgICBUYWIgPSA5LFxyXG4gICAgRjEgPSAxMTIsXHJcbiAgICBGMTIgPSAxMjNcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYXV0b2NvbXBsZXRlPFQgZXh0ZW5kcyBBdXRvY29tcGxldGVJdGVtPihpbnB1dDogSFRNTElucHV0RWxlbWVudCwgc2V0dGluZ3M6IEF1dG9jb21wbGV0ZVNldHRpbmdzPFQ+KTogQXV0b2NvbXBsZXRlUmVzdWx0IHtcclxuXHJcbiAgICAvLyBqdXN0IGFuIGFsaWFzIHRvIG1pbmltaXplIEpTIGZpbGUgc2l6ZVxyXG4gICAgY29uc3QgZG9jID0gZG9jdW1lbnQ7XHJcblxyXG4gICAgY29uc3QgY29udGFpbmVyOiBIVE1MRGl2RWxlbWVudCA9IGRvYy5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG4gICAgY29uc3QgY29udGFpbmVyU3R5bGUgPSBjb250YWluZXIuc3R5bGU7XHJcbiAgICBjb25zdCB1c2VyQWdlbnQgPSBuYXZpZ2F0b3IudXNlckFnZW50O1xyXG4gICAgY29uc3QgbW9iaWxlRmlyZWZveCA9IHVzZXJBZ2VudC5pbmRleE9mKFwiRmlyZWZveFwiKSAhPT0gLTEgJiYgdXNlckFnZW50LmluZGV4T2YoXCJNb2JpbGVcIikgIT09IC0xO1xyXG4gICAgY29uc3QgZGVib3VuY2VXYWl0TXMgPSBzZXR0aW5ncy5kZWJvdW5jZVdhaXRNcyB8fCAwO1xyXG4gICAgY29uc3QgcHJldmVudFN1Ym1pdCA9IHNldHRpbmdzLnByZXZlbnRTdWJtaXQgfHwgZmFsc2U7XHJcbiAgICBjb25zdCBsYWJlbEF0dHIgPSBzZXR0aW5ncy5sYWJlbEF0dHIgfHwgJ25hbWUnO1xyXG4gICAgY29uc3QgaW5pdGlhbEl0ZW1zID0gc2V0dGluZ3MuaW5pdGlhbEl0ZW1zO1xyXG4gICAgXHJcbiAgICAvLyAna2V5dXAnIGV2ZW50IHdpbGwgbm90IGJlIGZpcmVkIG9uIE1vYmlsZSBGaXJlZm94LCBzbyB3ZSBoYXZlIHRvIHVzZSAnaW5wdXQnIGV2ZW50IGluc3RlYWRcclxuICAgIGNvbnN0IGtleVVwRXZlbnROYW1lID0gbW9iaWxlRmlyZWZveCA/IFwiaW5wdXRcIiA6IFwia2V5dXBcIjtcclxuXHJcbiAgICBsZXQgaXNCZWZvcmVTdGFydCA9IHRydWU7XHJcbiAgICBcclxuICAgIGxldCBpdGVtczogVFtdID0gW107XHJcbiAgICBsZXQgaW5wdXRWYWx1ZSA9IFwiXCI7XHJcbiAgICBjb25zdCBtaW5MZW4gPSBzZXR0aW5ncy5taW5MZW5ndGggfHwgMjtcclxuICAgIGNvbnN0IHNob3dPbkZvY3VzID0gc2V0dGluZ3Muc2hvd09uRm9jdXM7XHJcbiAgICBsZXQgc2VsZWN0ZWQ6IFQgPSBzZXR0aW5ncy52YWx1ZTtcclxuICAgIGlmIChzZWxlY3RlZCkge1xyXG4gICAgICAgIGlucHV0LnZhbHVlID0gc2VsZWN0ZWRbbGFiZWxBdHRyXTtcclxuICAgIH1cclxuICAgIGxldCBrZXlwcmVzc0NvdW50ZXIgPSAwO1xyXG4gICAgbGV0IGRlYm91bmNlVGltZXIgOiBudW1iZXIgfCB1bmRlZmluZWQ7XHJcblxyXG4gICAgbGV0IHNlYXJjaENvdW50ZXI9MDtcclxuICAgIGxldCBsYXN0U2VhcmNoOnN0cmluZztcclxuXHJcbiAgICBpZiAoIWlucHV0KSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW5wdXQgdW5kZWZpbmVkXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBwcm9taXNlczogUHJvbWlzZTxhbnk+W10gPSBbXTtcclxuXHJcbiAgICBjb250YWluZXIuY2xhc3NOYW1lID0gXCJhdXRvY29tcGxldGUgXCIgKyAoc2V0dGluZ3MuY2xhc3NOYW1lIHx8IFwiXCIpO1xyXG5cclxuICAgIC8vIElPUyBpbXBsZW1lbnRhdGlvbiBmb3IgZml4ZWQgcG9zaXRpb25pbmcgaGFzIG1hbnkgYnVncywgc28gd2Ugd2lsbCB1c2UgYWJzb2x1dGUgcG9zaXRpb25pbmdcclxuICAgIGNvbnRhaW5lclN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGV0YWNoIHRoZSBjb250YWluZXIgZnJvbSBET01cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZGV0YWNoKCk6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IHBhcmVudCA9IGNvbnRhaW5lci5wYXJlbnROb2RlO1xyXG4gICAgICAgIGlmIChwYXJlbnQpIHtcclxuICAgICAgICAgICAgcGFyZW50LnJlbW92ZUNoaWxkKGNvbnRhaW5lcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2xlYXIgZGVib3VuY2luZyB0aW1lciBpZiBhc3NpZ25lZFxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBjbGVhckRlYm91bmNlVGltZXIoKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKGRlYm91bmNlVGltZXIpIHtcclxuICAgICAgICAgICAgd2luZG93LmNsZWFyVGltZW91dChkZWJvdW5jZVRpbWVyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBdHRhY2ggdGhlIGNvbnRhaW5lciB0byBET01cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gYXR0YWNoKCk6IHZvaWQge1xyXG4gICAgICAgIGlmICghY29udGFpbmVyLnBhcmVudE5vZGUpIHtcclxuICAgICAgICAgICAgZG9jLmJvZHkuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVjayBpZiBjb250YWluZXIgZm9yIGF1dG9jb21wbGV0ZSBpcyBkaXNwbGF5ZWRcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gY29udGFpbmVyRGlzcGxheWVkKCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiAhIWNvbnRhaW5lci5wYXJlbnROb2RlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2xlYXIgYXV0b2NvbXBsZXRlIHN0YXRlIGFuZCBoaWRlIGNvbnRhaW5lclxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBjbGVhcigpOiB2b2lkIHtcclxuICAgICAgICAvLyBwcmV2ZW50IHRoZSB1cGRhdGUgY2FsbCBpZiB0aGVyZSBhcmUgcGVuZGluZyBBSkFYIHJlcXVlc3RzXHJcbiAgICAgICAga2V5cHJlc3NDb3VudGVyKys7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaXRlbXMgPSBbXTtcclxuICAgICAgICBpbnB1dFZhbHVlID0gXCJcIjtcclxuICAgICAgICBzZWxlY3RlZCA9IHVuZGVmaW5lZDtcclxuICAgICAgICBkZXRhY2goKTtcclxuICAgICAgICBsYXN0U2VhcmNoID0gdW5kZWZpbmVkO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBpPTA7IGk8cHJvbWlzZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgcHJvbWlzZXNbaV1bXCJjYW5jZWxcIl0oKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGUgYXV0b2NvbXBsZXRlIHBvc2l0aW9uXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHVwZGF0ZVBvc2l0aW9uKCk6IHZvaWQge1xyXG5cclxuICAgICAgICAvLyBjb25zb2xlLndhcm4oXCJ1cGRhdGVQb3NpdGlvblwiKTtcclxuICAgICAgICBpZiAoIWNvbnRhaW5lckRpc3BsYXllZCgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnRhaW5lclN0eWxlLmhlaWdodCA9IFwiYXV0b1wiO1xyXG5cclxuICAgICAgICBsZXQgd2lkdGggPSBpbnB1dC5vZmZzZXRXaWR0aCArIFwicHhcIjtcclxuICAgICAgICAvLyB0cnkge1xyXG4gICAgICAgIC8vICAgICBjb25zb2xlLmluZm8oJ3VwZGF0ZVBvc2l0aW9uJywgaW5wdXQucGFyZW50RWxlbWVudC5wYXJlbnRFbGVtZW50KTtcclxuICAgICAgICAvLyB9IGNhdGNoIChleCkge1xyXG4gICAgICAgIC8vICAgICBjb25zb2xlLmVycm9yKGV4KVxyXG4gICAgICAgIC8vIH1cclxuXHJcblxyXG4gICAgICAgIGNvbnRhaW5lclN0eWxlLndpZHRoID0gd2lkdGg7XHJcblxyXG4gICAgICAgIGxldCBtYXhIZWlnaHQgPSAwO1xyXG4gICAgICAgIGxldCBtYXhXaWR0aCA9IGlucHV0Lm9mZnNldFdpZHRoO1xyXG4gICAgICAgIGxldCBpbnB1dFJlY3Q6IENsaWVudFJlY3QgfCBET01SZWN0IHwgdW5kZWZpbmVkO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBjYWxjKCkge1xyXG4gICAgICAgICAgICBjb25zdCBkb2NFbCA9IGRvYy5kb2N1bWVudEVsZW1lbnQgYXMgSFRNTEVsZW1lbnQ7XHJcbiAgICAgICAgICAgIGNvbnN0IGNsaWVudFRvcCA9IGRvY0VsLmNsaWVudFRvcCB8fCBkb2MuYm9keS5jbGllbnRUb3AgfHwgMDtcclxuICAgICAgICAgICAgY29uc3QgY2xpZW50TGVmdCA9IGRvY0VsLmNsaWVudExlZnQgfHwgZG9jLmJvZHkuY2xpZW50TGVmdCB8fCAwO1xyXG4gICAgICAgICAgICBjb25zdCBzY3JvbGxUb3AgPSB3aW5kb3cucGFnZVlPZmZzZXQgfHwgZG9jRWwuc2Nyb2xsVG9wO1xyXG4gICAgICAgICAgICBjb25zdCBzY3JvbGxMZWZ0ID0gd2luZG93LnBhZ2VYT2Zmc2V0IHx8IGRvY0VsLnNjcm9sbExlZnQ7XHJcblxyXG4gICAgICAgICAgICBpbnB1dFJlY3QgPSBpbnB1dC5wYXJlbnRFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICAgIFxyXG4gICAgICAgICAgICBjb25zdCB0b3AgPSBpbnB1dFJlY3QudG9wICsgaW5wdXQub2Zmc2V0SGVpZ2h0ICsgc2Nyb2xsVG9wIC0gY2xpZW50VG9wICsgNjtcclxuICAgICAgICAgICAgY29uc3QgbGVmdCA9IGlucHV0UmVjdC5sZWZ0ICsgc2Nyb2xsTGVmdCAtIGNsaWVudExlZnQ7XHJcbiAgICBcclxuICAgICAgICAgICAgY29udGFpbmVyU3R5bGUudG9wID0gdG9wICsgXCJweFwiO1xyXG4gICAgICAgICAgICBjb250YWluZXJTdHlsZS5sZWZ0ID0gbGVmdCArIFwicHhcIjtcclxuICAgIFxyXG4gICAgICAgICAgICBtYXhIZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQgLSAoaW5wdXRSZWN0LnRvcCArIGlucHV0Lm9mZnNldEhlaWdodCArIDgpO1xyXG4gICAgXHJcbiAgICAgICAgICAgIGlmIChtYXhIZWlnaHQgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICBtYXhIZWlnaHQgPSAwO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBtYXhXaWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoIC0gKGlucHV0UmVjdC5sZWZ0KVxyXG4gICAgXHJcbiAgICAgICAgICAgIGNvbnRhaW5lclN0eWxlLnRvcCA9IHRvcCArIFwicHhcIjtcclxuICAgICAgICAgICAgY29udGFpbmVyU3R5bGUuYm90dG9tID0gXCJcIjtcclxuICAgICAgICAgICAgY29udGFpbmVyU3R5bGUubGVmdCA9IGxlZnQgKyBcInB4XCI7XHJcbiAgICAgICAgICAgIGNvbnRhaW5lclN0eWxlLm1heEhlaWdodCA9IG1heEhlaWdodCArIFwicHhcIjtcclxuICAgICAgICAgICAgY29udGFpbmVyU3R5bGUubWluV2lkdGggPSBpbnB1dC5wYXJlbnRFbGVtZW50Lm9mZnNldFdpZHRoICsgXCJweFwiO1xyXG5cclxuXHJcbiAgICAgICAgICAgIGlmIChtYXhXaWR0aD4xMDApIHtcclxuICAgICAgICAgICAgICAgIGNvbnRhaW5lclN0eWxlLndpZHRoID0gJ3Vuc2V0JztcclxuICAgICAgICAgICAgICAgIGNvbnRhaW5lclN0eWxlLm1heFdpZHRoID0gbWF4V2lkdGggICsgXCJweFwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyB0aGUgY2FsYyBtZXRob2QgbXVzdCBiZSBjYWxsZWQgdHdpY2UsIG90aGVyd2lzZSB0aGUgY2FsY3VsYXRpb24gbWF5IGJlIHdyb25nIG9uIHJlc2l6ZSBldmVudCAoY2hyb21lIGJyb3dzZXIpXHJcbiAgICAgICAgY2FsYygpO1xyXG4gICAgICAgIGNhbGMoKTtcclxuXHJcbiAgICAgICAgaWYgKHNldHRpbmdzLmN1c3RvbWl6ZSAmJiBpbnB1dFJlY3QpIHtcclxuICAgICAgICAgICAgc2V0dGluZ3MuY3VzdG9taXplKGlucHV0LCBpbnB1dFJlY3QsIGNvbnRhaW5lciwgbWF4SGVpZ2h0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWRyYXcgdGhlIGF1dG9jb21wbGV0ZSBkaXYgZWxlbWVudCB3aXRoIHN1Z2dlc3Rpb25zXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHVwZGF0ZSgpOiB2b2lkIHtcclxuICAgICAgICAvLyBkZWxldGUgYWxsIGNoaWxkcmVuIGZyb20gYXV0b2NvbXBsZXRlIERPTSBjb250YWluZXJcclxuICAgICAgICB3aGlsZSAoY29udGFpbmVyLmZpcnN0Q2hpbGQpIHtcclxuICAgICAgICAgICAgY29udGFpbmVyLnJlbW92ZUNoaWxkKGNvbnRhaW5lci5maXJzdENoaWxkKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGZ1bmN0aW9uIGZvciByZW5kZXJpbmcgYXV0b2NvbXBsZXRlIHN1Z2dlc3Rpb25zXHJcbiAgICAgICAgY29uc3QgcmVuZGVyID0gc2V0dGluZ3MucmVuZGVyIHx8IGZ1bmN0aW9uKGl0ZW06IFQsIGN1cnJlbnRWYWx1ZTogc3RyaW5nKTogSFRNTERpdkVsZW1lbnQgfCB1bmRlZmluZWQgeyAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBjb25zdCBpdGVtRWxlbWVudCA9IGRvYy5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG4gICAgICAgICAgICBjb25zdCB0ZXh0QXJlYSA9IGRvYy5jcmVhdGVFbGVtZW50KFwibGFiZWxcIik7XHJcbiAgICAgICAgICAgIHRleHRBcmVhLmlubmVyVGV4dCA9IGl0ZW1bbGFiZWxBdHRyXSB8fCBcIlwiO1xyXG4gICAgICAgICAgICBpdGVtRWxlbWVudC5hcHBlbmRDaGlsZCh0ZXh0QXJlYSk7XHJcbiAgICAgICAgICAgIGlmIChpdGVtWydncm91cCddID09PSAnVGhlbWEnKSB7XHJcbiAgICAgICAgICAgICAgICBpdGVtRWxlbWVudC50aXRsZSA9ICg8TGF5ZXJXcmFwcGVyPml0ZW1bJ2xheWVyJ10pLmxheWVyRGVzY3JpcHRpb24uYWJzdHJhY3Q7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGl0ZW1FbGVtZW50O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gaWYgKHNldHRpbmdzLnJlbmRlcikge1xyXG4gICAgICAgIC8vICAgICByZW5kZXIgPSBzZXR0aW5ncy5yZW5kZXI7XHJcbiAgICAgICAgLy8gfVxyXG5cclxuICAgICAgICAvLyBmdW5jdGlvbiB0byByZW5kZXIgYXV0b2NvbXBsZXRlIGdyb3Vwc1xyXG4gICAgICAgIGNvbnN0IHJlbmRlckdyb3VwID0gc2V0dGluZ3MucmVuZGVyR3JvdXAgfHwgZnVuY3Rpb24oZ3JvdXBOYW1lOiBzdHJpbmcsIGN1cnJlbnRWYWx1ZTogc3RyaW5nKTogSFRNTERpdkVsZW1lbnQgfCB1bmRlZmluZWQge1xyXG4gICAgICAgICAgICBjb25zdCBncm91cERpdiA9IGRvYy5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG4gICAgICAgICAgICBncm91cERpdi50ZXh0Q29udGVudCA9IGdyb3VwTmFtZTtcclxuICAgICAgICAgICAgcmV0dXJuIGdyb3VwRGl2O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gaWYgKCkge1xyXG4gICAgICAgIC8vICAgICByZW5kZXJHcm91cCA9IHNldHRpbmdzLnJlbmRlckdyb3VwO1xyXG4gICAgICAgIC8vIH1cclxuXHJcbiAgICAgICAgY29uc3QgZnJhZ21lbnQgPSBkb2MuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xyXG4gICAgICAgIGxldCBwcmV2R3JvdXAgPSBcIiM5PyRcIjtcclxuXHJcbiAgICAgICAgaXRlbXMuZm9yRWFjaChmdW5jdGlvbihpdGVtOiBUKTogdm9pZCB7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZiAoaXRlbVtcImdyb3VwXCJdICYmIGl0ZW1bXCJncm91cFwiXSAhPT0gcHJldkdyb3VwKSB7XHJcbiAgICAgICAgICAgICAgICBwcmV2R3JvdXAgPSBpdGVtW1wiZ3JvdXBcIl07XHJcbiAgICAgICAgICAgICAgICBjb25zdCBncm91cERpdiA9IHJlbmRlckdyb3VwKGl0ZW1bXCJncm91cFwiXSwgaW5wdXRWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZ3JvdXBEaXYpIHtcclxuICAgICAgICAgICAgICAgICAgICBncm91cERpdi5jbGFzc05hbWUgKz0gXCIgZ3JvdXBcIjtcclxuICAgICAgICAgICAgICAgICAgICBmcmFnbWVudC5hcHBlbmRDaGlsZChncm91cERpdik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgZGl2ID0gcmVuZGVyKGl0ZW0sIGlucHV0VmFsdWUpO1xyXG4gICAgICAgICAgICBpZiAoZGl2KSB7XHJcbiAgICAgICAgICAgICAgICBkaXYuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uKGV2OiBNb3VzZUV2ZW50KTogdm9pZCB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQudmFsdWUgPSBpdGVtW2xhYmVsQXR0cl07XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3Mub25TZWxlY3QoaXRlbSwgaW5wdXQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcImlzQmVmb3JlU3RhcnQyNjcgdHJ1ZVwiKTtcclxuICAgICAgICAgICAgICAgICAgICBpc0JlZm9yZVN0YXJ0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBjbGVhcigpO1xyXG4gICAgICAgICAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGlmIChpdGVtID09PSBzZWxlY3RlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRpdi5jbGFzc05hbWUgKz0gXCIgc2VsZWN0ZWRcIjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKGRpdik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoZnJhZ21lbnQpO1xyXG4gICAgICAgIGlmIChpdGVtcy5sZW5ndGggPCAxKSB7XHJcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5lbXB0eU1zZykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZW1wdHkgPSBkb2MuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcclxuICAgICAgICAgICAgICAgIGVtcHR5LmNsYXNzTmFtZSA9IFwiZW1wdHlcIjtcclxuICAgICAgICAgICAgICAgIGVtcHR5LnRleHRDb250ZW50ID0gc2V0dGluZ3MuZW1wdHlNc2c7XHJcbiAgICAgICAgICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoZW1wdHkpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY2xlYXIoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgYXR0YWNoKCk7XHJcbiAgICAgICAgdXBkYXRlUG9zaXRpb24oKTtcclxuXHJcbiAgICAgICAgdXBkYXRlU2Nyb2xsKCk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gdXBkYXRlSWZEaXNwbGF5ZWQoKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKGNvbnRhaW5lckRpc3BsYXllZCgpKSB7XHJcbiAgICAgICAgICAgIHVwZGF0ZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiByZXNpemVFdmVudEhhbmRsZXIoKTogdm9pZCB7XHJcbiAgICAgICAgdXBkYXRlSWZEaXNwbGF5ZWQoKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBzY3JvbGxFdmVudEhhbmRsZXIoZTogRXZlbnQpOiB2b2lkIHtcclxuICAgICAgICBpZiAoZS50YXJnZXQgIT09IGNvbnRhaW5lcikge1xyXG4gICAgICAgICAgICB1cGRhdGVJZkRpc3BsYXllZCgpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24ga2V5dXBFdmVudEhhbmRsZXIoZXY6IEtleWJvYXJkRXZlbnQpOiB2b2lkIHtcclxuICAgICAgICBjb25zdCBrZXlDb2RlID0gZXYud2hpY2ggfHwgZXYua2V5Q29kZSB8fCAwO1xyXG5cclxuXHJcblxyXG4gICAgICAgIGNvbnN0IGlnbm9yZSA9IFtLZXlzLlVwLCBLZXlzLkVzYywgS2V5cy5SaWdodCwgS2V5cy5MZWZ0LCBLZXlzLlNoaWZ0LCBLZXlzLkN0cmwsIEtleXMuQWx0LCBLZXlzLkNhcHNMb2NrLCBLZXlzLldpbmRvd3NLZXksIEtleXMuVGFiXTtcclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBpZ25vcmUpIHtcclxuICAgICAgICAgICAgaWYgKGtleUNvZGUgPT09IGtleSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoa2V5Q29kZSA+PSBLZXlzLkYxICYmIGtleUNvZGUgPD0gS2V5cy5GMTIpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gdGhlIGRvd24ga2V5IGlzIHVzZWQgdG8gb3BlbiBhdXRvY29tcGxldGVcclxuICAgICAgICBpZiAoa2V5Q29kZSA9PT0gS2V5cy5Eb3duICYmIGNvbnRhaW5lckRpc3BsYXllZCgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHN0YXJ0RmV0Y2goRXZlbnRUcmlnZ2VyLktleWJvYXJkKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEF1dG9tYXRpY2FsbHkgbW92ZSBzY3JvbGwgYmFyIGlmIHNlbGVjdGVkIGl0ZW0gaXMgbm90IHZpc2libGVcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gdXBkYXRlU2Nyb2xsKCk6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IGVsZW1lbnRzID0gY29udGFpbmVyLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoXCJzZWxlY3RlZFwiKTtcclxuICAgICAgICBpZiAoZWxlbWVudHMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBsZXQgZWxlbWVudCA9IGVsZW1lbnRzWzBdIGFzIEhUTUxEaXZFbGVtZW50O1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gbWFrZSBncm91cCB2aXNpYmxlXHJcbiAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzID0gZWxlbWVudC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nIGFzIEhUTUxEaXZFbGVtZW50O1xyXG4gICAgICAgICAgICBpZiAocHJldmlvdXMgJiYgcHJldmlvdXMuY2xhc3NOYW1lLmluZGV4T2YoXCJncm91cFwiKSAhPT0gLTEgJiYgIXByZXZpb3VzLnByZXZpb3VzRWxlbWVudFNpYmxpbmcpIHtcclxuICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBwcmV2aW91cztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGVsZW1lbnQub2Zmc2V0VG9wIDwgY29udGFpbmVyLnNjcm9sbFRvcCkge1xyXG4gICAgICAgICAgICAgICAgY29udGFpbmVyLnNjcm9sbFRvcCA9IGVsZW1lbnQub2Zmc2V0VG9wO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2VsZWN0Qm90dG9tID0gZWxlbWVudC5vZmZzZXRUb3AgKyBlbGVtZW50Lm9mZnNldEhlaWdodDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRhaW5lckJvdHRvbSA9IGNvbnRhaW5lci5zY3JvbGxUb3AgKyBjb250YWluZXIub2Zmc2V0SGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdEJvdHRvbSA+IGNvbnRhaW5lckJvdHRvbSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lci5zY3JvbGxUb3AgKz0gc2VsZWN0Qm90dG9tIC0gY29udGFpbmVyQm90dG9tO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2VsZWN0IHRoZSBwcmV2aW91cyBpdGVtIGluIHN1Z2dlc3Rpb25zXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHNlbGVjdFByZXYoKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKGl0ZW1zLmxlbmd0aCA8IDEpIHtcclxuICAgICAgICAgICAgc2VsZWN0ZWQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHNlbGVjdGVkID09PSBpdGVtc1swXSkge1xyXG4gICAgICAgICAgICAgICAgc2VsZWN0ZWQgPSBpdGVtc1tpdGVtcy5sZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBpdGVtcy5sZW5ndGggLSAxOyBpID4gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdGVkID09PSBpdGVtc1tpXSB8fCBpID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkID0gaXRlbXNbaSAtIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZWxlY3QgdGhlIG5leHQgaXRlbSBpbiBzdWdnZXN0aW9uc1xyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBzZWxlY3ROZXh0KCk6IHZvaWQge1xyXG4gICAgICAgIGlmIChpdGVtcy5sZW5ndGggPCAxKSB7XHJcbiAgICAgICAgICAgIHNlbGVjdGVkID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXNlbGVjdGVkIHx8IHNlbGVjdGVkID09PSBpdGVtc1tpdGVtcy5sZW5ndGggLSAxXSkge1xyXG4gICAgICAgICAgICBzZWxlY3RlZCA9IGl0ZW1zWzBdO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgKGl0ZW1zLmxlbmd0aCAtIDEpOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKHNlbGVjdGVkID09PSBpdGVtc1tpXSkge1xyXG4gICAgICAgICAgICAgICAgc2VsZWN0ZWQgPSBpdGVtc1tpICsgMV07XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBrZXlkb3duRXZlbnRIYW5kbGVyKGV2OiBLZXlib2FyZEV2ZW50KTogdm9pZCB7XHJcbiAgICAgICAgY29uc3Qga2V5Q29kZSA9IGV2LndoaWNoIHx8IGV2LmtleUNvZGUgfHwgMDtcclxuXHJcbiAgICAgICAgaWYgKGlzQmVmb3JlU3RhcnQpIHtcclxuICAgICAgICAgICAgaWYgKHNldHRpbmdzLm9uU2VhcmNoU3RhcnQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcImtleWRvd25FdmVudEhhbmRsZXJcIiwgZXYpO1xyXG4gICAgICAgICAgICAgICAgc2V0dGluZ3Mub25TZWFyY2hTdGFydChpbnB1dCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaXNCZWZvcmVTdGFydCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGV2LmtleUNvZGUgPT0gNjUgJiYgZXYuY3RybEtleSkge1xyXG4gICAgICAgICAgICAoPGFueT5ldi50YXJnZXQpLnNlbGVjdCgpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoa2V5Q29kZSA9PT0gS2V5cy5VcCB8fCBrZXlDb2RlID09PSBLZXlzLkRvd24gfHwga2V5Q29kZSA9PT0gS2V5cy5Fc2MpIHtcclxuICAgICAgICAgICAgY29uc3QgY29udGFpbmVySXNEaXNwbGF5ZWQgPSBjb250YWluZXJEaXNwbGF5ZWQoKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChrZXlDb2RlID09PSBLZXlzLkVzYykge1xyXG4gICAgICAgICAgICAgICAgY2xlYXIoKTtcclxuICAgICAgICAgICAgICAgIC8vIGNhbmNlbCgpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFjb250YWluZXJEaXNwbGF5ZWQgfHwgaXRlbXMubGVuZ3RoIDwgMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGtleUNvZGUgPT09IEtleXMuVXBcclxuICAgICAgICAgICAgICAgICAgICA/IHNlbGVjdFByZXYoKVxyXG4gICAgICAgICAgICAgICAgICAgIDogc2VsZWN0TmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgdXBkYXRlKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIGlmIChjb250YWluZXJJc0Rpc3BsYXllZCkge1xyXG4gICAgICAgICAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChrZXlDb2RlID09PSBLZXlzLkVudGVyKSB7XHJcbiAgICAgICAgICAgIGlmIChzZWxlY3RlZCkge1xyXG4gICAgICAgICAgICAgICAgaW5wdXQudmFsdWUgPSBzZWxlY3RlZFtsYWJlbEF0dHJdO1xyXG4gICAgICAgICAgICAgICAgc2V0dGluZ3Mub25TZWxlY3Qoc2VsZWN0ZWQsIGlucHV0KTtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcImlzQmVmb3JlU3RhcnQ0NDQgdHJ1ZVwiKTtcclxuICAgICAgICAgICAgICAgIGlzQmVmb3JlU3RhcnQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgY2xlYXIoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgXHJcbiAgICAgICAgICAgIGlmIChwcmV2ZW50U3VibWl0KSB7XHJcbiAgICAgICAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGZvY3VzRXZlbnRIYW5kbGVyKCk6IHZvaWQge1xyXG4gICAgICAgIGlmIChzaG93T25Gb2N1cykge1xyXG4gICAgICAgICAgICBzdGFydEZldGNoKEV2ZW50VHJpZ2dlci5Gb2N1cyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpbml0aWFsSXRlbXMpIHtcclxuICAgICAgICAgICAgaXRlbXMgPSBpbml0aWFsSXRlbXM7XHJcbiAgICAgICAgICAgIHVwZGF0ZSgpOyAgICAgICAgICAgIFxyXG4gICAgICAgIH0gICAgICAgIFxyXG4gICAgICAgIGlmIChpbnB1dCkge1xyXG4gICAgICAgICAgICBpbnB1dC5zZWxlY3QoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gZnVuY3Rpb24gc3RhcnRGZXRjaCh0cmlnZ2VyOiBFdmVudFRyaWdnZXIpIHtcclxuICAgIC8vICAgICAvLyBpZiBtdWx0aXBsZSBrZXlzIHdlcmUgcHJlc3NlZCwgYmVmb3JlIHdlIGdldCB1cGRhdGUgZnJvbSBzZXJ2ZXIsXHJcbiAgICAvLyAgICAgLy8gdGhpcyBtYXkgY2F1c2UgcmVkcmF3aW5nIG91ciBhdXRvY29tcGxldGUgbXVsdGlwbGUgdGltZXMgYWZ0ZXIgdGhlIGxhc3Qga2V5IHByZXNzLlxyXG4gICAgLy8gICAgIC8vIHRvIGF2b2lkIHRoaXMsIHRoZSBudW1iZXIgb2YgdGltZXMga2V5Ym9hcmQgd2FzIHByZXNzZWQgd2lsbCBiZVxyXG4gICAgLy8gICAgIC8vIHNhdmVkIGFuZCBjaGVja2VkIGJlZm9yZSByZWRyYXcgb3VyIGF1dG9jb21wbGV0ZSBib3guXHJcbiAgICAvLyAgICAgY29uc3Qgc2F2ZWRLZXlwcmVzc0NvdW50ZXIgPSArK2tleXByZXNzQ291bnRlcjtcclxuXHJcbiAgICAvLyAgICAgY29uc3QgdmFsID0gaW5wdXQudmFsdWU7XHJcbiAgICAvLyAgICAgaWYgKHZhbC5sZW5ndGggPj0gbWluTGVuIHx8IHRyaWdnZXIgPT09IEV2ZW50VHJpZ2dlci5Gb2N1cykge1xyXG4gICAgLy8gICAgICAgICBjbGVhckRlYm91bmNlVGltZXIoKTtcclxuICAgIC8vICAgICAgICAgZGVib3VuY2VUaW1lciA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCk6IHZvaWQge1xyXG4gICAgLy8gICAgICAgICAgICAgc2V0dGluZ3MuZmV0Y2godmFsLCBmdW5jdGlvbihlbGVtZW50czogVFtdIHwgZmFsc2UpOiB2b2lkIHtcclxuICAgIC8vICAgICAgICAgICAgICAgICBpZiAoa2V5cHJlc3NDb3VudGVyID09PSBzYXZlZEtleXByZXNzQ291bnRlciAmJiBlbGVtZW50cykge1xyXG4gICAgLy8gICAgICAgICAgICAgICAgICAgICBpdGVtcyA9IGVsZW1lbnRzO1xyXG4gICAgLy8gICAgICAgICAgICAgICAgICAgICBpbnB1dFZhbHVlID0gdmFsO1xyXG4gICAgLy8gICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZCA9IGl0ZW1zLmxlbmd0aCA+IDAgPyBpdGVtc1swXSA6IHVuZGVmaW5lZDtcclxuICAgIC8vICAgICAgICAgICAgICAgICAgICAgdXBkYXRlKCk7XHJcbiAgICAvLyAgICAgICAgICAgICAgICAgfVxyXG4gICAgLy8gICAgICAgICAgICAgfSwgRXZlbnRUcmlnZ2VyLktleWJvYXJkKTtcclxuICAgIC8vICAgICAgICAgfSwgdHJpZ2dlciA9PT0gRXZlbnRUcmlnZ2VyLktleWJvYXJkID8gZGVib3VuY2VXYWl0TXMgOiAwKTtcclxuICAgIC8vICAgICB9IGVsc2Uge1xyXG4gICAgLy8gICAgICAgICBjbGVhcigpO1xyXG4gICAgLy8gICAgIH1cclxuICAgIC8vIH1cclxuXHJcbiAgICBmdW5jdGlvbiBhZGRUb1NlYXJjaENvdW50ZXIoaTpudW1iZXIpIHsgICAgICAgIFxyXG4gICAgICAgIHNlYXJjaENvdW50ZXIgPSBzZWFyY2hDb3VudGVyICsgaTtcclxuICAgICAgICBjb25zb2xlLmluZm8oYGFkZFRvU2VhcmNoQ291bnRlcigke2l9KT0+JHtzZWFyY2hDb3VudGVyfWApXHJcbiAgICAgICAgaWYgKHNlYXJjaENvdW50ZXI8MCkge1xyXG4gICAgICAgICAgICBzZWFyY2hDb3VudGVyID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNlYXJjaENvdW50ZXIgPT09IDApIHtcclxuICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKFwiYWxsU3NlYXJjaEZldGNoRG9uZVwiKTtcclxuICAgICAgICAgICAgaWYgKHNldHRpbmdzLm9uU2VhcmNoRmluaXNoZWQpIHtcclxuICAgICAgICAgICAgICAgIHNldHRpbmdzLm9uU2VhcmNoRmluaXNoZWQoaW5wdXQpXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKFwic2VhcmNoaW5nXCIpO1xyXG4gICAgICAgICAgICBpZiAoc2V0dGluZ3Mub25TZWFyY2hTdGFydFJ1bm5pbmcpIHtcclxuICAgICAgICAgICAgICAgIHNldHRpbmdzLm9uU2VhcmNoU3RhcnRSdW5uaW5nKGlucHV0KVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiByZW1vdmVQcm9taXNlKHA6UHJvbWlzZTxhbnk+KSB7XHJcbiAgICAgICAgcHJvbWlzZXMgPSBwcm9taXNlcy5maWx0ZXIoIChmKT0+e1xyXG4gICAgICAgICAgICByZXR1cm4gZiE9PXBcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBzdGFydEZldGNoKHRyaWdnZXI6IEV2ZW50VHJpZ2dlcikge1xyXG4gICAgICAgIC8vIGlmIG11bHRpcGxlIGtleXMgd2VyZSBwcmVzc2VkLCBiZWZvcmUgd2UgZ2V0IHVwZGF0ZSBmcm9tIHNlcnZlcixcclxuICAgICAgICAvLyB0aGlzIG1heSBjYXVzZSByZWRyYXdpbmcgb3VyIGF1dG9jb21wbGV0ZSBtdWx0aXBsZSB0aW1lcyBhZnRlciB0aGUgbGFzdCBrZXkgcHJlc3MuXHJcbiAgICAgICAgLy8gdG8gYXZvaWQgdGhpcywgdGhlIG51bWJlciBvZiB0aW1lcyBrZXlib2FyZCB3YXMgcHJlc3NlZCB3aWxsIGJlXHJcbiAgICAgICAgLy8gc2F2ZWQgYW5kIGNoZWNrZWQgYmVmb3JlIHJlZHJhdyBvdXIgYXV0b2NvbXBsZXRlIGJveC5cclxuICAgICAgICBjb25zdCBzYXZlZEtleXByZXNzQ291bnRlciA9ICsra2V5cHJlc3NDb3VudGVyO1xyXG4gICAgICAgIC8vIGNvbnNvbGUuaW5mbyhgc3RhcnRGZXRjaCBcIiR7aW5wdXQudmFsdWV9XCIgJHt0cmlnZ2VyfWAsIHRyaWdnZXIpO1xyXG4gICAgICAgIGNvbnN0IHZhbCA9IGlucHV0LnZhbHVlO1xyXG4gICAgICAgIC8vIGlmICh2YWwubGVuZ3RoID49IG1pbkxlbiB8fCB0cmlnZ2VyID09PSBFdmVudFRyaWdnZXIuRm9jdXMpIHtcclxuICAgICAgICBpZiAodmFsLmxlbmd0aCA+PSBtaW5MZW4gJiYgIHZhbCAhPT0gbGFzdFNlYXJjaCkgeyBcclxuICAgICAgICAgICAgaWYgKHZhbCA9PT0gbGFzdFNlYXJjaCkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5pbmZvKGBlcXUgJHt2YWx9ICR7bGFzdFNlYXJjaH1gKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxhc3RTZWFyY2ggPSB2YWw7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBjbGVhckRlYm91bmNlVGltZXIoKTtcclxuICAgICAgICAgICAgZGVib3VuY2VUaW1lciA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCk6IHZvaWQge1xyXG4gICAgICAgICAgICAgICAgYWRkVG9TZWFyY2hDb3VudGVyKDEpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcHJvbWlzZTpQcm9taXNlPGFueT4gPSBzZXR0aW5ncy5mZXRjaCh2YWwpO1xyXG4gICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChwcm9taXNlKTtcclxuICAgICAgICAgICAgICAgIHByb21pc2UudGhlbiggKGVsZW1lbnRzOiBUW10pID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmluZm8oXCJBdXRvY29tbnBsZXRlLnVwZGF0ZVwiLCBlbGVtZW50cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5pbmZvKGBhdXRvY29tcGxldGVyIGtleXByZXNzQ291bnRlcj0ke2tleXByZXNzQ291bnRlcn0gc2F2ZWRLZXlwcmVzc0NvdW50ZXI9JHtzYXZlZEtleXByZXNzQ291bnRlcn1gLCBlbGVtZW50cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleXByZXNzQ291bnRlciA9PT0gc2F2ZWRLZXlwcmVzc0NvdW50ZXIgJiYgZWxlbWVudHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXMgPSBlbGVtZW50cztcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRWYWx1ZSA9IHZhbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQgPSBpdGVtcy5sZW5ndGggPiAwID8gaXRlbXNbMF0gOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZSgpOyAgICAgICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBhZGRUb1NlYXJjaENvdW50ZXIoLTEpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZVByb21pc2UocHJvbWlzZSk7XHJcbiAgICAgICAgICAgICAgICB9KS5jYXRjaCgocmVhc29uKT0+e1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhgZmV0Y2ggbm90IHN1Y2NlZGRlZGAsIHJlYXNvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkVG9TZWFyY2hDb3VudGVyKC0xKTtcclxuICAgICAgICAgICAgICAgICAgICByZW1vdmVQcm9taXNlKHByb21pc2UpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgfSwgdHJpZ2dlciA9PT0gRXZlbnRUcmlnZ2VyLktleWJvYXJkID8gZGVib3VuY2VXYWl0TXMgOiAwKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zb2xlLmluZm8oXCJzdGFydEZldGNoPT5jbGVhclwiKTtcclxuICAgICAgICAgICAgY2xlYXIoKTtcclxuXHJcbiAgICAgICAgfVxyXG4gICAgfSAgICBcclxuXHJcbiAgICBmdW5jdGlvbiBibHVyRXZlbnRIYW5kbGVyKCk6IHZvaWQge1xyXG4gICAgICAgIC8vIHdlIG5lZWQgdG8gZGVsYXkgY2xlYXIsIGJlY2F1c2Ugd2hlbiB3ZSBjbGljayBvbiBhbiBpdGVtLCBibHVyIHdpbGwgYmUgY2FsbGVkIGJlZm9yZSBjbGljayBhbmQgcmVtb3ZlIGl0ZW1zIGZyb20gRE9NXHJcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChkb2MuYWN0aXZlRWxlbWVudCAhPT0gaW5wdXQpIHtcclxuICAgICAgICAgICAgICAgIGNsZWFyKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCAyMDApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRml4ZXMgIzI2OiBvbiBsb25nIGNsaWNrcyBmb2N1cyB3aWxsIGJlIGxvc3QgYW5kIG9uU2VsZWN0IG1ldGhvZCB3aWxsIG5vdCBiZSBjYWxsZWRcclxuICAgICAqL1xyXG4gICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgZnVuY3Rpb24oZXZ0OiBFdmVudCkge1xyXG4gICAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRml4ZXMgIzMwOiBhdXRvY29tcGxldGUgY2xvc2VzIHdoZW4gc2Nyb2xsYmFyIGlzIGNsaWNrZWQgaW4gSUVcclxuICAgICAqIFNlZTogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzkyMTAyNjcvMTMxNzIzNDlcclxuICAgICAqL1xyXG4gICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCAoKSA9PiBpbnB1dC5mb2N1cygpKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgZnVuY3Rpb24gd2lsbCByZW1vdmUgRE9NIGVsZW1lbnRzIGFuZCBjbGVhciBldmVudCBoYW5kbGVyc1xyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBkZXN0cm95KCk6IHZvaWQge1xyXG4gICAgICAgIGlucHV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCBmb2N1c0V2ZW50SGFuZGxlcik7XHJcbiAgICAgICAgaW5wdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwga2V5ZG93bkV2ZW50SGFuZGxlcik7XHJcbiAgICAgICAgaW5wdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihrZXlVcEV2ZW50TmFtZSwga2V5dXBFdmVudEhhbmRsZXIgYXMgRXZlbnRMaXN0ZW5lck9yRXZlbnRMaXN0ZW5lck9iamVjdCk7XHJcbiAgICAgICAgaW5wdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgYmx1ckV2ZW50SGFuZGxlcik7XHJcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgcmVzaXplRXZlbnRIYW5kbGVyKTtcclxuICAgICAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCBzY3JvbGxFdmVudEhhbmRsZXIsIHRydWUpO1xyXG4gICAgICAgIGNsZWFyRGVib3VuY2VUaW1lcigpO1xyXG4gICAgICAgIGNsZWFyKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gc2V0dXAgZXZlbnQgaGFuZGxlcnNcclxuICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGtleWRvd25FdmVudEhhbmRsZXIpO1xyXG4gICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihrZXlVcEV2ZW50TmFtZSwga2V5dXBFdmVudEhhbmRsZXIgYXMgRXZlbnRMaXN0ZW5lck9yRXZlbnRMaXN0ZW5lck9iamVjdCk7XHJcbiAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCBibHVyRXZlbnRIYW5kbGVyKTtcclxuICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCBmb2N1c0V2ZW50SGFuZGxlcik7XHJcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCByZXNpemVFdmVudEhhbmRsZXIpO1xyXG4gICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgc2Nyb2xsRXZlbnRIYW5kbGVyLCB0cnVlKTtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGRlc3Ryb3lcclxuICAgIH07XHJcbn0iLCJmdW5jdGlvbiBjcmVhdGVGb3JtYXRFeHByZXNzaW9uKHM6IHN0cmluZykge1xyXG4gICAgY29uc3QgdG9rZW5zID0gW107XHJcbiAgICBsZXQgdG9rZW4gPSAnJztcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmIChzW2ldID09PSAnJCcgJiYgdG9rZW4ubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XHJcbiAgICAgICAgICAgIHRva2VuID0gJyQnO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRva2VuICs9IHNbaV07XHJcbiAgICAgICAgICAgIGlmIChzW2ldID09PSAnfScpIHtcclxuICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcclxuICAgICAgICAgICAgICAgIHRva2VuID0gJyc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB0b2tlbnMucHVzaCh0b2tlbik7XHJcbiAgICByZXR1cm4gdG9rZW5zO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRXhwcmVzc2lvbkZjdChzOiBzdHJpbmcpIHtcclxuICAgIGNvbnN0IHRva2VucyA9IGNyZWF0ZUZvcm1hdEV4cHJlc3Npb24ocyk7XHJcblxyXG4gICAgY29uc29sZS5pbmZvKFwiY3JlYXRlZlwiKTtcclxuICAgIHJldHVybiAob2JqOiBhbnkpID0+IHtcclxuICAgICAgICBjb25zb2xlLmluZm8oXCJrc2hka2RoamFza2tra2tra2tra2tra2tra2tra2tra2tra2tra2tra2tra2tra2tra2trXCIpO1xyXG4gICAgICAgIGNvbnNvbGUuaW5mbyhcInBvcHVwXCIsIG9iaik7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKHRva2Vucy5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG9ialt0b2tlbnNbMF1dO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzID0gJyc7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgdG9rZW4gPSB0b2tlbnNbaV07XHJcbiAgICAgICAgICAgIGlmICh0b2tlbi5zdGFydHNXaXRoKCckJykpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGF0dE4gPSB0b2tlbi5zdWJzdHJpbmcoMiwgdG9rZW4ubGVuZ3RoIC0gMSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB2ID0gb2JqW2F0dE5dO1xyXG4gICAgICAgICAgICAgICAgcyArPSB2O1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcyArPSB0b2tlbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcztcclxuICAgIH07XHJcbn07XHJcbiIsImltcG9ydCAqIGFzIEwgZnJvbSAnbGVhZmxldCc7XHJcbmltcG9ydCB7IFJhZGlvR3JvdXBUcmVlTm9kZSB9IGZyb20gJy4uLy4uLy4uLy4uL3RyZWVjb21wb25lbnQvc3JjL3RzL1RyZWVOb2RlJztcclxuaW1wb3J0ICogIGFzIFV0aWwgZnJvbSBcIi4uL1V0aWxcIjtcclxuaW1wb3J0IHsgQ2FuY2VsYWJsZVByb21pc2UgfSBmcm9tICcuLi9VdGlsJztcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgR2VvY29kZXJHZW9jb2RpbmdRdWVyeVBhcmFtcyB7XHJcblxyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEdlb2NvZGVyUmV2ZXJzZVF1ZXJ5UGFyYW1zIHtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBHZW9jb2RlclBhcmFtIHtcclxuICAgIHNlcnZpY2VVcmw6IHN0cmluZyxcclxuICAgIG5hbWVQcm9wZXJ0aWVzPzogWydfdGl0bGVfJ10sXHJcbiAgICBnZW9jb2RpbmdRdWVyeVBhcmFtczogYW55LFxyXG4gICAgcmV2ZXJzZVF1ZXJ5UGFyYW1zOiBhbnksXHJcbiAgICBodG1sVGVtcGxhdGU/OmFueVxyXG59XHJcblxyXG5cclxuZXhwb3J0IGNsYXNzIEdlb2NvZGVyIHtcclxuICAgIG9wdGlvbnM6R2VvY29kZXJQYXJhbSA9IHtcclxuICAgICAgICBzZXJ2aWNlVXJsOiB1bmRlZmluZWQsXHJcbiAgICAgICAgbmFtZVByb3BlcnRpZXM6IFsnX3RpdGxlXyddLFxyXG4gICAgICAgIGdlb2NvZGluZ1F1ZXJ5UGFyYW1zOiB1bmRlZmluZWQsXHJcbiAgICAgICAgcmV2ZXJzZVF1ZXJ5UGFyYW1zOiB1bmRlZmluZWQsXHJcbiAgICB9XHJcbiAgICBfa2V5OiBzdHJpbmc7XHJcbiAgICBfYWN0aXZlUmVxdWVzdDogWE1MSHR0cFJlcXVlc3Q7XHJcblxyXG4gICAgY29uc3RydWN0b3Ioa2V5OiBzdHJpbmcsIG9wdGlvbnM6R2VvY29kZXJQYXJhbSkge1xyXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHsgLi4udGhpcy5vcHRpb25zLCAuLi5vcHRpb25zIH07XHJcbiAgICAgICAgdGhpcy5fa2V5ID0ga2V5O1xyXG4gICAgfVxyXG5cclxuICAgIGdlb2NvZGUocXVlcnk6c3RyaW5nKTpQcm9taXNlPGFueT4ge1xyXG4gICAgICAgIGlmICh0aGlzLl9hY3RpdmVSZXF1ZXN0KSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcImNhbmNlbCBsYXN0XCIpO1xyXG4gICAgICAgICAgICB0aGlzLl9hY3RpdmVSZXF1ZXN0LmFib3J0KCk7XHJcbiAgICAgICAgfSBcclxuICAgICAgICBjb25zdCBwYXJhbXMgPSB7XHJcbiAgICAgICAgICAgIHR5cGU6ICdzZWFyY2gnLFxyXG4gICAgICAgICAgICBrZXk6IHRoaXMuX2tleSxcclxuICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5LnRvTG93ZXJDYXNlKCksXHJcbiAgICAgICAgICAgIC4uLnRoaXMub3B0aW9ucy5nZW9jb2RpbmdRdWVyeVBhcmFtc1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB1cmwgPSB0aGlzLm9wdGlvbnMuc2VydmljZVVybCArIFV0aWwuZ2V0UGFyYW1TdHJpbmcocGFyYW1zKTsgICBcclxuICAgICAgICBjb25zdCB4aHIgPSB0aGlzLl9hY3RpdmVSZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XHRcclxuICAgICAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICB4aHIub25sb2FkZW5kID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHhoci5zdGF0dXMgPT09IDIwMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGpzb24gPSBKU09OLnBhcnNlKHhoci5yZXNwb25zZVRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLl9kZWNvZGVGZWF0dXJlcyhqc29uLCBwYXJhbXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhgcmVzb2x2ZWRgKTtcclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgfSBcclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogeGhyLnN0YXR1cyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzVGV4dDogeGhyLnN0YXR1c1RleHRcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgICAgIHJlamVjdCh7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiB0aGlzLnN0YXR1cyxcclxuICAgICAgICAgICAgICAgICAgICBzdGF0dXNUZXh0OiB4aHIuc3RhdHVzVGV4dCxcclxuICAgICAgICAgICAgICAgICAgICBldmVudDogZXZcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB4aHIub3BlbignR0VUJywgdXJsKTsgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBjb25zb2xlLmluZm8oYHJ1biByZXF1ZXN0IFwiJHt1cmx9XCJgKTtcclxuICAgICAgICAgICAgeGhyLnNlbmQoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBwcm9taXNlW1wiY2FuY2VsXCJdID0gKCkgPT4ge1xyXG4gICAgICAgICAgICB4aHIuYWJvcnQoKTtcclxuICAgICAgICAgICAgY29uc29sZS5pbmZvKFwieGhyLmNhbmNlbGVkXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcHJvbWlzZTtcclxuICAgIH1cclxuICAgIC8qXHJcbiAgICBhc3luYyBnZW9jb2RlMihxdWVyeTpzdHJpbmcpOlByb21pc2U8YW55PiB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2FjdGl2ZVJlcXVlc3QpIHtcclxuICAgICAgICAgICAgY29uc29sZS5pbmZvKFwiY2FuY2VsIGxhc3RcIik7XHJcbiAgICAgICAgICAgIHRoaXMuX2FjdGl2ZVJlcXVlc3QuY2FuY2VsKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZTxhbnk+KCAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IHtcclxuICAgICAgICAgICAgICAgIHR5cGU6ICdzZWFyY2gnLFxyXG4gICAgICAgICAgICAgICAga2V5OiB0aGlzLl9rZXksXHJcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnkudG9Mb3dlckNhc2UoKSxcclxuICAgICAgICAgICAgICAgIC4uLnRoaXMub3B0aW9ucy5nZW9jb2RpbmdRdWVyeVBhcmFtc1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcImNyZWF0ZSBSZXF1ZXN0XCIpO1xyXG4gICAgICAgICAgICBjb25zdCBwcm9taXNlID0gdGhpcy5fYWN0aXZlUmVxdWVzdCA9IFV0aWwubG9hZEpzb24odGhpcy5vcHRpb25zLnNlcnZpY2VVcmwsIHBhcmFtcyk7XHJcbiAgICAgICAgICAgIHByb21pc2UudGhlbiggICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBkYXRhID0+IHsgXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5pbmZvKFwibG9hZEpzb249PnRoZW5cIik7ICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hY3RpdmVSZXF1ZXN0ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUodGhpcy5fZGVjb2RlRmVhdHVyZXMoZGF0YSwgcGFyYW1zKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICkuY2F0Y2gocmVhc29uID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FjdGl2ZVJlcXVlc3QgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICByZWplY3QocmVhc29uKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vIGdldEpTT04oXHJcbiAgICAgICAgLy8gICAgIHRoaXMub3B0aW9ucy5zZXJ2aWNlVXJsLFxyXG4gICAgICAgIC8vICAgICBwYXJhbXMsXHJcbiAgICAgICAgLy8gICAgIChkYXRhKSA9PiB7IGNiLmNhbGwoY29udGV4dCwgdGhpcy5fZGVjb2RlRmVhdHVyZXMoZGF0YSwgcGFyYW1zLnF1ZXJ5KSkgfVxyXG4gICAgICAgIC8vIClcclxuICAgIH1cclxuKi9cclxuICAgIHN1Z2dlc3QocXVlcnk6c3RyaW5nKTpQcm9taXNlPGFueT4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdlb2NvZGUocXVlcnkpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldmVyc2UobGF0TG5nOkwuTGF0TG5nLCBzY2FsZSwgY2I6RnVuY3Rpb24sIGNvbnRleHQ6YW55KSB7XHJcbiAgICAgICAgY29uc3QgYmIgPSBsYXRMbmcudG9Cb3VuZHMoMjAwKTtcclxuICAgICAgICBsZXQgcGFyYW1zID0ge1xyXG4gICAgICAgICAgICB0eXBlOiAncmV2ZXJzZScsXHJcbiAgICAgICAgICAgIGtleTogdGhpcy5fa2V5LFxyXG4gICAgICAgICAgICBxdWVyeTogbGF0TG5nLmxuZyArICcsJyArIGxhdExuZy5sYXQsXHJcbiAgICAgICAgICAgIGJib3g6IGJiLmdldFdlc3QoKSArICcsJyArIGJiLmdldE5vcnRoKCkgKyAnLCcgKyBiYi5nZXRFYXN0KCkgKyAnLCcgKyBiYi5nZXRTb3V0aCgpLFxyXG4gICAgICAgICAgICBiYm94X2Vwc2c6ICc0MzI2J1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcGFyYW1zID0geyAuLi50aGlzLm9wdGlvbnMucmV2ZXJzZVF1ZXJ5UGFyYW1zLCAuLi5wYXJhbXMgfTtcclxuXHJcbiAgICAgICAgVXRpbC5sb2FkSnNvbih0aGlzLm9wdGlvbnMuc2VydmljZVVybCwgcGFyYW1zKS50aGVuKFxyXG4gICAgICAgICAgICBkYXRhID0+IHsgXHJcbiAgICAgICAgICAgICAgICBjYi5jYWxsKGNvbnRleHQsIHRoaXMuX2RlY29kZVJldmVyc2VGZWF0dXJlcyhkYXRhKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICApO1xyXG5cclxuICAgICAgICAvLyBnZXRKU09OKFxyXG4gICAgICAgIC8vICAgICB0aGlzLm9wdGlvbnMuc2VydmljZVVybCxcclxuICAgICAgICAvLyAgICAgcGFyYW1zLFxyXG4gICAgICAgIC8vICAgICAoZGF0YTogYW55KSA9PiB7IGNiLmNhbGwoY29udGV4dCwgdGhpcy5fZGVjb2RlUmV2ZXJzZUZlYXR1cmVzKGRhdGEpKSB9XHJcbiAgICAgICAgLy8gKTtcclxuICAgIH1cclxuXHJcbiAgICBfZGVjb2RlRmVhdHVyZXMoZGF0YSwgcXVlcnkpIHtcclxuXHJcbiAgICAgICAgLy8gY29uc29sZS5pbmZvKGBkZWNvZGVGZWF0dXJlcyAke3F1ZXJ5LmNsYXNzfWAsIHF1ZXJ5LCBkYXRhKTtcclxuICAgICAgICBjb25zdCByZXN1bHRzID0gW107XHJcbiAgICAgICAgY29uc3QgZ3JvdXAgPSBxdWVyeS5jbGFzcztcclxuXHJcbiAgICAgICAgLy8gY29uc29sZS5pbmZvKHF1ZXJ5LCBkYXRhKTtcclxuICAgICAgICBpZiAoZGF0YSAmJiBkYXRhLmZlYXR1cmVzKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5mZWF0dXJlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZiA9IGRhdGEuZmVhdHVyZXNbaV07XHJcbiAgICAgICAgICAgICAgICBpZiAoZi5wcm9wZXJ0aWVzLm9iamVrdGdydXBwZSA9PT0gXCJBZHJlc3NlXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiB0aGlzLl9kZW9jb2RlRmVhdHVyZU5hbWVBZHJlc3NlKGYpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBncm91cDogZi5wcm9wZXJ0aWVzLm9iamVrdGdydXBwZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaHRtbDogdGhpcy5vcHRpb25zLmh0bWxUZW1wbGF0ZSA/IHRoaXMub3B0aW9ucy5odG1sVGVtcGxhdGUoZikgOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZlYXR1cmU6IGYsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHByb3BlcnRpZXM6IGYucHJvcGVydGllcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcnRyIGNlbnRlcjogbmV3IEwuTGF0TG5nKGYuZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMV0sIGYuZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMF0pXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGYucHJvcGVydGllcy5vYmpla3RncnVwcGUgPT09IFwiU3RyYcOfZVwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogdGhpcy5fZGVvY29kZUZlYXR1cmVOYW1lU3RyYXNzZShmKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXA6IGYucHJvcGVydGllcy5vYmpla3RncnVwcGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGh0bWw6IHRoaXMub3B0aW9ucy5odG1sVGVtcGxhdGUgPyB0aGlzLm9wdGlvbnMuaHRtbFRlbXBsYXRlKGYpIDogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmZWF0dXJlOiBmLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwcm9wZXJ0aWVzOiBmLnByb3BlcnRpZXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJ0ciBjZW50ZXI6IG5ldyBMLkxhdExuZyhmLmdlb21ldHJ5LmNvb3JkaW5hdGVzWzFdLCBmLmdlb21ldHJ5LmNvb3JkaW5hdGVzWzBdKVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChmLnByb3BlcnRpZXMub2JqZWt0Z3J1cHBlID09PSBcIkdlbWVpbmRldGVpbFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogdGhpcy5fZGVvY29kZUZlYXR1cmVOYW1lR2VtZWluZGV0ZWlsKGYpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBncm91cDogZi5wcm9wZXJ0aWVzLm9iamVrdGdydXBwZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaHRtbDogdGhpcy5vcHRpb25zLmh0bWxUZW1wbGF0ZSA/IHRoaXMub3B0aW9ucy5odG1sVGVtcGxhdGUoZikgOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZlYXR1cmU6IGYsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHByb3BlcnRpZXM6IGYucHJvcGVydGllcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcnRyIGNlbnRlcjogbmV3IEwuTGF0TG5nKGYuZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMV0sIGYuZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMF0pXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGYucHJvcGVydGllcy5vYmpla3RncnVwcGUgPT09IFwiR2VtZWluZGVcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMuX2Rlb2NvZGVGZWF0dXJlTmFtZUdlbWVpbmRlKGYpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBncm91cDogZi5wcm9wZXJ0aWVzLm9iamVrdGdydXBwZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaHRtbDogdGhpcy5vcHRpb25zLmh0bWxUZW1wbGF0ZSA/IHRoaXMub3B0aW9ucy5odG1sVGVtcGxhdGUoZikgOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZlYXR1cmU6IGYsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHByb3BlcnRpZXM6IGYucHJvcGVydGllcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcnRyIGNlbnRlcjogbmV3IEwuTGF0TG5nKGYuZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMV0sIGYuZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMF0pXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMuX2Rlb2NvZGVGZWF0dXJlTmFtZShmKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXA6IGYucHJvcGVydGllcy5vYmpla3RncnVwcGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGh0bWw6IHRoaXMub3B0aW9ucy5odG1sVGVtcGxhdGUgPyB0aGlzLm9wdGlvbnMuaHRtbFRlbXBsYXRlKGYpIDogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmZWF0dXJlOiBmLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwcm9wZXJ0aWVzOiBmLnByb3BlcnRpZXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJ0ciBjZW50ZXI6IG5ldyBMLkxhdExuZyhmLmdlb21ldHJ5LmNvb3JkaW5hdGVzWzFdLCBmLmdlb21ldHJ5LmNvb3JkaW5hdGVzWzBdKVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHRzO1xyXG4gICAgfVxyXG5cclxuICAgIF9kZWNvZGVSZXZlcnNlRmVhdHVyZXMoZGF0YSkge1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcclxuICAgICAgICBpZiAoZGF0YSAmJiBkYXRhLmZlYXR1cmVzKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5mZWF0dXJlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZiA9IGRhdGEuZmVhdHVyZXNbaV07XHJcbiAgICAgICAgICAgICAgICBpZiAoZi5wcm9wZXJ0aWVzLm9iamVrdGdydXBwZSA9PT0gXCJBZHJlc3NlXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiB0aGlzLl9kZW9jb2RlRmVhdHVyZU5hbWVBZHJlc3NlKGYpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBodG1sOiB0aGlzLm9wdGlvbnMuaHRtbFRlbXBsYXRlID8gdGhpcy5vcHRpb25zLmh0bWxUZW1wbGF0ZShmKSA6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmVhdHVyZTogZixcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllczogZi5wcm9wZXJ0aWVzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjZW50ZXI6IG5ldyBMLkxhdExuZyhmLmdlb21ldHJ5LmNvb3JkaW5hdGVzWzFdLCBmLmdlb21ldHJ5LmNvb3JkaW5hdGVzWzBdKVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHRzO1xyXG4gICAgfVxyXG5cclxuICAgIF9kZW9jb2RlRmVhdHVyZU5hbWVHZW1laW5kZShmKSB7XHJcbiAgICAgICAgY29uc3QgbmFtZSA9IGYucHJvcGVydGllc1snZ2VtZWluZGVfbmFtZSddO1xyXG4gICAgICAgIGNvbnN0IGlkeCA9IG5hbWUuaW5kZXhPZignLCcpO1xyXG4gICAgICAgIHJldHVybiAoaWR4ID4gMCkgPyBuYW1lLnN1YnN0cmluZygwLCBpZHgpIDogbmFtZTtcclxuICAgIH1cclxuXHJcbiAgICBfZGVvY29kZUZlYXR1cmVOYW1lR2VtZWluZGV0ZWlsKGYpIHtcclxuICAgICAgICBjb25zdCBnZW1laW5kZV9uYW1lID0gZi5wcm9wZXJ0aWVzWydnZW1laW5kZV9uYW1lJ107XHJcbiAgICAgICAgY29uc3QgZ2VtZWluZGV0ZWlsX25hbWUgPSBmLnByb3BlcnRpZXNbJ2dlbWVpbmRldGVpbF9uYW1lJ107XHJcblxyXG4gICAgICAgIGNvbnN0IGlkeCA9IGdlbWVpbmRlX25hbWUuaW5kZXhPZignLCcpO1xyXG4gICAgICAgIGxldCBuYW1lID0gKGlkeCA+IDApID8gZ2VtZWluZGVfbmFtZS5zdWJzdHJpbmcoMCwgaWR4KSA6IGdlbWVpbmRlX25hbWU7XHJcbiAgICAgICAgaWYgKGdlbWVpbmRldGVpbF9uYW1lICYmIG5hbWUgIT09IGdlbWVpbmRldGVpbF9uYW1lKSB7XHJcbiAgICAgICAgICAgIG5hbWUgKz0gXCIsIFwiICsgZ2VtZWluZGV0ZWlsX25hbWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuYW1lO1xyXG4gICAgfVxyXG5cclxuICAgIF9kZW9jb2RlRmVhdHVyZU5hbWVTdHJhc3NlKGYpIHtcclxuICAgICAgICBjb25zdCBnZW1laW5kZV9uYW1lID0gZi5wcm9wZXJ0aWVzWydnZW1laW5kZV9uYW1lJ107XHJcbiAgICAgICAgY29uc3QgZ2VtZWluZGV0ZWlsX25hbWUgPSBmLnByb3BlcnRpZXNbJ2dlbWVpbmRldGVpbF9uYW1lJ107XHJcbiAgICAgICAgY29uc3Qgc3RyYXNzZV9uYW1lID0gZi5wcm9wZXJ0aWVzWydzdHJhc3NlX25hbWUnXTtcclxuICAgICAgICBjb25zdCBpZHggPSBnZW1laW5kZV9uYW1lLmluZGV4T2YoJywnKTtcclxuICAgICAgICAvLyBjb25zb2xlLmluZm8oZ2VtZWluZGVfbmFtZSArIFwiIFwiICsgaWR4KTtcclxuICAgICAgICBsZXQgbmFtZSA9IChpZHggPiAwKSA/IGdlbWVpbmRlX25hbWUuc3Vic3RyaW5nKDAsIGlkeCkgOiBnZW1laW5kZV9uYW1lO1xyXG5cclxuICAgICAgICBpZiAoZ2VtZWluZGV0ZWlsX25hbWUgJiYgbmFtZSAhPT0gZ2VtZWluZGV0ZWlsX25hbWUpIHtcclxuICAgICAgICAgICAgbmFtZSArPSBcIiwgXCIgKyBnZW1laW5kZXRlaWxfbmFtZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbmFtZSArPSBcIiwgXCIgKyBzdHJhc3NlX25hbWU7XHJcbiAgICAgICAgcmV0dXJuIG5hbWU7XHJcbiAgICB9XHJcblxyXG4gICAgX2Rlb2NvZGVGZWF0dXJlTmFtZUFkcmVzc2UoZikge1xyXG4gICAgICAgIGNvbnN0IGdlbWVpbmRlX25hbWUgPSBmLnByb3BlcnRpZXNbJ2dlbWVpbmRlX25hbWUnXTtcclxuICAgICAgICBjb25zdCBnZW1laW5kZXRlaWxfbmFtZSA9IGYucHJvcGVydGllc1snZ2VtZWluZGV0ZWlsX25hbWUnXTtcclxuICAgICAgICBjb25zdCBzdHJhc3NlX25hbWUgPSBmLnByb3BlcnRpZXNbJ3N0cmFzc2VfbmFtZSddO1xyXG4gICAgICAgIGNvbnN0IGlkeCA9IGdlbWVpbmRlX25hbWUuaW5kZXhPZignLCcpO1xyXG4gICAgICAgIGxldCBuYW1lID0gKGlkeCA+IDApID8gZ2VtZWluZGVfbmFtZS5zdWJzdHJpbmcoMCwgaWR4KSA6IGdlbWVpbmRlX25hbWU7XHJcblxyXG4gICAgICAgIGlmIChnZW1laW5kZXRlaWxfbmFtZSAmJiBuYW1lICE9PSBnZW1laW5kZXRlaWxfbmFtZSkge1xyXG4gICAgICAgICAgICBuYW1lICs9IFwiLCBcIiArIGdlbWVpbmRldGVpbF9uYW1lO1xyXG4gICAgICAgIH1cclxuICAgICAgICBuYW1lICs9IFwiLCBcIiArIHN0cmFzc2VfbmFtZTtcclxuXHJcbiAgICAgICAgY29uc3QgaGF1c251bW1lciA9IGYucHJvcGVydGllc1snaGF1c251bW1lciddO1xyXG4gICAgICAgIGNvbnN0IGhhdXNudW1tZXJfenVzYXR6ID0gZi5wcm9wZXJ0aWVzWydoYXVzbnVtbWVyX3p1c2F0eiddO1xyXG4gICAgICAgIGlmIChoYXVzbnVtbWVyKSB7XHJcbiAgICAgICAgICAgIG5hbWUgKz0gXCIgXCIgKyBoYXVzbnVtbWVyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaGF1c251bW1lcl96dXNhdHopIHtcclxuICAgICAgICAgICAgbmFtZSArPSBoYXVzbnVtbWVyX3p1c2F0ejtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBuYW1lO1xyXG4gICAgfVxyXG5cclxuICAgIF9kZW9jb2RlRmVhdHVyZU5hbWUoZikge1xyXG4gICAgICAgIGxldCBuYW1lOnN0cmluZztcclxuICAgICAgICBmb3IgKGxldCBqID0gMDsgIW5hbWUgJiYgaiA8IHRoaXMub3B0aW9ucy5uYW1lUHJvcGVydGllcy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICBuYW1lID0gZi5wcm9wZXJ0aWVzW3RoaXMub3B0aW9ucy5uYW1lUHJvcGVydGllc1tqXV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChmLnByb3BlcnRpZXMub2JqZWt0Z3J1cHBlID09PSBcIkdlbWVpbmRldGVpbFwiIHx8IGYucHJvcGVydGllcy5vYmpla3RncnVwcGUgPT09IFwiR2VtZWluZGVcIikge1xyXG4gICAgICAgICAgICBsZXQgaWR4ID0gZi5wcm9wZXJ0aWVzWydfdGl0bGVfJ10uaW5kZXhPZignLCcpO1xyXG4gICAgICAgICAgICBuYW1lID0gKGlkeCA+IDApID8gZi5wcm9wZXJ0aWVzWydfdGl0bGVfJ10uc3Vic3RyaW5nKDAsIGlkeCkgOiBmLnByb3BlcnRpZXNbJ190aXRsZV8nXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5hbWU7XHJcbiAgICB9XHJcbn1cclxuXHJcbiIsImltcG9ydCB7IGNyZWF0ZUh0bWxFbGVtZW50IH0gZnJvbSBcIi4uL1V0aWxcIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBBY2NvcmRpb25JdGVtIHtcclxuXHJcbiAgICB0aXRsZTpzdHJpbmdcclxuICAgIGNvbnRlbnQ6SFRNTEVsZW1lbnRcclxuICAgIGRvbTogSFRNTERpdkVsZW1lbnQ7XHJcblxyXG4gICAgY29uc3RydWN0b3IodGl0bGU6c3RyaW5nLCBjb250ZW50OkhUTUxFbGVtZW50KSB7XHJcbiAgICAgICAgdGhpcy50aXRsZSA9IHRpdGxlO1xyXG4gICAgICAgIHRoaXMuY29udGVudCA9IGNvbnRlbnQ7XHJcbiAgICB9XHJcblxyXG4gICAgcmVuZGVyKCk6SFRNTEVsZW1lbnQge1xyXG4gICAgICAgIGNvbnN0IGRvbSA9IHRoaXMuZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgZG9tLmNsYXNzTmFtZSA9ICdhY2NvcmRpb24taXRlbSc7XHJcbiAgICAgICAgY29uc3QgdGl0bGVEaXYgPSBjcmVhdGVIdG1sRWxlbWVudCgnZGl2JywgZG9tKTtcclxuICAgICAgICBjb25zdCBzcGFuID0gY3JlYXRlSHRtbEVsZW1lbnQoJ3NwYW4nLCB0aXRsZURpdik7XHJcbiAgICAgICAgY29uc3QgaSA9IGNyZWF0ZUh0bWxFbGVtZW50KCdzcGFuJywgdGl0bGVEaXYsICdpY29uJyk7ICAgICAgICBcclxuICAgICAgICBzcGFuLmlubmVySFRNTCA9IHRoaXMudGl0bGU7XHJcbiAgICAgICAgdGl0bGVEaXYuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZXZ0KT0+e2RvbS5jbGFzc0xpc3QudG9nZ2xlKCdvcGVuZWQnKX0pO1xyXG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnQpIHtcclxuICAgICAgICAgICAgZG9tLmFwcGVuZENoaWxkKHRoaXMuY29udGVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkb207XHJcbiAgICB9XHJcblxyXG4gICAgc2V0Q29sbGFwc2VkKGNvbGxhcHNlOmJvb2xlYW4pOnZvaWQge1xyXG4gICAgICAgIGlmIChjb2xsYXBzZSkge1xyXG4gICAgICAgICAgICB0aGlzLmRvbS5jbGFzc0xpc3QucmVtb3ZlKCdvcGVuZWQnKVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuZG9tLmNsYXNzTGlzdC5hZGQoJ29wZW5lZCcpXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxufVxyXG5leHBvcnQgY2xhc3MgQWNjb3JkaW9uIHtcclxuXHJcbiAgICBpdGVtczpBY2NvcmRpb25JdGVtW107XHJcblxyXG4gICAgY29uc3RydWN0b3IoaXRlbXM6QWNjb3JkaW9uSXRlbVtdKSB7XHJcbiAgICAgICAgdGhpcy5pdGVtcyA9IGl0ZW1zO1xyXG4gICAgfVxyXG5cclxuICAgIHJlbmRlcigpOkhUTUxFbGVtZW50IHtcclxuICAgICAgICBjb25zdCBkb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICBkb20uY2xhc3NOYW1lID0gJ2FjY29yZGlvbic7XHJcbiAgICAgICAgY29uc3QgaXRlbXMgPSB0aGlzLml0ZW1zO1xyXG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxpdGVtcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBpdGVtRG9tID0gaXRlbXNbaV0ucmVuZGVyKCk7XHJcbiAgICAgICAgICAgIGlmIChpPT09MCkge1xyXG4gICAgICAgICAgICAgICAgaXRlbURvbS5jbGFzc0xpc3QuYWRkKCdvcGVuZWQnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkb20uYXBwZW5kQ2hpbGQoaXRlbURvbSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkb207XHJcbiAgICB9XHJcblxyXG59IiwiaW1wb3J0IHsgRXZlbnREaXNwYXRjaGVyIH0gZnJvbSBcInN0cm9uZ2x5LXR5cGVkLWV2ZW50c1wiO1xyXG5pbXBvcnQgeyBTZWxlY3Rpb25Nb2RlLCBTZWxlY3Rpb25TdGF0dXMsIFRyZWVOb2RlIH0gZnJvbSBcIi4vVHJlZU5vZGVcIjtcclxuXHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFRyZWVQYXJhbSB7XHJcbiAgICBzZWxlY3RNb2RlPzpTZWxlY3Rpb25Nb2RlLFxyXG4gICAgZXhwYW5kT25seU9uZU5vZGU/IDogYm9vbGVhblxyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIENoYW5nZU5vZGVPcmRlckV2ZW50IHtcclxuICAgIG5vZGU6VHJlZU5vZGU7XHJcbiAgICB1cDogYm9vbGVhbjtcclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIFRyZWUge1xyXG5cclxuICAgIHN0YXRpYyBOT0RFX1NFTEVDVElPTl9DSEFOR0VfRVZFTlQgPSBcIm5vZGVTZWxlY3Rpb25DaGFuZ2VcIjtcclxuICAgIHN0YXRpYyBOT0RFX1NFTEVDVEVEX0VWRU5UID0gXCJub2RlX3NlbGVjdGVkXCI7XHJcbiAgICBzdGF0aWMgTk9ERV9VTlNFTEVDVEVEX0VWRU5UID0gXCJub2RlX3Vuc2VsZWN0ZWRcIjtcclxuXHJcbiAgICBzZWxlY3RNb2RlOlNlbGVjdGlvbk1vZGUgPSBTZWxlY3Rpb25Nb2RlLlNJTkdMRTtcclxuICAgIGV4cGFuZE9ubHlPbmVOb2RlOmJvb2xlYW47XHJcblxyXG4gICAgbm9kZVNlbGVjdGlvbkNoYW5nZUhhbmRsZXI6KG5vZGU6VHJlZU5vZGUsIFNlbGVjdGlvblN0YXR1czpTZWxlY3Rpb25TdGF0dXMpPT52b2lkO1xyXG4gICAgY2hpbGRFeHBhbmRDaGFuZ2VIYW5kbGVyOiAobm9kZTogVHJlZU5vZGUsIGV4cGFuZDogYm9vbGVhbikgPT4gdm9pZDtcclxuXHJcbiAgICBvblNlbGVjdGlvbkNoYW5nZSA9IG5ldyBFdmVudERpc3BhdGNoZXI8VHJlZU5vZGUsIFNlbGVjdGlvblN0YXR1cz4oKTtcclxuXHJcbiAgICBwYW5lOiBIVE1MRGl2RWxlbWVudCA9IG51bGw7XHJcblxyXG4gICAgbm9kZXM6IEFycmF5PFRyZWVOb2RlPiA9IFtdO1xyXG5cclxuICAgIHNlbGVjdGVkTm9kZTogVHJlZU5vZGU7XHJcblxyXG4gICAgb2JzZXJ2ZXI6IE11dGF0aW9uT2JzZXJ2ZXI7XHJcblxyXG4gICAgY29uc3RydWN0b3Iobm9kZXM6IEFycmF5PFRyZWVOb2RlPiwgcGFyYW0/OlRyZWVQYXJhbSkge1xyXG5cclxuICAgICAgICBpZiAocGFyYW0pIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgayBpbiBwYXJhbSkge1xyXG4gICAgICAgICAgICAgICAgdGhpc1trXSA9IHBhcmFtW2tdXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHBhcmFtLmV4cGFuZE9ubHlPbmVOb2RlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNoaWxkRXhwYW5kQ2hhbmdlSGFuZGxlciA9IChub2RlLCBleHBhbmRlZCkgPT4gdGhpcy5jaGlsZEV4cGFuZENoYW5nZWQobm9kZSwgZXhwYW5kZWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubm9kZVNlbGVjdGlvbkNoYW5nZUhhbmRsZXIgPSAobm9kZSwgc3RhdHVzKSA9PiB0aGlzLm5vZGVTZWxlY3RlZChub2RlLCBzdGF0dXMpO1xyXG4gICAgICAgIGlmIChub2Rlcykge1xyXG4gICAgICAgICAgICB0aGlzLm5vZGVzID0gbm9kZXM7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBjb3VudCA9IG5vZGVzLmxlbmd0aDsgaSA8IGNvdW50OyBpKyspIHtcclxuICAgICAgICAgICAgICAgIG5vZGVzW2ldLnNldFRyZWUodGhpcylcclxuICAgICAgICAgICAgICAgIG5vZGVzW2ldLm9uU2VsZWN0aW9uQ2hhbmdlLnN1YnNjcmliZSh0aGlzLm5vZGVTZWxlY3Rpb25DaGFuZ2VIYW5kbGVyKTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmV4cGFuZE9ubHlPbmVOb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZXNbaV0ub25FeHBhbmRDaGFuZ2Uuc3Vic2NyaWJlKCB0aGlzLmNoaWxkRXhwYW5kQ2hhbmdlSGFuZGxlciApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLm5vZGVzID0gW107XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIF9yZW5kZXIoKTogSFRNTERpdkVsZW1lbnQge1xyXG4gICAgICAgIGNvbnN0IHBhbmUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG4gICAgICAgIHBhbmUuY2xhc3NOYW1lID0gXCJ0cmVlY29udGFpbmVyXCJcclxuICAgICAgICBmb3IgKGxldCBpID0gMCwgY291bnQgPSB0aGlzLm5vZGVzLmxlbmd0aDsgaSA8IGNvdW50OyBpKyspIHtcclxuICAgICAgICAgICAgcGFuZS5hcHBlbmRDaGlsZCh0aGlzLm5vZGVzW2ldLnJlbmRlcigpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucGFuZSA9IHBhbmU7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIF9tdXRhdGlvbihtdXRhdGlvbnM6IE11dGF0aW9uUmVjb3JkW10sIG9ic2VydmVyOiBNdXRhdGlvbk9ic2VydmVyKSB7ICAgIFxyXG4gICAgICAgIHRoaXMucmVzaXplKClcclxuICAgICAgICBsZXQgZiA9ICgpID0+IHRoaXMucmVzaXplKClcclxuICAgICAgICB3aW5kb3cuc2V0VGltZW91dChmLCA1MjApICAgICAgIFxyXG4gICAgfVxyXG5cclxuXHJcbiAgICBfdXBkYXRlKCk6IEhUTUxEaXZFbGVtZW50IHtcclxuICAgICAgICBjb25zdCBwYW5lID0gdGhpcy5wYW5lO1xyXG4gICAgICAgIGNvbnN0IG5ld0NoaWxkcyA9IFtdO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBjb3VudCA9IHRoaXMubm9kZXMubGVuZ3RoOyBpIDwgY291bnQ7IGkrKykge1xyXG4gICAgICAgICAgICBuZXdDaGlsZHMucHVzaCh0aGlzLm5vZGVzW2ldLnJlbmRlcigpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcGFuZS5yZXBsYWNlQ2hpbGRyZW4oLi4ubmV3Q2hpbGRzKTtcclxuICAgICAgICBjb25zb2xlLmluZm8oXCJyZXBsYWNjXCIpXHJcbiAgICAgICAgcmV0dXJuIHRoaXMucGFuZSA9IHBhbmU7XHJcbiAgICB9XHJcblxyXG4gICAgbW92ZU5vZGVVcChuOlRyZWVOb2RlKSB7XHJcbiAgICAgICAgY29uc29sZS5pbmZvKCdtb3ZlTm9kZVVwJylcclxuICAgICAgICBjb25zdCBpZHggPSB0aGlzLm5vZGVzLmluZGV4T2Yobik7XHJcbiAgICAgICAgaWYgKGlkeD4wKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG90aGVyTm9kZSA9IHRoaXMubm9kZXNbaWR4LTFdO1xyXG4gICAgICAgICAgICB0aGlzLm5vZGVzW2lkeC0xXSA9IG47XHJcbiAgICAgICAgICAgIHRoaXMubm9kZXNbaWR4XSA9IG90aGVyTm9kZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fdXBkYXRlKCk7XHJcbiAgICB9XHJcbiAgICBtb3ZlTm9kZURvd24objpUcmVlTm9kZSkge1xyXG4gICAgICAgIGNvbnNvbGUuaW5mbygnbW92ZU5vZGVEb3duJylcclxuICAgICAgICBjb25zdCBpZHggPSB0aGlzLm5vZGVzLmluZGV4T2Yobik7XHJcbiAgICAgICAgaWYgKGlkeDx0aGlzLm5vZGVzLmxlbmd0aC0xKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG90aGVyTm9kZSA9IHRoaXMubm9kZXNbaWR4KzFdO1xyXG4gICAgICAgICAgICB0aGlzLm5vZGVzW2lkeCsxXSA9IG47XHJcbiAgICAgICAgICAgIHRoaXMubm9kZXNbaWR4XSA9IG90aGVyTm9kZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fdXBkYXRlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmVzaXplKCkge1xyXG4gICAgICAgIC8vIGNvbnNvbGUuaW5mbyhcIlRyZWUgXCIrIHRoaXMubm9kZXMubGVuZ3RoLCB0aGlzLnBhbmUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpOyAgICAgICAgXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGNvdW50ID0gdGhpcy5ub2Rlcy5sZW5ndGg7IGkgPCBjb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMubm9kZXNbaV0ucmVzaXplKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGFkZE5vZGUobm9kZTogVHJlZU5vZGUpIHtcclxuICAgICAgICAvLyBjb25zb2xlLmluZm8oXCJhZGROb2RlXCIsIG5vZGUpO1xyXG4gICAgICAgIG5vZGUuc2V0VHJlZSh0aGlzKVxyXG4gICAgICAgIG5vZGUub25TZWxlY3Rpb25DaGFuZ2Uuc3Vic2NyaWJlKCB0aGlzLm5vZGVTZWxlY3Rpb25DaGFuZ2VIYW5kbGVyICk7XHJcbiAgICAgICAgaWYgKHRoaXMuZXhwYW5kT25seU9uZU5vZGUpIHtcclxuICAgICAgICAgICAgbm9kZS5vbkV4cGFuZENoYW5nZS5zdWJzY3JpYmUoIHRoaXMuY2hpbGRFeHBhbmRDaGFuZ2VIYW5kbGVyICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubm9kZXMucHVzaChub2RlKSAgICAgICAgXHJcbiAgICAgICAgaWYgKHRoaXMucGFuZSkge1xyXG4gICAgICAgICAgICBsZXQgZWwgPSBub2RlLnJlbmRlcigpXHJcbiAgICAgICAgICAgIHRoaXMucGFuZS5hcHBlbmRDaGlsZChlbCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGFkZE5vZGVzKG5vZGVzOiBUcmVlTm9kZVtdKSB7XHJcbiAgICAgICAgLy8gY29uc29sZS5pbmZvKFwiYWRkTm9kZVwiLCBub2RlKTtcclxuICAgICAgICBjb25zdCBuZXdOb2RlczpUcmVlTm9kZVtdID0gW107XHJcbiAgICAgICAgY29uc3QgZCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcclxuICAgICAgICBmb3IgKGxldCBpPTA7IGk8bm9kZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldXHJcbiAgICAgICAgICAgIG5vZGUuc2V0VHJlZSh0aGlzKVxyXG4gICAgICAgICAgICBub2RlLm9uU2VsZWN0aW9uQ2hhbmdlLnN1YnNjcmliZSggdGhpcy5ub2RlU2VsZWN0aW9uQ2hhbmdlSGFuZGxlciApO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5leHBhbmRPbmx5T25lTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgbm9kZS5vbkV4cGFuZENoYW5nZS5zdWJzY3JpYmUoIHRoaXMuY2hpbGRFeHBhbmRDaGFuZ2VIYW5kbGVyICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKG5vZGUpICAgIFxyXG4gICAgICAgICAgICBuZXdOb2Rlcy5wdXNoKG5vZGUpO1xyXG4gICAgICAgICAgICBkLmFwcGVuZENoaWxkKG5vZGUucmVuZGVyKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5wYW5lKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBsZXQgZWwgPSBub2RlLnJlbmRlcigpXHJcbiAgICAgICAgICAgIHRoaXMucGFuZS5hcHBlbmRDaGlsZChkKTtcclxuICAgICAgICB9XHJcbiAgICB9ICAgIFxyXG5cclxuICAgIGluc2VydE5vZGUobm9kZTogVHJlZU5vZGUsIHBvczpudW1iZXIpIHtcclxuICAgICAgICBub2RlLnNldFRyZWUodGhpcylcclxuICAgICAgICBub2RlLm9uU2VsZWN0aW9uQ2hhbmdlLnN1YnNjcmliZSggdGhpcy5ub2RlU2VsZWN0aW9uQ2hhbmdlSGFuZGxlciApO1xyXG4gICAgICAgIGlmICh0aGlzLmV4cGFuZE9ubHlPbmVOb2RlKSB7XHJcbiAgICAgICAgICAgIG5vZGUub25FeHBhbmRDaGFuZ2Uuc3Vic2NyaWJlKCB0aGlzLmNoaWxkRXhwYW5kQ2hhbmdlSGFuZGxlciApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgbm9kZXM6QXJyYXk8VHJlZU5vZGU+ID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgaT0wLCBjb3VudD10aGlzLm5vZGVzLmxlbmd0aDsgaTxjb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChpPT09cG9zKSB7XHJcbiAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKG5vZGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG5vZGVzLnB1c2godGhpcy5ub2Rlc1tpXSk7XHJcbiAgICAgICAgfSAgIFxyXG4gICAgICAgIGlmIChwb3M8dGhpcy5ub2Rlcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdGhpcy5wYW5lLmluc2VydEJlZm9yZShub2RlLnJlbmRlcigpLCB0aGlzLm5vZGVzW3Bvc10uZG9tKVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5wYW5lLmFwcGVuZENoaWxkKG5vZGUucmVuZGVyKCkpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubm9kZXMgPSBub2Rlc1xyXG4gICAgfVxyXG5cclxuICAgIGZpbmROb2RlKGRhdGE6YW55LCBub2RlPzpUcmVlTm9kZSk6VHJlZU5vZGUge1xyXG4gICAgICAgIGxldCBub2RlczpBcnJheTxUcmVlTm9kZT4gPSBub2RlPyBub2RlLmNoaWxkcyA6IHRoaXMubm9kZXM7XHJcbiAgICAgICAgaWYgKG5vZGVzKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGk9MCwgY291bnQ9bm9kZXMubGVuZ3RoOyBpPGNvdW50OyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChkYXRhID09PSBub2Rlc1tpXS5kYXRhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGVzW2ldXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgbm9kZSA9IHRoaXMuZmluZE5vZGUoZGF0YSwgbm9kZXNbaV0pXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsXHJcbiAgICB9XHJcblxyXG4gICAgc2VsZWN0Tm9kZShkYXRhOmFueSwgcHJvcD86c3RyaW5nKTpBcnJheTxUcmVlTm9kZT4ge1xyXG4gICAgICAgIGZvciAobGV0IGk9MCwgY291bnQ9dGhpcy5ub2Rlcy5sZW5ndGg7IGk8Y291bnQ7IGkrKykge1xyXG4gICAgICAgICAgICBsZXQgc2VsTm9kZXMgPSB0aGlzLm5vZGVzW2ldLnNlbGVjdE5vZGUoZGF0YSwgcHJvcCk7ICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmIChzZWxOb2Rlcykge1xyXG4gICAgICAgICAgICAgICByZXR1cm4gc2VsTm9kZXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB1bnNlbGVjdE5vZGUoZGF0YTphbnksIHByb3A/OnN0cmluZykge1xyXG4gICAgICAgIGZvciAobGV0IGk9MCwgY291bnQ9dGhpcy5ub2Rlcy5sZW5ndGg7IGk8Y291bnQ7IGkrKykge1xyXG4gICAgICAgICAgICBsZXQgc2VsTm9kZXMgPSB0aGlzLm5vZGVzW2ldLnVuc2VsZWN0Tm9kZShkYXRhLCBwcm9wKTsgICAgICAgICAgICBcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgc2VsZWN0QW5kRXhwYW5kTm9kZShkYXRhOmFueSwgcHJvcD86c3RyaW5nKTpBcnJheTxUcmVlTm9kZT4ge1xyXG4gICAgICAgIGZvciAobGV0IGk9MCwgY291bnQ9dGhpcy5ub2Rlcy5sZW5ndGg7IGk8Y291bnQ7IGkrKykge1xyXG4gICAgICAgICAgICBsZXQgc2VsTm9kZXMgPSB0aGlzLm5vZGVzW2ldLnNlbGVjdE5vZGUoZGF0YSwgcHJvcClcclxuICAgICAgICAgICAgLy8gY29uc29sZS5pbmZvKCdzZWxlY3ROb2RlJywgc2VsTm9kZXMpO1xyXG4gICAgICAgICAgICBpZiAoc2VsTm9kZXMpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzZWxOb2RlcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBleHBhbmRBbGwoKTp2b2lkIHtcclxuICAgICAgICBmb3IgKGxldCBpPTAsIGNvdW50PXRoaXMubm9kZXMubGVuZ3RoOyBpPGNvdW50OyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy5ub2Rlc1tpXS5leHBhbmQoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmVtb3ZlTm9kZShub2RlOiBUcmVlTm9kZSkge1xyXG4gICAgICAgIC8vIGNvbnNvbGUuaW5mbyhcInJlbW92ZU5vZGVcIiwgbm9kZSk7XHJcbiAgICAgICAgbm9kZS5zZXRUcmVlKG51bGwpXHJcbiAgICAgICAgbm9kZS5vblNlbGVjdGlvbkNoYW5nZS51bnN1YnNjcmliZSh0aGlzLm5vZGVTZWxlY3Rpb25DaGFuZ2VIYW5kbGVyKTtcclxuICAgICAgICBpZiAodGhpcy5leHBhbmRPbmx5T25lTm9kZSkge1xyXG4gICAgICAgICAgICBub2RlLm9uRXhwYW5kQ2hhbmdlLnVuc3Vic2NyaWJlKCB0aGlzLmNoaWxkRXhwYW5kQ2hhbmdlSGFuZGxlciApO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBub2RlLm9mZihcImNoYW5nZVwiLCB0aGlzLnNlbGVjdGlvbkNoYW5nZWQsIHRoaXMpO1xyXG4gICAgICAgXHJcbiAgICAgICAgaWYgKG5vZGUucGFyZW50KSB7XHJcbiAgICAgICAgICAgIG5vZGUucGFyZW50Ll9yZW1vdmVDaGlsZChub2RlKVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbGV0IG5vZGVzOkFycmF5PFRyZWVOb2RlPiA9IFtdICAgXHJcbiAgICAgICAgICAgIGZvciAobGV0IGk9MCwgY291bnQ9dGhpcy5ub2Rlcy5sZW5ndGg7IGk8Y291bnQ7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubm9kZXNbaV0hPT1ub2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZXMucHVzaCh0aGlzLm5vZGVzW2ldKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcInJlbW92ZU5vZGUgXCIraSwgdGhpcy5ub2Rlc1tpXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbm9kZS5yZW1vdmUoKTtcclxuICAgICAgICAgICAgdGhpcy5ub2RlcyA9IG5vZGVzXHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIFxyXG4gICAgfVxyXG5cclxuICAgIG9uUmVzaXplKGV2OiBVSUV2ZW50KTogYW55IHtcclxuICAgICAgICB0aGlzLnJlc2l6ZSgpXHJcbiAgICB9XHJcblxyXG5cclxuICAgIGFkZFRvKGVsZW06IEhUTUxFbGVtZW50KSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnBhbmUpIHtcclxuICAgICAgICAgICAgdGhpcy5fcmVuZGVyKClcclxuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgKGV2OlVJRXZlbnQpID0+IHRoaXMub25SZXNpemUoZXYpKVxyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgcGFuZSA9IHRoaXMuZ2V0RG9tKCk7XHJcbiAgICAgICAgcGFuZS5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIChldjpVSUV2ZW50KSA9PiB0aGlzLm9uUmVzaXplKGV2KSlcclxuICAgICAgICBlbGVtLmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgKGV2OlVJRXZlbnQpID0+IHRoaXMub25SZXNpemUoZXYpKVxyXG4gICAgICAgIGVsZW0uYXBwZW5kQ2hpbGQodGhpcy5nZXREb20oKSlcclxuICAgIH1cclxuXHJcbiAgICBnZXRXaWRoKCk6IG51bWJlciB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLnBhbmUgJiYgdGhpcy5wYW5lLnBhcmVudEVsZW1lbnQpID8gdGhpcy5wYW5lLnBhcmVudEVsZW1lbnQuY2xpZW50V2lkdGggOiAtMSAgICAgICAgXHJcbiAgICB9XHJcblxyXG4gICAgZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5wYW5lICYmIHRoaXMucGFuZS5wYXJlbnRFbGVtZW50KSA/IHRoaXMucGFuZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSAgOiBudWxsXHJcbiAgICB9XHJcblxyXG4gICAgZ2V0RG9tKCk6IEhUTUxEaXZFbGVtZW50IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5wYW5lO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogcmV0dXJuIHRoZSBEYXRhIG9mIHRoZSBzZWxlY3RlZCBub2Rlc1xyXG4gICAgICovXHJcbiAgICBnZXRTZWxlY3RlZCgpOiBBcnJheTxhbnk+IHtcclxuICAgICAgICBsZXQgcmVzdWx0ID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGNvdW50ID0gdGhpcy5ub2Rlcy5sZW5ndGg7IGkgPCBjb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQodGhpcy5ub2Rlc1tpXS5nZXRTZWxlY3RlZCgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcblxyXG4gICAgY2hpbGRFeHBhbmRDaGFuZ2VkKG5vZGU6IFRyZWVOb2RlLCBleHBhbmRlZDogYm9vbGVhbik6IHZvaWQge1xyXG4gICAgICAgIGNvbnNvbGUuaW5mbyhcImNoaWxkRXhwYW5kQ2hhbmdlZFwiKTtcclxuICAgICAgICBpZiAoZXhwYW5kZWQgJiYgdGhpcy5leHBhbmRPbmx5T25lTm9kZSkge1xyXG4gICAgICAgICAgICBjb25zdCBjb3VudCA9IHRoaXMubm9kZXMgPyB0aGlzLm5vZGVzLmxlbmd0aCA6IDA7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGk9MDsgaTxjb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobm9kZSAhPT0gdGhpcy5ub2Rlc1tpXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubm9kZXNbaV0uY29sbGFwc2UoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8gbm9kZVNlbGVjdGVkKGV2dDpMLkxlYWZsZXRFdmVudCkge1xyXG4gICAgbm9kZVNlbGVjdGVkKG5vZGU6VHJlZU5vZGUsIHN0YXR1czpTZWxlY3Rpb25TdGF0dXMpIHtcclxuICAgICAgICAvLyBjb25zb2xlLmluZm8oYFRyZWUgbm9kZVNlbGVjdGVkKCR7bm9kZS5kYXRhLm5hbWV9IHN0YXR1cz0ke1NlbGVjdGlvblN0YXR1c1tzdGF0dXNdfSkgc2VsZWN0ZWROb2RlPSR7dGhpcy5zZWxlY3RlZE5vZGUgPyB0aGlzLnNlbGVjdGVkTm9kZS5kYXRhLm5hbWUgOiBcInVuZGVmaW5lZFwifWApO1xyXG4gICAgICAgIGlmICh0aGlzLnNlbGVjdE1vZGU9PT1TZWxlY3Rpb25Nb2RlLlNJTkdMRSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5zZWxlY3RlZE5vZGUpIHtcclxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUuaW5mbyhgb2xkU2VsZWN0ZWROb2RlPSR7dGhpcy5zZWxlY3RlZE5vZGUuZGF0YS5uYW1lfSAgYCt0aGlzLnNlbGVjdGVkTm9kZS5kYXRhLm5hbWUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWROb2RlIT09bm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWROb2RlLnNldFNlbGVjdGVkKGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobm9kZSAmJiBub2RlLnNlbGVjdGlvblN0YXR1cz09PVNlbGVjdGlvblN0YXR1cy5TRUxFQ1RFRCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZE5vZGUgPSBub2RlO1xyXG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5pbmZvKFwiZGlzcGF0Y2gwMlwiKTtcclxuICAgICAgICAgICAgICAgIHRoaXMub25TZWxlY3Rpb25DaGFuZ2UuZGlzcGF0Y2godGhpcy5zZWxlY3RlZE5vZGUsIHN0YXR1cyk7IFxyXG4gICAgICAgICAgICB9IFxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUuaW5mbyhcImRpc3BhdGNoMDNcIik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9uU2VsZWN0aW9uQ2hhbmdlLmRpc3BhdGNoKG5vZGUsIHN0YXR1cyk7IFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLm9uU2VsZWN0aW9uQ2hhbmdlLmRpc3BhdGNoKG5vZGUsIHN0YXR1cyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxufSIsIlxyXG5pbXBvcnQgeyBEaXNwYXRjaGVyV3JhcHBlciwgRXZlbnREaXNwYXRjaGVyIH0gZnJvbSAnc3Ryb25nbHktdHlwZWQtZXZlbnRzJztcclxuaW1wb3J0IHsgQWN0aW9uIH0gZnJvbSAnLi9BY3Rpb24nO1xyXG5pbXBvcnQgeyBDaGFuZ2VOb2RlT3JkZXJFdmVudCwgVHJlZSB9IGZyb20gJy4vVHJlZSc7XHJcblxyXG5cclxuZXhwb3J0IGVudW0gU2VsZWN0aW9uTW9kZSB7XHJcbiAgICBNVUxUSSxcclxuICAgIFNJTkdMRSxcclxuICAgIFJBRElPLFxyXG4gICAgLy8gTm9kZSB3aXRoIGNoaWxkcyB3aGVyZSBvbmUgY2FuIGJlIGNob29zZW5cclxuICAgIFJBRElPX0dST1VQXHJcbn1cclxuXHJcbi8vIGZ1bmN0aW9uIHNlbGVjdGlvbk1vZGVUb1N0cmluZyhtb2RlOlNlbGVjdGlvbk1vZGUpOnN0cmluZyB7XHJcbi8vICAgICBzd2l0Y2ggKG1vZGUpIHtcclxuLy8gICAgICAgICBjYXNlIFNlbGVjdGlvbk1vZGUuTVVMVEk6XHJcbi8vICAgICAgICAgICAgIHJldHVybiAnbXVsdGknO1xyXG4vLyAgICAgICAgIGNhc2UgU2VsZWN0aW9uTW9kZS5TSU5HTEU6XHJcbi8vICAgICAgICAgICAgIHJldHVybiAnbXVsdGknO1xyXG4vLyAgICAgICAgIGRlZmF1bHQ6XHJcbi8vICAgICAgICAgICAgIGJyZWFrO1xyXG4vLyAgICAgfVxyXG4vLyB9XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIENoYW5nZUxheWVyT3JkZXJFdmVudCB7XHJcbiAgICBsYXllcjphbnk7XHJcbiAgICB1cDpib29sZWFuO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIE5vZGVSZW5kZXJlciB7XHJcbiAgICByZW5kZXIob2JqZWN0OiBhbnkpOiBIVE1MRWxlbWVudDtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBUcmVlTm9kZVBhcmFtIHtcclxuICAgIG5vZGVSZW5kZXJlcj86IE5vZGVSZW5kZXJlcixcclxuICAgIGFjdGlvbnM/OiBBcnJheTxBY3Rpb24+LFxyXG4gICAgLy8gbXVsdGlzZWxlY3Rpb24/OmJvb2xlYW5cclxuICAgIGhpZGVFbXB0eU5vZGU/OiBib29sZWFuLFxyXG4gICAgc2VsZWN0TW9kZT86IFNlbGVjdGlvbk1vZGUsXHJcbiAgICBzZWxlY3RlZD86IGJvb2xlYW4sXHJcbiAgICBhdHROYW1lMlJlbmRlcj86c3RyaW5nLFxyXG4gICAgZXhwYW5kT25seU9uZU5vZGU/IDogYm9vbGVhbixcclxuICAgIHNob3dPbmx5Q2hpbGRzPzogYm9vbGVhbixcclxuICAgIGZDaGFuZ2VOb2RlT3JkZXI/OihldjpDaGFuZ2VOb2RlT3JkZXJFdmVudCk9PnZvaWRcclxufVxyXG5cclxuXHJcbi8vIGxldCBub2RlQ291bnRlciA9IDE7XHJcblxyXG5cclxuY29uc3Qgc3RhbmRhcmRSZW5kZXI6IE5vZGVSZW5kZXJlciA9IHsgICAgXHJcbiAgICByZW5kZXI6IChub2RlOiBUcmVlTm9kZSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBub2RlLmRhdGEgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIGRpdi5pbm5lckhUTUwgPSBub2RlLmRhdGE7XHJcbiAgICAgICAgICAgIGRpdi5kYXRhc2V0LnRvb2x0aXAgPSBub2RlLmRhdGE7XHJcbiAgICAgICAgICAgIGRpdi5zZXRBdHRyaWJ1dGUoXCJkYXRhLXRvb2x0aXBcIiwgbm9kZS5kYXRhKTtcclxuICAgICAgICAgICAgZGl2LnRpdGxlID0gbm9kZS5kYXRhO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgdHh0ID0gKG5vZGUuYXR0TmFtZTJSZW5kZXIpPyBub2RlLmRhdGFbbm9kZS5hdHROYW1lMlJlbmRlcl0gOiBub2RlLmRhdGEubmFtZTtcclxuICAgICAgICAgICAgaWYgKCF0eHQpIHtcclxuICAgICAgICAgICAgICAgIGRlYnVnZ2VyXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZGl2LmlubmVySFRNTCA9IHR4dDtcclxuICAgICAgICAgICAgZGl2LmRhdGFzZXQudG9vbHRpcCA9IHR4dDtcclxuICAgICAgICAgICAgZGl2LnNldEF0dHJpYnV0ZShcImRhdGEtdG9vbHRpcFwiLCB0eHQpO1xyXG4gICAgICAgICAgICBkaXYudGl0bGUgPSB0eHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRpdi5jbGFzc05hbWUgPSAndG9vbHRpcCc7XHJcbiAgICAgICAgcmV0dXJuIGRpdlxyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZW51bSBTZWxlY3Rpb25TdGF0dXMge1xyXG4gICAgU0VMRUNURUQsXHJcbiAgICBVTlNFTEVDVEVELFxyXG4gICAgSU5ERVRFUk1JTkFURVxyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgVHJlZU5vZGUgaW1wbGVtZW50cyBUcmVlTm9kZVBhcmFtIHtcclxuXHJcbiAgICBzdGF0aWMgbm9kZUNvdW50ZXIgPSAwO1xyXG5cclxuICAgIG5vZGVTZWxlY3Rpb25DaGFuZ2VIYW5kbGVyOiAobm9kZTogVHJlZU5vZGUsIFNlbGVjdGlvblN0YXR1czogU2VsZWN0aW9uU3RhdHVzKSA9PiB2b2lkO1xyXG4gICAgY2hpbGRFeHBhbmRDaGFuZ2VIYW5kbGVyOiAobm9kZTogVHJlZU5vZGUsIGV4cGFuZDogYm9vbGVhbikgPT4gdm9pZDtcclxuXHJcbiAgICBvblNlbGVjdGlvbkNoYW5nZSA9IG5ldyBFdmVudERpc3BhdGNoZXI8VHJlZU5vZGUsIFNlbGVjdGlvblN0YXR1cz4oKTtcclxuICAgIG9uRXhwYW5kQ2hhbmdlID0gbmV3IEV2ZW50RGlzcGF0Y2hlcjxUcmVlTm9kZSwgYm9vbGVhbj4oKTtcclxuXHJcbiAgICBkYXRhOiBhbnk7XHJcblxyXG4gICAgcGFyZW50OiBUcmVlTm9kZTtcclxuXHJcbiAgICBjaGlsZHM6IEFycmF5PFRyZWVOb2RlPjtcclxuXHJcbiAgICBub2RlUmVuZGVyZXI6IE5vZGVSZW5kZXJlciA9IHN0YW5kYXJkUmVuZGVyO1xyXG5cclxuICAgIGNoaWxkRG9tOiBIVE1MRGl2RWxlbWVudDtcclxuICAgIGRvbTogSFRNTEVsZW1lbnQ7XHJcblxyXG4gICAgLy8gc2VsZWN0ZWQ6IGJvb2xlYW4gPSBmYWxzZTtcclxuICAgIHNlbGVjdGlvblN0YXR1czogU2VsZWN0aW9uU3RhdHVzID0gU2VsZWN0aW9uU3RhdHVzLlVOU0VMRUNURUQ7XHJcblxyXG4gICAgZXhwYW5kT25seU9uZU5vZGUgOiBib29sZWFuO1xyXG5cclxuICAgIHNob3dPbmx5Q2hpbGRzID0gZmFsc2U7XHJcblxyXG4gICAgdGV4dE5vZGU6IEhUTUxTcGFuRWxlbWVudDtcclxuXHJcbiAgICB0cmVlcm93OiBIVE1MRGl2RWxlbWVudDtcclxuXHJcbiAgICBhY3Rpb25zOiBBcnJheTxBY3Rpb24+XHJcblxyXG4gICAgaGlkZUVtcHR5Tm9kZSA9IGZhbHNlXHJcblxyXG4gICAgdHJlZTogVHJlZVxyXG5cclxuICAgIHNlbGVjdE1vZGU6IFNlbGVjdGlvbk1vZGVcclxuXHJcbiAgICBjaEJveDogSFRNTElucHV0RWxlbWVudFxyXG4gICAgc3Bhbk9wZW5DbG9zZTogSFRNTFNwYW5FbGVtZW50O1xyXG5cclxuICAgIGF0dE5hbWUyUmVuZGVyOiBzdHJpbmc7XHJcblxyXG5cclxuICAgIHN0YXRpYyBfY3NzX3Byb3AgPSB7XHJcbiAgICAgICAgaWNvbldpZHRoIDogJzAuOTUwcmVtJyxcclxuICAgICAgICBpY29uRGlzdGFuY2U6ICcwLjE4cmVtJyxcclxuICAgICAgICB0cmVlUGFkZGluZzogJzAuM3JlbSdcclxuICAgIH1cclxuXHJcbiAgICBjc3NfcHJvcCA9IFRyZWVOb2RlLl9jc3NfcHJvcDtcclxuICAgIGluc2V0Q2hpbGRzOiBudW1iZXI7XHJcbiAgICBjb2xsYXBzZWQ6IGJvb2xlYW4gPSB0cnVlO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGRhdGE6IGFueSwgY2hpbGRzPzogQXJyYXk8VHJlZU5vZGU+LCBwYXJhbXM/OiBUcmVlTm9kZVBhcmFtKSB7ICAgICAgICBcclxuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xyXG4gICAgICAgIHRoaXMuY2hpbGRzID0gY2hpbGRzO1xyXG4gICAgICAgIHRoaXMubm9kZVNlbGVjdGlvbkNoYW5nZUhhbmRsZXIgPSAobm9kZTogVHJlZU5vZGUsIHNlbGVjdGlvblN0YXR1czogU2VsZWN0aW9uU3RhdHVzKSA9PiB0aGlzLmNoaWxkU2VsZWN0ZWQobm9kZSwgc2VsZWN0aW9uU3RhdHVzKTtcclxuICAgICAgICBpZiAocGFyYW1zKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGsgaW4gcGFyYW1zKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzW2tdID0gcGFyYW1zW2tdXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHBhcmFtcy5leHBhbmRPbmx5T25lTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jaGlsZEV4cGFuZENoYW5nZUhhbmRsZXIgPSAobm9kZSwgZXhwYW5kZWQpID0+IHRoaXMuY2hpbGRFeHBhbmRDaGFuZ2VkKG5vZGUsIGV4cGFuZGVkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBpZiAoY2hpbGRzICYmIGNoaWxkcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBjb3VudCA9IGNoaWxkcy5sZW5ndGg7IGkgPCBjb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjaGlsZHNbaV0ub25TZWxlY3Rpb25DaGFuZ2Uuc3Vic2NyaWJlKHRoaXMubm9kZVNlbGVjdGlvbkNoYW5nZUhhbmRsZXIpO1xyXG4gICAgICAgICAgICAgICAgY2hpbGRzW2ldLnBhcmVudCA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICBpZiAocGFyYW1zPy5leHBhbmRPbmx5T25lTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkc1tpXS5vbkV4cGFuZENoYW5nZS5zdWJzY3JpYmUodGhpcy5jaGlsZEV4cGFuZENoYW5nZUhhbmRsZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5hY3Rpb25zKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGFjdGlvbnMgPSB0aGlzLmFjdGlvbnNcclxuICAgICAgICAgICAgbGV0IGYgPSAoZXZ0KSA9PiB0aGlzLmFjdGlvbkNoYW5nZWQoZXZ0KVxyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFjdGlvbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGFjdGlvbnNbaV0uYWRkTGlzdGVuZXIoZilcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcblxyXG4gICAgYWN0aW9uQ2hhbmdlZChldnQpIHtcclxuICAgICAgICB0aGlzLnJlbmRlcigpO1xyXG4gICAgfVxyXG5cclxuICAgIGdldFdpZGgoKTogbnVtYmVyIHtcclxuICAgICAgICBpZiAodGhpcy50cmVlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRyZWUuZ2V0V2lkaCgpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAtMVxyXG4gICAgfVxyXG5cclxuICAgIHNldFRyZWUodHJlZTogVHJlZSkge1xyXG4gICAgICAgIHRoaXMudHJlZSA9IHRyZWVcclxuICAgICAgICBjb25zdCBjaGlsZHMgPSB0aGlzLmNoaWxkc1xyXG4gICAgICAgIGlmIChjaGlsZHMgJiYgY2hpbGRzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGNvdW50ID0gY2hpbGRzLmxlbmd0aDsgaSA8IGNvdW50OyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGNoaWxkc1tpXS5zZXRUcmVlKHRyZWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHNldENoaWxkcyhjaGlsZHM6IEFycmF5PFRyZWVOb2RlPikge1xyXG4gICAgICAgIHRoaXMuX3JlbW92ZUNoaWxkcygpO1xyXG4gICAgICAgIGlmIChjaGlsZHMgJiYgY2hpbGRzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGNvdW50ID0gY2hpbGRzLmxlbmd0aDsgaSA8IGNvdW50OyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGNoaWxkc1tpXS5vblNlbGVjdGlvbkNoYW5nZS5zdWJzY3JpYmUodGhpcy5ub2RlU2VsZWN0aW9uQ2hhbmdlSGFuZGxlcik7XHJcbiAgICAgICAgICAgICAgICAvLyBjaGlsZHNbaV0ub24oXCJjaGFuZ2VcIiwgdGhpcy5jaGlsZENoYW5nZWQsIHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgLy8gY2hpbGRzW2ldLm9uKFwic2VsZWN0ZWRcIiwgdGhpcy5jaGlsZFNlbGVjdGVkLCB0aGlzKTtcclxuICAgICAgICAgICAgICAgIGNoaWxkc1tpXS5wYXJlbnQgPSB0aGlzXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50cmVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRzW2ldLnNldFRyZWUodGhpcy50cmVlKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY2hpbGRzID0gY2hpbGRzO1xyXG4gICAgICAgIHRoaXMucmVuZGVyKClcclxuICAgIH1cclxuXHJcblxyXG4gICAgZmluZE5vZGUoZGF0YTogYW55LCBwcm9wPzogc3RyaW5nKTogQXJyYXk8VHJlZU5vZGU+IHtcclxuICAgICAgICAvLyBjb25zb2xlLmluZm8oZGF0YStcIiBcIitwcm9wLCB0aGlzLmRhdGEsIHRoaXMuZGF0YVtwcm9wXSlcclxuICAgICAgICBpZiAoKHByb3AgJiYgdGhpcy5kYXRhW3Byb3BdID09PSBkYXRhKSB8fCB0aGlzLmRhdGEgPT09IGRhdGEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFt0aGlzXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5jaGlsZHMpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGNvdW50ID0gdGhpcy5jaGlsZHMubGVuZ3RoOyBpIDwgY291bnQ7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2VsTm9kZXMgPSB0aGlzLmNoaWxkc1tpXS5maW5kTm9kZShkYXRhLCBwcm9wKVxyXG4gICAgICAgICAgICAgICAgaWYgKHNlbE5vZGVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsTm9kZXMucHVzaCh0aGlzKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsTm9kZXM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9ICAgIFxyXG5cclxuICAgIHNlbGVjdE5vZGUoZGF0YTogYW55LCBwcm9wPzogc3RyaW5nKTogQXJyYXk8VHJlZU5vZGU+IHtcclxuICAgICAgICAvLyBjb25zb2xlLmluZm8oZGF0YStcIiBcIitwcm9wLCB0aGlzLmRhdGEsIHRoaXMuZGF0YVtwcm9wXSlcclxuICAgICAgICBpZiAoKHByb3AgJiYgdGhpcy5kYXRhW3Byb3BdID09PSBkYXRhKSB8fCB0aGlzLmRhdGEgPT09IGRhdGEpIHtcclxuICAgICAgICAgICAgLy8gY29uc29sZS5lcnJvcihcIlRyZWVOb2RlLnNlbGVjdE5vZGVcIik7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0U2VsZWN0ZWQodHJ1ZSk7ICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHJldHVybiBbdGhpc107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuY2hpbGRzKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBjb3VudCA9IHRoaXMuY2hpbGRzLmxlbmd0aDsgaSA8IGNvdW50OyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNlbE5vZGVzID0gdGhpcy5jaGlsZHNbaV0uc2VsZWN0Tm9kZShkYXRhLCBwcm9wKVxyXG4gICAgICAgICAgICAgICAgaWYgKHNlbE5vZGVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsTm9kZXMucHVzaCh0aGlzKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsTm9kZXM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG5cclxuICAgIHVuc2VsZWN0Tm9kZShkYXRhOiBhbnksIHByb3A6IHN0cmluZykge1xyXG4gICAgICAgIGlmICgocHJvcCAmJiB0aGlzLmRhdGFbcHJvcF0gPT09IGRhdGEpIHx8IHRoaXMuZGF0YSA9PT0gZGF0YSkge1xyXG4gICAgICAgICAgICB0aGlzLnNldFNlbGVjdGVkKGZhbHNlKVxyXG4gICAgICAgICAgICByZXR1cm4gW3RoaXNdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLmNoaWxkcykge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgY291bnQgPSB0aGlzLmNoaWxkcy5sZW5ndGg7IGkgPCBjb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzZWxOb2RlcyA9IHRoaXMuY2hpbGRzW2ldLnVuc2VsZWN0Tm9kZShkYXRhLCBwcm9wKVxyXG4gICAgICAgICAgICAgICAgaWYgKHNlbE5vZGVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsTm9kZXMucHVzaCh0aGlzKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsTm9kZXM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgYWRkTm9kZShjaGlsZDogVHJlZU5vZGUpIHtcclxuICAgICAgICAvLyBjaGlsZC5vbihcInNlbGVjdGVkXCIsIHRoaXMuY2hpbGRTZWxlY3RlZCwgdGhpcyk7XHJcbiAgICAgICAgLy8gY29uc29sZS5pbmZvKGBhZGROb2RlIGNoaWxkSW5zZXQ9JHt0aGlzLmluc2V0Q2hpbGRzfWAsIHRoaXMuZGF0YSwgY2hpbGQuZGF0YSk7XHJcbiAgICAgICAgY2hpbGQub25TZWxlY3Rpb25DaGFuZ2Uuc3Vic2NyaWJlKHRoaXMubm9kZVNlbGVjdGlvbkNoYW5nZUhhbmRsZXIpO1xyXG4gICAgICAgIGlmICh0aGlzLm9uRXhwYW5kQ2hhbmdlKSB7XHJcbiAgICAgICAgICAgIGNoaWxkLm9uRXhwYW5kQ2hhbmdlLnN1YnNjcmliZSh0aGlzLmNoaWxkRXhwYW5kQ2hhbmdlSGFuZGxlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGhpcy5jaGlsZHMpIHtcclxuICAgICAgICAgICAgdGhpcy5jaGlsZHMgPSBbXVxyXG4gICAgICAgIH1cclxuICAgICAgICBjaGlsZC5wYXJlbnQgPSB0aGlzO1xyXG4gICAgICAgIGNoaWxkLnNldFRyZWUodGhpcy50cmVlKTtcclxuICAgICAgICB0aGlzLmNoaWxkcy5wdXNoKGNoaWxkKTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuZG9tKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5jaGlsZERvbSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgbm9kZWNvbnRhaW5lciA9IHRoaXMuY2hpbGREb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICAgICAgICAgIG5vZGVjb250YWluZXIuY2xhc3NOYW1lID0gXCJub2RlY29udGFpbmVyXCJcclxuICAgICAgICAgICAgICAgIHRoaXMuZG9tLmFwcGVuZENoaWxkKG5vZGVjb250YWluZXIpO1xyXG4gICAgICAgICAgICAgICAgLy8gcnRyIG5vZGVjb250YWluZXIuc3R5bGUuZGlzcGxheSA9ICdub25lJ1xyXG4gICAgICAgICAgICB9ICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHRoaXMuY2hpbGREb20uYXBwZW5kQ2hpbGQoY2hpbGQucmVuZGVyKHRoaXMuaW5zZXRDaGlsZHMpKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkQ291bnQgPSB0aGlzLmNoaWxkcyA/IHRoaXMuY2hpbGRzLmxlbmd0aCA6IDBcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIGNvbnN0IGNvbCA9IFRyZWVOb2RlLmdldFRyZWVQYXRoKHRoaXMpLmxlbmd0aDtcclxuICAgICAgICAgICAgLy8gdGhpcy50cmVlcm93LnN0eWxlLnBhZGRpbmdMZWZ0ID0gKChjb2wgLSAxKSAqIDEuOSArIDAuMykgKyBcInJlbVwiXHJcblxyXG4gICAgICAgICAgICBjb25zdCBjb2wgPSBUcmVlTm9kZS5nZXRUcmVlUGF0aCh0aGlzKS5sZW5ndGg7XHJcbiAgICAgICAgICAgIGxldCBpbnNldCA9IGNvbDtcclxuICAgICAgICAgICAgaWYgKGNoaWxkQ291bnQgPiAwKSB7ICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAvLyB0aGlzLnRyZWVyb3cuc3R5bGUucGFkZGluZ0xlZnQgPSAoKGNvbCAtIDEpICogMS4xOCArIDAuMykgKyBcInJlbVwiO1xyXG4gICAgICAgICAgICAgICAgLy8gbGV0IHMgPSBgY2FsYygke2NvbCAtIDF9ICogKCR7dGhpcy5jc3NfcHJvcC5pY29uV2lkdGh9ICsgJHt0aGlzLmNzc19wcm9wLmljb25EaXN0YW5jZX0pICsgJHt0aGlzLmNzc19wcm9wLnRyZWVQYWRkaW5nfSlgO1xyXG4gICAgICAgICAgICAgICAgLy8gdGhpcy50cmVlcm93LnN0eWxlLnBhZGRpbmdMZWZ0ID0gYGNhbGMoJHtjb2wgLSAxfSAqICgke3RoaXMuY3NzX3Byb3AuaWNvbldpZHRofSArICR7dGhpcy5jc3NfcHJvcC5pY29uRGlzdGFuY2V9KSArICR7dGhpcy5jc3NfcHJvcC50cmVlUGFkZGluZ30pYDtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzQ29sbGFwc2VkKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzLnNwYW5PcGVuQ2xvc2UuaW5uZXJUZXh0ID0gU3RyaW5nLmZyb21DaGFyQ29kZSg5NjYwKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoaWxkRG9tLmNsYXNzTGlzdC5yZXBsYWNlKCdvcGVuZWQnLCAnY2xvc2VkJyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3Bhbk9wZW5DbG9zZS5jbGFzc0xpc3QuYWRkKCdjbG9zZWQnKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNwYW5PcGVuQ2xvc2UuY2xhc3NMaXN0LnJlbW92ZSgnb3BlbmVkJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzLnNwYW5PcGVuQ2xvc2UuaW5uZXJUZXh0ID0gU3RyaW5nLmZyb21DaGFyQ29kZSg5NjU0KTsgICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hpbGREb20uY2xhc3NMaXN0LnJlcGxhY2UoJ2Nsb3NlZCcsICdvcGVuZWQnKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zcGFuT3BlbkNsb3NlLmNsYXNzTGlzdC5hZGQoJ29wZW5lZCcpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3Bhbk9wZW5DbG9zZS5jbGFzc0xpc3QucmVtb3ZlKCdjbG9zZWQnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMudHJlZXJvdy5jbGFzc0xpc3QucmVtb3ZlKCdsZWFmJyk7XHJcbiAgICAgICAgICAgIH0gXHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gdGhpcy50cmVlcm93LnN0eWxlLnBhZGRpbmdMZWZ0ID0gKChjb2wgLSAyKSAqIDEuMTggKyAwLjMpICsgXCJyZW1cIjtcclxuICAgICAgICAgICAgICAgIC8vIHRoaXMudHJlZXJvdy5zdHlsZS5wYWRkaW5nTGVmdCA9IGBjYWxjKCR7Y29sIC0gMX0gKiAoJHt0aGlzLmNzc19wcm9wLmljb25XaWR0aH0gKyAke3RoaXMuY3NzX3Byb3AuaWNvbkRpc3RhbmNlfSkgKyAke3RoaXMuY3NzX3Byb3AudHJlZVBhZGRpbmd9KWA7XHJcbiAgICAgICAgICAgIH0gICAgICAgICAgIFxyXG4gICAgICAgIH1cclxuICAgIH0gICAgXHJcblxyXG5cclxuXHJcbiAgICByZW1vdmUoKSB7XHJcbiAgICAgICAgdGhpcy5kb20ucmVtb3ZlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgX3JlbW92ZUNoaWxkcygpIHtcclxuICAgICAgICBjb25zdCBjaGlsZHMgPSB0aGlzLmNoaWxkcztcclxuICAgICAgICBpZiAoY2hpbGRzICYmIGNoaWxkcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBjb3VudCA9IGNoaWxkcy5sZW5ndGg7IGkgPCBjb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjaGlsZHNbaV0ub25TZWxlY3Rpb25DaGFuZ2UudW5zdWJzY3JpYmUodGhpcy5ub2RlU2VsZWN0aW9uQ2hhbmdlSGFuZGxlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jaGlsZHMgPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIF9yZW1vdmVDaGlsZChub2RlOiBUcmVlTm9kZSkge1xyXG4gICAgICAgIGxldCBub2RlczogQXJyYXk8VHJlZU5vZGU+ID0gW11cclxuICAgICAgICBmb3IgKGxldCBpID0gMCwgY291bnQgPSB0aGlzLmNoaWxkcy5sZW5ndGg7IGkgPCBjb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNoaWxkc1tpXSAhPT0gbm9kZSkge1xyXG4gICAgICAgICAgICAgICAgbm9kZXMucHVzaCh0aGlzLmNoaWxkc1tpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmluZm8oXCJyZW1vdmVOb2RlIFwiICsgaSwgdGhpcy5jaGlsZHNbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG5vZGUub25TZWxlY3Rpb25DaGFuZ2UudW5zdWJzY3JpYmUodGhpcy5ub2RlU2VsZWN0aW9uQ2hhbmdlSGFuZGxlcik7XHJcbiAgICAgICAgbm9kZS5yZW1vdmUoKTtcclxuICAgICAgICB0aGlzLmNoaWxkcyA9IG5vZGVzXHJcbiAgICAgICAgdGhpcy5yZW5kZXIoKTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgaXNDb2xsYXBzZWQoKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sbGFwc2VkO1xyXG4gICAgICAgIC8vIHJldHVybiB0aGlzLmNoaWxkRG9tICYmIHRoaXMuY2hpbGREb20uc3R5bGUuZGlzcGxheSA9PSAnZmxleCdcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIGV4cGFuZHMgdGhpcyBub2RlIGFuZCBjaGlsZHMgaWYgb25seUN1cnJlbnROb2RlIGlzIG5vdCB0cnVlXHJcbiAgICAgKi9cclxuICAgIGV4cGFuZChvbmx5Q3VycmVudE5vZGU/OmJvb2xlYW4pIHtcclxuICAgICAgICBpZiAodGhpcy5jb2xsYXBzZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5jb2xsYXBzZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZG9tKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRvbS5jbGFzc0xpc3QucmVwbGFjZSgnY2xvc2VkJywgJ29wZW5lZCcpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zcGFuT3BlbkNsb3NlLmNsYXNzTGlzdC5yZXBsYWNlKCdjbG9zZWQnLCAnb3BlbmVkJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9ICAgICAgICBcclxuICAgICAgICBpZiAoIW9ubHlDdXJyZW50Tm9kZSAmJiB0aGlzLmNoaWxkcykge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpPTAsIGNvdW50PXRoaXMuY2hpbGRzLmxlbmd0aDsgaTxjb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNoaWxkc1tpXS5leHBhbmQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gXHJcbiAgICB9XHJcblxyXG4gICAgY29sbGFwc2UoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmNvbGxhcHNlZCkge1xyXG4gICAgICAgICAgICB0aGlzLmNvbGxhcHNlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmRvbSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kb20uY2xhc3NMaXN0LnJlcGxhY2UoJ29wZW5lZCcsICdjbG9zZWQnKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3Bhbk9wZW5DbG9zZS5jbGFzc0xpc3QucmVwbGFjZSgnb3BlbmVkJywgJ2Nsb3NlZCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0U2VsZWN0TW9kZSgpOiBTZWxlY3Rpb25Nb2RlIHtcclxuICAgICAgICBpZiAodGhpcy5zZWxlY3RNb2RlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0TW9kZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmdldFNlbGVjdE1vZGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnRyZWUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50cmVlLnNlbGVjdE1vZGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFNlbGVjdGlvbk1vZGUuU0lOR0xFXHJcbiAgICB9XHJcbi8qXHJcbiAgICByZW5kZXIyMDIxMDUyMShpbnNldD86bnVtYmVyKTogSFRNTEVsZW1lbnQge1xyXG4gICAgICAgIC8vIGNvbnNvbGUuaW5mbyhgcmVuZGVyIGluc2V0PSR7aW5zZXR9YCwgdGhpcy5kYXRhLCB0aGlzLmNvbGxhcHNlZCk7XHJcbiAgICAgICAgY29uc3QgY29sID0gVHJlZU5vZGUuZ2V0VHJlZVBhdGgodGhpcykubGVuZ3RoO1xyXG4gICAgICAgIGlmICghaW5zZXQpIHtcclxuICAgICAgICAgICAgaW5zZXQgPSAwO1xyXG4gICAgICAgIH0gICAgICAgIFxyXG4gICAgICAgIGxldCBpbnNldFNlbGYgPSAwO1xyXG4gICAgICAgIC8vIGxldCBpbnNldCA9IGNvbC0xO1xyXG5cclxuICAgICAgICBsZXQgZG9tID0gdGhpcy5kb207XHJcbiAgICAgICAgbGV0IHRyZWVyb3cgPSB0aGlzLnRyZWVyb3dcclxuICAgICAgICBpZiAoIWRvbSkge1xyXG4gICAgICAgICAgICBkb20gPSB0aGlzLmRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XHJcbiAgICAgICAgICAgIGRvbS5jbGFzc05hbWUgPSAncm93LXdyYXBwZXInLFxyXG4gICAgICAgICAgICB0cmVlcm93ID0gdGhpcy50cmVlcm93ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgICAgIHRyZWVyb3cuaWQgPSBcInRyZWVyb3dcIiArIG5vZGVDb3VudGVyICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHRyZWVyb3cuY2xhc3NOYW1lID0gXCJ0cmVlcm93XCI7XHJcbiAgICAgICAgICAgIC8vIGlmICghdGhpcy5zaG93T25seUNoaWxkcykge1xyXG4gICAgICAgICAgICAvLyAgICAgZG9tLmFwcGVuZENoaWxkKHRyZWVyb3cpO1xyXG4gICAgICAgICAgICAvLyB9XHJcblxyXG4gICAgICAgICAgICBjb25zdCBjaGlsZENvdW50ID0gdGhpcy5jaGlsZHMgPyB0aGlzLmNoaWxkcy5sZW5ndGggOiAwXHJcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdE1vZGUgPSB0aGlzLmdldFNlbGVjdE1vZGUoKTtcclxuICAgICAgICAgICAgY29uc3Qgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgICAgICBzcGFuLmNsYXNzTmFtZSA9IFwidHJlZWljb25cIjtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHNwYW5PcGVuQ2xvc2UgPSB0aGlzLnNwYW5PcGVuQ2xvc2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XHJcbiAgICAgICAgICAgIHNwYW5PcGVuQ2xvc2UuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZXYpID0+IHRoaXMub25UcmVlSWNvbkNsaWNrKGV2KSk7XHJcbiAgICAgICAgICAgIGluc2V0U2VsZisrO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMuY29sbGFwc2VkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRvbS5jbGFzc0xpc3QuYWRkKCdjbG9zZWQnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHsgICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgdGhpcy5kb20uY2xhc3NMaXN0LmFkZCgnb3BlbmVkJyk7XHJcbiAgICAgICAgICAgIH0gICAgXHJcblxyXG4gICAgICAgICAgICBpZiAoY2hpbGRDb3VudCA+IDApIHtcclxuICAgICAgICAgICAgICAgIC8vIHRyZWVyb3cuc3R5bGUucGFkZGluZ0xlZnQgPSBgY2FsYygke2NvbCAtIDF9ICogKCR7dGhpcy5jc3NfcHJvcC5pY29uV2lkdGh9ICsgJHt0aGlzLmNzc19wcm9wLmljb25EaXN0YW5jZX0pICsgJHt0aGlzLmNzc19wcm9wLnRyZWVQYWRkaW5nfSlgO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY29sbGFwc2VkKSB7ICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNwYW5PcGVuQ2xvc2UuY2xhc3NMaXN0LmFkZCgnY2xvc2VkJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHsgICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3Bhbk9wZW5DbG9zZS5jbGFzc0xpc3QuYWRkKCdvcGVuZWQnKTtcclxuICAgICAgICAgICAgICAgIH0gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0TW9kZSA9PT0gU2VsZWN0aW9uTW9kZS5TSU5HTEUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0cmVlcm93LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGV2KSA9PiB0aGlzLml0ZW1DbGlja2VkKGV2KSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyB0cmVlcm93LnN0eWxlLnBhZGRpbmdMZWZ0ID0gKGNvbCAtIDIpICogMi44ICsgMC4zKSArIFwicmVtXCJcclxuICAgICAgICAgICAgICAgIGlmIChzZWxlY3RNb2RlID09PSBTZWxlY3Rpb25Nb2RlLlJBRElPKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcy50cmVlcm93LnN0eWxlLnBhZGRpbmdMZWZ0ID0gYGNhbGMoJHtjb2wgLSAxfSAqICgke3RoaXMuY3NzX3Byb3AuaWNvbldpZHRofSArICR7dGhpcy5jc3NfcHJvcC5pY29uRGlzdGFuY2V9KSArICR7dGhpcy5jc3NfcHJvcC50cmVlUGFkZGluZ30pYDtcclxuICAgICAgICAgICAgICAgICAgICAvL3RyZWVyb3cuc3R5bGUucGFkZGluZ0xlZnQgPSAoKGNvbC0xKSoxLjE4ICsgMC4zKSArIFwicmVtXCJcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdHJlZXJvdy5zdHlsZS5wYWRkaW5nTGVmdCA9ICgoY29sKSoxLjE4ICsgMC4zKSArIFwicmVtXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcy50cmVlcm93LnN0eWxlLnBhZGRpbmdMZWZ0ID0gYGNhbGMoJHtjb2x9ICogKCR7dGhpcy5jc3NfcHJvcC5pY29uV2lkdGh9ICsgJHt0aGlzLmNzc19wcm9wLmljb25EaXN0YW5jZX0pICsgJHt0aGlzLmNzc19wcm9wLnRyZWVQYWRkaW5nfSlgO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGNvbCA+IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICB0cmVlcm93LmNsYXNzTmFtZSA9ICd0cmVlcm93IGxlYWYnXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBzcGFuT3BlbkNsb3NlLmlubmVySFRNTCA9IFwiJm5ic3A7XCJcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnRleHROb2RlID0gc3Bhbk9wZW5DbG9zZVxyXG4gICAgICAgICAgICBzcGFuLmFwcGVuZENoaWxkKHNwYW5PcGVuQ2xvc2UpO1xyXG4gICAgICAgICAgICBpZiAoc2VsZWN0TW9kZSA9PT0gU2VsZWN0aW9uTW9kZS5NVUxUSSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2I6IEhUTUxJbnB1dEVsZW1lbnQgPSB0aGlzLl9jcmVhdGVDZWNrQm94KClcclxuICAgICAgICAgICAgICAgIHNwYW4uYXBwZW5kQ2hpbGQoY2IpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGFiZWxcIik7XHJcbiAgICAgICAgICAgICAgICBzcGFuLmFwcGVuZENoaWxkKGxhYmVsKTtcclxuICAgICAgICAgICAgICAgIGxhYmVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKCkgeyBjYi5jbGljaygpIH0pOyAgIFxyXG4gICAgICAgICAgICAgICAgaW5zZXRTZWxmKys7ICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNlbGVjdE1vZGUgPT09IFNlbGVjdGlvbk1vZGUuUkFESU8pIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNiOiBIVE1MSW5wdXRFbGVtZW50ID0gdGhpcy5fY3JlYXRlUmFkaW9CdHRuKClcclxuICAgICAgICAgICAgICAgIHNwYW4uYXBwZW5kQ2hpbGQoY2IpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGFiZWxcIik7XHJcbiAgICAgICAgICAgICAgICBzcGFuLmFwcGVuZENoaWxkKGxhYmVsKVxyXG4gICAgICAgICAgICAgICAgbGFiZWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoKSB7IFxyXG4gICAgICAgICAgICAgICAgICAgIGNiLmNsaWNrKCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGluc2V0U2VsZisrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGxldCBpbnNlZyA9IDA7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGk9MDsgaTxpbnNldCA7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaW5zZXRCbG9jayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xyXG4gICAgICAgICAgICAgICAgaW5zZXRCbG9jay5jbGFzc05hbWUgPSBcImluc2V0LWJsb2NrXCI7XHJcbiAgICAgICAgICAgICAgICB0cmVlcm93LmFwcGVuZENoaWxkKGluc2V0QmxvY2spO1xyXG4gICAgICAgICAgICAgICAgLy8gaW5zZWcrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBjb25zb2xlLmluZm8oYGluc2VnPSR7aW5zZWd9YClcclxuICAgICAgICAgICAgdHJlZXJvdy5hcHBlbmRDaGlsZChzcGFuKTtcclxuICAgICAgICAgICAgY29uc3QgbGFiZWxEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpXHJcbiAgICAgICAgICAgIGxhYmVsRGl2LmNsYXNzTmFtZSA9ICd0cmVlbGFiZWwnXHJcbiAgICAgICAgICAgIGNvbnN0IGxhYmVsID0gdGhpcy5ub2RlUmVuZGVyZXIucmVuZGVyKHRoaXMpXHJcbiAgICAgICAgICAgIGlmIChsYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgbGFiZWxEaXYuYXBwZW5kQ2hpbGQobGFiZWwpXHJcbiAgICAgICAgICAgICAgICB0cmVlcm93LmFwcGVuZENoaWxkKGxhYmVsRGl2KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMuYWN0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgdHJlZXJvdy5hcHBlbmRDaGlsZCh0aGlzLnJlbmRlckFjdGlvbnMoKSlcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgbGV0IG5vZGVjb250YWluZXIgPSB0aGlzLmNoaWxkRG9tO1xyXG4gICAgICAgICAgICBpZiAobm9kZWNvbnRhaW5lcikge1xyXG4gICAgICAgICAgICAgICAgbm9kZWNvbnRhaW5lci5pbm5lckhUTUwgPSBudWxsXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChjaGlsZENvdW50ID4gMCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFub2RlY29udGFpbmVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZWNvbnRhaW5lciA9IHRoaXMuY2hpbGREb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICAgICAgICAgICAgICBub2RlY29udGFpbmVyLmNsYXNzTmFtZSA9IFwibm9kZWNvbnRhaW5lclwiXHJcbiAgICAgICAgICAgICAgICAgICAgZG9tLmFwcGVuZENoaWxkKG5vZGVjb250YWluZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIG5vZGVjb250YWluZXIuc3R5bGUuZGlzcGxheSA9ICdub25lJ1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGVjb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5jaGlsZHNbaV0ucmVuZGVyKGluc2V0K2luc2V0U2VsZikpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfSAgICAgIFxyXG4gICAgICAgICAgICB0aGlzLmRvbS5zdHlsZS5kaXNwbGF5ID0gKHRoaXMuaGlkZUVtcHR5Tm9kZSAmJiBjaGlsZENvdW50ID09PSAwKSA/ICdub25lJyA6ICdmbGV4JztcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5pbnNldENoaWxkcyA9IGluc2V0K2luc2V0U2VsZjtcclxuICAgICAgICByZXR1cm4gZG9tXHJcbiAgICB9XHJcbiovXHJcbiAgICByZW5kZXIoaW5zZXQ/Om51bWJlcik6IEhUTUxFbGVtZW50IHtcclxuICAgICAgICAvLyBjb25zb2xlLmluZm8oYHJlbmRlciBpbnNldD0ke2luc2V0fWAsIHRoaXMuZGF0YSwgdGhpcy5jb2xsYXBzZWQsIHRoaXMuc2hvd09ubHlDaGlsZHMpO1xyXG4gICAgICAgIGNvbnN0IGNvbCA9IFRyZWVOb2RlLmdldFRyZWVQYXRoKHRoaXMpLmxlbmd0aDtcclxuICAgICAgICBpZiAoIWluc2V0KSB7XHJcbiAgICAgICAgICAgIGluc2V0ID0gMDtcclxuICAgICAgICB9ICAgICAgICBcclxuICAgICAgICBsZXQgaW5zZXRTZWxmID0gMDtcclxuICAgICAgICAvLyBsZXQgaW5zZXQgPSBjb2wtMTtcclxuXHJcbiAgICAgICAgbGV0IGRvbSA9IHRoaXMuZG9tO1xyXG4gICAgICAgIGxldCB0cmVlcm93ID0gdGhpcy50cmVlcm93XHJcbiAgICAgICAgaWYgKCFkb20pIHtcclxuICAgICAgICAgICAgZG9tID0gdGhpcy5kb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG4gICAgICAgICAgICBkb20uY2xhc3NOYW1lID0gJ3Jvdy13cmFwcGVyJyxcclxuICAgICAgICAgICAgdHJlZXJvdyA9IHRoaXMudHJlZXJvdyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgICAgICB0cmVlcm93LmlkID0gXCJ0cmVlcm93XCIgKyBUcmVlTm9kZS5ub2RlQ291bnRlcisrICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHRyZWVyb3cuY2xhc3NOYW1lID0gXCJ0cmVlcm93XCI7XHJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUuaW5mbyhgc2hvd09ubHlDaGlsZHM9JHt0aGlzLnNob3dPbmx5Q2hpbGRzfWApO1xyXG5cclxuICAgICAgICAgICAgaWYgKCF0aGlzLnNob3dPbmx5Q2hpbGRzKSB7XHJcbiAgICAgICAgICAgICAgICBkb20uYXBwZW5kQ2hpbGQodHJlZXJvdyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkQ291bnQgPSB0aGlzLmNoaWxkcyA/IHRoaXMuY2hpbGRzLmxlbmd0aCA6IDBcclxuICAgICAgICAgICAgY29uc3Qgc2VsZWN0TW9kZSA9IHRoaXMuZ2V0U2VsZWN0TW9kZSgpO1xyXG4gICAgICAgICAgICBjb25zdCBzcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgICAgIHNwYW4uY2xhc3NOYW1lID0gXCJ0cmVlaWNvblwiO1xyXG5cclxuICAgICAgICAgICAgY29uc3Qgc3Bhbk9wZW5DbG9zZSA9IHRoaXMuc3Bhbk9wZW5DbG9zZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcclxuICAgICAgICAgICAgc3Bhbk9wZW5DbG9zZS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChldikgPT4gdGhpcy5vblRyZWVJY29uQ2xpY2soZXYpKTtcclxuICAgICAgICAgICAgaW5zZXRTZWxmKys7XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5jb2xsYXBzZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZG9tLmNsYXNzTGlzdC5hZGQoJ2Nsb3NlZCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgeyAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICB0aGlzLmRvbS5jbGFzc0xpc3QuYWRkKCdvcGVuZWQnKTtcclxuICAgICAgICAgICAgfSAgICBcclxuXHJcbiAgICAgICAgICAgIGlmIChjaGlsZENvdW50ID4gMCkge1xyXG4gICAgICAgICAgICAgICAgLy8gdHJlZXJvdy5zdHlsZS5wYWRkaW5nTGVmdCA9IGBjYWxjKCR7Y29sIC0gMX0gKiAoJHt0aGlzLmNzc19wcm9wLmljb25XaWR0aH0gKyAke3RoaXMuY3NzX3Byb3AuaWNvbkRpc3RhbmNlfSkgKyAke3RoaXMuY3NzX3Byb3AudHJlZVBhZGRpbmd9KWA7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb2xsYXBzZWQpIHsgICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3Bhbk9wZW5DbG9zZS5jbGFzc0xpc3QuYWRkKCdjbG9zZWQnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgeyAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zcGFuT3BlbkNsb3NlLmNsYXNzTGlzdC5hZGQoJ29wZW5lZCcpO1xyXG4gICAgICAgICAgICAgICAgfSAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChzZWxlY3RNb2RlID09PSBTZWxlY3Rpb25Nb2RlLlNJTkdMRSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyZWVyb3cuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZXYpID0+IHRoaXMuaXRlbUNsaWNrZWQoZXYpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIHRyZWVyb3cuc3R5bGUucGFkZGluZ0xlZnQgPSAoY29sIC0gMikgKiAyLjggKyAwLjMpICsgXCJyZW1cIlxyXG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdE1vZGUgPT09IFNlbGVjdGlvbk1vZGUuUkFESU8pIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzLnRyZWVyb3cuc3R5bGUucGFkZGluZ0xlZnQgPSBgY2FsYygke2NvbCAtIDF9ICogKCR7dGhpcy5jc3NfcHJvcC5pY29uV2lkdGh9ICsgJHt0aGlzLmNzc19wcm9wLmljb25EaXN0YW5jZX0pICsgJHt0aGlzLmNzc19wcm9wLnRyZWVQYWRkaW5nfSlgO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vdHJlZXJvdy5zdHlsZS5wYWRkaW5nTGVmdCA9ICgoY29sLTEpKjEuMTggKyAwLjMpICsgXCJyZW1cIlxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyB0cmVlcm93LnN0eWxlLnBhZGRpbmdMZWZ0ID0gKChjb2wpKjEuMTggKyAwLjMpICsgXCJyZW1cIjtcclxuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzLnRyZWVyb3cuc3R5bGUucGFkZGluZ0xlZnQgPSBgY2FsYygke2NvbH0gKiAoJHt0aGlzLmNzc19wcm9wLmljb25XaWR0aH0gKyAke3RoaXMuY3NzX3Byb3AuaWNvbkRpc3RhbmNlfSkgKyAke3RoaXMuY3NzX3Byb3AudHJlZVBhZGRpbmd9KWA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoY29sID4gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyZWVyb3cuY2xhc3NOYW1lID0gJ3RyZWVyb3cgbGVhZidcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIHNwYW5PcGVuQ2xvc2UuaW5uZXJIVE1MID0gXCImbmJzcDtcIlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMudGV4dE5vZGUgPSBzcGFuT3BlbkNsb3NlXHJcbiAgICAgICAgICAgIHNwYW4uYXBwZW5kQ2hpbGQoc3Bhbk9wZW5DbG9zZSk7XHJcbiAgICAgICAgICAgIGlmIChzZWxlY3RNb2RlID09PSBTZWxlY3Rpb25Nb2RlLk1VTFRJKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjYjogSFRNTElucHV0RWxlbWVudCA9IHRoaXMuX2NyZWF0ZUNlY2tCb3goKVxyXG4gICAgICAgICAgICAgICAgc3Bhbi5hcHBlbmRDaGlsZChjYik7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBsYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsYWJlbFwiKTtcclxuICAgICAgICAgICAgICAgIHNwYW4uYXBwZW5kQ2hpbGQobGFiZWwpO1xyXG4gICAgICAgICAgICAgICAgbGFiZWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoKSB7IGNiLmNsaWNrKCkgfSk7ICAgXHJcbiAgICAgICAgICAgICAgICBpbnNldFNlbGYrKzsgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2VsZWN0TW9kZSA9PT0gU2VsZWN0aW9uTW9kZS5SQURJTykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2I6IEhUTUxJbnB1dEVsZW1lbnQgPSB0aGlzLl9jcmVhdGVSYWRpb0J0dG4oKVxyXG4gICAgICAgICAgICAgICAgc3Bhbi5hcHBlbmRDaGlsZChjYik7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBsYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsYWJlbFwiKTtcclxuICAgICAgICAgICAgICAgIHNwYW4uYXBwZW5kQ2hpbGQobGFiZWwpXHJcbiAgICAgICAgICAgICAgICBsYWJlbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uICgpIHsgXHJcbiAgICAgICAgICAgICAgICAgICAgY2IuY2xpY2soKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgaW5zZXRTZWxmKys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gbGV0IGluc2VnID0gMDtcclxuICAgICAgICAgICAgZm9yIChsZXQgaT0wOyBpPGluc2V0IDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpbnNldEJsb2NrID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XHJcbiAgICAgICAgICAgICAgICBpbnNldEJsb2NrLmNsYXNzTmFtZSA9IFwiaW5zZXQtYmxvY2tcIjtcclxuICAgICAgICAgICAgICAgIHRyZWVyb3cuYXBwZW5kQ2hpbGQoaW5zZXRCbG9jayk7XHJcbiAgICAgICAgICAgICAgICAvLyBpbnNlZysrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUuaW5mbyhgaW5zZWc9JHtpbnNlZ31gKVxyXG4gICAgICAgICAgICB0cmVlcm93LmFwcGVuZENoaWxkKHNwYW4pO1xyXG4gICAgICAgICAgICBjb25zdCBsYWJlbERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIilcclxuICAgICAgICAgICAgbGFiZWxEaXYuY2xhc3NOYW1lID0gJ3RyZWVsYWJlbCdcclxuICAgICAgICAgICAgY29uc3QgbGFiZWwgPSB0aGlzLm5vZGVSZW5kZXJlci5yZW5kZXIodGhpcylcclxuICAgICAgICAgICAgaWYgKGxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICBsYWJlbERpdi5hcHBlbmRDaGlsZChsYWJlbClcclxuICAgICAgICAgICAgICAgIHRyZWVyb3cuYXBwZW5kQ2hpbGQobGFiZWxEaXYpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5hY3Rpb25zKSB7XHJcbiAgICAgICAgICAgICAgICB0cmVlcm93LmFwcGVuZENoaWxkKHRoaXMucmVuZGVyQWN0aW9ucygpKVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBsZXQgbm9kZWNvbnRhaW5lciA9IHRoaXMuY2hpbGREb207XHJcbiAgICAgICAgICAgIGlmIChub2RlY29udGFpbmVyKSB7XHJcbiAgICAgICAgICAgICAgICBub2RlY29udGFpbmVyLmlubmVySFRNTCA9IG51bGxcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGNoaWxkQ291bnQgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIW5vZGVjb250YWluZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICBub2RlY29udGFpbmVyID0gdGhpcy5jaGlsZERvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGVjb250YWluZXIuY2xhc3NOYW1lID0gXCJub2RlY29udGFpbmVyXCJcclxuICAgICAgICAgICAgICAgICAgICBkb20uYXBwZW5kQ2hpbGQobm9kZWNvbnRhaW5lcik7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbm9kZWNvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZEluc2V0ID0gdGhpcy5zaG93T25seUNoaWxkcyA/IGluc2V0IDogKGluc2V0ICsgaW5zZXRTZWxmKTtcclxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUuaW5mbyhgaW5zZXRzICR7aW5zZXR9IC0gJHtpbnNldCtpbnNldFNlbGZ9YClcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaGlsZHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBub2RlY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuY2hpbGRzW2ldLnJlbmRlcihjaGlsZEluc2V0KSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9ICAgICAgXHJcbiAgICAgICAgICAgIHRoaXMuZG9tLnN0eWxlLmRpc3BsYXkgPSAodGhpcy5oaWRlRW1wdHlOb2RlICYmIGNoaWxkQ291bnQgPT09IDApID8gJ25vbmUnIDogJ2ZsZXgnO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmluc2V0Q2hpbGRzID0gdGhpcy5zaG93T25seUNoaWxkcyA/IGluc2V0IDogKGluc2V0ICsgaW5zZXRTZWxmKTtcclxuICAgICAgICByZXR1cm4gZG9tXHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vIHJlbmRlck9yZyhpbnNldD86bnVtYmVyKTogSFRNTEVsZW1lbnQge1xyXG4gICAgLy8gICAgIC8vIGNvbnNvbGUuaW5mbyhgcmVuZGVyIGluc2V0PSR7aW5zZXR9YCwgdGhpcy5kYXRhLCB0aGlzLmNvbGxhcHNlZCk7XHJcbiAgICAvLyAgICAgY29uc3QgY29sID0gVHJlZU5vZGUuZ2V0VHJlZVBhdGgodGhpcykubGVuZ3RoO1xyXG4gICAgLy8gICAgIGlmICghaW5zZXQpIHtcclxuICAgIC8vICAgICAgICAgaW5zZXQgPSAwO1xyXG4gICAgLy8gICAgIH0gICAgICAgIFxyXG4gICAgLy8gICAgIGxldCBpbnNldFNlbGYgPSAwO1xyXG4gICAgLy8gICAgIC8vIGxldCBpbnNldCA9IGNvbC0xO1xyXG5cclxuICAgIC8vICAgICBsZXQgZG9tID0gdGhpcy5kb207XHJcbiAgICAvLyAgICAgbGV0IHRyZWVyb3cgPSB0aGlzLnRyZWVyb3dcclxuICAgIC8vICAgICBpZiAoIWRvbSkge1xyXG4gICAgLy8gICAgICAgICBkb20gPSB0aGlzLmRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XHJcbiAgICAvLyAgICAgICAgIGRvbS5jbGFzc05hbWUgPSAncm93LXdyYXBwZXInLFxyXG4gICAgLy8gICAgICAgICB0cmVlcm93ID0gdGhpcy50cmVlcm93ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAvLyAgICAgICAgIHRyZWVyb3cuaWQgPSBcInRyZWVyb3dcIiArIFRyZWVOb2RlLm5vZGVDb3VudGVyKysgICAgICAgICAgICBcclxuICAgIC8vICAgICAgICAgdHJlZXJvdy5jbGFzc05hbWUgPSBcInRyZWVyb3dcIjtcclxuICAgIC8vICAgICAgICAgZG9tLmFwcGVuZENoaWxkKHRyZWVyb3cpO1xyXG5cclxuICAgIC8vICAgICAgICAgY29uc3QgY2hpbGRDb3VudCA9IHRoaXMuY2hpbGRzID8gdGhpcy5jaGlsZHMubGVuZ3RoIDogMFxyXG4gICAgLy8gICAgICAgICBjb25zdCBzZWxlY3RNb2RlID0gdGhpcy5nZXRTZWxlY3RNb2RlKCk7XHJcbiAgICAvLyAgICAgICAgIGNvbnN0IHNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgIC8vICAgICAgICAgc3Bhbi5jbGFzc05hbWUgPSBcInRyZWVpY29uXCI7XHJcblxyXG4gICAgLy8gICAgICAgICBjb25zdCBzcGFuT3BlbkNsb3NlID0gdGhpcy5zcGFuT3BlbkNsb3NlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xyXG4gICAgLy8gICAgICAgICBzcGFuT3BlbkNsb3NlLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGV2KSA9PiB0aGlzLm9uVHJlZUljb25DbGljayhldikpO1xyXG4gICAgLy8gICAgICAgICBpbnNldFNlbGYrKztcclxuXHJcbiAgICAvLyAgICAgICAgIGlmICh0aGlzLmNvbGxhcHNlZCkge1xyXG4gICAgLy8gICAgICAgICAgICAgdGhpcy5kb20uY2xhc3NMaXN0LmFkZCgnY2xvc2VkJyk7XHJcbiAgICAvLyAgICAgICAgIH1cclxuICAgIC8vICAgICAgICAgZWxzZSB7ICAgICAgICAgICAgICAgICAgICBcclxuICAgIC8vICAgICAgICAgICAgIHRoaXMuZG9tLmNsYXNzTGlzdC5hZGQoJ29wZW5lZCcpO1xyXG4gICAgLy8gICAgICAgICB9ICAgIFxyXG5cclxuICAgIC8vICAgICAgICAgaWYgKGNoaWxkQ291bnQgPiAwKSB7XHJcbiAgICAvLyAgICAgICAgICAgICAvLyB0cmVlcm93LnN0eWxlLnBhZGRpbmdMZWZ0ID0gYGNhbGMoJHtjb2wgLSAxfSAqICgke3RoaXMuY3NzX3Byb3AuaWNvbldpZHRofSArICR7dGhpcy5jc3NfcHJvcC5pY29uRGlzdGFuY2V9KSArICR7dGhpcy5jc3NfcHJvcC50cmVlUGFkZGluZ30pYDtcclxuICAgIC8vICAgICAgICAgICAgIGlmICh0aGlzLmNvbGxhcHNlZCkgeyAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAvLyAgICAgICAgICAgICAgICAgdGhpcy5zcGFuT3BlbkNsb3NlLmNsYXNzTGlzdC5hZGQoJ2Nsb3NlZCcpO1xyXG4gICAgLy8gICAgICAgICAgICAgfVxyXG4gICAgLy8gICAgICAgICAgICAgZWxzZSB7ICAgICAgICAgICAgICAgICAgICBcclxuICAgIC8vICAgICAgICAgICAgICAgICB0aGlzLnNwYW5PcGVuQ2xvc2UuY2xhc3NMaXN0LmFkZCgnb3BlbmVkJyk7XHJcbiAgICAvLyAgICAgICAgICAgICB9ICAgICAgICAgICAgICAgIFxyXG4gICAgLy8gICAgICAgICB9XHJcbiAgICAvLyAgICAgICAgIGVsc2Uge1xyXG4gICAgLy8gICAgICAgICAgICAgaWYgKHNlbGVjdE1vZGUgPT09IFNlbGVjdGlvbk1vZGUuU0lOR0xFKSB7XHJcbiAgICAvLyAgICAgICAgICAgICAgICAgdHJlZXJvdy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChldikgPT4gdGhpcy5pdGVtQ2xpY2tlZChldikpO1xyXG4gICAgLy8gICAgICAgICAgICAgfVxyXG4gICAgLy8gICAgICAgICAgICAgLy8gdHJlZXJvdy5zdHlsZS5wYWRkaW5nTGVmdCA9IChjb2wgLSAyKSAqIDIuOCArIDAuMykgKyBcInJlbVwiXHJcbiAgICAvLyAgICAgICAgICAgICBpZiAoc2VsZWN0TW9kZSA9PT0gU2VsZWN0aW9uTW9kZS5SQURJTykge1xyXG4gICAgLy8gICAgICAgICAgICAgICAgIC8vIHRoaXMudHJlZXJvdy5zdHlsZS5wYWRkaW5nTGVmdCA9IGBjYWxjKCR7Y29sIC0gMX0gKiAoJHt0aGlzLmNzc19wcm9wLmljb25XaWR0aH0gKyAke3RoaXMuY3NzX3Byb3AuaWNvbkRpc3RhbmNlfSkgKyAke3RoaXMuY3NzX3Byb3AudHJlZVBhZGRpbmd9KWA7XHJcbiAgICAvLyAgICAgICAgICAgICAgICAgLy90cmVlcm93LnN0eWxlLnBhZGRpbmdMZWZ0ID0gKChjb2wtMSkqMS4xOCArIDAuMykgKyBcInJlbVwiXHJcbiAgICAvLyAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgLy8gICAgICAgICAgICAgICAgIC8vIHRyZWVyb3cuc3R5bGUucGFkZGluZ0xlZnQgPSAoKGNvbCkqMS4xOCArIDAuMykgKyBcInJlbVwiO1xyXG4gICAgLy8gICAgICAgICAgICAgICAgIC8vIHRoaXMudHJlZXJvdy5zdHlsZS5wYWRkaW5nTGVmdCA9IGBjYWxjKCR7Y29sfSAqICgke3RoaXMuY3NzX3Byb3AuaWNvbldpZHRofSArICR7dGhpcy5jc3NfcHJvcC5pY29uRGlzdGFuY2V9KSArICR7dGhpcy5jc3NfcHJvcC50cmVlUGFkZGluZ30pYDtcclxuICAgIC8vICAgICAgICAgICAgIH1cclxuICAgIC8vICAgICAgICAgICAgIGlmIChjb2wgPiAxKSB7XHJcbiAgICAvLyAgICAgICAgICAgICAgICAgdHJlZXJvdy5jbGFzc05hbWUgPSAndHJlZXJvdyBsZWFmJ1xyXG4gICAgLy8gICAgICAgICAgICAgfVxyXG4gICAgLy8gICAgICAgICAgICAgLy8gc3Bhbk9wZW5DbG9zZS5pbm5lckhUTUwgPSBcIiZuYnNwO1wiXHJcbiAgICAvLyAgICAgICAgIH1cclxuICAgIC8vICAgICAgICAgdGhpcy50ZXh0Tm9kZSA9IHNwYW5PcGVuQ2xvc2VcclxuICAgIC8vICAgICAgICAgc3Bhbi5hcHBlbmRDaGlsZChzcGFuT3BlbkNsb3NlKTtcclxuICAgIC8vICAgICAgICAgaWYgKHNlbGVjdE1vZGUgPT09IFNlbGVjdGlvbk1vZGUuTVVMVEkpIHtcclxuICAgIC8vICAgICAgICAgICAgIGNvbnN0IGNiOiBIVE1MSW5wdXRFbGVtZW50ID0gdGhpcy5fY3JlYXRlQ2Vja0JveCgpXHJcbiAgICAvLyAgICAgICAgICAgICBzcGFuLmFwcGVuZENoaWxkKGNiKTtcclxuICAgIC8vICAgICAgICAgICAgIGNvbnN0IGxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxhYmVsXCIpO1xyXG4gICAgLy8gICAgICAgICAgICAgc3Bhbi5hcHBlbmRDaGlsZChsYWJlbCk7XHJcbiAgICAvLyAgICAgICAgICAgICBsYWJlbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uICgpIHsgY2IuY2xpY2soKSB9KTsgICBcclxuICAgIC8vICAgICAgICAgICAgIGluc2V0U2VsZisrOyAgICAgICAgICAgICBcclxuICAgIC8vICAgICAgICAgfSBlbHNlIGlmIChzZWxlY3RNb2RlID09PSBTZWxlY3Rpb25Nb2RlLlJBRElPKSB7XHJcbiAgICAvLyAgICAgICAgICAgICBjb25zdCBjYjogSFRNTElucHV0RWxlbWVudCA9IHRoaXMuX2NyZWF0ZVJhZGlvQnR0bigpXHJcbiAgICAvLyAgICAgICAgICAgICBzcGFuLmFwcGVuZENoaWxkKGNiKTtcclxuICAgIC8vICAgICAgICAgICAgIGNvbnN0IGxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxhYmVsXCIpO1xyXG4gICAgLy8gICAgICAgICAgICAgc3Bhbi5hcHBlbmRDaGlsZChsYWJlbClcclxuICAgIC8vICAgICAgICAgICAgIGxhYmVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKCkgeyBcclxuICAgIC8vICAgICAgICAgICAgICAgICBjYi5jbGljaygpO1xyXG4gICAgLy8gICAgICAgICAgICAgfSk7XHJcbiAgICAvLyAgICAgICAgICAgICBpbnNldFNlbGYrKztcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgLy8gICAgICAgICB9XHJcblxyXG4gICAgLy8gICAgICAgICBmb3IgKGxldCBpPTA7IGk8aW5zZXQ7IGkrKykge1xyXG4gICAgLy8gICAgICAgICAgICAgY29uc3QgaW5zZXRCbG9jayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xyXG4gICAgLy8gICAgICAgICAgICAgaW5zZXRCbG9jay5jbGFzc05hbWUgPSBcImluc2V0LWJsb2NrXCI7XHJcbiAgICAvLyAgICAgICAgICAgICB0cmVlcm93LmFwcGVuZENoaWxkKGluc2V0QmxvY2spO1xyXG4gICAgLy8gICAgICAgICB9XHJcbiAgICAvLyAgICAgICAgIHRyZWVyb3cuYXBwZW5kQ2hpbGQoc3Bhbik7XHJcbiAgICAvLyAgICAgICAgIGNvbnN0IGxhYmVsRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKVxyXG4gICAgLy8gICAgICAgICBsYWJlbERpdi5jbGFzc05hbWUgPSAndHJlZWxhYmVsJ1xyXG4gICAgLy8gICAgICAgICBjb25zdCBsYWJlbCA9IHRoaXMubm9kZVJlbmRlcmVyLnJlbmRlcih0aGlzKVxyXG4gICAgLy8gICAgICAgICBpZiAobGFiZWwpIHtcclxuICAgIC8vICAgICAgICAgICAgIGxhYmVsRGl2LmFwcGVuZENoaWxkKGxhYmVsKVxyXG4gICAgLy8gICAgICAgICAgICAgdHJlZXJvdy5hcHBlbmRDaGlsZChsYWJlbERpdik7XHJcbiAgICAvLyAgICAgICAgIH1cclxuXHJcbiAgICAvLyAgICAgICAgIGlmICh0aGlzLmFjdGlvbnMpIHtcclxuICAgIC8vICAgICAgICAgICAgIHRyZWVyb3cuYXBwZW5kQ2hpbGQodGhpcy5yZW5kZXJBY3Rpb25zKCkpXHJcbiAgICAvLyAgICAgICAgIH1cclxuXHJcbiAgICAvLyAgICAgICAgIGxldCBub2RlY29udGFpbmVyID0gdGhpcy5jaGlsZERvbTtcclxuICAgIC8vICAgICAgICAgaWYgKG5vZGVjb250YWluZXIpIHtcclxuICAgIC8vICAgICAgICAgICAgIG5vZGVjb250YWluZXIuaW5uZXJIVE1MID0gbnVsbFxyXG4gICAgLy8gICAgICAgICB9XHJcblxyXG4gICAgLy8gICAgICAgICBpZiAoY2hpbGRDb3VudCA+IDApIHtcclxuICAgIC8vICAgICAgICAgICAgIGlmICghbm9kZWNvbnRhaW5lcikge1xyXG4gICAgLy8gICAgICAgICAgICAgICAgIG5vZGVjb250YWluZXIgPSB0aGlzLmNoaWxkRG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAvLyAgICAgICAgICAgICAgICAgbm9kZWNvbnRhaW5lci5jbGFzc05hbWUgPSBcIm5vZGVjb250YWluZXJcIlxyXG4gICAgLy8gICAgICAgICAgICAgICAgIGRvbS5hcHBlbmRDaGlsZChub2RlY29udGFpbmVyKTtcclxuICAgIC8vICAgICAgICAgICAgICAgICAvLyBub2RlY29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSdcclxuICAgIC8vICAgICAgICAgICAgIH1cclxuICAgIC8vICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaGlsZHMubGVuZ3RoOyBpKyspIHtcclxuICAgIC8vICAgICAgICAgICAgICAgICBub2RlY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuY2hpbGRzW2ldLnJlbmRlck9yZyhpbnNldCtpbnNldFNlbGYpKTtcclxuICAgIC8vICAgICAgICAgICAgIH1cclxuXHJcbiAgICAvLyAgICAgICAgIH0gICAgICBcclxuICAgIC8vICAgICAgICAgdGhpcy5kb20uc3R5bGUuZGlzcGxheSA9ICh0aGlzLmhpZGVFbXB0eU5vZGUgJiYgY2hpbGRDb3VudCA9PT0gMCkgPyAnbm9uZScgOiAnZmxleCc7XHJcbiAgICAvLyAgICAgfVxyXG4gICAgLy8gICAgIHRoaXMuaW5zZXRDaGlsZHMgPSBpbnNldCtpbnNldFNlbGY7XHJcbiAgICAvLyAgICAgcmV0dXJuIGRvbVxyXG4gICAgLy8gfVxyXG5cclxuICAgIHJlbmRlckFjdGlvbnMoKTogSFRNTEVsZW1lbnQge1xyXG4gICAgICAgIGxldCBhY3REaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpXHJcbiAgICAgICAgYWN0RGl2LmNsYXNzTmFtZSA9IFwidHJlZV9hY3Rpb25faWNvbnNcIlxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5hY3Rpb25zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGEgPSB0aGlzLmFjdGlvbnNbaV1cclxuICAgICAgICAgICAgaWYgKGEuYXV0aG9yaXplZCkge1xyXG4gICAgICAgICAgICAgICAgYWN0RGl2LmFwcGVuZENoaWxkKHRoaXMucmVuZGVySWNvbihhLmljb24sICgpID0+IGEuY2FsbGJhY2sodGhpcy5kYXRhKSkpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGFjdERpdlxyXG4gICAgfVxyXG5cclxuICAgIHJlbmRlckljb24oaWNvbjogc3RyaW5nLCBjYjogKGV2dCkgPT4gdm9pZCk6IEhUTUxFbGVtZW50IHtcclxuICAgICAgICBjb25zdCBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpXCIpXHJcbiAgICAgICAgZWwuc3R5bGUuY3NzRmxvYXQgPSBcInJpZ2h0XCJcclxuICAgICAgICBlbC5zdHlsZS5tYXJnaW5MZWZ0ID0gXCIxMnB4XCJcclxuICAgICAgICBlbC5jbGFzc05hbWUgPSBcImZhcyBmYS1cIiArIGljb25cclxuICAgICAgICBlbC5vbmNsaWNrID0gY2JcclxuICAgICAgICByZXR1cm4gZWw7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiByZXR1cm4gdGhlIGNoZWNrYm94IGZvciBpdGVtIHNlbGVjdGlvbiwgaWYgbm90IGV4aXN0IGNyZWF0ZSBcclxuICAgICAqL1xyXG4gICAgX2NyZWF0ZUNlY2tCb3goKTogSFRNTElucHV0RWxlbWVudCB7XHJcbiAgICAgICAgbGV0IGNoQm94OiBIVE1MSW5wdXRFbGVtZW50O1xyXG4gICAgICAgIGlmICghdGhpcy5jaEJveCkge1xyXG4gICAgICAgICAgICBjaEJveCA9IHRoaXMuY2hCb3ggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xyXG4gICAgICAgICAgICBjaEJveC50eXBlID0gJ2NoZWNrYm94JztcclxuICAgICAgICAgICAgY2hCb3guY2xhc3NOYW1lID0gJ3JlZ3VsYXItY2hlY2tib3gnO1xyXG4gICAgICAgICAgICBjaEJveC5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnLCB0aGlzLmRhdGEuaWQpO1xyXG4gICAgICAgICAgICBjaEJveC5jaGVja2VkID0gdGhpcy5zZWxlY3Rpb25TdGF0dXMgPT09IFNlbGVjdGlvblN0YXR1cy5TRUxFQ1RFRCB8fCB0aGlzLnNlbGVjdGlvblN0YXR1cyA9PT0gU2VsZWN0aW9uU3RhdHVzLklOREVURVJNSU5BVEU7XHJcbiAgICAgICAgICAgIGNoQm94LmluZGV0ZXJtaW5hdGUgPSB0aGlzLnNlbGVjdGlvblN0YXR1cyA9PT0gU2VsZWN0aW9uU3RhdHVzLklOREVURVJNSU5BVEU7XHJcbiAgICAgICAgICAgIGNoQm94LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIChldikgPT4gdGhpcy5vbmNoQm94Q2hhbmdlKGV2KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmNoQm94XHJcbiAgICB9XHJcblxyXG4gICAgX2NyZWF0ZVJhZGlvQnR0bigpOiBIVE1MSW5wdXRFbGVtZW50IHtcclxuICAgICAgICBpZiAoIXRoaXMuY2hCb3gpIHtcclxuICAgICAgICAgICAgY29uc3QgY2hCb3ggPSB0aGlzLmNoQm94ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcclxuICAgICAgICAgICAgY2hCb3gudHlwZSA9ICdyYWRpbyc7XHJcbiAgICAgICAgICAgIGNoQm94LmNsYXNzTmFtZSA9ICdyZWd1bGFyLWNoZWNrYm94JztcclxuICAgICAgICAgICAgY2hCb3guc2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsJywgdGhpcy5kYXRhLmlkKTtcclxuICAgICAgICAgICAgY2hCb3guY2hlY2tlZCA9IHRoaXMuc2VsZWN0aW9uU3RhdHVzPT09U2VsZWN0aW9uU3RhdHVzLlNFTEVDVEVEO1xyXG4gICAgICAgICAgICBjaEJveC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCAoZXYpID0+IHRoaXMub25jaEJveENoYW5nZShldikpOyAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB0aGlzLmNoQm94ID0gY2hCb3g7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmNoQm94XHJcbiAgICB9XHJcblxyXG4gICAgb25jaEJveENoYW5nZShldnQ6IGFueSkge1xyXG4gICAgICAgIC8vIGNvbnNvbGUud2Fybihgb25jaEJveENoYW5nZSAke3RoaXMuZGF0YS5uYW1lfSAke3RoaXMuY2hCb3guY2hlY2tlZH0gY2hpbGRDb3VudD0ke3RoaXMuY2hpbGRzID8gdGhpcy5jaGlsZHMubGVuZ3RoIDogMH1gKTtcclxuICAgICAgICAvLyBjb25zb2xlLndhcm4odGhpcyk7XHJcbiAgICAgICAgaWYgKHRoaXMuY2hpbGRzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGlzU2VsZWN0ZWQgPSB0aGlzLmNoQm94LmNoZWNrZWQ7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaGlsZHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRzW2ldLnNldFNlbGVjdGVkKGlzU2VsZWN0ZWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnNldFNlbGVjdGVkKHRoaXMuY2hCb3guY2hlY2tlZClcclxuICAgICAgICB9XHJcbiAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICB9XHJcblxyXG5cclxuXHJcbiAgICBpdGVtQ2xpY2tlZChldnQ6IE1vdXNlRXZlbnQpOiB2b2lkIHsgICBcclxuICAgICAgICBjb25zb2xlLmluZm8oYFRyZWVOb2RlLml0ZW1DbGlja2VkYCkgICAgIFxyXG4gICAgICAgIHRoaXMuc2V0U2VsZWN0ZWQodGhpcy5zZWxlY3Rpb25TdGF0dXM9PT1TZWxlY3Rpb25TdGF0dXMuVU5TRUxFQ1RFRCk7XHJcbiAgICB9XHJcblxyXG4gICAgb25UcmVlSWNvbkNsaWNrKGV2dDogTW91c2VFdmVudCkge1xyXG4gICAgICAgIC8vIGNvbnNvbGUuaW5mbyhgb25UcmVlSWNvbkNsaWNrICR7dGhpcy5jb2xsYXBzZWR9YCk7XHJcbiAgICAgICAgaWYgKHRoaXMuY2hpbGRzICYmIHRoaXMuY2hpbGRzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuY29sbGFwc2VkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRvbS5jbGFzc0xpc3QucmVwbGFjZSgnY2xvc2VkJywgJ29wZW5lZCcpO1xyXG4gICAgICAgICAgICAgICAgLy8gdGhpcy5jaGlsZERvbS5jbGFzc0xpc3QucmVwbGFjZSgnY2xvc2VkJywgJ29wZW5lZCcpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zcGFuT3BlbkNsb3NlLmNsYXNzTGlzdC5yZXBsYWNlKCdjbG9zZWQnLCAnb3BlbmVkJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRvbS5jbGFzc0xpc3QucmVwbGFjZSgnb3BlbmVkJywgJ2Nsb3NlZCcpO1xyXG4gICAgICAgICAgICAgICAgLy8gdGhpcy5jaGlsZERvbS5jbGFzc0xpc3QucmVwbGFjZSgnb3BlbmVkJywgJ2Nsb3NlZCcpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zcGFuT3BlbkNsb3NlLmNsYXNzTGlzdC5yZXBsYWNlKCdvcGVuZWQnLCAnY2xvc2VkJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5jb2xsYXBzZWQ9IXRoaXMuY29sbGFwc2VkO1xyXG4gICAgICAgICAgICB0aGlzLm9uRXhwYW5kQ2hhbmdlLmRpc3BhdGNoKHRoaXMsICF0aGlzLmNvbGxhcHNlZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGV2dC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBpc1NlbGVjdGVkKCk6IGJvb2xlYW4ge1xyXG4gICAgLy8gICAgIGlmICh0aGlzLmNoQm94KSB7XHJcbiAgICAvLyAgICAgICAgIHJldHVybiB0aGlzLmNoQm94LmNoZWNrZWQ7XHJcbiAgICAvLyAgICAgfVxyXG4gICAgLy8gICAgIHJldHVybiB0aGlzLnNlbGVjdGVkO1xyXG4gICAgLy8gfVxyXG5cclxuICAgIGdldFNlbGVjdGlvbnNTdGF0dXMoKTpTZWxlY3Rpb25TdGF0dXMge1xyXG4gICAgICAgIC8vIGlmICh0aGlzLmNoQm94KSB7XHJcbiAgICAgICAgLy8gICAgIGlmICh0aGlzLmNoQm94LmNoZWNrZWQpIHtcclxuICAgICAgICAvLyAgICAgICAgIHJldHVybiB0aGlzLmNoQm94LmluZGV0ZXJtaW5hdGUgPyBTZWxlY3Rpb25TdGF0dXMuSU5ERVRFUk1JTkFURSA6IFNlbGVjdGlvblN0YXR1cy5TRUxFQ1RFRDtcclxuICAgICAgICAvLyAgICAgfVxyXG4gICAgICAgIC8vICAgICByZXR1cm4gU2VsZWN0aW9uU3RhdHVzLlVOU0VMRUNURUQ7XHJcbiAgICAgICAgLy8gfVxyXG4gICAgICAgIC8vIHJldHVybiB0aGlzLnNlbGVjdGVkID8gU2VsZWN0aW9uU3RhdHVzLlNFTEVDVEVEIDogU2VsZWN0aW9uU3RhdHVzLlVOU0VMRUNURUQ7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uU3RhdHVzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qXHJcbiAgICBjaGlsZFNlbGVjdGVkKGV2dDpUcmVlU2VsZWN0aW9uQ2hhbmdlRXZlbnQpIHtcclxuICAgICAgICB0aGlzLmZpcmUoVHJlZS5OT0RFX1NFTEVDVElPTl9DSEFOR0VfRVZFTlQsIHtjaGFuZ2VkTm9kZTpldnQuY2hhbmdlZE5vZGV9KTtcclxuICAgIH1cclxuICAgICovXHJcblxyXG4gICAgX2dldFN0YXR1c09mQ2hpbGRzKCk6U2VsZWN0aW9uU3RhdHVzIHtcclxuICAgICAgICBsZXQgY291bnQgPSAwO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaGlsZHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgLy8gY29uc29sZS5pbmZvKGBcXHQgJHtpfSAke1NlbGVjdGlvblN0YXR1c1t0aGlzLmNoaWxkc1tpXS5nZXRTZWxlY3Rpb25zU3RhdHVzKCldfWApO1xyXG4gICAgICAgICAgICBjb25zdCBzU3RhdHVzID0gdGhpcy5jaGlsZHNbaV0uZ2V0U2VsZWN0aW9uc1N0YXR1cygpO1xyXG4gICAgICAgICAgICBpZiAoc1N0YXR1cz09PVNlbGVjdGlvblN0YXR1cy5TRUxFQ1RFRCkge1xyXG4gICAgICAgICAgICAgICAgIGNvdW50Kys7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc1N0YXR1cz09PVNlbGVjdGlvblN0YXR1cy5JTkRFVEVSTUlOQVRFKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFNlbGVjdGlvblN0YXR1cy5JTkRFVEVSTUlOQVRFO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjb3VudCA9PT0gMCkgcmV0dXJuIFNlbGVjdGlvblN0YXR1cy5VTlNFTEVDVEVEO1xyXG4gICAgICAgIHJldHVybiAodGhpcy5jaGlsZHMubGVuZ3RoID4gY291bnQpID8gU2VsZWN0aW9uU3RhdHVzLklOREVURVJNSU5BVEUgOiBTZWxlY3Rpb25TdGF0dXMuU0VMRUNURUQ7XHJcbiAgICB9XHJcblxyXG4gICAgY2hpbGRFeHBhbmRDaGFuZ2VkKG5vZGU6IFRyZWVOb2RlLCBleHBhbmRlZDogYm9vbGVhbik6IHZvaWQge1xyXG4gICAgICAgIGNvbnNvbGUuaW5mbyhcImNoaWxkRXhwYW5kQ2hhbmdlZFwiKTtcclxuICAgICAgICBpZiAoZXhwYW5kZWQgJiYgdGhpcy5leHBhbmRPbmx5T25lTm9kZSkge1xyXG4gICAgICAgICAgICBjb25zdCBjb3VudCA9IHRoaXMuY2hpbGRzID8gdGhpcy5jaGlsZHMubGVuZ3RoIDogMDtcclxuICAgICAgICAgICAgZm9yIChsZXQgaT0wOyBpPGNvdW50OyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChub2RlICE9PSB0aGlzLmNoaWxkc1tpXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRzW2ldLmNvbGxhcHNlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGNoaWxkU2VsZWN0ZWQobjogVHJlZU5vZGUsIHNlbGVjdGlvblN0YXR1czogU2VsZWN0aW9uU3RhdHVzKSB7XHJcbiAgICAgICAgLy8gY29uc29sZS5pbmZvKGBjaGlsZFNlbGVjdGVkIHRoaXM9JHt0aGlzLmRhdGEuYmV6ZWljaG51bmd9IGNoaWxkPSR7bi5kYXRhLmJlemVpY2hudW5nfSAke1NlbGVjdGlvblN0YXR1c1tzZWxlY3Rpb25TdGF0dXNdfWApO1xyXG4gICAgICAgIGNvbnN0IHNlbFN0YXR1cyA9IHRoaXMuX2dldFN0YXR1c09mQ2hpbGRzKCk7XHJcbiAgICAgICAgaWYgKHRoaXMuY2hCb3gpIHsgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZiAoc2VsU3RhdHVzID09PSBTZWxlY3Rpb25TdGF0dXMuVU5TRUxFQ1RFRCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jaEJveC5jaGVja2VkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNoQm94LmluZGV0ZXJtaW5hdGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2hCb3guY2hlY2tlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNoQm94LmluZGV0ZXJtaW5hdGUgPSBzZWxTdGF0dXMgPT09IFNlbGVjdGlvblN0YXR1cy5JTkRFVEVSTUlOQVRFO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGNvbnNvbGUuaW5mbyhgY2hpbGRTZWxlY3RlZCB0aGlzPSR7dGhpcy5kYXRhLmJlemVpY2hudW5nfSBjaGlsZD0ke24uZGF0YS5iZXplaWNobnVuZ30gJHtTZWxlY3Rpb25TdGF0dXNbc2VsZWN0aW9uU3RhdHVzXX0gXHJcbiAgICAgICAgLy8gPT4gJHtzZWxTdGF0dXN9YCk7XHJcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25TdGF0dXMgPSBzZWxTdGF0dXM7XHJcbiAgICAgICAgdGhpcy5vblNlbGVjdGlvbkNoYW5nZS5kaXNwYXRjaCh0aGlzLCBzZWxTdGF0dXMpOyAgIFxyXG4gICAgICAgIFxyXG4gICAgICAgIFxyXG4gICAgfVxyXG5cclxuXHJcbiAgICBnZXRTZWxlY3RlZCgpOiBBcnJheTxhbnk+IHtcclxuICAgICAgICBsZXQgaWRzOiBBcnJheTxhbnk+ID0gW107XHJcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uU3RhdHVzPT09U2VsZWN0aW9uU3RhdHVzLlNFTEVDVEVEIHx8IHRoaXMuc2VsZWN0aW9uU3RhdHVzPT09U2VsZWN0aW9uU3RhdHVzLklOREVURVJNSU5BVEUpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uU3RhdHVzPT09U2VsZWN0aW9uU3RhdHVzLlNFTEVDVEVEKSB7XHJcbiAgICAgICAgICAgICAgICBpZHMucHVzaCh0aGlzLmRhdGEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNoaWxkcykge1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlkcyA9IGlkcy5jb25jYXQodGhpcy5jaGlsZHNbaV0uZ2V0U2VsZWN0ZWQoKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGlkcztcclxuICAgIH1cclxuXHJcblxyXG4gICAgc2V0U2VsZWN0ZWQoc2VsZWN0ZWQ6IGJvb2xlYW4pIHtcclxuICAgICAgICBcclxuICAgICAgICBjb25zb2xlLmluZm8oYHNldFNlbGVjdGVkICR7dGhpcy5kYXRhLm5hbWU/IHRoaXMuZGF0YS5uYW1lIDogdGhpcy5kYXRhLmxhYmVsPyB0aGlzLmRhdGEubGFiZWwgOiB0aGlzLmRhdGF9IFNlbGVjdGlvbk1vZGU9JHtTZWxlY3Rpb25Nb2RlW3RoaXMuZ2V0U2VsZWN0TW9kZSgpXX1gKTtcclxuICAgICAgICBjb25zb2xlLmluZm8oJ1RyZWVOb2RlLnNldFNlbGVjdGVkJywgdGhpcy5kYXRhKTtcclxuICAgICAgICBjb25zdCBzZWxlY3Rpb25zU3RhdHVzID0gc2VsZWN0ZWQgPyBTZWxlY3Rpb25TdGF0dXMuU0VMRUNURUQgOiBTZWxlY3Rpb25TdGF0dXMuVU5TRUxFQ1RFRDtcclxuICAgICAgICBpZiAoc2VsZWN0aW9uc1N0YXR1cyA9PT0gdGhpcy5zZWxlY3Rpb25TdGF0dXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5nZXRTZWxlY3RNb2RlKCkgPT09IFNlbGVjdGlvbk1vZGUuU0lOR0xFKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnRyZWVyb3cpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGlvblN0YXR1cz09PVNlbGVjdGlvblN0YXR1cy5VTlNFTEVDVEVEKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmVlcm93LmNsYXNzTGlzdC5hZGQoJ3NlbGVjdGVkJyk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgeyAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmVlcm93LmNsYXNzTGlzdC5yZW1vdmUoJ3NlbGVjdGVkJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNoQm94KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNoQm94LmNoZWNrZWQgPSBzZWxlY3RlZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5jaGlsZHMpIHtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaGlsZHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoaWxkc1tpXS5zZXRTZWxlY3RlZChzZWxlY3RlZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gICAgICAgICAgICBcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25TdGF0dXMgPSBzZWxlY3RlZCA/IFNlbGVjdGlvblN0YXR1cy5TRUxFQ1RFRCA6IFNlbGVjdGlvblN0YXR1cy5VTlNFTEVDVEVEO1xyXG4gICAgICAgIHRoaXMub25TZWxlY3Rpb25DaGFuZ2UuZGlzcGF0Y2godGhpcywgdGhpcy5zZWxlY3Rpb25TdGF0dXMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIF9zZXRTZWxlY3RlZChzZWxlY3RlZDogYm9vbGVhbikge1xyXG4gICAgLy8gICAgIGNvbnNvbGUuZXJyb3IoYF9zZXRTZWxlY3RlZCAke3RoaXMuZGF0YS5uYW1lfSB0aGlzLnNlbGVjdGVkPSR7dGhpcy5zZWxlY3RlZH0gPT4gJHtzZWxlY3RlZH1gKTtcclxuICAgIC8vICAgICBpZiAoc2VsZWN0ZWQgPT09IHRoaXMuc2VsZWN0ZWQpIHtcclxuICAgIC8vICAgICAgICAgcmV0dXJuO1xyXG4gICAgLy8gICAgIH1cclxuICAgIC8vICAgICBpZiAodGhpcy50cmVlcm93KSB7XHJcbiAgICAvLyAgICAgICAgIGlmICh0aGlzLnNlbGVjdGVkKSB7XHJcbiAgICAvLyAgICAgICAgICAgICB0aGlzLnRyZWVyb3cuY2xhc3NMaXN0LnJlbW92ZSgnc2VsZWN0ZWQnKTtcclxuICAgIC8vICAgICAgICAgfVxyXG4gICAgLy8gICAgICAgICBlbHNlIHtcclxuICAgIC8vICAgICAgICAgICAgIHRoaXMudHJlZXJvdy5jbGFzc0xpc3QuYWRkKCdzZWxlY3RlZCcpO1xyXG4gICAgLy8gICAgICAgICB9XHJcbiAgICAvLyAgICAgfVxyXG4gICAgLy8gICAgIHRoaXMuc2VsZWN0ZWQgPSAhdGhpcy5zZWxlY3RlZDtcclxuICAgIC8vIH1cclxuXHJcbiAgICByZXNpemUoKSB7XHJcbiAgICAgICAgY29uc3QgdHJlZVdpZHRoID0gdGhpcy50cmVlLmdldFdpZGgoKTtcclxuICAgICAgICAvLyByZXR1cm47XHJcbiAgICAgICAgLy8gY29uc29sZS5pbmZvKHRoaXMuZGF0YS5uYW1lICsgXCIgICEhISEhISEhIVwiKTtcclxuICAgICAgICAvLyBjb25zb2xlLmluZm8oXCJ0cmVlXCIsIHRoaXMudHJlZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSkgICAgICAgIFxyXG4gICAgICAgIGNvbnN0IGNoaWxkcyA9IHRoaXMuY2hpbGRzXHJcbiAgICAgICAgaWYgKGNoaWxkcyAmJiBjaGlsZHMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgY291bnQgPSBjaGlsZHMubGVuZ3RoOyBpIDwgY291bnQ7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY2hpbGRzW2ldLnJlc2l6ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBsZXQgdHJlZVJvdyA9IHRoaXMudHJlZXJvd1xyXG4gICAgICAgICAgICBsZXQgcmVjUm93ID0gdHJlZVJvdy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxyXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcInRyZWVSb3dcIiwgcmVjUm93KTtcclxuICAgICAgICAgICAgbGV0IHdBOiBBcnJheTxudW1iZXI+ID0gW11cclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmVlUm93LmNoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGxldCBjaGlsZDogSFRNTEVsZW1lbnQgPSA8SFRNTEVsZW1lbnQ+dHJlZVJvdy5jaGlsZHJlbltpXVxyXG5cclxuICAgICAgICAgICAgICAgIGxldCByZWNDaGlsZCA9IGNoaWxkLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXHJcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcImVsZW1cIiArIGkgKyBcIiAgXCIsIHJlY0NoaWxkKTtcclxuICAgICAgICAgICAgICAgIHdBLnB1c2gocmVjQ2hpbGQud2lkdGgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwic3BhblwiKzErXCIgIFwiLCByZWNSb3csIHJlY1NwYSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkOiBIVE1MRWxlbWVudCA9IDxIVE1MRWxlbWVudD50cmVlUm93LmNoaWxkcmVuWzFdXHJcbiAgICAgICAgICAgIC8vIGNoaWxkLnN0eWxlLndpZHRoID0gKHRyZWVXaWR0aCAtIDEzMCkgKyBcInB4XCJcclxuICAgICAgICAgICAgLy8gbGV0IHc6bnVtYmVyID0gKCB0cmVlV2lkdGggLSB3QVswXSAtIHdBWzJdIC0gOTIgKVxyXG4gICAgICAgICAgICBjb25zdCB3OiBudW1iZXIgPSAodHJlZVdpZHRoICsgcmVjUm93LmxlZnQgLSBjaGlsZC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0IC0gd0FbMl0pXHJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwicmVzICAgXCIrIHcgKyBcIiA9IFwiICsgdHJlZVdpZHRoICtcIiAtIFwiKyB3QVswXStcIiAtIFwiKyB3QVsyXSk7XHJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwicmVzICAgXCIrIHcgKyBcIiA9IFwiICsgdHJlZVdpZHRoICtcIiArIFwiKyByZWNSb3cubGVmdCsgXCIgLSBcIisgY2hpbGQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCArIFwiIC0gXCIgKyB3QVsyXSk7XHJcbiAgICAgICAgICAgIGNoaWxkLnN0eWxlLndpZHRoID0gdyArIFwicHhcIlxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcblxyXG5cclxuICAgIHN0YXRpYyBnZXRUcmVlUGF0aChub2RlOiBUcmVlTm9kZSk6IEFycmF5PFRyZWVOb2RlPiB7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW25vZGVdO1xyXG4gICAgICAgIGxldCBwYXJlbnQgPSBub2RlLnBhcmVudDtcclxuICAgICAgICB3aGlsZSAocGFyZW50KSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHBhcmVudClcclxuICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudFxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0LnJldmVyc2UoKTtcclxuICAgIH1cclxuXHJcbn1cclxuXHJcblxyXG5cclxuZXhwb3J0IGNsYXNzIFJhZGlvR3JvdXBUcmVlTm9kZSBleHRlbmRzIFRyZWVOb2RlIHtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihkYXRhOiBhbnksIGNoaWxkczogQXJyYXk8VHJlZU5vZGU+LCBwYXJhbXM/OiBUcmVlTm9kZVBhcmFtKSB7XHJcbiAgICAgICAgc3VwZXIoZGF0YSwgY2hpbGRzLCBwYXJhbXMpXHJcbiAgICAgICAgdGhpcy5zZWxlY3RNb2RlID0gU2VsZWN0aW9uTW9kZS5SQURJT19HUk9VUFxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBjb3VudCA9IGNoaWxkcy5sZW5ndGg7IGkgPCBjb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNoaWxkc1tpXS5zZWxlY3RNb2RlID0gU2VsZWN0aW9uTW9kZS5SQURJT1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBjaGlsZFNlbGVjdGVkKG46IFRyZWVOb2RlLCBzZWxlY3Rpb25TdGF0dXM6IFNlbGVjdGlvblN0YXR1cykge1xyXG4gICAgLy8gICAgIGNvbnNvbGUuaW5mbyhgcmFkaW9UcmVlTm9kZS5jaGlsZFNlbGVjdGVkIHRoaXM9JHt0aGlzLmRhdGEuYmV6ZWljaG51bmd9IGNoaWxkPSR7bi5kYXRhLmJlemVpY2hudW5nfSAke1NlbGVjdGlvblN0YXR1c1tzZWxlY3Rpb25TdGF0dXNdfWApOyAgICAgXHJcbiAgICAvLyAgICAgdGhpcy5vblNlbGVjdGlvbkNoYW5nZS5kaXNwYXRjaChuLCBzZWxlY3Rpb25TdGF0dXMpOyAgICAgICAgXHJcbiAgICAvLyB9XHJcblxyXG4gICAgY2hpbGRTZWxlY3RlZChub2RlOiBUcmVlTm9kZSwgc3RhdHVzOiBTZWxlY3Rpb25TdGF0dXMpIHtcclxuICAgICAgICAvLyBjb25zb2xlLmVycm9yKGBSYWRpb0dyb3VwVHJlZU5vZGUuY2hpbGRTZWxlY3RlZCAke25vZGUuZGF0YS5uYW1lfSAke1NlbGVjdGlvblN0YXR1c1tzdGF0dXNdfWApOyAgICAgICAgXHJcbiAgICAgICAgLy8gY29uc29sZS5pbmZvKGByYWRpb1RyZWVOb2RlLmNoaWxkU2VsZWN0ZWQgdGhpcz0ke3RoaXMuZGF0YS5iZXplaWNobnVuZ30gY2hpbGQ9JHtub2RlLmRhdGEuYmV6ZWljaG51bmd9ICR7U2VsZWN0aW9uU3RhdHVzW3N0YXR1c119YCk7ICAgICBcclxuICAgICAgICBpZiAobm9kZS5nZXRTZWxlY3Rpb25zU3RhdHVzKCk9PT1TZWxlY3Rpb25TdGF0dXMuU0VMRUNURUQpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGNvdW50ID0gdGhpcy5jaGlsZHMubGVuZ3RoOyBpIDwgY291bnQ7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2hpbGRzW2ldICE9PSBub2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGlsZHNbaV0uc2V0U2VsZWN0ZWQoZmFsc2UpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gY29uc29sZS5pbmZvKGBSYWRpb0dyb3VwVHJlZU5vZGUuY2hpbGRTZWxlY3RlZCBkaXNwYXRjaCAke25vZGUuZGF0YS5uYW1lfWApO1xyXG4gICAgICAgICAgICB0aGlzLm9uU2VsZWN0aW9uQ2hhbmdlLmRpc3BhdGNoKG5vZGUsIFNlbGVjdGlvblN0YXR1cy5TRUxFQ1RFRCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5cclxuXHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19zcHJlYWRBcnJheXMgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXlzKSB8fCBmdW5jdGlvbiAoKSB7XHJcbiAgICBmb3IgKHZhciBzID0gMCwgaSA9IDAsIGlsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHMgKz0gYXJndW1lbnRzW2ldLmxlbmd0aDtcclxuICAgIGZvciAodmFyIHIgPSBBcnJheShzKSwgayA9IDAsIGkgPSAwOyBpIDwgaWw7IGkrKylcclxuICAgICAgICBmb3IgKHZhciBhID0gYXJndW1lbnRzW2ldLCBqID0gMCwgamwgPSBhLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsrKylcclxuICAgICAgICAgICAgcltrXSA9IGFbal07XHJcbiAgICByZXR1cm4gcjtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLkRpc3BhdGNoZXJXcmFwcGVyID0gZXhwb3J0cy5FdmVudExpc3RCYXNlID0gZXhwb3J0cy5EaXNwYXRjaGVyQmFzZSA9IHZvaWQgMDtcclxudmFyIG1hbmFnZW1lbnRfMSA9IHJlcXVpcmUoXCIuL21hbmFnZW1lbnRcIik7XHJcbnZhciBzdWJzY3JpcHRpb25fMSA9IHJlcXVpcmUoXCIuL3N1YnNjcmlwdGlvblwiKTtcclxuLyoqXHJcbiAqIEJhc2UgY2xhc3MgZm9yIGltcGxlbWVudGF0aW9uIG9mIHRoZSBkaXNwYXRjaGVyLiBJdCBmYWNpbGl0YXRlcyB0aGUgc3Vic2NyaWJlXHJcbiAqIGFuZCB1bnN1YnNjcmliZSBtZXRob2RzIGJhc2VkIG9uIGdlbmVyaWMgaGFuZGxlcnMuIFRoZSBURXZlbnRUeXBlIHNwZWNpZmllc1xyXG4gKiB0aGUgdHlwZSBvZiBldmVudCB0aGF0IHNob3VsZCBiZSBleHBvc2VkLiBVc2UgdGhlIGFzRXZlbnQgdG8gZXhwb3NlIHRoZVxyXG4gKiBkaXNwYXRjaGVyIGFzIGV2ZW50LlxyXG4gKi9cclxudmFyIERpc3BhdGNoZXJCYXNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRGlzcGF0Y2hlckJhc2UoKSB7XHJcbiAgICAgICAgdGhpcy5fd3JhcCA9IG5ldyBEaXNwYXRjaGVyV3JhcHBlcih0aGlzKTtcclxuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb25zID0gbmV3IEFycmF5KCk7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGlzcGF0Y2hlckJhc2UucHJvdG90eXBlLCBcImNvdW50XCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2Ygc3Vic2NyaXB0aW9ucy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZWFkb25seVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlck9mIERpc3BhdGNoZXJCYXNlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdWJzY3JpcHRpb25zLmxlbmd0aDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICAvKipcclxuICAgICAqIFN1YnNjcmliZSB0byB0aGUgZXZlbnQgZGlzcGF0Y2hlci5cclxuICAgICAqIEBwYXJhbSBmbiBUaGUgZXZlbnQgaGFuZGxlciB0aGF0IGlzIGNhbGxlZCB3aGVuIHRoZSBldmVudCBpcyBkaXNwYXRjaGVkLlxyXG4gICAgICogQHJldHVybnMgQSBmdW5jdGlvbiB0aGF0IHVuc3Vic2NyaWJlcyB0aGUgZXZlbnQgaGFuZGxlciBmcm9tIHRoZSBldmVudC5cclxuICAgICAqL1xyXG4gICAgRGlzcGF0Y2hlckJhc2UucHJvdG90eXBlLnN1YnNjcmliZSA9IGZ1bmN0aW9uIChmbikge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKGZuKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbnMucHVzaChuZXcgc3Vic2NyaXB0aW9uXzEuU3Vic2NyaXB0aW9uKGZuLCBmYWxzZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBfdGhpcy51bnN1YnNjcmliZShmbik7XHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFN1YnNjcmliZSB0byB0aGUgZXZlbnQgZGlzcGF0Y2hlci5cclxuICAgICAqIEBwYXJhbSBmbiBUaGUgZXZlbnQgaGFuZGxlciB0aGF0IGlzIGNhbGxlZCB3aGVuIHRoZSBldmVudCBpcyBkaXNwYXRjaGVkLlxyXG4gICAgICogQHJldHVybnMgQSBmdW5jdGlvbiB0aGF0IHVuc3Vic2NyaWJlcyB0aGUgZXZlbnQgaGFuZGxlciBmcm9tIHRoZSBldmVudC5cclxuICAgICAqL1xyXG4gICAgRGlzcGF0Y2hlckJhc2UucHJvdG90eXBlLnN1YiA9IGZ1bmN0aW9uIChmbikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnN1YnNjcmliZShmbik7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBTdWJzY3JpYmUgb25jZSB0byB0aGUgZXZlbnQgd2l0aCB0aGUgc3BlY2lmaWVkIG5hbWUuXHJcbiAgICAgKiBAcGFyYW0gZm4gVGhlIGV2ZW50IGhhbmRsZXIgdGhhdCBpcyBjYWxsZWQgd2hlbiB0aGUgZXZlbnQgaXMgZGlzcGF0Y2hlZC5cclxuICAgICAqIEByZXR1cm5zIEEgZnVuY3Rpb24gdGhhdCB1bnN1YnNjcmliZXMgdGhlIGV2ZW50IGhhbmRsZXIgZnJvbSB0aGUgZXZlbnQuXHJcbiAgICAgKi9cclxuICAgIERpc3BhdGNoZXJCYXNlLnByb3RvdHlwZS5vbmUgPSBmdW5jdGlvbiAoZm4pIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmIChmbikge1xyXG4gICAgICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb25zLnB1c2gobmV3IHN1YnNjcmlwdGlvbl8xLlN1YnNjcmlwdGlvbihmbiwgdHJ1ZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBfdGhpcy51bnN1YnNjcmliZShmbik7XHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyBpdCB0aGUgZXZlbnQgaGFzIGEgc3Vic2NyaXB0aW9uIGZvciB0aGUgc3BlY2lmaWVkIGhhbmRsZXIuXHJcbiAgICAgKiBAcGFyYW0gZm4gVGhlIGV2ZW50IGhhbmRsZXIuXHJcbiAgICAgKi9cclxuICAgIERpc3BhdGNoZXJCYXNlLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiAoZm4pIHtcclxuICAgICAgICBpZiAoIWZuKVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N1YnNjcmlwdGlvbnMuc29tZShmdW5jdGlvbiAoc3ViKSB7IHJldHVybiBzdWIuaGFuZGxlciA9PSBmbjsgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBVbnN1YnNjcmliZXMgdGhlIGhhbmRsZXIgZnJvbSB0aGUgZGlzcGF0Y2hlci5cclxuICAgICAqIEBwYXJhbSBmbiBUaGUgZXZlbnQgaGFuZGxlci5cclxuICAgICAqL1xyXG4gICAgRGlzcGF0Y2hlckJhc2UucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKGZuKSB7XHJcbiAgICAgICAgaWYgKCFmbilcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fc3Vic2NyaXB0aW9ucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fc3Vic2NyaXB0aW9uc1tpXS5oYW5kbGVyID09IGZuKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb25zLnNwbGljZShpLCAxKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogVW5zdWJzY3JpYmVzIHRoZSBoYW5kbGVyIGZyb20gdGhlIGRpc3BhdGNoZXIuXHJcbiAgICAgKiBAcGFyYW0gZm4gVGhlIGV2ZW50IGhhbmRsZXIuXHJcbiAgICAgKi9cclxuICAgIERpc3BhdGNoZXJCYXNlLnByb3RvdHlwZS51bnN1YiA9IGZ1bmN0aW9uIChmbikge1xyXG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmUoZm4pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogR2VuZXJpYyBkaXNwYXRjaCB3aWxsIGRpc3BhdGNoIHRoZSBoYW5kbGVycyB3aXRoIHRoZSBnaXZlbiBhcmd1bWVudHMuXHJcbiAgICAgKlxyXG4gICAgICogQHByb3RlY3RlZFxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBleGVjdXRlQXN5bmMgVHJ1ZSBpZiB0aGUgZXZlbiBzaG91bGQgYmUgZXhlY3V0ZWQgYXN5bmMuXHJcbiAgICAgKiBAcGFyYW0geyp9IFRoZSBzY29wZSB0aGUgc2NvcGUgb2YgdGhlIGV2ZW50LiBUaGUgc2NvcGUgYmVjb21lcyB0aGUgXCJ0aGlzXCIgZm9yIGhhbmRsZXIuXHJcbiAgICAgKiBAcGFyYW0ge0lBcmd1bWVudHN9IGFyZ3MgVGhlIGFyZ3VtZW50cyBmb3IgdGhlIGV2ZW50LlxyXG4gICAgICovXHJcbiAgICBEaXNwYXRjaGVyQmFzZS5wcm90b3R5cGUuX2Rpc3BhdGNoID0gZnVuY3Rpb24gKGV4ZWN1dGVBc3luYywgc2NvcGUsIGFyZ3MpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKHN1Yikge1xyXG4gICAgICAgICAgICB2YXIgZXYgPSBuZXcgbWFuYWdlbWVudF8xLkV2ZW50TWFuYWdlbWVudChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy51bnN1YihzdWIuaGFuZGxlcik7IH0pO1xyXG4gICAgICAgICAgICB2YXIgbmFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzKTtcclxuICAgICAgICAgICAgbmFyZ3MucHVzaChldik7XHJcbiAgICAgICAgICAgIHN1Yi5leGVjdXRlKGV4ZWN1dGVBc3luYywgc2NvcGUsIG5hcmdzKTtcclxuICAgICAgICAgICAgLy9jbGVhbnVwIHN1YnMgdGhhdCBhcmUgbm8gbG9uZ2VyIG5lZWRlZFxyXG4gICAgICAgICAgICB0aGlzXzEuY2xlYW51cChzdWIpO1xyXG4gICAgICAgICAgICBpZiAoIWV4ZWN1dGVBc3luYyAmJiBldi5wcm9wYWdhdGlvblN0b3BwZWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBcImJyZWFrXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciB0aGlzXzEgPSB0aGlzO1xyXG4gICAgICAgIC8vZXhlY3V0ZSBvbiBhIGNvcHkgYmVjYXVzZSBvZiBidWcgIzlcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gX19zcHJlYWRBcnJheXModGhpcy5fc3Vic2NyaXB0aW9ucyk7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBzdWIgPSBfYVtfaV07XHJcbiAgICAgICAgICAgIHZhciBzdGF0ZV8xID0gX2xvb3BfMShzdWIpO1xyXG4gICAgICAgICAgICBpZiAoc3RhdGVfMSA9PT0gXCJicmVha1wiKVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQ2xlYW5zIHVwIHN1YnMgdGhhdCByYW4gYW5kIHNob3VsZCBydW4gb25seSBvbmNlLlxyXG4gICAgICovXHJcbiAgICBEaXNwYXRjaGVyQmFzZS5wcm90b3R5cGUuY2xlYW51cCA9IGZ1bmN0aW9uIChzdWIpIHtcclxuICAgICAgICBpZiAoc3ViLmlzT25jZSAmJiBzdWIuaXNFeGVjdXRlZCkge1xyXG4gICAgICAgICAgICB2YXIgaSA9IHRoaXMuX3N1YnNjcmlwdGlvbnMuaW5kZXhPZihzdWIpO1xyXG4gICAgICAgICAgICBpZiAoaSA+IC0xKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb25zLnNwbGljZShpLCAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gZXZlbnQgZnJvbSB0aGUgZGlzcGF0Y2hlci4gV2lsbCByZXR1cm4gdGhlIGRpc3BhdGNoZXJcclxuICAgICAqIGluIGEgd3JhcHBlci4gVGhpcyB3aWxsIHByZXZlbnQgZXhwb3N1cmUgb2YgYW55IGRpc3BhdGNoZXIgbWV0aG9kcy5cclxuICAgICAqL1xyXG4gICAgRGlzcGF0Y2hlckJhc2UucHJvdG90eXBlLmFzRXZlbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dyYXA7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDbGVhcnMgYWxsIHRoZSBzdWJzY3JpcHRpb25zLlxyXG4gICAgICovXHJcbiAgICBEaXNwYXRjaGVyQmFzZS5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9ucy5zcGxpY2UoMCwgdGhpcy5fc3Vic2NyaXB0aW9ucy5sZW5ndGgpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBEaXNwYXRjaGVyQmFzZTtcclxufSgpKTtcclxuZXhwb3J0cy5EaXNwYXRjaGVyQmFzZSA9IERpc3BhdGNoZXJCYXNlO1xyXG4vKipcclxuICogQmFzZSBjbGFzcyBmb3IgZXZlbnQgbGlzdHMgY2xhc3Nlcy4gSW1wbGVtZW50cyB0aGUgZ2V0IGFuZCByZW1vdmUuXHJcbiAqL1xyXG52YXIgRXZlbnRMaXN0QmFzZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEV2ZW50TGlzdEJhc2UoKSB7XHJcbiAgICAgICAgdGhpcy5fZXZlbnRzID0ge307XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIGRpc3BhdGNoZXIgYXNzb2NpYXRlZCB3aXRoIHRoZSBuYW1lLlxyXG4gICAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50LlxyXG4gICAgICovXHJcbiAgICBFdmVudExpc3RCYXNlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgIHZhciBldmVudCA9IHRoaXMuX2V2ZW50c1tuYW1lXTtcclxuICAgICAgICBpZiAoZXZlbnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGV2ZW50O1xyXG4gICAgICAgIH1cclxuICAgICAgICBldmVudCA9IHRoaXMuY3JlYXRlRGlzcGF0Y2hlcigpO1xyXG4gICAgICAgIHRoaXMuX2V2ZW50c1tuYW1lXSA9IGV2ZW50O1xyXG4gICAgICAgIHJldHVybiBldmVudDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgdGhlIGRpc3BhdGNoZXIgYXNzb2NpYXRlZCB3aXRoIHRoZSBuYW1lLlxyXG4gICAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50LlxyXG4gICAgICovXHJcbiAgICBFdmVudExpc3RCYXNlLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbbmFtZV07XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEV2ZW50TGlzdEJhc2U7XHJcbn0oKSk7XHJcbmV4cG9ydHMuRXZlbnRMaXN0QmFzZSA9IEV2ZW50TGlzdEJhc2U7XHJcbi8qKlxyXG4gKiBIaWRlcyB0aGUgaW1wbGVtZW50YXRpb24gb2YgdGhlIGV2ZW50IGRpc3BhdGNoZXIuIFdpbGwgZXhwb3NlIG1ldGhvZHMgdGhhdFxyXG4gKiBhcmUgcmVsZXZlbnQgdG8gdGhlIGV2ZW50LlxyXG4gKi9cclxudmFyIERpc3BhdGNoZXJXcmFwcGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IEV2ZW50RGlzcGF0Y2hlcldyYXBwZXIgaW5zdGFuY2UuXHJcbiAgICAgKiBAcGFyYW0gZGlzcGF0Y2hlciBUaGUgZGlzcGF0Y2hlci5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gRGlzcGF0Y2hlcldyYXBwZXIoZGlzcGF0Y2hlcikge1xyXG4gICAgICAgIHRoaXMuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChmbikgeyByZXR1cm4gZGlzcGF0Y2hlci5zdWJzY3JpYmUoZm4pOyB9O1xyXG4gICAgICAgIHRoaXMuX3Vuc3Vic2NyaWJlID0gZnVuY3Rpb24gKGZuKSB7IHJldHVybiBkaXNwYXRjaGVyLnVuc3Vic2NyaWJlKGZuKTsgfTtcclxuICAgICAgICB0aGlzLl9vbmUgPSBmdW5jdGlvbiAoZm4pIHsgcmV0dXJuIGRpc3BhdGNoZXIub25lKGZuKTsgfTtcclxuICAgICAgICB0aGlzLl9oYXMgPSBmdW5jdGlvbiAoZm4pIHsgcmV0dXJuIGRpc3BhdGNoZXIuaGFzKGZuKTsgfTtcclxuICAgICAgICB0aGlzLl9jbGVhciA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRpc3BhdGNoZXIuY2xlYXIoKTsgfTtcclxuICAgICAgICB0aGlzLl9jb3VudCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRpc3BhdGNoZXIuY291bnQ7IH07XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGlzcGF0Y2hlcldyYXBwZXIucHJvdG90eXBlLCBcImNvdW50XCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2Ygc3Vic2NyaXB0aW9ucy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZWFkb25seVxyXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgICAgICogQG1lbWJlck9mIERpc3BhdGNoZXJXcmFwcGVyXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb3VudCgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIC8qKlxyXG4gICAgICogU3Vic2NyaWJlIHRvIHRoZSBldmVudCBkaXNwYXRjaGVyLlxyXG4gICAgICogQHBhcmFtIGZuIFRoZSBldmVudCBoYW5kbGVyIHRoYXQgaXMgY2FsbGVkIHdoZW4gdGhlIGV2ZW50IGlzIGRpc3BhdGNoZWQuXHJcbiAgICAgKiBAcmV0dXJucyBBIGZ1bmN0aW9uIHRoYXQgdW5zdWJzY3JpYmVzIHRoZSBldmVudCBoYW5kbGVyIGZyb20gdGhlIGV2ZW50LlxyXG4gICAgICovXHJcbiAgICBEaXNwYXRjaGVyV3JhcHBlci5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24gKGZuKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N1YnNjcmliZShmbik7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBTdWJzY3JpYmUgdG8gdGhlIGV2ZW50IGRpc3BhdGNoZXIuXHJcbiAgICAgKiBAcGFyYW0gZm4gVGhlIGV2ZW50IGhhbmRsZXIgdGhhdCBpcyBjYWxsZWQgd2hlbiB0aGUgZXZlbnQgaXMgZGlzcGF0Y2hlZC5cclxuICAgICAqIEByZXR1cm5zIEEgZnVuY3Rpb24gdGhhdCB1bnN1YnNjcmliZXMgdGhlIGV2ZW50IGhhbmRsZXIgZnJvbSB0aGUgZXZlbnQuXHJcbiAgICAgKi9cclxuICAgIERpc3BhdGNoZXJXcmFwcGVyLnByb3RvdHlwZS5zdWIgPSBmdW5jdGlvbiAoZm4pIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zdWJzY3JpYmUoZm4pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogVW5zdWJzY3JpYmUgZnJvbSB0aGUgZXZlbnQgZGlzcGF0Y2hlci5cclxuICAgICAqIEBwYXJhbSBmbiBUaGUgZXZlbnQgaGFuZGxlciB0aGF0IGlzIGNhbGxlZCB3aGVuIHRoZSBldmVudCBpcyBkaXNwYXRjaGVkLlxyXG4gICAgICovXHJcbiAgICBEaXNwYXRjaGVyV3JhcHBlci5wcm90b3R5cGUudW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoZm4pIHtcclxuICAgICAgICB0aGlzLl91bnN1YnNjcmliZShmbik7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBVbnN1YnNjcmliZSBmcm9tIHRoZSBldmVudCBkaXNwYXRjaGVyLlxyXG4gICAgICogQHBhcmFtIGZuIFRoZSBldmVudCBoYW5kbGVyIHRoYXQgaXMgY2FsbGVkIHdoZW4gdGhlIGV2ZW50IGlzIGRpc3BhdGNoZWQuXHJcbiAgICAgKi9cclxuICAgIERpc3BhdGNoZXJXcmFwcGVyLnByb3RvdHlwZS51bnN1YiA9IGZ1bmN0aW9uIChmbikge1xyXG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmUoZm4pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogU3Vic2NyaWJlIG9uY2UgdG8gdGhlIGV2ZW50IHdpdGggdGhlIHNwZWNpZmllZCBuYW1lLlxyXG4gICAgICogQHBhcmFtIGZuIFRoZSBldmVudCBoYW5kbGVyIHRoYXQgaXMgY2FsbGVkIHdoZW4gdGhlIGV2ZW50IGlzIGRpc3BhdGNoZWQuXHJcbiAgICAgKi9cclxuICAgIERpc3BhdGNoZXJXcmFwcGVyLnByb3RvdHlwZS5vbmUgPSBmdW5jdGlvbiAoZm4pIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fb25lKGZuKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyBpdCB0aGUgZXZlbnQgaGFzIGEgc3Vic2NyaXB0aW9uIGZvciB0aGUgc3BlY2lmaWVkIGhhbmRsZXIuXHJcbiAgICAgKiBAcGFyYW0gZm4gVGhlIGV2ZW50IGhhbmRsZXIuXHJcbiAgICAgKi9cclxuICAgIERpc3BhdGNoZXJXcmFwcGVyLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiAoZm4pIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faGFzKGZuKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENsZWFycyBhbGwgdGhlIHN1YnNjcmlwdGlvbnMuXHJcbiAgICAgKi9cclxuICAgIERpc3BhdGNoZXJXcmFwcGVyLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLl9jbGVhcigpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBEaXNwYXRjaGVyV3JhcHBlcjtcclxufSgpKTtcclxuZXhwb3J0cy5EaXNwYXRjaGVyV3JhcHBlciA9IERpc3BhdGNoZXJXcmFwcGVyO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuLyohXHJcbiAqIFN0cm9uZ2x5IFR5cGVkIEV2ZW50cyBmb3IgVHlwZVNjcmlwdCAtIENvcmVcclxuICogaHR0cHM6Ly9naXRodWIuY29tL0tlZXNDQmFra2VyL1N0cm9ubHlUeXBlZEV2ZW50cy9cclxuICogaHR0cDovL2tlZXN0YWxrc3RlY2guY29tXHJcbiAqXHJcbiAqIENvcHlyaWdodCBLZWVzIEMuIEJha2tlciAvIEtlZXNUYWxrc1RlY2hcclxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuU3Vic2NyaXB0aW9uID0gZXhwb3J0cy5FdmVudExpc3RCYXNlID0gZXhwb3J0cy5EaXNwYXRjaGVyV3JhcHBlciA9IGV4cG9ydHMuRGlzcGF0Y2hlckJhc2UgPSB2b2lkIDA7XHJcbnZhciBkaXNwYXRjaGluZ18xID0gcmVxdWlyZShcIi4vZGlzcGF0Y2hpbmdcIik7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkRpc3BhdGNoZXJCYXNlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkaXNwYXRjaGluZ18xLkRpc3BhdGNoZXJCYXNlOyB9IH0pO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJEaXNwYXRjaGVyV3JhcHBlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZGlzcGF0Y2hpbmdfMS5EaXNwYXRjaGVyV3JhcHBlcjsgfSB9KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRXZlbnRMaXN0QmFzZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZGlzcGF0Y2hpbmdfMS5FdmVudExpc3RCYXNlOyB9IH0pO1xyXG52YXIgc3Vic2NyaXB0aW9uXzEgPSByZXF1aXJlKFwiLi9zdWJzY3JpcHRpb25cIik7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlN1YnNjcmlwdGlvblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc3Vic2NyaXB0aW9uXzEuU3Vic2NyaXB0aW9uOyB9IH0pO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLkV2ZW50TWFuYWdlbWVudCA9IHZvaWQgMDtcclxuLyoqXHJcbiAqIEFsbG93cyB0aGUgdXNlciB0byBpbnRlcmFjdCB3aXRoIHRoZSBldmVudC5cclxuICpcclxuICogQGNsYXNzIEV2ZW50TWFuYWdlbWVudFxyXG4gKiBAaW1wbGVtZW50cyB7SUV2ZW50TWFuYWdlbWVudH1cclxuICovXHJcbnZhciBFdmVudE1hbmFnZW1lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBFdmVudE1hbmFnZW1lbnQodW5zdWIpIHtcclxuICAgICAgICB0aGlzLnVuc3ViID0gdW5zdWI7XHJcbiAgICAgICAgdGhpcy5wcm9wYWdhdGlvblN0b3BwZWQgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIEV2ZW50TWFuYWdlbWVudC5wcm90b3R5cGUuc3RvcFByb3BhZ2F0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMucHJvcGFnYXRpb25TdG9wcGVkID0gdHJ1ZTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRXZlbnRNYW5hZ2VtZW50O1xyXG59KCkpO1xyXG5leHBvcnRzLkV2ZW50TWFuYWdlbWVudCA9IEV2ZW50TWFuYWdlbWVudDtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5TdWJzY3JpcHRpb24gPSB2b2lkIDA7XHJcbi8qKlxyXG4gKiBTdG9yZXMgYSBoYW5kbGVyLiBNYW5hZ2VzIGV4ZWN1dGlvbiBtZXRhIGRhdGEuXHJcbiAqIEBjbGFzcyBTdWJzY3JpcHRpb25cclxuICogQHRlbXBsYXRlIFRFdmVudEhhbmRsZXJcclxuICovXHJcbnZhciBTdWJzY3JpcHRpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgU3Vic2NyaXB0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7VEV2ZW50SGFuZGxlcn0gaGFuZGxlciBUaGUgaGFuZGxlciBmb3IgdGhlIHN1YnNjcmlwdGlvbi5cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNPbmNlIEluZGljYXRlcyBpZiB0aGUgaGFuZGxlciBzaG91bGQgb25seSBiZSBleGVjdXRlZCBvbmNlLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBTdWJzY3JpcHRpb24oaGFuZGxlciwgaXNPbmNlKSB7XHJcbiAgICAgICAgdGhpcy5oYW5kbGVyID0gaGFuZGxlcjtcclxuICAgICAgICB0aGlzLmlzT25jZSA9IGlzT25jZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbmRpY2F0ZXMgaWYgdGhlIHN1YnNjcmlwdGlvbiBoYXMgYmVlbiBleGVjdXRlZCBiZWZvcmUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5pc0V4ZWN1dGVkID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEV4ZWN1dGVzIHRoZSBoYW5kbGVyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZXhlY3V0ZUFzeW5jIFRydWUgaWYgdGhlIGV2ZW4gc2hvdWxkIGJlIGV4ZWN1dGVkIGFzeW5jLlxyXG4gICAgICogQHBhcmFtIHsqfSBzY29wZSBUaGUgc2NvcGUgdGhlIHNjb3BlIG9mIHRoZSBldmVudC5cclxuICAgICAqIEBwYXJhbSB7SUFyZ3VtZW50c30gYXJncyBUaGUgYXJndW1lbnRzIGZvciB0aGUgZXZlbnQuXHJcbiAgICAgKi9cclxuICAgIFN1YnNjcmlwdGlvbi5wcm90b3R5cGUuZXhlY3V0ZSA9IGZ1bmN0aW9uIChleGVjdXRlQXN5bmMsIHNjb3BlLCBhcmdzKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmlzT25jZSB8fCAhdGhpcy5pc0V4ZWN1dGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaXNFeGVjdXRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIHZhciBmbiA9IHRoaXMuaGFuZGxlcjtcclxuICAgICAgICAgICAgaWYgKGV4ZWN1dGVBc3luYykge1xyXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm4uYXBwbHkoc2NvcGUsIGFyZ3MpO1xyXG4gICAgICAgICAgICAgICAgfSwgMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBmbi5hcHBseShzY29wZSwgYXJncyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFN1YnNjcmlwdGlvbjtcclxufSgpKTtcclxuZXhwb3J0cy5TdWJzY3JpcHRpb24gPSBTdWJzY3JpcHRpb247XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9O1xyXG59KSgpO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuRXZlbnRIYW5kbGluZ0Jhc2UgPSBleHBvcnRzLkV2ZW50TGlzdCA9IGV4cG9ydHMuTm9uVW5pZm9ybUV2ZW50TGlzdCA9IGV4cG9ydHMuRXZlbnREaXNwYXRjaGVyID0gdm9pZCAwO1xyXG52YXIgc3RlX2NvcmVfMSA9IHJlcXVpcmUoXCJzdGUtY29yZVwiKTtcclxuLyoqXHJcbiAqIERpc3BhdGNoZXIgaW1wbGVtZW50YXRpb24gZm9yIGV2ZW50cy4gQ2FuIGJlIHVzZWQgdG8gc3Vic2NyaWJlLCB1bnN1YnNjcmliZVxyXG4gKiBvciBkaXNwYXRjaCBldmVudHMuIFVzZSB0aGUgVG9FdmVudCgpIG1ldGhvZCB0byBleHBvc2UgdGhlIGV2ZW50LlxyXG4gKi9cclxudmFyIEV2ZW50RGlzcGF0Y2hlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhFdmVudERpc3BhdGNoZXIsIF9zdXBlcik7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgRXZlbnREaXNwYXRjaGVyIGluc3RhbmNlLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBFdmVudERpc3BhdGNoZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERpc3BhdGNoZXMgdGhlIGV2ZW50LlxyXG4gICAgICogQHBhcmFtIHNlbmRlciBUaGUgc2VuZGVyLlxyXG4gICAgICogQHBhcmFtIGFyZ3MgVGhlIGFyZ3VtZW50cyBvYmplY3QuXHJcbiAgICAgKi9cclxuICAgIEV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuZGlzcGF0Y2ggPSBmdW5jdGlvbiAoc2VuZGVyLCBhcmdzKSB7XHJcbiAgICAgICAgdGhpcy5fZGlzcGF0Y2goZmFsc2UsIHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBEaXNwYXRjaGVzIHRoZSBldmVudHMgdGhyZWFkLlxyXG4gICAgICogQHBhcmFtIHNlbmRlciBUaGUgc2VuZGVyLlxyXG4gICAgICogQHBhcmFtIGFyZ3MgVGhlIGFyZ3VtZW50cyBvYmplY3QuXHJcbiAgICAgKi9cclxuICAgIEV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuZGlzcGF0Y2hBc3luYyA9IGZ1bmN0aW9uIChzZW5kZXIsIGFyZ3MpIHtcclxuICAgICAgICB0aGlzLl9kaXNwYXRjaCh0cnVlLCB0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBldmVudCBmcm9tIHRoZSBkaXNwYXRjaGVyLiBXaWxsIHJldHVybiB0aGUgZGlzcGF0Y2hlclxyXG4gICAgICogaW4gYSB3cmFwcGVyLiBUaGlzIHdpbGwgcHJldmVudCBleHBvc3VyZSBvZiBhbnkgZGlzcGF0Y2hlciBtZXRob2RzLlxyXG4gICAgICovXHJcbiAgICBFdmVudERpc3BhdGNoZXIucHJvdG90eXBlLmFzRXZlbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuYXNFdmVudC5jYWxsKHRoaXMpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBFdmVudERpc3BhdGNoZXI7XHJcbn0oc3RlX2NvcmVfMS5EaXNwYXRjaGVyQmFzZSkpO1xyXG5leHBvcnRzLkV2ZW50RGlzcGF0Y2hlciA9IEV2ZW50RGlzcGF0Y2hlcjtcclxuLyoqXHJcbiAqIFNpbWlsYXIgdG8gRXZlbnRMaXN0LCBidXQgaW5zdGVhZCBvZiBUQXJncywgYSBtYXAgb2YgZXZlbnQgbmFtZXMgYW5nIGFyZ3VtZW50IHR5cGVzIGlzIHByb3ZpZGVkIHdpdGggVEFyZ3NNYXAuXHJcbiAqL1xyXG52YXIgTm9uVW5pZm9ybUV2ZW50TGlzdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIE5vblVuaWZvcm1FdmVudExpc3QoKSB7XHJcbiAgICAgICAgdGhpcy5fZXZlbnRzID0ge307XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIGRpc3BhdGNoZXIgYXNzb2NpYXRlZCB3aXRoIHRoZSBuYW1lLlxyXG4gICAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50LlxyXG4gICAgICovXHJcbiAgICBOb25Vbmlmb3JtRXZlbnRMaXN0LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgIGlmICh0aGlzLl9ldmVudHNbbmFtZV0pIHtcclxuICAgICAgICAgICAgLy8gQFRPRE8gYXZvaWQgdHlwZWNhc3RpbmcuIE5vdCBzdXJlIHdoeSBUUyB0aGlua3MgdGhpcy5fZXZlbnRzW25hbWVdIGNvdWxkIHN0aWxsIGJlIHVuZGVmaW5lZC5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2V2ZW50c1tuYW1lXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGV2ZW50ID0gdGhpcy5jcmVhdGVEaXNwYXRjaGVyKCk7XHJcbiAgICAgICAgdGhpcy5fZXZlbnRzW25hbWVdID0gZXZlbnQ7XHJcbiAgICAgICAgcmV0dXJuIGV2ZW50O1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyB0aGUgZGlzcGF0Y2hlciBhc3NvY2lhdGVkIHdpdGggdGhlIG5hbWUuXHJcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQuXHJcbiAgICAgKi9cclxuICAgIE5vblVuaWZvcm1FdmVudExpc3QucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1tuYW1lXTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgZGlzcGF0Y2hlciBpbnN0YW5jZS5cclxuICAgICAqL1xyXG4gICAgTm9uVW5pZm9ybUV2ZW50TGlzdC5wcm90b3R5cGUuY3JlYXRlRGlzcGF0Y2hlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEV2ZW50RGlzcGF0Y2hlcigpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBOb25Vbmlmb3JtRXZlbnRMaXN0O1xyXG59KCkpO1xyXG5leHBvcnRzLk5vblVuaWZvcm1FdmVudExpc3QgPSBOb25Vbmlmb3JtRXZlbnRMaXN0O1xyXG4vKipcclxuICogU3RvcmFnZSBjbGFzcyBmb3IgbXVsdGlwbGUgZXZlbnRzIHRoYXQgYXJlIGFjY2Vzc2libGUgYnkgbmFtZS5cclxuICogRXZlbnRzIGRpc3BhdGNoZXJzIGFyZSBhdXRvbWF0aWNhbGx5IGNyZWF0ZWQuXHJcbiAqL1xyXG52YXIgRXZlbnRMaXN0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEV2ZW50TGlzdCwgX3N1cGVyKTtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBFdmVudExpc3QgaW5zdGFuY2UuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIEV2ZW50TGlzdCgpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBkaXNwYXRjaGVyIGluc3RhbmNlLlxyXG4gICAgICovXHJcbiAgICBFdmVudExpc3QucHJvdG90eXBlLmNyZWF0ZURpc3BhdGNoZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBFdmVudERpc3BhdGNoZXIoKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRXZlbnRMaXN0O1xyXG59KHN0ZV9jb3JlXzEuRXZlbnRMaXN0QmFzZSkpO1xyXG5leHBvcnRzLkV2ZW50TGlzdCA9IEV2ZW50TGlzdDtcclxuLyoqXHJcbiAqIEV4dGVuZHMgb2JqZWN0cyB3aXRoIGV2ZW50IGhhbmRsaW5nIGNhcGFiaWxpdGllcy5cclxuICovXHJcbnZhciBFdmVudEhhbmRsaW5nQmFzZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEV2ZW50SGFuZGxpbmdCYXNlKCkge1xyXG4gICAgICAgIHRoaXMuX2V2ZW50cyA9IG5ldyBFdmVudExpc3QoKTtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEhhbmRsaW5nQmFzZS5wcm90b3R5cGUsIFwiZXZlbnRzXCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIHRoZSBsaXN0IHdpdGggYWxsIHRoZSBldmVudCBkaXNwYXRjaGVycy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2V2ZW50cztcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICAvKipcclxuICAgICAqIFN1YnNjcmliZXMgdG8gdGhlIGV2ZW50IHdpdGggdGhlIHNwZWNpZmllZCBuYW1lLlxyXG4gICAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50LlxyXG4gICAgICogQHBhcmFtIGZuIFRoZSBldmVudCBoYW5kbGVyLlxyXG4gICAgICovXHJcbiAgICBFdmVudEhhbmRsaW5nQmFzZS5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24gKG5hbWUsIGZuKSB7XHJcbiAgICAgICAgdGhpcy5fZXZlbnRzLmdldChuYW1lKS5zdWJzY3JpYmUoZm4pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogU3Vic2NyaWJlcyB0byB0aGUgZXZlbnQgd2l0aCB0aGUgc3BlY2lmaWVkIG5hbWUuXHJcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQuXHJcbiAgICAgKiBAcGFyYW0gZm4gVGhlIGV2ZW50IGhhbmRsZXIuXHJcbiAgICAgKi9cclxuICAgIEV2ZW50SGFuZGxpbmdCYXNlLnByb3RvdHlwZS5zdWIgPSBmdW5jdGlvbiAobmFtZSwgZm4pIHtcclxuICAgICAgICB0aGlzLnN1YnNjcmliZShuYW1lLCBmbik7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBVbnN1YnNjcmliZXMgZnJvbSB0aGUgZXZlbnQgd2l0aCB0aGUgc3BlY2lmaWVkIG5hbWUuXHJcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQuXHJcbiAgICAgKiBAcGFyYW0gZm4gVGhlIGV2ZW50IGhhbmRsZXIuXHJcbiAgICAgKi9cclxuICAgIEV2ZW50SGFuZGxpbmdCYXNlLnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uIChuYW1lLCBmbikge1xyXG4gICAgICAgIHRoaXMuX2V2ZW50cy5nZXQobmFtZSkudW5zdWJzY3JpYmUoZm4pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogVW5zdWJzY3JpYmVzIGZyb20gdGhlIGV2ZW50IHdpdGggdGhlIHNwZWNpZmllZCBuYW1lLlxyXG4gICAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50LlxyXG4gICAgICogQHBhcmFtIGZuIFRoZSBldmVudCBoYW5kbGVyLlxyXG4gICAgICovXHJcbiAgICBFdmVudEhhbmRsaW5nQmFzZS5wcm90b3R5cGUudW5zdWIgPSBmdW5jdGlvbiAobmFtZSwgZm4pIHtcclxuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKG5hbWUsIGZuKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFN1YnNjcmliZXMgdG8gb25jZSB0aGUgZXZlbnQgd2l0aCB0aGUgc3BlY2lmaWVkIG5hbWUuXHJcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQuXHJcbiAgICAgKiBAcGFyYW0gZm4gVGhlIGV2ZW50IGhhbmRsZXIuXHJcbiAgICAgKi9cclxuICAgIEV2ZW50SGFuZGxpbmdCYXNlLnByb3RvdHlwZS5vbmUgPSBmdW5jdGlvbiAobmFtZSwgZm4pIHtcclxuICAgICAgICB0aGlzLl9ldmVudHMuZ2V0KG5hbWUpLm9uZShmbik7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBTdWJzY3JpYmVzIHRvIG9uY2UgdGhlIGV2ZW50IHdpdGggdGhlIHNwZWNpZmllZCBuYW1lLlxyXG4gICAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50LlxyXG4gICAgICogQHBhcmFtIGZuIFRoZSBldmVudCBoYW5kbGVyLlxyXG4gICAgICovXHJcbiAgICBFdmVudEhhbmRsaW5nQmFzZS5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gKG5hbWUsIGZuKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2V2ZW50cy5nZXQobmFtZSkuaGFzKGZuKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRXZlbnRIYW5kbGluZ0Jhc2U7XHJcbn0oKSk7XHJcbmV4cG9ydHMuRXZlbnRIYW5kbGluZ0Jhc2UgPSBFdmVudEhhbmRsaW5nQmFzZTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5Ob25Vbmlmb3JtRXZlbnRMaXN0ID0gZXhwb3J0cy5FdmVudExpc3QgPSBleHBvcnRzLkV2ZW50SGFuZGxpbmdCYXNlID0gZXhwb3J0cy5FdmVudERpc3BhdGNoZXIgPSB2b2lkIDA7XHJcbnZhciBldmVudHNfMSA9IHJlcXVpcmUoXCIuL2V2ZW50c1wiKTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRXZlbnREaXNwYXRjaGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBldmVudHNfMS5FdmVudERpc3BhdGNoZXI7IH0gfSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkV2ZW50SGFuZGxpbmdCYXNlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBldmVudHNfMS5FdmVudEhhbmRsaW5nQmFzZTsgfSB9KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRXZlbnRMaXN0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBldmVudHNfMS5FdmVudExpc3Q7IH0gfSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5vblVuaWZvcm1FdmVudExpc3RcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGV2ZW50c18xLk5vblVuaWZvcm1FdmVudExpc3Q7IH0gfSk7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuU2lnbmFsTGlzdCA9IGV4cG9ydHMuU2lnbmFsSGFuZGxpbmdCYXNlID0gZXhwb3J0cy5TaWduYWxEaXNwYXRjaGVyID0gdm9pZCAwO1xyXG52YXIgc2lnbmFsc18xID0gcmVxdWlyZShcIi4vc2lnbmFsc1wiKTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU2lnbmFsRGlzcGF0Y2hlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2lnbmFsc18xLlNpZ25hbERpc3BhdGNoZXI7IH0gfSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNpZ25hbEhhbmRsaW5nQmFzZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2lnbmFsc18xLlNpZ25hbEhhbmRsaW5nQmFzZTsgfSB9KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU2lnbmFsTGlzdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2lnbmFsc18xLlNpZ25hbExpc3Q7IH0gfSk7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9O1xyXG59KSgpO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuU2lnbmFsSGFuZGxpbmdCYXNlID0gZXhwb3J0cy5TaWduYWxMaXN0ID0gZXhwb3J0cy5TaWduYWxEaXNwYXRjaGVyID0gdm9pZCAwO1xyXG52YXIgc3RlX2NvcmVfMSA9IHJlcXVpcmUoXCJzdGUtY29yZVwiKTtcclxuLyoqXHJcbiAqIFRoZSBkaXNwYXRjaGVyIGhhbmRsZXMgdGhlIHN0b3JhZ2Ugb2Ygc3Vic2NpcHRpb25zIGFuZCBmYWNpbGl0YXRlc1xyXG4gKiBzdWJzY3JpcHRpb24sIHVuc3Vic2NyaXB0aW9uIGFuZCBkaXNwYXRjaGluZyBvZiBhIHNpZ25hbCBldmVudC5cclxuICovXHJcbnZhciBTaWduYWxEaXNwYXRjaGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFNpZ25hbERpc3BhdGNoZXIsIF9zdXBlcik7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgU2lnbmFsRGlzcGF0Y2hlciBpbnN0YW5jZS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gU2lnbmFsRGlzcGF0Y2hlcigpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRGlzcGF0Y2hlcyB0aGUgc2lnbmFsLlxyXG4gICAgICovXHJcbiAgICBTaWduYWxEaXNwYXRjaGVyLnByb3RvdHlwZS5kaXNwYXRjaCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLl9kaXNwYXRjaChmYWxzZSwgdGhpcywgYXJndW1lbnRzKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIERpc3BhdGNoZXMgdGhlIHNpZ25hbCB0aHJlYWRlZC5cclxuICAgICAqL1xyXG4gICAgU2lnbmFsRGlzcGF0Y2hlci5wcm90b3R5cGUuZGlzcGF0Y2hBc3luYyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLl9kaXNwYXRjaCh0cnVlLCB0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBldmVudCBmcm9tIHRoZSBkaXNwYXRjaGVyLiBXaWxsIHJldHVybiB0aGUgZGlzcGF0Y2hlclxyXG4gICAgICogaW4gYSB3cmFwcGVyLiBUaGlzIHdpbGwgcHJldmVudCBleHBvc3VyZSBvZiBhbnkgZGlzcGF0Y2hlciBtZXRob2RzLlxyXG4gICAgICovXHJcbiAgICBTaWduYWxEaXNwYXRjaGVyLnByb3RvdHlwZS5hc0V2ZW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLmFzRXZlbnQuY2FsbCh0aGlzKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gU2lnbmFsRGlzcGF0Y2hlcjtcclxufShzdGVfY29yZV8xLkRpc3BhdGNoZXJCYXNlKSk7XHJcbmV4cG9ydHMuU2lnbmFsRGlzcGF0Y2hlciA9IFNpZ25hbERpc3BhdGNoZXI7XHJcbi8qKlxyXG4gKiBTdG9yYWdlIGNsYXNzIGZvciBtdWx0aXBsZSBzaWduYWwgZXZlbnRzIHRoYXQgYXJlIGFjY2Vzc2libGUgYnkgbmFtZS5cclxuICogRXZlbnRzIGRpc3BhdGNoZXJzIGFyZSBhdXRvbWF0aWNhbGx5IGNyZWF0ZWQuXHJcbiAqL1xyXG52YXIgU2lnbmFsTGlzdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhTaWduYWxMaXN0LCBfc3VwZXIpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFNpZ25hbExpc3QgaW5zdGFuY2UuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIFNpZ25hbExpc3QoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgZGlzcGF0Y2hlciBpbnN0YW5jZS5cclxuICAgICAqL1xyXG4gICAgU2lnbmFsTGlzdC5wcm90b3R5cGUuY3JlYXRlRGlzcGF0Y2hlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFNpZ25hbERpc3BhdGNoZXIoKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gU2lnbmFsTGlzdDtcclxufShzdGVfY29yZV8xLkV2ZW50TGlzdEJhc2UpKTtcclxuZXhwb3J0cy5TaWduYWxMaXN0ID0gU2lnbmFsTGlzdDtcclxuLyoqXHJcbiAqIEV4dGVuZHMgb2JqZWN0cyB3aXRoIHNpZ25hbCBldmVudCBoYW5kbGluZyBjYXBhYmlsaXRpZXMuXHJcbiAqL1xyXG52YXIgU2lnbmFsSGFuZGxpbmdCYXNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gU2lnbmFsSGFuZGxpbmdCYXNlKCkge1xyXG4gICAgICAgIHRoaXMuX2V2ZW50cyA9IG5ldyBTaWduYWxMaXN0KCk7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2lnbmFsSGFuZGxpbmdCYXNlLnByb3RvdHlwZSwgXCJldmVudHNcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZXZlbnRzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIC8qKlxyXG4gICAgICogU3Vic2NyaWJlcyBvbmNlIHRvIHRoZSBldmVudCB3aXRoIHRoZSBzcGVjaWZpZWQgbmFtZS5cclxuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudC5cclxuICAgICAqIEBwYXJhbSBmbiBUaGUgZXZlbnQgaGFuZGxlci5cclxuICAgICAqL1xyXG4gICAgU2lnbmFsSGFuZGxpbmdCYXNlLnByb3RvdHlwZS5vbmUgPSBmdW5jdGlvbiAobmFtZSwgZm4pIHtcclxuICAgICAgICB0aGlzLl9ldmVudHMuZ2V0KG5hbWUpLm9uZShmbik7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3MgaXQgdGhlIGV2ZW50IGhhcyBhIHN1YnNjcmlwdGlvbiBmb3IgdGhlIHNwZWNpZmllZCBoYW5kbGVyLlxyXG4gICAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50LlxyXG4gICAgICogQHBhcmFtIGZuIFRoZSBldmVudCBoYW5kbGVyLlxyXG4gICAgICovXHJcbiAgICBTaWduYWxIYW5kbGluZ0Jhc2UucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIChuYW1lLCBmbikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9ldmVudHMuZ2V0KG5hbWUpLmhhcyhmbik7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBTdWJzY3JpYmVzIHRvIHRoZSBldmVudCB3aXRoIHRoZSBzcGVjaWZpZWQgbmFtZS5cclxuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudC5cclxuICAgICAqIEBwYXJhbSBmbiBUaGUgZXZlbnQgaGFuZGxlci5cclxuICAgICAqL1xyXG4gICAgU2lnbmFsSGFuZGxpbmdCYXNlLnByb3RvdHlwZS5zdWJzY3JpYmUgPSBmdW5jdGlvbiAobmFtZSwgZm4pIHtcclxuICAgICAgICB0aGlzLl9ldmVudHMuZ2V0KG5hbWUpLnN1YnNjcmliZShmbik7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBTdWJzY3JpYmVzIHRvIHRoZSBldmVudCB3aXRoIHRoZSBzcGVjaWZpZWQgbmFtZS5cclxuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudC5cclxuICAgICAqIEBwYXJhbSBmbiBUaGUgZXZlbnQgaGFuZGxlci5cclxuICAgICAqL1xyXG4gICAgU2lnbmFsSGFuZGxpbmdCYXNlLnByb3RvdHlwZS5zdWIgPSBmdW5jdGlvbiAobmFtZSwgZm4pIHtcclxuICAgICAgICB0aGlzLnN1YnNjcmliZShuYW1lLCBmbik7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBVbnN1YnNjcmliZXMgZnJvbSB0aGUgZXZlbnQgd2l0aCB0aGUgc3BlY2lmaWVkIG5hbWUuXHJcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQuXHJcbiAgICAgKiBAcGFyYW0gZm4gVGhlIGV2ZW50IGhhbmRsZXIuXHJcbiAgICAgKi9cclxuICAgIFNpZ25hbEhhbmRsaW5nQmFzZS5wcm90b3R5cGUudW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAobmFtZSwgZm4pIHtcclxuICAgICAgICB0aGlzLl9ldmVudHMuZ2V0KG5hbWUpLnVuc3Vic2NyaWJlKGZuKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFVuc3Vic2NyaWJlcyBmcm9tIHRoZSBldmVudCB3aXRoIHRoZSBzcGVjaWZpZWQgbmFtZS5cclxuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudC5cclxuICAgICAqIEBwYXJhbSBmbiBUaGUgZXZlbnQgaGFuZGxlci5cclxuICAgICAqL1xyXG4gICAgU2lnbmFsSGFuZGxpbmdCYXNlLnByb3RvdHlwZS51bnN1YiA9IGZ1bmN0aW9uIChuYW1lLCBmbikge1xyXG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmUobmFtZSwgZm4pO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBTaWduYWxIYW5kbGluZ0Jhc2U7XHJcbn0oKSk7XHJcbmV4cG9ydHMuU2lnbmFsSGFuZGxpbmdCYXNlID0gU2lnbmFsSGFuZGxpbmdCYXNlO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLk5vblVuaWZvcm1TaW1wbGVFdmVudExpc3QgPSBleHBvcnRzLlNpbXBsZUV2ZW50TGlzdCA9IGV4cG9ydHMuU2ltcGxlRXZlbnRIYW5kbGluZ0Jhc2UgPSBleHBvcnRzLlNpbXBsZUV2ZW50RGlzcGF0Y2hlciA9IHZvaWQgMDtcclxudmFyIHNpbXBsZV9ldmVudHNfMSA9IHJlcXVpcmUoXCIuL3NpbXBsZS1ldmVudHNcIik7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNpbXBsZUV2ZW50RGlzcGF0Y2hlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2ltcGxlX2V2ZW50c18xLlNpbXBsZUV2ZW50RGlzcGF0Y2hlcjsgfSB9KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU2ltcGxlRXZlbnRIYW5kbGluZ0Jhc2VcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNpbXBsZV9ldmVudHNfMS5TaW1wbGVFdmVudEhhbmRsaW5nQmFzZTsgfSB9KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU2ltcGxlRXZlbnRMaXN0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzaW1wbGVfZXZlbnRzXzEuU2ltcGxlRXZlbnRMaXN0OyB9IH0pO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOb25Vbmlmb3JtU2ltcGxlRXZlbnRMaXN0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzaW1wbGVfZXZlbnRzXzEuTm9uVW5pZm9ybVNpbXBsZUV2ZW50TGlzdDsgfSB9KTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuICAgIH07XHJcbn0pKCk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5TaW1wbGVFdmVudEhhbmRsaW5nQmFzZSA9IGV4cG9ydHMuU2ltcGxlRXZlbnRMaXN0ID0gZXhwb3J0cy5Ob25Vbmlmb3JtU2ltcGxlRXZlbnRMaXN0ID0gZXhwb3J0cy5TaW1wbGVFdmVudERpc3BhdGNoZXIgPSB2b2lkIDA7XHJcbnZhciBzdGVfY29yZV8xID0gcmVxdWlyZShcInN0ZS1jb3JlXCIpO1xyXG4vKipcclxuICogVGhlIGRpc3BhdGNoZXIgaGFuZGxlcyB0aGUgc3RvcmFnZSBvZiBzdWJzY2lwdGlvbnMgYW5kIGZhY2lsaXRhdGVzXHJcbiAqIHN1YnNjcmlwdGlvbiwgdW5zdWJzY3JpcHRpb24gYW5kIGRpc3BhdGNoaW5nIG9mIGEgc2ltcGxlIGV2ZW50XHJcbiAqL1xyXG52YXIgU2ltcGxlRXZlbnREaXNwYXRjaGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFNpbXBsZUV2ZW50RGlzcGF0Y2hlciwgX3N1cGVyKTtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBTaW1wbGVFdmVudERpc3BhdGNoZXIgaW5zdGFuY2UuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIFNpbXBsZUV2ZW50RGlzcGF0Y2hlcigpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRGlzcGF0Y2hlcyB0aGUgZXZlbnQuXHJcbiAgICAgKiBAcGFyYW0gYXJncyBUaGUgYXJndW1lbnRzIG9iamVjdC5cclxuICAgICAqL1xyXG4gICAgU2ltcGxlRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5kaXNwYXRjaCA9IGZ1bmN0aW9uIChhcmdzKSB7XHJcbiAgICAgICAgdGhpcy5fZGlzcGF0Y2goZmFsc2UsIHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBEaXNwYXRjaGVzIHRoZSBldmVudHMgdGhyZWFkLlxyXG4gICAgICogQHBhcmFtIGFyZ3MgVGhlIGFyZ3VtZW50cyBvYmplY3QuXHJcbiAgICAgKi9cclxuICAgIFNpbXBsZUV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuZGlzcGF0Y2hBc3luYyA9IGZ1bmN0aW9uIChhcmdzKSB7XHJcbiAgICAgICAgdGhpcy5fZGlzcGF0Y2godHJ1ZSwgdGhpcywgYXJndW1lbnRzKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gZXZlbnQgZnJvbSB0aGUgZGlzcGF0Y2hlci4gV2lsbCByZXR1cm4gdGhlIGRpc3BhdGNoZXJcclxuICAgICAqIGluIGEgd3JhcHBlci4gVGhpcyB3aWxsIHByZXZlbnQgZXhwb3N1cmUgb2YgYW55IGRpc3BhdGNoZXIgbWV0aG9kcy5cclxuICAgICAqL1xyXG4gICAgU2ltcGxlRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5hc0V2ZW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLmFzRXZlbnQuY2FsbCh0aGlzKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gU2ltcGxlRXZlbnREaXNwYXRjaGVyO1xyXG59KHN0ZV9jb3JlXzEuRGlzcGF0Y2hlckJhc2UpKTtcclxuZXhwb3J0cy5TaW1wbGVFdmVudERpc3BhdGNoZXIgPSBTaW1wbGVFdmVudERpc3BhdGNoZXI7XHJcbi8qKlxyXG4gKiBTaW1pbGFyIHRvIEV2ZW50TGlzdCwgYnV0IGluc3RlYWQgb2YgVEFyZ3MsIGEgbWFwIG9mIGV2ZW50IG5hbWVzIGFuZyBhcmd1bWVudCB0eXBlcyBpcyBwcm92aWRlZCB3aXRoIFRBcmdzTWFwLlxyXG4gKi9cclxudmFyIE5vblVuaWZvcm1TaW1wbGVFdmVudExpc3QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBOb25Vbmlmb3JtU2ltcGxlRXZlbnRMaXN0KCkge1xyXG4gICAgICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBkaXNwYXRjaGVyIGFzc29jaWF0ZWQgd2l0aCB0aGUgbmFtZS5cclxuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudC5cclxuICAgICAqL1xyXG4gICAgTm9uVW5pZm9ybVNpbXBsZUV2ZW50TGlzdC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICBpZiAodGhpcy5fZXZlbnRzW25hbWVdKSB7XHJcbiAgICAgICAgICAgIC8vIEBUT0RPIGF2b2lkIHR5cGVjYXN0aW5nLiBOb3Qgc3VyZSB3aHkgVFMgdGhpbmtzIHRoaXMuX2V2ZW50c1tuYW1lXSBjb3VsZCBzdGlsbCBiZSB1bmRlZmluZWQuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9ldmVudHNbbmFtZV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBldmVudCA9IHRoaXMuY3JlYXRlRGlzcGF0Y2hlcigpO1xyXG4gICAgICAgIHRoaXMuX2V2ZW50c1tuYW1lXSA9IGV2ZW50O1xyXG4gICAgICAgIHJldHVybiBldmVudDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgdGhlIGRpc3BhdGNoZXIgYXNzb2NpYXRlZCB3aXRoIHRoZSBuYW1lLlxyXG4gICAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50LlxyXG4gICAgICovXHJcbiAgICBOb25Vbmlmb3JtU2ltcGxlRXZlbnRMaXN0LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbbmFtZV07XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGRpc3BhdGNoZXIgaW5zdGFuY2UuXHJcbiAgICAgKi9cclxuICAgIE5vblVuaWZvcm1TaW1wbGVFdmVudExpc3QucHJvdG90eXBlLmNyZWF0ZURpc3BhdGNoZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBTaW1wbGVFdmVudERpc3BhdGNoZXIoKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gTm9uVW5pZm9ybVNpbXBsZUV2ZW50TGlzdDtcclxufSgpKTtcclxuZXhwb3J0cy5Ob25Vbmlmb3JtU2ltcGxlRXZlbnRMaXN0ID0gTm9uVW5pZm9ybVNpbXBsZUV2ZW50TGlzdDtcclxuLyoqXHJcbiAqIFN0b3JhZ2UgY2xhc3MgZm9yIG11bHRpcGxlIHNpbXBsZSBldmVudHMgdGhhdCBhcmUgYWNjZXNzaWJsZSBieSBuYW1lLlxyXG4gKiBFdmVudHMgZGlzcGF0Y2hlcnMgYXJlIGF1dG9tYXRpY2FsbHkgY3JlYXRlZC5cclxuICovXHJcbnZhciBTaW1wbGVFdmVudExpc3QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoU2ltcGxlRXZlbnRMaXN0LCBfc3VwZXIpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFNpbXBsZUV2ZW50TGlzdCBpbnN0YW5jZS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gU2ltcGxlRXZlbnRMaXN0KCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGRpc3BhdGNoZXIgaW5zdGFuY2UuXHJcbiAgICAgKi9cclxuICAgIFNpbXBsZUV2ZW50TGlzdC5wcm90b3R5cGUuY3JlYXRlRGlzcGF0Y2hlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFNpbXBsZUV2ZW50RGlzcGF0Y2hlcigpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBTaW1wbGVFdmVudExpc3Q7XHJcbn0oc3RlX2NvcmVfMS5FdmVudExpc3RCYXNlKSk7XHJcbmV4cG9ydHMuU2ltcGxlRXZlbnRMaXN0ID0gU2ltcGxlRXZlbnRMaXN0O1xyXG4vKipcclxuICogRXh0ZW5kcyBvYmplY3RzIHdpdGggc2ltcGxlIGV2ZW50IGhhbmRsaW5nIGNhcGFiaWxpdGllcy5cclxuICovXHJcbnZhciBTaW1wbGVFdmVudEhhbmRsaW5nQmFzZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFNpbXBsZUV2ZW50SGFuZGxpbmdCYXNlKCkge1xyXG4gICAgICAgIHRoaXMuX2V2ZW50cyA9IG5ldyBTaW1wbGVFdmVudExpc3QoKTtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTaW1wbGVFdmVudEhhbmRsaW5nQmFzZS5wcm90b3R5cGUsIFwiZXZlbnRzXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2V2ZW50cztcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICAvKipcclxuICAgICAqIFN1YnNjcmliZXMgdG8gdGhlIGV2ZW50IHdpdGggdGhlIHNwZWNpZmllZCBuYW1lLlxyXG4gICAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50LlxyXG4gICAgICogQHBhcmFtIGZuIFRoZSBldmVudCBoYW5kbGVyLlxyXG4gICAgICovXHJcbiAgICBTaW1wbGVFdmVudEhhbmRsaW5nQmFzZS5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24gKG5hbWUsIGZuKSB7XHJcbiAgICAgICAgdGhpcy5fZXZlbnRzLmdldChuYW1lKS5zdWJzY3JpYmUoZm4pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogU3Vic2NyaWJlcyB0byB0aGUgZXZlbnQgd2l0aCB0aGUgc3BlY2lmaWVkIG5hbWUuXHJcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQuXHJcbiAgICAgKiBAcGFyYW0gZm4gVGhlIGV2ZW50IGhhbmRsZXIuXHJcbiAgICAgKi9cclxuICAgIFNpbXBsZUV2ZW50SGFuZGxpbmdCYXNlLnByb3RvdHlwZS5zdWIgPSBmdW5jdGlvbiAobmFtZSwgZm4pIHtcclxuICAgICAgICB0aGlzLnN1YnNjcmliZShuYW1lLCBmbik7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBTdWJzY3JpYmVzIG9uY2UgdG8gdGhlIGV2ZW50IHdpdGggdGhlIHNwZWNpZmllZCBuYW1lLlxyXG4gICAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50LlxyXG4gICAgICogQHBhcmFtIGZuIFRoZSBldmVudCBoYW5kbGVyLlxyXG4gICAgICovXHJcbiAgICBTaW1wbGVFdmVudEhhbmRsaW5nQmFzZS5wcm90b3R5cGUub25lID0gZnVuY3Rpb24gKG5hbWUsIGZuKSB7XHJcbiAgICAgICAgdGhpcy5fZXZlbnRzLmdldChuYW1lKS5vbmUoZm4pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIGl0IHRoZSBldmVudCBoYXMgYSBzdWJzY3JpcHRpb24gZm9yIHRoZSBzcGVjaWZpZWQgaGFuZGxlci5cclxuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudC5cclxuICAgICAqIEBwYXJhbSBmbiBUaGUgZXZlbnQgaGFuZGxlci5cclxuICAgICAqL1xyXG4gICAgU2ltcGxlRXZlbnRIYW5kbGluZ0Jhc2UucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIChuYW1lLCBmbikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9ldmVudHMuZ2V0KG5hbWUpLmhhcyhmbik7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBVbnN1YnNjcmliZXMgZnJvbSB0aGUgZXZlbnQgd2l0aCB0aGUgc3BlY2lmaWVkIG5hbWUuXHJcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQuXHJcbiAgICAgKiBAcGFyYW0gZm4gVGhlIGV2ZW50IGhhbmRsZXIuXHJcbiAgICAgKi9cclxuICAgIFNpbXBsZUV2ZW50SGFuZGxpbmdCYXNlLnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uIChuYW1lLCBmbikge1xyXG4gICAgICAgIHRoaXMuX2V2ZW50cy5nZXQobmFtZSkudW5zdWJzY3JpYmUoZm4pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogVW5zdWJzY3JpYmVzIGZyb20gdGhlIGV2ZW50IHdpdGggdGhlIHNwZWNpZmllZCBuYW1lLlxyXG4gICAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50LlxyXG4gICAgICogQHBhcmFtIGZuIFRoZSBldmVudCBoYW5kbGVyLlxyXG4gICAgICovXHJcbiAgICBTaW1wbGVFdmVudEhhbmRsaW5nQmFzZS5wcm90b3R5cGUudW5zdWIgPSBmdW5jdGlvbiAobmFtZSwgZm4pIHtcclxuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKG5hbWUsIGZuKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gU2ltcGxlRXZlbnRIYW5kbGluZ0Jhc2U7XHJcbn0oKSk7XHJcbmV4cG9ydHMuU2ltcGxlRXZlbnRIYW5kbGluZ0Jhc2UgPSBTaW1wbGVFdmVudEhhbmRsaW5nQmFzZTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qIVxyXG4gKiBTdHJvbmdseSBUeXBlZCBFdmVudHMgZm9yIFR5cGVTY3JpcHRcclxuICogaHR0cHM6Ly9naXRodWIuY29tL0tlZXNDQmFra2VyL1N0cm9ubHlUeXBlZEV2ZW50cy9cclxuICogaHR0cDovL2tlZXN0YWxrc3RlY2guY29tXHJcbiAqXHJcbiAqIENvcHlyaWdodCBLZWVzIEMuIEJha2tlciAvIEtlZXNUYWxrc1RlY2hcclxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuU2lnbmFsTGlzdCA9IGV4cG9ydHMuU2lnbmFsSGFuZGxpbmdCYXNlID0gZXhwb3J0cy5TaWduYWxEaXNwYXRjaGVyID0gZXhwb3J0cy5Ob25Vbmlmb3JtU2ltcGxlRXZlbnRMaXN0ID0gZXhwb3J0cy5TaW1wbGVFdmVudExpc3QgPSBleHBvcnRzLlNpbXBsZUV2ZW50SGFuZGxpbmdCYXNlID0gZXhwb3J0cy5TaW1wbGVFdmVudERpc3BhdGNoZXIgPSBleHBvcnRzLk5vblVuaWZvcm1FdmVudExpc3QgPSBleHBvcnRzLkV2ZW50TGlzdCA9IGV4cG9ydHMuRXZlbnRIYW5kbGluZ0Jhc2UgPSBleHBvcnRzLkV2ZW50RGlzcGF0Y2hlciA9IGV4cG9ydHMuU3Vic2NyaXB0aW9uID0gZXhwb3J0cy5FdmVudExpc3RCYXNlID0gZXhwb3J0cy5EaXNwYXRjaGVyV3JhcHBlciA9IGV4cG9ydHMuRGlzcGF0Y2hlckJhc2UgPSB2b2lkIDA7XHJcbnZhciBzdGVfY29yZV8xID0gcmVxdWlyZShcInN0ZS1jb3JlXCIpO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJEaXNwYXRjaGVyQmFzZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc3RlX2NvcmVfMS5EaXNwYXRjaGVyQmFzZTsgfSB9KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRGlzcGF0Y2hlcldyYXBwZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN0ZV9jb3JlXzEuRGlzcGF0Y2hlcldyYXBwZXI7IH0gfSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkV2ZW50TGlzdEJhc2VcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN0ZV9jb3JlXzEuRXZlbnRMaXN0QmFzZTsgfSB9KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU3Vic2NyaXB0aW9uXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzdGVfY29yZV8xLlN1YnNjcmlwdGlvbjsgfSB9KTtcclxudmFyIHN0ZV9ldmVudHNfMSA9IHJlcXVpcmUoXCJzdGUtZXZlbnRzXCIpO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJFdmVudERpc3BhdGNoZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN0ZV9ldmVudHNfMS5FdmVudERpc3BhdGNoZXI7IH0gfSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkV2ZW50SGFuZGxpbmdCYXNlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzdGVfZXZlbnRzXzEuRXZlbnRIYW5kbGluZ0Jhc2U7IH0gfSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkV2ZW50TGlzdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc3RlX2V2ZW50c18xLkV2ZW50TGlzdDsgfSB9KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTm9uVW5pZm9ybUV2ZW50TGlzdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc3RlX2V2ZW50c18xLk5vblVuaWZvcm1FdmVudExpc3Q7IH0gfSk7XHJcbnZhciBzdGVfc2ltcGxlX2V2ZW50c18xID0gcmVxdWlyZShcInN0ZS1zaW1wbGUtZXZlbnRzXCIpO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTaW1wbGVFdmVudERpc3BhdGNoZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN0ZV9zaW1wbGVfZXZlbnRzXzEuU2ltcGxlRXZlbnREaXNwYXRjaGVyOyB9IH0pO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTaW1wbGVFdmVudEhhbmRsaW5nQmFzZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc3RlX3NpbXBsZV9ldmVudHNfMS5TaW1wbGVFdmVudEhhbmRsaW5nQmFzZTsgfSB9KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU2ltcGxlRXZlbnRMaXN0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzdGVfc2ltcGxlX2V2ZW50c18xLlNpbXBsZUV2ZW50TGlzdDsgfSB9KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTm9uVW5pZm9ybVNpbXBsZUV2ZW50TGlzdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc3RlX3NpbXBsZV9ldmVudHNfMS5Ob25Vbmlmb3JtU2ltcGxlRXZlbnRMaXN0OyB9IH0pO1xyXG52YXIgc3RlX3NpZ25hbHNfMSA9IHJlcXVpcmUoXCJzdGUtc2lnbmFsc1wiKTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU2lnbmFsRGlzcGF0Y2hlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc3RlX3NpZ25hbHNfMS5TaWduYWxEaXNwYXRjaGVyOyB9IH0pO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTaWduYWxIYW5kbGluZ0Jhc2VcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN0ZV9zaWduYWxzXzEuU2lnbmFsSGFuZGxpbmdCYXNlOyB9IH0pO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTaWduYWxMaXN0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzdGVfc2lnbmFsc18xLlNpZ25hbExpc3Q7IH0gfSk7XHJcbiIsIi8vIFRoZSBtb2R1bGUgY2FjaGVcbnZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcblxuLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbmZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuXHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG5cdH1cblx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG5cdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuXHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG5cdFx0ZXhwb3J0czoge31cblx0fTtcblxuXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4iLCIvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuXHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuXHRcdH1cblx0fVxufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSAob2JqLCBwcm9wKSA9PiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpIiwiLy8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gKGV4cG9ydHMpID0+IHtcblx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cdH1cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbn07IiwiIiwiLy8gc3RhcnR1cFxuLy8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vLyBUaGlzIGVudHJ5IG1vZHVsZSB1c2VkICdtb2R1bGUnIHNvIGl0IGNhbid0IGJlIGlubGluZWRcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vc3JjL0VuZXJnaWVBdGxhcy50c1wiKTtcbiIsIiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==